// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>At least one delegate must be associated to the resource to disable automatic replies from the resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BookingOptions {
    /// <p>The resource's ability to automatically reply to requests. If disabled, delegates must be associated to the resource.</p>
    #[doc(hidden)]
    pub auto_accept_requests: bool,
    /// <p>The resource's ability to automatically decline any recurring requests.</p>
    #[doc(hidden)]
    pub auto_decline_recurring_requests: bool,
    /// <p>The resource's ability to automatically decline any conflicting requests.</p>
    #[doc(hidden)]
    pub auto_decline_conflicting_requests: bool,
}
impl BookingOptions {
    /// <p>The resource's ability to automatically reply to requests. If disabled, delegates must be associated to the resource.</p>
    pub fn auto_accept_requests(&self) -> bool {
        self.auto_accept_requests
    }
    /// <p>The resource's ability to automatically decline any recurring requests.</p>
    pub fn auto_decline_recurring_requests(&self) -> bool {
        self.auto_decline_recurring_requests
    }
    /// <p>The resource's ability to automatically decline any conflicting requests.</p>
    pub fn auto_decline_conflicting_requests(&self) -> bool {
        self.auto_decline_conflicting_requests
    }
}
/// See [`BookingOptions`](crate::model::BookingOptions).
pub mod booking_options {

    /// A builder for [`BookingOptions`](crate::model::BookingOptions).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) auto_accept_requests: std::option::Option<bool>,
        pub(crate) auto_decline_recurring_requests: std::option::Option<bool>,
        pub(crate) auto_decline_conflicting_requests: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The resource's ability to automatically reply to requests. If disabled, delegates must be associated to the resource.</p>
        pub fn auto_accept_requests(mut self, input: bool) -> Self {
            self.auto_accept_requests = Some(input);
            self
        }
        /// <p>The resource's ability to automatically reply to requests. If disabled, delegates must be associated to the resource.</p>
        pub fn set_auto_accept_requests(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_accept_requests = input;
            self
        }
        /// <p>The resource's ability to automatically decline any recurring requests.</p>
        pub fn auto_decline_recurring_requests(mut self, input: bool) -> Self {
            self.auto_decline_recurring_requests = Some(input);
            self
        }
        /// <p>The resource's ability to automatically decline any recurring requests.</p>
        pub fn set_auto_decline_recurring_requests(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.auto_decline_recurring_requests = input;
            self
        }
        /// <p>The resource's ability to automatically decline any conflicting requests.</p>
        pub fn auto_decline_conflicting_requests(mut self, input: bool) -> Self {
            self.auto_decline_conflicting_requests = Some(input);
            self
        }
        /// <p>The resource's ability to automatically decline any conflicting requests.</p>
        pub fn set_auto_decline_conflicting_requests(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.auto_decline_conflicting_requests = input;
            self
        }
        /// Consumes the builder and constructs a [`BookingOptions`](crate::model::BookingOptions).
        pub fn build(self) -> crate::model::BookingOptions {
            crate::model::BookingOptions {
                auto_accept_requests: self.auto_accept_requests.unwrap_or_default(),
                auto_decline_recurring_requests: self
                    .auto_decline_recurring_requests
                    .unwrap_or_default(),
                auto_decline_conflicting_requests: self
                    .auto_decline_conflicting_requests
                    .unwrap_or_default(),
            }
        }
    }
}
impl BookingOptions {
    /// Creates a new builder-style object to manufacture [`BookingOptions`](crate::model::BookingOptions).
    pub fn builder() -> crate::model::booking_options::Builder {
        crate::model::booking_options::Builder::default()
    }
}

/// When writing a match expression against `MobileDeviceAccessRuleEffect`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let mobiledeviceaccessruleeffect = unimplemented!();
/// match mobiledeviceaccessruleeffect {
///     MobileDeviceAccessRuleEffect::Allow => { /* ... */ },
///     MobileDeviceAccessRuleEffect::Deny => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `mobiledeviceaccessruleeffect` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MobileDeviceAccessRuleEffect::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MobileDeviceAccessRuleEffect::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MobileDeviceAccessRuleEffect::NewFeature` is defined.
/// Specifically, when `mobiledeviceaccessruleeffect` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MobileDeviceAccessRuleEffect::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MobileDeviceAccessRuleEffect {
    #[allow(missing_docs)] // documentation missing in model
    Allow,
    #[allow(missing_docs)] // documentation missing in model
    Deny,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MobileDeviceAccessRuleEffect {
    fn from(s: &str) -> Self {
        match s {
            "ALLOW" => MobileDeviceAccessRuleEffect::Allow,
            "DENY" => MobileDeviceAccessRuleEffect::Deny,
            other => MobileDeviceAccessRuleEffect::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for MobileDeviceAccessRuleEffect {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MobileDeviceAccessRuleEffect::from(s))
    }
}
impl MobileDeviceAccessRuleEffect {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MobileDeviceAccessRuleEffect::Allow => "ALLOW",
            MobileDeviceAccessRuleEffect::Deny => "DENY",
            MobileDeviceAccessRuleEffect::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALLOW", "DENY"]
    }
}
impl AsRef<str> for MobileDeviceAccessRuleEffect {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The rules for the given impersonation role.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImpersonationRule {
    /// <p>The identifier of the rule.</p>
    #[doc(hidden)]
    pub impersonation_rule_id: std::option::Option<std::string::String>,
    /// <p>The rule name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The rule description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The effect of the rule when it matches the input. Allowed effect values are <code>ALLOW</code> or <code>DENY</code>.</p>
    #[doc(hidden)]
    pub effect: std::option::Option<crate::model::AccessEffect>,
    /// <p>A list of user IDs that match the rule.</p>
    #[doc(hidden)]
    pub target_users: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of user IDs that don't match the rule.</p>
    #[doc(hidden)]
    pub not_target_users: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl ImpersonationRule {
    /// <p>The identifier of the rule.</p>
    pub fn impersonation_rule_id(&self) -> std::option::Option<&str> {
        self.impersonation_rule_id.as_deref()
    }
    /// <p>The rule name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The rule description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The effect of the rule when it matches the input. Allowed effect values are <code>ALLOW</code> or <code>DENY</code>.</p>
    pub fn effect(&self) -> std::option::Option<&crate::model::AccessEffect> {
        self.effect.as_ref()
    }
    /// <p>A list of user IDs that match the rule.</p>
    pub fn target_users(&self) -> std::option::Option<&[std::string::String]> {
        self.target_users.as_deref()
    }
    /// <p>A list of user IDs that don't match the rule.</p>
    pub fn not_target_users(&self) -> std::option::Option<&[std::string::String]> {
        self.not_target_users.as_deref()
    }
}
/// See [`ImpersonationRule`](crate::model::ImpersonationRule).
pub mod impersonation_rule {

    /// A builder for [`ImpersonationRule`](crate::model::ImpersonationRule).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) impersonation_rule_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) effect: std::option::Option<crate::model::AccessEffect>,
        pub(crate) target_users: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) not_target_users: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The identifier of the rule.</p>
        pub fn impersonation_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.impersonation_rule_id = Some(input.into());
            self
        }
        /// <p>The identifier of the rule.</p>
        pub fn set_impersonation_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.impersonation_rule_id = input;
            self
        }
        /// <p>The rule name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The rule name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The rule description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The rule description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The effect of the rule when it matches the input. Allowed effect values are <code>ALLOW</code> or <code>DENY</code>.</p>
        pub fn effect(mut self, input: crate::model::AccessEffect) -> Self {
            self.effect = Some(input);
            self
        }
        /// <p>The effect of the rule when it matches the input. Allowed effect values are <code>ALLOW</code> or <code>DENY</code>.</p>
        pub fn set_effect(
            mut self,
            input: std::option::Option<crate::model::AccessEffect>,
        ) -> Self {
            self.effect = input;
            self
        }
        /// Appends an item to `target_users`.
        ///
        /// To override the contents of this collection use [`set_target_users`](Self::set_target_users).
        ///
        /// <p>A list of user IDs that match the rule.</p>
        pub fn target_users(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.target_users.unwrap_or_default();
            v.push(input.into());
            self.target_users = Some(v);
            self
        }
        /// <p>A list of user IDs that match the rule.</p>
        pub fn set_target_users(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.target_users = input;
            self
        }
        /// Appends an item to `not_target_users`.
        ///
        /// To override the contents of this collection use [`set_not_target_users`](Self::set_not_target_users).
        ///
        /// <p>A list of user IDs that don't match the rule.</p>
        pub fn not_target_users(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.not_target_users.unwrap_or_default();
            v.push(input.into());
            self.not_target_users = Some(v);
            self
        }
        /// <p>A list of user IDs that don't match the rule.</p>
        pub fn set_not_target_users(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.not_target_users = input;
            self
        }
        /// Consumes the builder and constructs a [`ImpersonationRule`](crate::model::ImpersonationRule).
        pub fn build(self) -> crate::model::ImpersonationRule {
            crate::model::ImpersonationRule {
                impersonation_rule_id: self.impersonation_rule_id,
                name: self.name,
                description: self.description,
                effect: self.effect,
                target_users: self.target_users,
                not_target_users: self.not_target_users,
            }
        }
    }
}
impl ImpersonationRule {
    /// Creates a new builder-style object to manufacture [`ImpersonationRule`](crate::model::ImpersonationRule).
    pub fn builder() -> crate::model::impersonation_rule::Builder {
        crate::model::impersonation_rule::Builder::default()
    }
}

/// When writing a match expression against `AccessEffect`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let accesseffect = unimplemented!();
/// match accesseffect {
///     AccessEffect::Allow => { /* ... */ },
///     AccessEffect::Deny => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `accesseffect` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AccessEffect::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AccessEffect::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AccessEffect::NewFeature` is defined.
/// Specifically, when `accesseffect` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AccessEffect::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccessEffect {
    #[allow(missing_docs)] // documentation missing in model
    Allow,
    #[allow(missing_docs)] // documentation missing in model
    Deny,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AccessEffect {
    fn from(s: &str) -> Self {
        match s {
            "ALLOW" => AccessEffect::Allow,
            "DENY" => AccessEffect::Deny,
            other => AccessEffect::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AccessEffect {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccessEffect::from(s))
    }
}
impl AccessEffect {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AccessEffect::Allow => "ALLOW",
            AccessEffect::Deny => "DENY",
            AccessEffect::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALLOW", "DENY"]
    }
}
impl AsRef<str> for AccessEffect {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ImpersonationRoleType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let impersonationroletype = unimplemented!();
/// match impersonationroletype {
///     ImpersonationRoleType::FullAccess => { /* ... */ },
///     ImpersonationRoleType::ReadOnly => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `impersonationroletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ImpersonationRoleType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ImpersonationRoleType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ImpersonationRoleType::NewFeature` is defined.
/// Specifically, when `impersonationroletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ImpersonationRoleType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImpersonationRoleType {
    #[allow(missing_docs)] // documentation missing in model
    FullAccess,
    #[allow(missing_docs)] // documentation missing in model
    ReadOnly,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ImpersonationRoleType {
    fn from(s: &str) -> Self {
        match s {
            "FULL_ACCESS" => ImpersonationRoleType::FullAccess,
            "READ_ONLY" => ImpersonationRoleType::ReadOnly,
            other => {
                ImpersonationRoleType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ImpersonationRoleType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImpersonationRoleType::from(s))
    }
}
impl ImpersonationRoleType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImpersonationRoleType::FullAccess => "FULL_ACCESS",
            ImpersonationRoleType::ReadOnly => "READ_ONLY",
            ImpersonationRoleType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FULL_ACCESS", "READ_ONLY"]
    }
}
impl AsRef<str> for ImpersonationRoleType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a Lambda based availability provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LambdaAvailabilityProvider {
    /// <p>The Amazon Resource Name (ARN) of the Lambda that acts as the availability provider.</p>
    #[doc(hidden)]
    pub lambda_arn: std::option::Option<std::string::String>,
}
impl LambdaAvailabilityProvider {
    /// <p>The Amazon Resource Name (ARN) of the Lambda that acts as the availability provider.</p>
    pub fn lambda_arn(&self) -> std::option::Option<&str> {
        self.lambda_arn.as_deref()
    }
}
/// See [`LambdaAvailabilityProvider`](crate::model::LambdaAvailabilityProvider).
pub mod lambda_availability_provider {

    /// A builder for [`LambdaAvailabilityProvider`](crate::model::LambdaAvailabilityProvider).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lambda_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Lambda that acts as the availability provider.</p>
        pub fn lambda_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.lambda_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Lambda that acts as the availability provider.</p>
        pub fn set_lambda_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.lambda_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LambdaAvailabilityProvider`](crate::model::LambdaAvailabilityProvider).
        pub fn build(self) -> crate::model::LambdaAvailabilityProvider {
            crate::model::LambdaAvailabilityProvider {
                lambda_arn: self.lambda_arn,
            }
        }
    }
}
impl LambdaAvailabilityProvider {
    /// Creates a new builder-style object to manufacture [`LambdaAvailabilityProvider`](crate::model::LambdaAvailabilityProvider).
    pub fn builder() -> crate::model::lambda_availability_provider::Builder {
        crate::model::lambda_availability_provider::Builder::default()
    }
}

/// <p>Describes an EWS based availability provider. This is only used as input to the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EwsAvailabilityProvider {
    /// <p>The endpoint of the remote EWS server.</p>
    #[doc(hidden)]
    pub ews_endpoint: std::option::Option<std::string::String>,
    /// <p>The username used to authenticate the remote EWS server.</p>
    #[doc(hidden)]
    pub ews_username: std::option::Option<std::string::String>,
    /// <p>The password used to authenticate the remote EWS server.</p>
    #[doc(hidden)]
    pub ews_password: std::option::Option<std::string::String>,
}
impl EwsAvailabilityProvider {
    /// <p>The endpoint of the remote EWS server.</p>
    pub fn ews_endpoint(&self) -> std::option::Option<&str> {
        self.ews_endpoint.as_deref()
    }
    /// <p>The username used to authenticate the remote EWS server.</p>
    pub fn ews_username(&self) -> std::option::Option<&str> {
        self.ews_username.as_deref()
    }
    /// <p>The password used to authenticate the remote EWS server.</p>
    pub fn ews_password(&self) -> std::option::Option<&str> {
        self.ews_password.as_deref()
    }
}
impl std::fmt::Debug for EwsAvailabilityProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EwsAvailabilityProvider");
        formatter.field("ews_endpoint", &self.ews_endpoint);
        formatter.field("ews_username", &self.ews_username);
        formatter.field("ews_password", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`EwsAvailabilityProvider`](crate::model::EwsAvailabilityProvider).
pub mod ews_availability_provider {

    /// A builder for [`EwsAvailabilityProvider`](crate::model::EwsAvailabilityProvider).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) ews_endpoint: std::option::Option<std::string::String>,
        pub(crate) ews_username: std::option::Option<std::string::String>,
        pub(crate) ews_password: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The endpoint of the remote EWS server.</p>
        pub fn ews_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.ews_endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of the remote EWS server.</p>
        pub fn set_ews_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ews_endpoint = input;
            self
        }
        /// <p>The username used to authenticate the remote EWS server.</p>
        pub fn ews_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.ews_username = Some(input.into());
            self
        }
        /// <p>The username used to authenticate the remote EWS server.</p>
        pub fn set_ews_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ews_username = input;
            self
        }
        /// <p>The password used to authenticate the remote EWS server.</p>
        pub fn ews_password(mut self, input: impl Into<std::string::String>) -> Self {
            self.ews_password = Some(input.into());
            self
        }
        /// <p>The password used to authenticate the remote EWS server.</p>
        pub fn set_ews_password(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ews_password = input;
            self
        }
        /// Consumes the builder and constructs a [`EwsAvailabilityProvider`](crate::model::EwsAvailabilityProvider).
        pub fn build(self) -> crate::model::EwsAvailabilityProvider {
            crate::model::EwsAvailabilityProvider {
                ews_endpoint: self.ews_endpoint,
                ews_username: self.ews_username,
                ews_password: self.ews_password,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("ews_endpoint", &self.ews_endpoint);
            formatter.field("ews_username", &self.ews_username);
            formatter.field("ews_password", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl EwsAvailabilityProvider {
    /// Creates a new builder-style object to manufacture [`EwsAvailabilityProvider`](crate::model::EwsAvailabilityProvider).
    pub fn builder() -> crate::model::ews_availability_provider::Builder {
        crate::model::ews_availability_provider::Builder::default()
    }
}

/// <p>Describes a tag applied to a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The key of the tag.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The key of the tag.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the tag.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the tag.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>The configuration applied to an organization's folders by its retention policy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FolderConfiguration {
    /// <p>The folder name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::FolderName>,
    /// <p>The action to take on the folder contents at the end of the folder configuration period.</p>
    #[doc(hidden)]
    pub action: std::option::Option<crate::model::RetentionAction>,
    /// <p>The number of days for which the folder-configuration action applies.</p>
    #[doc(hidden)]
    pub period: std::option::Option<i32>,
}
impl FolderConfiguration {
    /// <p>The folder name.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::FolderName> {
        self.name.as_ref()
    }
    /// <p>The action to take on the folder contents at the end of the folder configuration period.</p>
    pub fn action(&self) -> std::option::Option<&crate::model::RetentionAction> {
        self.action.as_ref()
    }
    /// <p>The number of days for which the folder-configuration action applies.</p>
    pub fn period(&self) -> std::option::Option<i32> {
        self.period
    }
}
/// See [`FolderConfiguration`](crate::model::FolderConfiguration).
pub mod folder_configuration {

    /// A builder for [`FolderConfiguration`](crate::model::FolderConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::FolderName>,
        pub(crate) action: std::option::Option<crate::model::RetentionAction>,
        pub(crate) period: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The folder name.</p>
        pub fn name(mut self, input: crate::model::FolderName) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The folder name.</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::FolderName>) -> Self {
            self.name = input;
            self
        }
        /// <p>The action to take on the folder contents at the end of the folder configuration period.</p>
        pub fn action(mut self, input: crate::model::RetentionAction) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action to take on the folder contents at the end of the folder configuration period.</p>
        pub fn set_action(
            mut self,
            input: std::option::Option<crate::model::RetentionAction>,
        ) -> Self {
            self.action = input;
            self
        }
        /// <p>The number of days for which the folder-configuration action applies.</p>
        pub fn period(mut self, input: i32) -> Self {
            self.period = Some(input);
            self
        }
        /// <p>The number of days for which the folder-configuration action applies.</p>
        pub fn set_period(mut self, input: std::option::Option<i32>) -> Self {
            self.period = input;
            self
        }
        /// Consumes the builder and constructs a [`FolderConfiguration`](crate::model::FolderConfiguration).
        pub fn build(self) -> crate::model::FolderConfiguration {
            crate::model::FolderConfiguration {
                name: self.name,
                action: self.action,
                period: self.period,
            }
        }
    }
}
impl FolderConfiguration {
    /// Creates a new builder-style object to manufacture [`FolderConfiguration`](crate::model::FolderConfiguration).
    pub fn builder() -> crate::model::folder_configuration::Builder {
        crate::model::folder_configuration::Builder::default()
    }
}

/// When writing a match expression against `RetentionAction`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let retentionaction = unimplemented!();
/// match retentionaction {
///     RetentionAction::Delete => { /* ... */ },
///     RetentionAction::None => { /* ... */ },
///     RetentionAction::PermanentlyDelete => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `retentionaction` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RetentionAction::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RetentionAction::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RetentionAction::NewFeature` is defined.
/// Specifically, when `retentionaction` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RetentionAction::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RetentionAction {
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    PermanentlyDelete,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RetentionAction {
    fn from(s: &str) -> Self {
        match s {
            "DELETE" => RetentionAction::Delete,
            "NONE" => RetentionAction::None,
            "PERMANENTLY_DELETE" => RetentionAction::PermanentlyDelete,
            other => RetentionAction::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RetentionAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RetentionAction::from(s))
    }
}
impl RetentionAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RetentionAction::Delete => "DELETE",
            RetentionAction::None => "NONE",
            RetentionAction::PermanentlyDelete => "PERMANENTLY_DELETE",
            RetentionAction::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETE", "NONE", "PERMANENTLY_DELETE"]
    }
}
impl AsRef<str> for RetentionAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `FolderName`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let foldername = unimplemented!();
/// match foldername {
///     FolderName::DeletedItems => { /* ... */ },
///     FolderName::Drafts => { /* ... */ },
///     FolderName::Inbox => { /* ... */ },
///     FolderName::JunkEmail => { /* ... */ },
///     FolderName::SentItems => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `foldername` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FolderName::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FolderName::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FolderName::NewFeature` is defined.
/// Specifically, when `foldername` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FolderName::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FolderName {
    #[allow(missing_docs)] // documentation missing in model
    DeletedItems,
    #[allow(missing_docs)] // documentation missing in model
    Drafts,
    #[allow(missing_docs)] // documentation missing in model
    Inbox,
    #[allow(missing_docs)] // documentation missing in model
    JunkEmail,
    #[allow(missing_docs)] // documentation missing in model
    SentItems,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FolderName {
    fn from(s: &str) -> Self {
        match s {
            "DELETED_ITEMS" => FolderName::DeletedItems,
            "DRAFTS" => FolderName::Drafts,
            "INBOX" => FolderName::Inbox,
            "JUNK_EMAIL" => FolderName::JunkEmail,
            "SENT_ITEMS" => FolderName::SentItems,
            other => FolderName::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FolderName {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FolderName::from(s))
    }
}
impl FolderName {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FolderName::DeletedItems => "DELETED_ITEMS",
            FolderName::Drafts => "DRAFTS",
            FolderName::Inbox => "INBOX",
            FolderName::JunkEmail => "JUNK_EMAIL",
            FolderName::SentItems => "SENT_ITEMS",
            FolderName::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DELETED_ITEMS",
            "DRAFTS",
            "INBOX",
            "JUNK_EMAIL",
            "SENT_ITEMS",
        ]
    }
}
impl AsRef<str> for FolderName {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PermissionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let permissiontype = unimplemented!();
/// match permissiontype {
///     PermissionType::FullAccess => { /* ... */ },
///     PermissionType::SendAs => { /* ... */ },
///     PermissionType::SendOnBehalf => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `permissiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PermissionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PermissionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PermissionType::NewFeature` is defined.
/// Specifically, when `permissiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PermissionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PermissionType {
    #[allow(missing_docs)] // documentation missing in model
    FullAccess,
    #[allow(missing_docs)] // documentation missing in model
    SendAs,
    #[allow(missing_docs)] // documentation missing in model
    SendOnBehalf,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PermissionType {
    fn from(s: &str) -> Self {
        match s {
            "FULL_ACCESS" => PermissionType::FullAccess,
            "SEND_AS" => PermissionType::SendAs,
            "SEND_ON_BEHALF" => PermissionType::SendOnBehalf,
            other => PermissionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PermissionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PermissionType::from(s))
    }
}
impl PermissionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PermissionType::FullAccess => "FULL_ACCESS",
            PermissionType::SendAs => "SEND_AS",
            PermissionType::SendOnBehalf => "SEND_ON_BEHALF",
            PermissionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FULL_ACCESS", "SEND_AS", "SEND_ON_BEHALF"]
    }
}
impl AsRef<str> for PermissionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `AccessControlRuleEffect`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let accesscontrolruleeffect = unimplemented!();
/// match accesscontrolruleeffect {
///     AccessControlRuleEffect::Allow => { /* ... */ },
///     AccessControlRuleEffect::Deny => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `accesscontrolruleeffect` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AccessControlRuleEffect::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AccessControlRuleEffect::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AccessControlRuleEffect::NewFeature` is defined.
/// Specifically, when `accesscontrolruleeffect` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AccessControlRuleEffect::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccessControlRuleEffect {
    #[allow(missing_docs)] // documentation missing in model
    Allow,
    #[allow(missing_docs)] // documentation missing in model
    Deny,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AccessControlRuleEffect {
    fn from(s: &str) -> Self {
        match s {
            "ALLOW" => AccessControlRuleEffect::Allow,
            "DENY" => AccessControlRuleEffect::Deny,
            other => AccessControlRuleEffect::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AccessControlRuleEffect {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccessControlRuleEffect::from(s))
    }
}
impl AccessControlRuleEffect {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AccessControlRuleEffect::Allow => "ALLOW",
            AccessControlRuleEffect::Deny => "DENY",
            AccessControlRuleEffect::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALLOW", "DENY"]
    }
}
impl AsRef<str> for AccessControlRuleEffect {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The representation of an WorkMail user.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct User {
    /// <p>The identifier of the user.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The email of the user.</p>
    #[doc(hidden)]
    pub email: std::option::Option<std::string::String>,
    /// <p>The name of the user.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The display name of the user.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The state of the user, which can be ENABLED, DISABLED, or DELETED.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::EntityState>,
    /// <p>The role of the user.</p>
    #[doc(hidden)]
    pub user_role: std::option::Option<crate::model::UserRole>,
    /// <p>The date indicating when the user was enabled for WorkMail use.</p>
    #[doc(hidden)]
    pub enabled_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date indicating when the user was disabled from WorkMail use.</p>
    #[doc(hidden)]
    pub disabled_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl User {
    /// <p>The identifier of the user.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The email of the user.</p>
    pub fn email(&self) -> std::option::Option<&str> {
        self.email.as_deref()
    }
    /// <p>The name of the user.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The display name of the user.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The state of the user, which can be ENABLED, DISABLED, or DELETED.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::EntityState> {
        self.state.as_ref()
    }
    /// <p>The role of the user.</p>
    pub fn user_role(&self) -> std::option::Option<&crate::model::UserRole> {
        self.user_role.as_ref()
    }
    /// <p>The date indicating when the user was enabled for WorkMail use.</p>
    pub fn enabled_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.enabled_date.as_ref()
    }
    /// <p>The date indicating when the user was disabled from WorkMail use.</p>
    pub fn disabled_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.disabled_date.as_ref()
    }
}
/// See [`User`](crate::model::User).
pub mod user {

    /// A builder for [`User`](crate::model::User).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::EntityState>,
        pub(crate) user_role: std::option::Option<crate::model::UserRole>,
        pub(crate) enabled_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) disabled_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the user.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the user.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The email of the user.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.email = Some(input.into());
            self
        }
        /// <p>The email of the user.</p>
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.email = input;
            self
        }
        /// <p>The name of the user.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the user.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The display name of the user.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>The display name of the user.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The state of the user, which can be ENABLED, DISABLED, or DELETED.</p>
        pub fn state(mut self, input: crate::model::EntityState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the user, which can be ENABLED, DISABLED, or DELETED.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::EntityState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The role of the user.</p>
        pub fn user_role(mut self, input: crate::model::UserRole) -> Self {
            self.user_role = Some(input);
            self
        }
        /// <p>The role of the user.</p>
        pub fn set_user_role(mut self, input: std::option::Option<crate::model::UserRole>) -> Self {
            self.user_role = input;
            self
        }
        /// <p>The date indicating when the user was enabled for WorkMail use.</p>
        pub fn enabled_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.enabled_date = Some(input);
            self
        }
        /// <p>The date indicating when the user was enabled for WorkMail use.</p>
        pub fn set_enabled_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.enabled_date = input;
            self
        }
        /// <p>The date indicating when the user was disabled from WorkMail use.</p>
        pub fn disabled_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.disabled_date = Some(input);
            self
        }
        /// <p>The date indicating when the user was disabled from WorkMail use.</p>
        pub fn set_disabled_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.disabled_date = input;
            self
        }
        /// Consumes the builder and constructs a [`User`](crate::model::User).
        pub fn build(self) -> crate::model::User {
            crate::model::User {
                id: self.id,
                email: self.email,
                name: self.name,
                display_name: self.display_name,
                state: self.state,
                user_role: self.user_role,
                enabled_date: self.enabled_date,
                disabled_date: self.disabled_date,
            }
        }
    }
}
impl User {
    /// Creates a new builder-style object to manufacture [`User`](crate::model::User).
    pub fn builder() -> crate::model::user::Builder {
        crate::model::user::Builder::default()
    }
}

/// When writing a match expression against `UserRole`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let userrole = unimplemented!();
/// match userrole {
///     UserRole::Resource => { /* ... */ },
///     UserRole::SystemUser => { /* ... */ },
///     UserRole::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `userrole` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UserRole::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UserRole::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UserRole::NewFeature` is defined.
/// Specifically, when `userrole` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UserRole::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UserRole {
    #[allow(missing_docs)] // documentation missing in model
    Resource,
    #[allow(missing_docs)] // documentation missing in model
    SystemUser,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UserRole {
    fn from(s: &str) -> Self {
        match s {
            "RESOURCE" => UserRole::Resource,
            "SYSTEM_USER" => UserRole::SystemUser,
            "USER" => UserRole::User,
            other => UserRole::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UserRole {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UserRole::from(s))
    }
}
impl UserRole {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UserRole::Resource => "RESOURCE",
            UserRole::SystemUser => "SYSTEM_USER",
            UserRole::User => "USER",
            UserRole::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["RESOURCE", "SYSTEM_USER", "USER"]
    }
}
impl AsRef<str> for UserRole {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `EntityState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let entitystate = unimplemented!();
/// match entitystate {
///     EntityState::Deleted => { /* ... */ },
///     EntityState::Disabled => { /* ... */ },
///     EntityState::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `entitystate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EntityState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EntityState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EntityState::NewFeature` is defined.
/// Specifically, when `entitystate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EntityState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EntityState {
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EntityState {
    fn from(s: &str) -> Self {
        match s {
            "DELETED" => EntityState::Deleted,
            "DISABLED" => EntityState::Disabled,
            "ENABLED" => EntityState::Enabled,
            other => EntityState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for EntityState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EntityState::from(s))
    }
}
impl EntityState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EntityState::Deleted => "DELETED",
            EntityState::Disabled => "DISABLED",
            EntityState::Enabled => "ENABLED",
            EntityState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETED", "DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for EntityState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The representation of a resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Resource {
    /// <p>The identifier of the resource.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The email of the resource.</p>
    #[doc(hidden)]
    pub email: std::option::Option<std::string::String>,
    /// <p>The name of the resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of the resource: equipment or room.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ResourceType>,
    /// <p>The state of the resource, which can be ENABLED, DISABLED, or DELETED.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::EntityState>,
    /// <p>The date indicating when the resource was enabled for WorkMail use.</p>
    #[doc(hidden)]
    pub enabled_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date indicating when the resource was disabled from WorkMail use.</p>
    #[doc(hidden)]
    pub disabled_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl Resource {
    /// <p>The identifier of the resource.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The email of the resource.</p>
    pub fn email(&self) -> std::option::Option<&str> {
        self.email.as_deref()
    }
    /// <p>The name of the resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of the resource: equipment or room.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ResourceType> {
        self.r#type.as_ref()
    }
    /// <p>The state of the resource, which can be ENABLED, DISABLED, or DELETED.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::EntityState> {
        self.state.as_ref()
    }
    /// <p>The date indicating when the resource was enabled for WorkMail use.</p>
    pub fn enabled_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.enabled_date.as_ref()
    }
    /// <p>The date indicating when the resource was disabled from WorkMail use.</p>
    pub fn disabled_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.disabled_date.as_ref()
    }
}
/// See [`Resource`](crate::model::Resource).
pub mod resource {

    /// A builder for [`Resource`](crate::model::Resource).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ResourceType>,
        pub(crate) state: std::option::Option<crate::model::EntityState>,
        pub(crate) enabled_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) disabled_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the resource.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the resource.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The email of the resource.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.email = Some(input.into());
            self
        }
        /// <p>The email of the resource.</p>
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.email = input;
            self
        }
        /// <p>The name of the resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of the resource: equipment or room.</p>
        pub fn r#type(mut self, input: crate::model::ResourceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the resource: equipment or room.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::ResourceType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The state of the resource, which can be ENABLED, DISABLED, or DELETED.</p>
        pub fn state(mut self, input: crate::model::EntityState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the resource, which can be ENABLED, DISABLED, or DELETED.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::EntityState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The date indicating when the resource was enabled for WorkMail use.</p>
        pub fn enabled_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.enabled_date = Some(input);
            self
        }
        /// <p>The date indicating when the resource was enabled for WorkMail use.</p>
        pub fn set_enabled_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.enabled_date = input;
            self
        }
        /// <p>The date indicating when the resource was disabled from WorkMail use.</p>
        pub fn disabled_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.disabled_date = Some(input);
            self
        }
        /// <p>The date indicating when the resource was disabled from WorkMail use.</p>
        pub fn set_disabled_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.disabled_date = input;
            self
        }
        /// Consumes the builder and constructs a [`Resource`](crate::model::Resource).
        pub fn build(self) -> crate::model::Resource {
            crate::model::Resource {
                id: self.id,
                email: self.email,
                name: self.name,
                r#type: self.r#type,
                state: self.state,
                enabled_date: self.enabled_date,
                disabled_date: self.disabled_date,
            }
        }
    }
}
impl Resource {
    /// Creates a new builder-style object to manufacture [`Resource`](crate::model::Resource).
    pub fn builder() -> crate::model::resource::Builder {
        crate::model::resource::Builder::default()
    }
}

/// When writing a match expression against `ResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let resourcetype = unimplemented!();
/// match resourcetype {
///     ResourceType::Equipment => { /* ... */ },
///     ResourceType::Room => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `resourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ResourceType::NewFeature` is defined.
/// Specifically, when `resourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ResourceType {
    #[allow(missing_docs)] // documentation missing in model
    Equipment,
    #[allow(missing_docs)] // documentation missing in model
    Room,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ResourceType {
    fn from(s: &str) -> Self {
        match s {
            "EQUIPMENT" => ResourceType::Equipment,
            "ROOM" => ResourceType::Room,
            other => ResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ResourceType::from(s))
    }
}
impl ResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ResourceType::Equipment => "EQUIPMENT",
            ResourceType::Room => "ROOM",
            ResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EQUIPMENT", "ROOM"]
    }
}
impl AsRef<str> for ResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The name of the attribute, which is one of the values defined in the UserAttribute enumeration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Delegate {
    /// <p>The identifier for the user or group associated as the resource's delegate.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The type of the delegate: user or group.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::MemberType>,
}
impl Delegate {
    /// <p>The identifier for the user or group associated as the resource's delegate.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The type of the delegate: user or group.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::MemberType> {
        self.r#type.as_ref()
    }
}
/// See [`Delegate`](crate::model::Delegate).
pub mod delegate {

    /// A builder for [`Delegate`](crate::model::Delegate).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::MemberType>,
    }
    impl Builder {
        /// <p>The identifier for the user or group associated as the resource's delegate.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier for the user or group associated as the resource's delegate.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The type of the delegate: user or group.</p>
        pub fn r#type(mut self, input: crate::model::MemberType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the delegate: user or group.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::MemberType>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`Delegate`](crate::model::Delegate).
        pub fn build(self) -> crate::model::Delegate {
            crate::model::Delegate {
                id: self.id,
                r#type: self.r#type,
            }
        }
    }
}
impl Delegate {
    /// Creates a new builder-style object to manufacture [`Delegate`](crate::model::Delegate).
    pub fn builder() -> crate::model::delegate::Builder {
        crate::model::delegate::Builder::default()
    }
}

/// When writing a match expression against `MemberType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let membertype = unimplemented!();
/// match membertype {
///     MemberType::Group => { /* ... */ },
///     MemberType::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `membertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MemberType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MemberType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MemberType::NewFeature` is defined.
/// Specifically, when `membertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MemberType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MemberType {
    #[allow(missing_docs)] // documentation missing in model
    Group,
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MemberType {
    fn from(s: &str) -> Self {
        match s {
            "GROUP" => MemberType::Group,
            "USER" => MemberType::User,
            other => MemberType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MemberType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MemberType::from(s))
    }
}
impl MemberType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MemberType::Group => "GROUP",
            MemberType::User => "USER",
            MemberType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GROUP", "USER"]
    }
}
impl AsRef<str> for MemberType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The representation of an organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OrganizationSummary {
    /// <p>The identifier associated with the organization.</p>
    #[doc(hidden)]
    pub organization_id: std::option::Option<std::string::String>,
    /// <p>The alias associated with the organization.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>The default email domain associated with the organization.</p>
    #[doc(hidden)]
    pub default_mail_domain: std::option::Option<std::string::String>,
    /// <p>The error message associated with the organization. It is only present if unexpected behavior has occurred with regards to the organization. It provides insight or solutions regarding unexpected behavior.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The state associated with the organization.</p>
    #[doc(hidden)]
    pub state: std::option::Option<std::string::String>,
}
impl OrganizationSummary {
    /// <p>The identifier associated with the organization.</p>
    pub fn organization_id(&self) -> std::option::Option<&str> {
        self.organization_id.as_deref()
    }
    /// <p>The alias associated with the organization.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
    /// <p>The default email domain associated with the organization.</p>
    pub fn default_mail_domain(&self) -> std::option::Option<&str> {
        self.default_mail_domain.as_deref()
    }
    /// <p>The error message associated with the organization. It is only present if unexpected behavior has occurred with regards to the organization. It provides insight or solutions regarding unexpected behavior.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The state associated with the organization.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
}
/// See [`OrganizationSummary`](crate::model::OrganizationSummary).
pub mod organization_summary {

    /// A builder for [`OrganizationSummary`](crate::model::OrganizationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) organization_id: std::option::Option<std::string::String>,
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) default_mail_domain: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier associated with the organization.</p>
        pub fn organization_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.organization_id = Some(input.into());
            self
        }
        /// <p>The identifier associated with the organization.</p>
        pub fn set_organization_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organization_id = input;
            self
        }
        /// <p>The alias associated with the organization.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The alias associated with the organization.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// <p>The default email domain associated with the organization.</p>
        pub fn default_mail_domain(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_mail_domain = Some(input.into());
            self
        }
        /// <p>The default email domain associated with the organization.</p>
        pub fn set_default_mail_domain(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_mail_domain = input;
            self
        }
        /// <p>The error message associated with the organization. It is only present if unexpected behavior has occurred with regards to the organization. It provides insight or solutions regarding unexpected behavior.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The error message associated with the organization. It is only present if unexpected behavior has occurred with regards to the organization. It provides insight or solutions regarding unexpected behavior.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The state associated with the organization.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The state associated with the organization.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`OrganizationSummary`](crate::model::OrganizationSummary).
        pub fn build(self) -> crate::model::OrganizationSummary {
            crate::model::OrganizationSummary {
                organization_id: self.organization_id,
                alias: self.alias,
                default_mail_domain: self.default_mail_domain,
                error_message: self.error_message,
                state: self.state,
            }
        }
    }
}
impl OrganizationSummary {
    /// Creates a new builder-style object to manufacture [`OrganizationSummary`](crate::model::OrganizationSummary).
    pub fn builder() -> crate::model::organization_summary::Builder {
        crate::model::organization_summary::Builder::default()
    }
}

/// <p>A rule that controls access to mobile devices for an WorkMail group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MobileDeviceAccessRule {
    /// <p>The ID assigned to a mobile access rule.</p>
    #[doc(hidden)]
    pub mobile_device_access_rule_id: std::option::Option<std::string::String>,
    /// <p>The name of a mobile access rule.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of a mobile access rule.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The effect of the rule when it matches. Allowed values are <code>ALLOW</code> or <code>DENY</code>.</p>
    #[doc(hidden)]
    pub effect: std::option::Option<crate::model::MobileDeviceAccessRuleEffect>,
    /// <p>Device types that a rule will match.</p>
    #[doc(hidden)]
    pub device_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Device types that a rule <b>will not</b> match. All other device types will match.</p>
    #[doc(hidden)]
    pub not_device_types: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Device models that a rule will match.</p>
    #[doc(hidden)]
    pub device_models: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Device models that a rule <b>will not</b> match. All other device models will match.</p>
    #[doc(hidden)]
    pub not_device_models: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Device operating systems that a rule will match.</p>
    #[doc(hidden)]
    pub device_operating_systems: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Device operating systems that a rule <b>will not</b> match. All other device types will match.</p>
    #[doc(hidden)]
    pub not_device_operating_systems: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Device user agents that a rule will match.</p>
    #[doc(hidden)]
    pub device_user_agents: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Device user agents that a rule <b>will not</b> match. All other device user agents will match.</p>
    #[doc(hidden)]
    pub not_device_user_agents: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The date and time at which an access rule was created.</p>
    #[doc(hidden)]
    pub date_created: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time at which an access rule was modified.</p>
    #[doc(hidden)]
    pub date_modified: std::option::Option<aws_smithy_types::DateTime>,
}
impl MobileDeviceAccessRule {
    /// <p>The ID assigned to a mobile access rule.</p>
    pub fn mobile_device_access_rule_id(&self) -> std::option::Option<&str> {
        self.mobile_device_access_rule_id.as_deref()
    }
    /// <p>The name of a mobile access rule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of a mobile access rule.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The effect of the rule when it matches. Allowed values are <code>ALLOW</code> or <code>DENY</code>.</p>
    pub fn effect(&self) -> std::option::Option<&crate::model::MobileDeviceAccessRuleEffect> {
        self.effect.as_ref()
    }
    /// <p>Device types that a rule will match.</p>
    pub fn device_types(&self) -> std::option::Option<&[std::string::String]> {
        self.device_types.as_deref()
    }
    /// <p>Device types that a rule <b>will not</b> match. All other device types will match.</p>
    pub fn not_device_types(&self) -> std::option::Option<&[std::string::String]> {
        self.not_device_types.as_deref()
    }
    /// <p>Device models that a rule will match.</p>
    pub fn device_models(&self) -> std::option::Option<&[std::string::String]> {
        self.device_models.as_deref()
    }
    /// <p>Device models that a rule <b>will not</b> match. All other device models will match.</p>
    pub fn not_device_models(&self) -> std::option::Option<&[std::string::String]> {
        self.not_device_models.as_deref()
    }
    /// <p>Device operating systems that a rule will match.</p>
    pub fn device_operating_systems(&self) -> std::option::Option<&[std::string::String]> {
        self.device_operating_systems.as_deref()
    }
    /// <p>Device operating systems that a rule <b>will not</b> match. All other device types will match.</p>
    pub fn not_device_operating_systems(&self) -> std::option::Option<&[std::string::String]> {
        self.not_device_operating_systems.as_deref()
    }
    /// <p>Device user agents that a rule will match.</p>
    pub fn device_user_agents(&self) -> std::option::Option<&[std::string::String]> {
        self.device_user_agents.as_deref()
    }
    /// <p>Device user agents that a rule <b>will not</b> match. All other device user agents will match.</p>
    pub fn not_device_user_agents(&self) -> std::option::Option<&[std::string::String]> {
        self.not_device_user_agents.as_deref()
    }
    /// <p>The date and time at which an access rule was created.</p>
    pub fn date_created(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_created.as_ref()
    }
    /// <p>The date and time at which an access rule was modified.</p>
    pub fn date_modified(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_modified.as_ref()
    }
}
/// See [`MobileDeviceAccessRule`](crate::model::MobileDeviceAccessRule).
pub mod mobile_device_access_rule {

    /// A builder for [`MobileDeviceAccessRule`](crate::model::MobileDeviceAccessRule).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mobile_device_access_rule_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) effect: std::option::Option<crate::model::MobileDeviceAccessRuleEffect>,
        pub(crate) device_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) not_device_types: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) device_models: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) not_device_models: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) device_operating_systems:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) not_device_operating_systems:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) device_user_agents: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) not_device_user_agents: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) date_created: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) date_modified: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID assigned to a mobile access rule.</p>
        pub fn mobile_device_access_rule_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.mobile_device_access_rule_id = Some(input.into());
            self
        }
        /// <p>The ID assigned to a mobile access rule.</p>
        pub fn set_mobile_device_access_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.mobile_device_access_rule_id = input;
            self
        }
        /// <p>The name of a mobile access rule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a mobile access rule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of a mobile access rule.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of a mobile access rule.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The effect of the rule when it matches. Allowed values are <code>ALLOW</code> or <code>DENY</code>.</p>
        pub fn effect(mut self, input: crate::model::MobileDeviceAccessRuleEffect) -> Self {
            self.effect = Some(input);
            self
        }
        /// <p>The effect of the rule when it matches. Allowed values are <code>ALLOW</code> or <code>DENY</code>.</p>
        pub fn set_effect(
            mut self,
            input: std::option::Option<crate::model::MobileDeviceAccessRuleEffect>,
        ) -> Self {
            self.effect = input;
            self
        }
        /// Appends an item to `device_types`.
        ///
        /// To override the contents of this collection use [`set_device_types`](Self::set_device_types).
        ///
        /// <p>Device types that a rule will match.</p>
        pub fn device_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.device_types.unwrap_or_default();
            v.push(input.into());
            self.device_types = Some(v);
            self
        }
        /// <p>Device types that a rule will match.</p>
        pub fn set_device_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.device_types = input;
            self
        }
        /// Appends an item to `not_device_types`.
        ///
        /// To override the contents of this collection use [`set_not_device_types`](Self::set_not_device_types).
        ///
        /// <p>Device types that a rule <b>will not</b> match. All other device types will match.</p>
        pub fn not_device_types(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.not_device_types.unwrap_or_default();
            v.push(input.into());
            self.not_device_types = Some(v);
            self
        }
        /// <p>Device types that a rule <b>will not</b> match. All other device types will match.</p>
        pub fn set_not_device_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.not_device_types = input;
            self
        }
        /// Appends an item to `device_models`.
        ///
        /// To override the contents of this collection use [`set_device_models`](Self::set_device_models).
        ///
        /// <p>Device models that a rule will match.</p>
        pub fn device_models(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.device_models.unwrap_or_default();
            v.push(input.into());
            self.device_models = Some(v);
            self
        }
        /// <p>Device models that a rule will match.</p>
        pub fn set_device_models(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.device_models = input;
            self
        }
        /// Appends an item to `not_device_models`.
        ///
        /// To override the contents of this collection use [`set_not_device_models`](Self::set_not_device_models).
        ///
        /// <p>Device models that a rule <b>will not</b> match. All other device models will match.</p>
        pub fn not_device_models(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.not_device_models.unwrap_or_default();
            v.push(input.into());
            self.not_device_models = Some(v);
            self
        }
        /// <p>Device models that a rule <b>will not</b> match. All other device models will match.</p>
        pub fn set_not_device_models(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.not_device_models = input;
            self
        }
        /// Appends an item to `device_operating_systems`.
        ///
        /// To override the contents of this collection use [`set_device_operating_systems`](Self::set_device_operating_systems).
        ///
        /// <p>Device operating systems that a rule will match.</p>
        pub fn device_operating_systems(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.device_operating_systems.unwrap_or_default();
            v.push(input.into());
            self.device_operating_systems = Some(v);
            self
        }
        /// <p>Device operating systems that a rule will match.</p>
        pub fn set_device_operating_systems(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.device_operating_systems = input;
            self
        }
        /// Appends an item to `not_device_operating_systems`.
        ///
        /// To override the contents of this collection use [`set_not_device_operating_systems`](Self::set_not_device_operating_systems).
        ///
        /// <p>Device operating systems that a rule <b>will not</b> match. All other device types will match.</p>
        pub fn not_device_operating_systems(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.not_device_operating_systems.unwrap_or_default();
            v.push(input.into());
            self.not_device_operating_systems = Some(v);
            self
        }
        /// <p>Device operating systems that a rule <b>will not</b> match. All other device types will match.</p>
        pub fn set_not_device_operating_systems(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.not_device_operating_systems = input;
            self
        }
        /// Appends an item to `device_user_agents`.
        ///
        /// To override the contents of this collection use [`set_device_user_agents`](Self::set_device_user_agents).
        ///
        /// <p>Device user agents that a rule will match.</p>
        pub fn device_user_agents(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.device_user_agents.unwrap_or_default();
            v.push(input.into());
            self.device_user_agents = Some(v);
            self
        }
        /// <p>Device user agents that a rule will match.</p>
        pub fn set_device_user_agents(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.device_user_agents = input;
            self
        }
        /// Appends an item to `not_device_user_agents`.
        ///
        /// To override the contents of this collection use [`set_not_device_user_agents`](Self::set_not_device_user_agents).
        ///
        /// <p>Device user agents that a rule <b>will not</b> match. All other device user agents will match.</p>
        pub fn not_device_user_agents(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.not_device_user_agents.unwrap_or_default();
            v.push(input.into());
            self.not_device_user_agents = Some(v);
            self
        }
        /// <p>Device user agents that a rule <b>will not</b> match. All other device user agents will match.</p>
        pub fn set_not_device_user_agents(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.not_device_user_agents = input;
            self
        }
        /// <p>The date and time at which an access rule was created.</p>
        pub fn date_created(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_created = Some(input);
            self
        }
        /// <p>The date and time at which an access rule was created.</p>
        pub fn set_date_created(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_created = input;
            self
        }
        /// <p>The date and time at which an access rule was modified.</p>
        pub fn date_modified(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_modified = Some(input);
            self
        }
        /// <p>The date and time at which an access rule was modified.</p>
        pub fn set_date_modified(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_modified = input;
            self
        }
        /// Consumes the builder and constructs a [`MobileDeviceAccessRule`](crate::model::MobileDeviceAccessRule).
        pub fn build(self) -> crate::model::MobileDeviceAccessRule {
            crate::model::MobileDeviceAccessRule {
                mobile_device_access_rule_id: self.mobile_device_access_rule_id,
                name: self.name,
                description: self.description,
                effect: self.effect,
                device_types: self.device_types,
                not_device_types: self.not_device_types,
                device_models: self.device_models,
                not_device_models: self.not_device_models,
                device_operating_systems: self.device_operating_systems,
                not_device_operating_systems: self.not_device_operating_systems,
                device_user_agents: self.device_user_agents,
                not_device_user_agents: self.not_device_user_agents,
                date_created: self.date_created,
                date_modified: self.date_modified,
            }
        }
    }
}
impl MobileDeviceAccessRule {
    /// Creates a new builder-style object to manufacture [`MobileDeviceAccessRule`](crate::model::MobileDeviceAccessRule).
    pub fn builder() -> crate::model::mobile_device_access_rule::Builder {
        crate::model::mobile_device_access_rule::Builder::default()
    }
}

/// <p>The override object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MobileDeviceAccessOverride {
    /// <p>The WorkMail user to which the access override applies.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The device to which the override applies.</p>
    #[doc(hidden)]
    pub device_id: std::option::Option<std::string::String>,
    /// <p>The effect of the override, <code>ALLOW</code> or <code>DENY</code>.</p>
    #[doc(hidden)]
    pub effect: std::option::Option<crate::model::MobileDeviceAccessRuleEffect>,
    /// <p>A description of the override.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The date the override was first created.</p>
    #[doc(hidden)]
    pub date_created: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date the override was last modified.</p>
    #[doc(hidden)]
    pub date_modified: std::option::Option<aws_smithy_types::DateTime>,
}
impl MobileDeviceAccessOverride {
    /// <p>The WorkMail user to which the access override applies.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The device to which the override applies.</p>
    pub fn device_id(&self) -> std::option::Option<&str> {
        self.device_id.as_deref()
    }
    /// <p>The effect of the override, <code>ALLOW</code> or <code>DENY</code>.</p>
    pub fn effect(&self) -> std::option::Option<&crate::model::MobileDeviceAccessRuleEffect> {
        self.effect.as_ref()
    }
    /// <p>A description of the override.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The date the override was first created.</p>
    pub fn date_created(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_created.as_ref()
    }
    /// <p>The date the override was last modified.</p>
    pub fn date_modified(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_modified.as_ref()
    }
}
/// See [`MobileDeviceAccessOverride`](crate::model::MobileDeviceAccessOverride).
pub mod mobile_device_access_override {

    /// A builder for [`MobileDeviceAccessOverride`](crate::model::MobileDeviceAccessOverride).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) device_id: std::option::Option<std::string::String>,
        pub(crate) effect: std::option::Option<crate::model::MobileDeviceAccessRuleEffect>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) date_created: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) date_modified: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The WorkMail user to which the access override applies.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The WorkMail user to which the access override applies.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The device to which the override applies.</p>
        pub fn device_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_id = Some(input.into());
            self
        }
        /// <p>The device to which the override applies.</p>
        pub fn set_device_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.device_id = input;
            self
        }
        /// <p>The effect of the override, <code>ALLOW</code> or <code>DENY</code>.</p>
        pub fn effect(mut self, input: crate::model::MobileDeviceAccessRuleEffect) -> Self {
            self.effect = Some(input);
            self
        }
        /// <p>The effect of the override, <code>ALLOW</code> or <code>DENY</code>.</p>
        pub fn set_effect(
            mut self,
            input: std::option::Option<crate::model::MobileDeviceAccessRuleEffect>,
        ) -> Self {
            self.effect = input;
            self
        }
        /// <p>A description of the override.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of the override.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The date the override was first created.</p>
        pub fn date_created(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_created = Some(input);
            self
        }
        /// <p>The date the override was first created.</p>
        pub fn set_date_created(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_created = input;
            self
        }
        /// <p>The date the override was last modified.</p>
        pub fn date_modified(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_modified = Some(input);
            self
        }
        /// <p>The date the override was last modified.</p>
        pub fn set_date_modified(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_modified = input;
            self
        }
        /// Consumes the builder and constructs a [`MobileDeviceAccessOverride`](crate::model::MobileDeviceAccessOverride).
        pub fn build(self) -> crate::model::MobileDeviceAccessOverride {
            crate::model::MobileDeviceAccessOverride {
                user_id: self.user_id,
                device_id: self.device_id,
                effect: self.effect,
                description: self.description,
                date_created: self.date_created,
                date_modified: self.date_modified,
            }
        }
    }
}
impl MobileDeviceAccessOverride {
    /// Creates a new builder-style object to manufacture [`MobileDeviceAccessOverride`](crate::model::MobileDeviceAccessOverride).
    pub fn builder() -> crate::model::mobile_device_access_override::Builder {
        crate::model::mobile_device_access_override::Builder::default()
    }
}

/// <p>The data for a given domain.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MailDomainSummary {
    /// <p>The domain name.</p>
    #[doc(hidden)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>Whether the domain is default or not.</p>
    #[doc(hidden)]
    pub default_domain: bool,
}
impl MailDomainSummary {
    /// <p>The domain name.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>Whether the domain is default or not.</p>
    pub fn default_domain(&self) -> bool {
        self.default_domain
    }
}
/// See [`MailDomainSummary`](crate::model::MailDomainSummary).
pub mod mail_domain_summary {

    /// A builder for [`MailDomainSummary`](crate::model::MailDomainSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) default_domain: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The domain name.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The domain name.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>Whether the domain is default or not.</p>
        pub fn default_domain(mut self, input: bool) -> Self {
            self.default_domain = Some(input);
            self
        }
        /// <p>Whether the domain is default or not.</p>
        pub fn set_default_domain(mut self, input: std::option::Option<bool>) -> Self {
            self.default_domain = input;
            self
        }
        /// Consumes the builder and constructs a [`MailDomainSummary`](crate::model::MailDomainSummary).
        pub fn build(self) -> crate::model::MailDomainSummary {
            crate::model::MailDomainSummary {
                domain_name: self.domain_name,
                default_domain: self.default_domain.unwrap_or_default(),
            }
        }
    }
}
impl MailDomainSummary {
    /// Creates a new builder-style object to manufacture [`MailDomainSummary`](crate::model::MailDomainSummary).
    pub fn builder() -> crate::model::mail_domain_summary::Builder {
        crate::model::mail_domain_summary::Builder::default()
    }
}

/// <p>Permission granted to a user, group, or resource to access a certain aspect of another user, group, or resource mailbox.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Permission {
    /// <p>The identifier of the user, group, or resource to which the permissions are granted.</p>
    #[doc(hidden)]
    pub grantee_id: std::option::Option<std::string::String>,
    /// <p>The type of user, group, or resource referred to in GranteeId.</p>
    #[doc(hidden)]
    pub grantee_type: std::option::Option<crate::model::MemberType>,
    /// <p>The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.</p>
    #[doc(hidden)]
    pub permission_values: std::option::Option<std::vec::Vec<crate::model::PermissionType>>,
}
impl Permission {
    /// <p>The identifier of the user, group, or resource to which the permissions are granted.</p>
    pub fn grantee_id(&self) -> std::option::Option<&str> {
        self.grantee_id.as_deref()
    }
    /// <p>The type of user, group, or resource referred to in GranteeId.</p>
    pub fn grantee_type(&self) -> std::option::Option<&crate::model::MemberType> {
        self.grantee_type.as_ref()
    }
    /// <p>The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.</p>
    pub fn permission_values(&self) -> std::option::Option<&[crate::model::PermissionType]> {
        self.permission_values.as_deref()
    }
}
/// See [`Permission`](crate::model::Permission).
pub mod permission {

    /// A builder for [`Permission`](crate::model::Permission).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) grantee_id: std::option::Option<std::string::String>,
        pub(crate) grantee_type: std::option::Option<crate::model::MemberType>,
        pub(crate) permission_values:
            std::option::Option<std::vec::Vec<crate::model::PermissionType>>,
    }
    impl Builder {
        /// <p>The identifier of the user, group, or resource to which the permissions are granted.</p>
        pub fn grantee_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.grantee_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user, group, or resource to which the permissions are granted.</p>
        pub fn set_grantee_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.grantee_id = input;
            self
        }
        /// <p>The type of user, group, or resource referred to in GranteeId.</p>
        pub fn grantee_type(mut self, input: crate::model::MemberType) -> Self {
            self.grantee_type = Some(input);
            self
        }
        /// <p>The type of user, group, or resource referred to in GranteeId.</p>
        pub fn set_grantee_type(
            mut self,
            input: std::option::Option<crate::model::MemberType>,
        ) -> Self {
            self.grantee_type = input;
            self
        }
        /// Appends an item to `permission_values`.
        ///
        /// To override the contents of this collection use [`set_permission_values`](Self::set_permission_values).
        ///
        /// <p>The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.</p>
        pub fn permission_values(mut self, input: crate::model::PermissionType) -> Self {
            let mut v = self.permission_values.unwrap_or_default();
            v.push(input);
            self.permission_values = Some(v);
            self
        }
        /// <p>The permissions granted to the grantee. SEND_AS allows the grantee to send email as the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full access to the mailbox, irrespective of other folder-level permissions set on the mailbox.</p>
        pub fn set_permission_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PermissionType>>,
        ) -> Self {
            self.permission_values = input;
            self
        }
        /// Consumes the builder and constructs a [`Permission`](crate::model::Permission).
        pub fn build(self) -> crate::model::Permission {
            crate::model::Permission {
                grantee_id: self.grantee_id,
                grantee_type: self.grantee_type,
                permission_values: self.permission_values,
            }
        }
    }
}
impl Permission {
    /// Creates a new builder-style object to manufacture [`Permission`](crate::model::Permission).
    pub fn builder() -> crate::model::permission::Builder {
        crate::model::permission::Builder::default()
    }
}

/// <p>The details of a mailbox export job, including the user or resource ID associated with the mailbox and the S3 bucket that the mailbox contents are exported to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MailboxExportJob {
    /// <p>The identifier of the mailbox export job.</p>
    #[doc(hidden)]
    pub job_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the user or resource associated with the mailbox.</p>
    #[doc(hidden)]
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The mailbox export job description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the S3 bucket.</p>
    #[doc(hidden)]
    pub s3_bucket_name: std::option::Option<std::string::String>,
    /// <p>The path to the S3 bucket and file that the mailbox export job exports to.</p>
    #[doc(hidden)]
    pub s3_path: std::option::Option<std::string::String>,
    /// <p>The estimated progress of the mailbox export job, in percentage points.</p>
    #[doc(hidden)]
    pub estimated_progress: i32,
    /// <p>The state of the mailbox export job.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::MailboxExportJobState>,
    /// <p>The mailbox export job start timestamp.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The mailbox export job end timestamp.</p>
    #[doc(hidden)]
    pub end_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl MailboxExportJob {
    /// <p>The identifier of the mailbox export job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
    /// <p>The identifier of the user or resource associated with the mailbox.</p>
    pub fn entity_id(&self) -> std::option::Option<&str> {
        self.entity_id.as_deref()
    }
    /// <p>The mailbox export job description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name of the S3 bucket.</p>
    pub fn s3_bucket_name(&self) -> std::option::Option<&str> {
        self.s3_bucket_name.as_deref()
    }
    /// <p>The path to the S3 bucket and file that the mailbox export job exports to.</p>
    pub fn s3_path(&self) -> std::option::Option<&str> {
        self.s3_path.as_deref()
    }
    /// <p>The estimated progress of the mailbox export job, in percentage points.</p>
    pub fn estimated_progress(&self) -> i32 {
        self.estimated_progress
    }
    /// <p>The state of the mailbox export job.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::MailboxExportJobState> {
        self.state.as_ref()
    }
    /// <p>The mailbox export job start timestamp.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The mailbox export job end timestamp.</p>
    pub fn end_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.end_time.as_ref()
    }
}
/// See [`MailboxExportJob`](crate::model::MailboxExportJob).
pub mod mailbox_export_job {

    /// A builder for [`MailboxExportJob`](crate::model::MailboxExportJob).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) s3_bucket_name: std::option::Option<std::string::String>,
        pub(crate) s3_path: std::option::Option<std::string::String>,
        pub(crate) estimated_progress: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::MailboxExportJobState>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the mailbox export job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the mailbox export job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// <p>The identifier of the user or resource associated with the mailbox.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The identifier of the user or resource associated with the mailbox.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>The mailbox export job description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The mailbox export job description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name of the S3 bucket.</p>
        pub fn s3_bucket_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_bucket_name = Some(input.into());
            self
        }
        /// <p>The name of the S3 bucket.</p>
        pub fn set_s3_bucket_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_bucket_name = input;
            self
        }
        /// <p>The path to the S3 bucket and file that the mailbox export job exports to.</p>
        pub fn s3_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_path = Some(input.into());
            self
        }
        /// <p>The path to the S3 bucket and file that the mailbox export job exports to.</p>
        pub fn set_s3_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_path = input;
            self
        }
        /// <p>The estimated progress of the mailbox export job, in percentage points.</p>
        pub fn estimated_progress(mut self, input: i32) -> Self {
            self.estimated_progress = Some(input);
            self
        }
        /// <p>The estimated progress of the mailbox export job, in percentage points.</p>
        pub fn set_estimated_progress(mut self, input: std::option::Option<i32>) -> Self {
            self.estimated_progress = input;
            self
        }
        /// <p>The state of the mailbox export job.</p>
        pub fn state(mut self, input: crate::model::MailboxExportJobState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the mailbox export job.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::MailboxExportJobState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The mailbox export job start timestamp.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The mailbox export job start timestamp.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The mailbox export job end timestamp.</p>
        pub fn end_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The mailbox export job end timestamp.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// Consumes the builder and constructs a [`MailboxExportJob`](crate::model::MailboxExportJob).
        pub fn build(self) -> crate::model::MailboxExportJob {
            crate::model::MailboxExportJob {
                job_id: self.job_id,
                entity_id: self.entity_id,
                description: self.description,
                s3_bucket_name: self.s3_bucket_name,
                s3_path: self.s3_path,
                estimated_progress: self.estimated_progress.unwrap_or_default(),
                state: self.state,
                start_time: self.start_time,
                end_time: self.end_time,
            }
        }
    }
}
impl MailboxExportJob {
    /// Creates a new builder-style object to manufacture [`MailboxExportJob`](crate::model::MailboxExportJob).
    pub fn builder() -> crate::model::mailbox_export_job::Builder {
        crate::model::mailbox_export_job::Builder::default()
    }
}

/// When writing a match expression against `MailboxExportJobState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let mailboxexportjobstate = unimplemented!();
/// match mailboxexportjobstate {
///     MailboxExportJobState::Cancelled => { /* ... */ },
///     MailboxExportJobState::Completed => { /* ... */ },
///     MailboxExportJobState::Failed => { /* ... */ },
///     MailboxExportJobState::Running => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `mailboxexportjobstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MailboxExportJobState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MailboxExportJobState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MailboxExportJobState::NewFeature` is defined.
/// Specifically, when `mailboxexportjobstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MailboxExportJobState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MailboxExportJobState {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MailboxExportJobState {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => MailboxExportJobState::Cancelled,
            "COMPLETED" => MailboxExportJobState::Completed,
            "FAILED" => MailboxExportJobState::Failed,
            "RUNNING" => MailboxExportJobState::Running,
            other => {
                MailboxExportJobState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for MailboxExportJobState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MailboxExportJobState::from(s))
    }
}
impl MailboxExportJobState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MailboxExportJobState::Cancelled => "CANCELLED",
            MailboxExportJobState::Completed => "COMPLETED",
            MailboxExportJobState::Failed => "FAILED",
            MailboxExportJobState::Running => "RUNNING",
            MailboxExportJobState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CANCELLED", "COMPLETED", "FAILED", "RUNNING"]
    }
}
impl AsRef<str> for MailboxExportJobState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An impersonation role for the given WorkMail organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImpersonationRole {
    /// <p>The identifier of the impersonation role.</p>
    #[doc(hidden)]
    pub impersonation_role_id: std::option::Option<std::string::String>,
    /// <p>The impersonation role name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The impersonation role type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ImpersonationRoleType>,
    /// <p>The date when the impersonation role was created.</p>
    #[doc(hidden)]
    pub date_created: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date when the impersonation role was last modified.</p>
    #[doc(hidden)]
    pub date_modified: std::option::Option<aws_smithy_types::DateTime>,
}
impl ImpersonationRole {
    /// <p>The identifier of the impersonation role.</p>
    pub fn impersonation_role_id(&self) -> std::option::Option<&str> {
        self.impersonation_role_id.as_deref()
    }
    /// <p>The impersonation role name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The impersonation role type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ImpersonationRoleType> {
        self.r#type.as_ref()
    }
    /// <p>The date when the impersonation role was created.</p>
    pub fn date_created(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_created.as_ref()
    }
    /// <p>The date when the impersonation role was last modified.</p>
    pub fn date_modified(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_modified.as_ref()
    }
}
/// See [`ImpersonationRole`](crate::model::ImpersonationRole).
pub mod impersonation_role {

    /// A builder for [`ImpersonationRole`](crate::model::ImpersonationRole).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) impersonation_role_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::ImpersonationRoleType>,
        pub(crate) date_created: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) date_modified: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the impersonation role.</p>
        pub fn impersonation_role_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.impersonation_role_id = Some(input.into());
            self
        }
        /// <p>The identifier of the impersonation role.</p>
        pub fn set_impersonation_role_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.impersonation_role_id = input;
            self
        }
        /// <p>The impersonation role name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The impersonation role name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The impersonation role type.</p>
        pub fn r#type(mut self, input: crate::model::ImpersonationRoleType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The impersonation role type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ImpersonationRoleType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The date when the impersonation role was created.</p>
        pub fn date_created(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_created = Some(input);
            self
        }
        /// <p>The date when the impersonation role was created.</p>
        pub fn set_date_created(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_created = input;
            self
        }
        /// <p>The date when the impersonation role was last modified.</p>
        pub fn date_modified(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_modified = Some(input);
            self
        }
        /// <p>The date when the impersonation role was last modified.</p>
        pub fn set_date_modified(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_modified = input;
            self
        }
        /// Consumes the builder and constructs a [`ImpersonationRole`](crate::model::ImpersonationRole).
        pub fn build(self) -> crate::model::ImpersonationRole {
            crate::model::ImpersonationRole {
                impersonation_role_id: self.impersonation_role_id,
                name: self.name,
                r#type: self.r#type,
                date_created: self.date_created,
                date_modified: self.date_modified,
            }
        }
    }
}
impl ImpersonationRole {
    /// Creates a new builder-style object to manufacture [`ImpersonationRole`](crate::model::ImpersonationRole).
    pub fn builder() -> crate::model::impersonation_role::Builder {
        crate::model::impersonation_role::Builder::default()
    }
}

/// <p>The representation of an WorkMail group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Group {
    /// <p>The identifier of the group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The email of the group.</p>
    #[doc(hidden)]
    pub email: std::option::Option<std::string::String>,
    /// <p>The name of the group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The state of the group, which can be ENABLED, DISABLED, or DELETED.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::EntityState>,
    /// <p>The date indicating when the group was enabled for WorkMail use.</p>
    #[doc(hidden)]
    pub enabled_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date indicating when the group was disabled from WorkMail use.</p>
    #[doc(hidden)]
    pub disabled_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl Group {
    /// <p>The identifier of the group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The email of the group.</p>
    pub fn email(&self) -> std::option::Option<&str> {
        self.email.as_deref()
    }
    /// <p>The name of the group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The state of the group, which can be ENABLED, DISABLED, or DELETED.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::EntityState> {
        self.state.as_ref()
    }
    /// <p>The date indicating when the group was enabled for WorkMail use.</p>
    pub fn enabled_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.enabled_date.as_ref()
    }
    /// <p>The date indicating when the group was disabled from WorkMail use.</p>
    pub fn disabled_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.disabled_date.as_ref()
    }
}
/// See [`Group`](crate::model::Group).
pub mod group {

    /// A builder for [`Group`](crate::model::Group).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::EntityState>,
        pub(crate) enabled_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) disabled_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The email of the group.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.email = Some(input.into());
            self
        }
        /// <p>The email of the group.</p>
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.email = input;
            self
        }
        /// <p>The name of the group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The state of the group, which can be ENABLED, DISABLED, or DELETED.</p>
        pub fn state(mut self, input: crate::model::EntityState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the group, which can be ENABLED, DISABLED, or DELETED.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::EntityState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The date indicating when the group was enabled for WorkMail use.</p>
        pub fn enabled_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.enabled_date = Some(input);
            self
        }
        /// <p>The date indicating when the group was enabled for WorkMail use.</p>
        pub fn set_enabled_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.enabled_date = input;
            self
        }
        /// <p>The date indicating when the group was disabled from WorkMail use.</p>
        pub fn disabled_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.disabled_date = Some(input);
            self
        }
        /// <p>The date indicating when the group was disabled from WorkMail use.</p>
        pub fn set_disabled_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.disabled_date = input;
            self
        }
        /// Consumes the builder and constructs a [`Group`](crate::model::Group).
        pub fn build(self) -> crate::model::Group {
            crate::model::Group {
                id: self.id,
                email: self.email,
                name: self.name,
                state: self.state,
                enabled_date: self.enabled_date,
                disabled_date: self.disabled_date,
            }
        }
    }
}
impl Group {
    /// Creates a new builder-style object to manufacture [`Group`](crate::model::Group).
    pub fn builder() -> crate::model::group::Builder {
        crate::model::group::Builder::default()
    }
}

/// <p>The representation of a user or group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Member {
    /// <p>The identifier of the member.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the member.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A member can be a user or group.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::MemberType>,
    /// <p>The state of the member, which can be ENABLED, DISABLED, or DELETED.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::EntityState>,
    /// <p>The date indicating when the member was enabled for WorkMail use.</p>
    #[doc(hidden)]
    pub enabled_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date indicating when the member was disabled from WorkMail use.</p>
    #[doc(hidden)]
    pub disabled_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl Member {
    /// <p>The identifier of the member.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the member.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>A member can be a user or group.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::MemberType> {
        self.r#type.as_ref()
    }
    /// <p>The state of the member, which can be ENABLED, DISABLED, or DELETED.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::EntityState> {
        self.state.as_ref()
    }
    /// <p>The date indicating when the member was enabled for WorkMail use.</p>
    pub fn enabled_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.enabled_date.as_ref()
    }
    /// <p>The date indicating when the member was disabled from WorkMail use.</p>
    pub fn disabled_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.disabled_date.as_ref()
    }
}
/// See [`Member`](crate::model::Member).
pub mod member {

    /// A builder for [`Member`](crate::model::Member).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::MemberType>,
        pub(crate) state: std::option::Option<crate::model::EntityState>,
        pub(crate) enabled_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) disabled_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the member.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The identifier of the member.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the member.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the member.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A member can be a user or group.</p>
        pub fn r#type(mut self, input: crate::model::MemberType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>A member can be a user or group.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::MemberType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The state of the member, which can be ENABLED, DISABLED, or DELETED.</p>
        pub fn state(mut self, input: crate::model::EntityState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the member, which can be ENABLED, DISABLED, or DELETED.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::EntityState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The date indicating when the member was enabled for WorkMail use.</p>
        pub fn enabled_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.enabled_date = Some(input);
            self
        }
        /// <p>The date indicating when the member was enabled for WorkMail use.</p>
        pub fn set_enabled_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.enabled_date = input;
            self
        }
        /// <p>The date indicating when the member was disabled from WorkMail use.</p>
        pub fn disabled_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.disabled_date = Some(input);
            self
        }
        /// <p>The date indicating when the member was disabled from WorkMail use.</p>
        pub fn set_disabled_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.disabled_date = input;
            self
        }
        /// Consumes the builder and constructs a [`Member`](crate::model::Member).
        pub fn build(self) -> crate::model::Member {
            crate::model::Member {
                id: self.id,
                name: self.name,
                r#type: self.r#type,
                state: self.state,
                enabled_date: self.enabled_date,
                disabled_date: self.disabled_date,
            }
        }
    }
}
impl Member {
    /// Creates a new builder-style object to manufacture [`Member`](crate::model::Member).
    pub fn builder() -> crate::model::member::Builder {
        crate::model::member::Builder::default()
    }
}

/// <p>List all the <code>AvailabilityConfiguration</code>'s for the given WorkMail organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AvailabilityConfiguration {
    /// <p>Displays the domain to which the provider applies.</p>
    #[doc(hidden)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>Displays the provider type that applies to this domain.</p>
    #[doc(hidden)]
    pub provider_type: std::option::Option<crate::model::AvailabilityProviderType>,
    /// <p>If <code>ProviderType</code> is <code>EWS</code>, then this field contains <code>RedactedEwsAvailabilityProvider</code>. Otherwise, it is not required.</p>
    #[doc(hidden)]
    pub ews_provider: std::option::Option<crate::model::RedactedEwsAvailabilityProvider>,
    /// <p>If ProviderType is <code>LAMBDA</code> then this field contains <code>LambdaAvailabilityProvider</code>. Otherwise, it is not required.</p>
    #[doc(hidden)]
    pub lambda_provider: std::option::Option<crate::model::LambdaAvailabilityProvider>,
    /// <p>The date and time at which the availability configuration was created.</p>
    #[doc(hidden)]
    pub date_created: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time at which the availability configuration was last modified.</p>
    #[doc(hidden)]
    pub date_modified: std::option::Option<aws_smithy_types::DateTime>,
}
impl AvailabilityConfiguration {
    /// <p>Displays the domain to which the provider applies.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>Displays the provider type that applies to this domain.</p>
    pub fn provider_type(&self) -> std::option::Option<&crate::model::AvailabilityProviderType> {
        self.provider_type.as_ref()
    }
    /// <p>If <code>ProviderType</code> is <code>EWS</code>, then this field contains <code>RedactedEwsAvailabilityProvider</code>. Otherwise, it is not required.</p>
    pub fn ews_provider(
        &self,
    ) -> std::option::Option<&crate::model::RedactedEwsAvailabilityProvider> {
        self.ews_provider.as_ref()
    }
    /// <p>If ProviderType is <code>LAMBDA</code> then this field contains <code>LambdaAvailabilityProvider</code>. Otherwise, it is not required.</p>
    pub fn lambda_provider(
        &self,
    ) -> std::option::Option<&crate::model::LambdaAvailabilityProvider> {
        self.lambda_provider.as_ref()
    }
    /// <p>The date and time at which the availability configuration was created.</p>
    pub fn date_created(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_created.as_ref()
    }
    /// <p>The date and time at which the availability configuration was last modified.</p>
    pub fn date_modified(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_modified.as_ref()
    }
}
/// See [`AvailabilityConfiguration`](crate::model::AvailabilityConfiguration).
pub mod availability_configuration {

    /// A builder for [`AvailabilityConfiguration`](crate::model::AvailabilityConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) provider_type: std::option::Option<crate::model::AvailabilityProviderType>,
        pub(crate) ews_provider: std::option::Option<crate::model::RedactedEwsAvailabilityProvider>,
        pub(crate) lambda_provider: std::option::Option<crate::model::LambdaAvailabilityProvider>,
        pub(crate) date_created: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) date_modified: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Displays the domain to which the provider applies.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>Displays the domain to which the provider applies.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>Displays the provider type that applies to this domain.</p>
        pub fn provider_type(mut self, input: crate::model::AvailabilityProviderType) -> Self {
            self.provider_type = Some(input);
            self
        }
        /// <p>Displays the provider type that applies to this domain.</p>
        pub fn set_provider_type(
            mut self,
            input: std::option::Option<crate::model::AvailabilityProviderType>,
        ) -> Self {
            self.provider_type = input;
            self
        }
        /// <p>If <code>ProviderType</code> is <code>EWS</code>, then this field contains <code>RedactedEwsAvailabilityProvider</code>. Otherwise, it is not required.</p>
        pub fn ews_provider(
            mut self,
            input: crate::model::RedactedEwsAvailabilityProvider,
        ) -> Self {
            self.ews_provider = Some(input);
            self
        }
        /// <p>If <code>ProviderType</code> is <code>EWS</code>, then this field contains <code>RedactedEwsAvailabilityProvider</code>. Otherwise, it is not required.</p>
        pub fn set_ews_provider(
            mut self,
            input: std::option::Option<crate::model::RedactedEwsAvailabilityProvider>,
        ) -> Self {
            self.ews_provider = input;
            self
        }
        /// <p>If ProviderType is <code>LAMBDA</code> then this field contains <code>LambdaAvailabilityProvider</code>. Otherwise, it is not required.</p>
        pub fn lambda_provider(mut self, input: crate::model::LambdaAvailabilityProvider) -> Self {
            self.lambda_provider = Some(input);
            self
        }
        /// <p>If ProviderType is <code>LAMBDA</code> then this field contains <code>LambdaAvailabilityProvider</code>. Otherwise, it is not required.</p>
        pub fn set_lambda_provider(
            mut self,
            input: std::option::Option<crate::model::LambdaAvailabilityProvider>,
        ) -> Self {
            self.lambda_provider = input;
            self
        }
        /// <p>The date and time at which the availability configuration was created.</p>
        pub fn date_created(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_created = Some(input);
            self
        }
        /// <p>The date and time at which the availability configuration was created.</p>
        pub fn set_date_created(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_created = input;
            self
        }
        /// <p>The date and time at which the availability configuration was last modified.</p>
        pub fn date_modified(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_modified = Some(input);
            self
        }
        /// <p>The date and time at which the availability configuration was last modified.</p>
        pub fn set_date_modified(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_modified = input;
            self
        }
        /// Consumes the builder and constructs a [`AvailabilityConfiguration`](crate::model::AvailabilityConfiguration).
        pub fn build(self) -> crate::model::AvailabilityConfiguration {
            crate::model::AvailabilityConfiguration {
                domain_name: self.domain_name,
                provider_type: self.provider_type,
                ews_provider: self.ews_provider,
                lambda_provider: self.lambda_provider,
                date_created: self.date_created,
                date_modified: self.date_modified,
            }
        }
    }
}
impl AvailabilityConfiguration {
    /// Creates a new builder-style object to manufacture [`AvailabilityConfiguration`](crate::model::AvailabilityConfiguration).
    pub fn builder() -> crate::model::availability_configuration::Builder {
        crate::model::availability_configuration::Builder::default()
    }
}

/// <p>Describes an EWS based availability provider when returned from the service. It does not contain the password of the endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RedactedEwsAvailabilityProvider {
    /// <p>The endpoint of the remote EWS server.</p>
    #[doc(hidden)]
    pub ews_endpoint: std::option::Option<std::string::String>,
    /// <p>The username used to authenticate the remote EWS server.</p>
    #[doc(hidden)]
    pub ews_username: std::option::Option<std::string::String>,
}
impl RedactedEwsAvailabilityProvider {
    /// <p>The endpoint of the remote EWS server.</p>
    pub fn ews_endpoint(&self) -> std::option::Option<&str> {
        self.ews_endpoint.as_deref()
    }
    /// <p>The username used to authenticate the remote EWS server.</p>
    pub fn ews_username(&self) -> std::option::Option<&str> {
        self.ews_username.as_deref()
    }
}
/// See [`RedactedEwsAvailabilityProvider`](crate::model::RedactedEwsAvailabilityProvider).
pub mod redacted_ews_availability_provider {

    /// A builder for [`RedactedEwsAvailabilityProvider`](crate::model::RedactedEwsAvailabilityProvider).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ews_endpoint: std::option::Option<std::string::String>,
        pub(crate) ews_username: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The endpoint of the remote EWS server.</p>
        pub fn ews_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.ews_endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of the remote EWS server.</p>
        pub fn set_ews_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ews_endpoint = input;
            self
        }
        /// <p>The username used to authenticate the remote EWS server.</p>
        pub fn ews_username(mut self, input: impl Into<std::string::String>) -> Self {
            self.ews_username = Some(input.into());
            self
        }
        /// <p>The username used to authenticate the remote EWS server.</p>
        pub fn set_ews_username(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ews_username = input;
            self
        }
        /// Consumes the builder and constructs a [`RedactedEwsAvailabilityProvider`](crate::model::RedactedEwsAvailabilityProvider).
        pub fn build(self) -> crate::model::RedactedEwsAvailabilityProvider {
            crate::model::RedactedEwsAvailabilityProvider {
                ews_endpoint: self.ews_endpoint,
                ews_username: self.ews_username,
            }
        }
    }
}
impl RedactedEwsAvailabilityProvider {
    /// Creates a new builder-style object to manufacture [`RedactedEwsAvailabilityProvider`](crate::model::RedactedEwsAvailabilityProvider).
    pub fn builder() -> crate::model::redacted_ews_availability_provider::Builder {
        crate::model::redacted_ews_availability_provider::Builder::default()
    }
}

/// When writing a match expression against `AvailabilityProviderType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let availabilityprovidertype = unimplemented!();
/// match availabilityprovidertype {
///     AvailabilityProviderType::Ews => { /* ... */ },
///     AvailabilityProviderType::Lambda => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `availabilityprovidertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AvailabilityProviderType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AvailabilityProviderType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AvailabilityProviderType::NewFeature` is defined.
/// Specifically, when `availabilityprovidertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AvailabilityProviderType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AvailabilityProviderType {
    #[allow(missing_docs)] // documentation missing in model
    Ews,
    #[allow(missing_docs)] // documentation missing in model
    Lambda,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AvailabilityProviderType {
    fn from(s: &str) -> Self {
        match s {
            "EWS" => AvailabilityProviderType::Ews,
            "LAMBDA" => AvailabilityProviderType::Lambda,
            other => AvailabilityProviderType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AvailabilityProviderType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AvailabilityProviderType::from(s))
    }
}
impl AvailabilityProviderType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AvailabilityProviderType::Ews => "EWS",
            AvailabilityProviderType::Lambda => "LAMBDA",
            AvailabilityProviderType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EWS", "LAMBDA"]
    }
}
impl AsRef<str> for AvailabilityProviderType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A rule that controls access to an WorkMail organization.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccessControlRule {
    /// <p>The rule name.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The rule effect.</p>
    #[doc(hidden)]
    pub effect: std::option::Option<crate::model::AccessControlRuleEffect>,
    /// <p>The rule description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>IPv4 CIDR ranges to include in the rule.</p>
    #[doc(hidden)]
    pub ip_ranges: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>IPv4 CIDR ranges to exclude from the rule.</p>
    #[doc(hidden)]
    pub not_ip_ranges: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Access protocol actions to include in the rule. Valid values include <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>, <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
    #[doc(hidden)]
    pub actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Access protocol actions to exclude from the rule. Valid values include <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>, <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
    #[doc(hidden)]
    pub not_actions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>User IDs to include in the rule.</p>
    #[doc(hidden)]
    pub user_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>User IDs to exclude from the rule.</p>
    #[doc(hidden)]
    pub not_user_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The date that the rule was created.</p>
    #[doc(hidden)]
    pub date_created: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date that the rule was modified.</p>
    #[doc(hidden)]
    pub date_modified: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>Impersonation role IDs to include in the rule.</p>
    #[doc(hidden)]
    pub impersonation_role_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Impersonation role IDs to exclude from the rule.</p>
    #[doc(hidden)]
    pub not_impersonation_role_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl AccessControlRule {
    /// <p>The rule name.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The rule effect.</p>
    pub fn effect(&self) -> std::option::Option<&crate::model::AccessControlRuleEffect> {
        self.effect.as_ref()
    }
    /// <p>The rule description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>IPv4 CIDR ranges to include in the rule.</p>
    pub fn ip_ranges(&self) -> std::option::Option<&[std::string::String]> {
        self.ip_ranges.as_deref()
    }
    /// <p>IPv4 CIDR ranges to exclude from the rule.</p>
    pub fn not_ip_ranges(&self) -> std::option::Option<&[std::string::String]> {
        self.not_ip_ranges.as_deref()
    }
    /// <p>Access protocol actions to include in the rule. Valid values include <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>, <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
    pub fn actions(&self) -> std::option::Option<&[std::string::String]> {
        self.actions.as_deref()
    }
    /// <p>Access protocol actions to exclude from the rule. Valid values include <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>, <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
    pub fn not_actions(&self) -> std::option::Option<&[std::string::String]> {
        self.not_actions.as_deref()
    }
    /// <p>User IDs to include in the rule.</p>
    pub fn user_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.user_ids.as_deref()
    }
    /// <p>User IDs to exclude from the rule.</p>
    pub fn not_user_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.not_user_ids.as_deref()
    }
    /// <p>The date that the rule was created.</p>
    pub fn date_created(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_created.as_ref()
    }
    /// <p>The date that the rule was modified.</p>
    pub fn date_modified(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.date_modified.as_ref()
    }
    /// <p>Impersonation role IDs to include in the rule.</p>
    pub fn impersonation_role_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.impersonation_role_ids.as_deref()
    }
    /// <p>Impersonation role IDs to exclude from the rule.</p>
    pub fn not_impersonation_role_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.not_impersonation_role_ids.as_deref()
    }
}
/// See [`AccessControlRule`](crate::model::AccessControlRule).
pub mod access_control_rule {

    /// A builder for [`AccessControlRule`](crate::model::AccessControlRule).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) effect: std::option::Option<crate::model::AccessControlRuleEffect>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ip_ranges: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) not_ip_ranges: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) not_actions: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) user_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) not_user_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) date_created: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) date_modified: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) impersonation_role_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) not_impersonation_role_ids:
            std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The rule name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The rule name.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The rule effect.</p>
        pub fn effect(mut self, input: crate::model::AccessControlRuleEffect) -> Self {
            self.effect = Some(input);
            self
        }
        /// <p>The rule effect.</p>
        pub fn set_effect(
            mut self,
            input: std::option::Option<crate::model::AccessControlRuleEffect>,
        ) -> Self {
            self.effect = input;
            self
        }
        /// <p>The rule description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The rule description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `ip_ranges`.
        ///
        /// To override the contents of this collection use [`set_ip_ranges`](Self::set_ip_ranges).
        ///
        /// <p>IPv4 CIDR ranges to include in the rule.</p>
        pub fn ip_ranges(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ip_ranges.unwrap_or_default();
            v.push(input.into());
            self.ip_ranges = Some(v);
            self
        }
        /// <p>IPv4 CIDR ranges to include in the rule.</p>
        pub fn set_ip_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ip_ranges = input;
            self
        }
        /// Appends an item to `not_ip_ranges`.
        ///
        /// To override the contents of this collection use [`set_not_ip_ranges`](Self::set_not_ip_ranges).
        ///
        /// <p>IPv4 CIDR ranges to exclude from the rule.</p>
        pub fn not_ip_ranges(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.not_ip_ranges.unwrap_or_default();
            v.push(input.into());
            self.not_ip_ranges = Some(v);
            self
        }
        /// <p>IPv4 CIDR ranges to exclude from the rule.</p>
        pub fn set_not_ip_ranges(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.not_ip_ranges = input;
            self
        }
        /// Appends an item to `actions`.
        ///
        /// To override the contents of this collection use [`set_actions`](Self::set_actions).
        ///
        /// <p>Access protocol actions to include in the rule. Valid values include <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>, <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
        pub fn actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.actions.unwrap_or_default();
            v.push(input.into());
            self.actions = Some(v);
            self
        }
        /// <p>Access protocol actions to include in the rule. Valid values include <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>, <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
        pub fn set_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.actions = input;
            self
        }
        /// Appends an item to `not_actions`.
        ///
        /// To override the contents of this collection use [`set_not_actions`](Self::set_not_actions).
        ///
        /// <p>Access protocol actions to exclude from the rule. Valid values include <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>, <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
        pub fn not_actions(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.not_actions.unwrap_or_default();
            v.push(input.into());
            self.not_actions = Some(v);
            self
        }
        /// <p>Access protocol actions to exclude from the rule. Valid values include <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>, <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
        pub fn set_not_actions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.not_actions = input;
            self
        }
        /// Appends an item to `user_ids`.
        ///
        /// To override the contents of this collection use [`set_user_ids`](Self::set_user_ids).
        ///
        /// <p>User IDs to include in the rule.</p>
        pub fn user_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.user_ids.unwrap_or_default();
            v.push(input.into());
            self.user_ids = Some(v);
            self
        }
        /// <p>User IDs to include in the rule.</p>
        pub fn set_user_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.user_ids = input;
            self
        }
        /// Appends an item to `not_user_ids`.
        ///
        /// To override the contents of this collection use [`set_not_user_ids`](Self::set_not_user_ids).
        ///
        /// <p>User IDs to exclude from the rule.</p>
        pub fn not_user_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.not_user_ids.unwrap_or_default();
            v.push(input.into());
            self.not_user_ids = Some(v);
            self
        }
        /// <p>User IDs to exclude from the rule.</p>
        pub fn set_not_user_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.not_user_ids = input;
            self
        }
        /// <p>The date that the rule was created.</p>
        pub fn date_created(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_created = Some(input);
            self
        }
        /// <p>The date that the rule was created.</p>
        pub fn set_date_created(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_created = input;
            self
        }
        /// <p>The date that the rule was modified.</p>
        pub fn date_modified(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.date_modified = Some(input);
            self
        }
        /// <p>The date that the rule was modified.</p>
        pub fn set_date_modified(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.date_modified = input;
            self
        }
        /// Appends an item to `impersonation_role_ids`.
        ///
        /// To override the contents of this collection use [`set_impersonation_role_ids`](Self::set_impersonation_role_ids).
        ///
        /// <p>Impersonation role IDs to include in the rule.</p>
        pub fn impersonation_role_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.impersonation_role_ids.unwrap_or_default();
            v.push(input.into());
            self.impersonation_role_ids = Some(v);
            self
        }
        /// <p>Impersonation role IDs to include in the rule.</p>
        pub fn set_impersonation_role_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.impersonation_role_ids = input;
            self
        }
        /// Appends an item to `not_impersonation_role_ids`.
        ///
        /// To override the contents of this collection use [`set_not_impersonation_role_ids`](Self::set_not_impersonation_role_ids).
        ///
        /// <p>Impersonation role IDs to exclude from the rule.</p>
        pub fn not_impersonation_role_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.not_impersonation_role_ids.unwrap_or_default();
            v.push(input.into());
            self.not_impersonation_role_ids = Some(v);
            self
        }
        /// <p>Impersonation role IDs to exclude from the rule.</p>
        pub fn set_not_impersonation_role_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.not_impersonation_role_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessControlRule`](crate::model::AccessControlRule).
        pub fn build(self) -> crate::model::AccessControlRule {
            crate::model::AccessControlRule {
                name: self.name,
                effect: self.effect,
                description: self.description,
                ip_ranges: self.ip_ranges,
                not_ip_ranges: self.not_ip_ranges,
                actions: self.actions,
                not_actions: self.not_actions,
                user_ids: self.user_ids,
                not_user_ids: self.not_user_ids,
                date_created: self.date_created,
                date_modified: self.date_modified,
                impersonation_role_ids: self.impersonation_role_ids,
                not_impersonation_role_ids: self.not_impersonation_role_ids,
            }
        }
    }
}
impl AccessControlRule {
    /// Creates a new builder-style object to manufacture [`AccessControlRule`](crate::model::AccessControlRule).
    pub fn builder() -> crate::model::access_control_rule::Builder {
        crate::model::access_control_rule::Builder::default()
    }
}

/// <p>The rule that a simulated user matches.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MobileDeviceAccessMatchedRule {
    /// <p>Identifier of the rule that a simulated user matches.</p>
    #[doc(hidden)]
    pub mobile_device_access_rule_id: std::option::Option<std::string::String>,
    /// <p>Name of a rule that a simulated user matches.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl MobileDeviceAccessMatchedRule {
    /// <p>Identifier of the rule that a simulated user matches.</p>
    pub fn mobile_device_access_rule_id(&self) -> std::option::Option<&str> {
        self.mobile_device_access_rule_id.as_deref()
    }
    /// <p>Name of a rule that a simulated user matches.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`MobileDeviceAccessMatchedRule`](crate::model::MobileDeviceAccessMatchedRule).
pub mod mobile_device_access_matched_rule {

    /// A builder for [`MobileDeviceAccessMatchedRule`](crate::model::MobileDeviceAccessMatchedRule).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mobile_device_access_rule_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifier of the rule that a simulated user matches.</p>
        pub fn mobile_device_access_rule_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.mobile_device_access_rule_id = Some(input.into());
            self
        }
        /// <p>Identifier of the rule that a simulated user matches.</p>
        pub fn set_mobile_device_access_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.mobile_device_access_rule_id = input;
            self
        }
        /// <p>Name of a rule that a simulated user matches.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of a rule that a simulated user matches.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`MobileDeviceAccessMatchedRule`](crate::model::MobileDeviceAccessMatchedRule).
        pub fn build(self) -> crate::model::MobileDeviceAccessMatchedRule {
            crate::model::MobileDeviceAccessMatchedRule {
                mobile_device_access_rule_id: self.mobile_device_access_rule_id,
                name: self.name,
            }
        }
    }
}
impl MobileDeviceAccessMatchedRule {
    /// Creates a new builder-style object to manufacture [`MobileDeviceAccessMatchedRule`](crate::model::MobileDeviceAccessMatchedRule).
    pub fn builder() -> crate::model::mobile_device_access_matched_rule::Builder {
        crate::model::mobile_device_access_matched_rule::Builder::default()
    }
}

/// When writing a match expression against `DnsRecordVerificationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dnsrecordverificationstatus = unimplemented!();
/// match dnsrecordverificationstatus {
///     DnsRecordVerificationStatus::Failed => { /* ... */ },
///     DnsRecordVerificationStatus::Pending => { /* ... */ },
///     DnsRecordVerificationStatus::Verified => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dnsrecordverificationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DnsRecordVerificationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DnsRecordVerificationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DnsRecordVerificationStatus::NewFeature` is defined.
/// Specifically, when `dnsrecordverificationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DnsRecordVerificationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DnsRecordVerificationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Verified,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DnsRecordVerificationStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => DnsRecordVerificationStatus::Failed,
            "PENDING" => DnsRecordVerificationStatus::Pending,
            "VERIFIED" => DnsRecordVerificationStatus::Verified,
            other => DnsRecordVerificationStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DnsRecordVerificationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DnsRecordVerificationStatus::from(s))
    }
}
impl DnsRecordVerificationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DnsRecordVerificationStatus::Failed => "FAILED",
            DnsRecordVerificationStatus::Pending => "PENDING",
            DnsRecordVerificationStatus::Verified => "VERIFIED",
            DnsRecordVerificationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "PENDING", "VERIFIED"]
    }
}
impl AsRef<str> for DnsRecordVerificationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A DNS record uploaded to your DNS provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DnsRecord {
    /// <p>The RFC 1035 record type. Possible values: <code>CNAME</code>, <code>A</code>, <code>MX</code>.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The DNS hostname.- For example, <code>domain.example.com</code>.</p>
    #[doc(hidden)]
    pub hostname: std::option::Option<std::string::String>,
    /// <p>The value returned by the DNS for a query to that hostname and record type.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl DnsRecord {
    /// <p>The RFC 1035 record type. Possible values: <code>CNAME</code>, <code>A</code>, <code>MX</code>.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The DNS hostname.- For example, <code>domain.example.com</code>.</p>
    pub fn hostname(&self) -> std::option::Option<&str> {
        self.hostname.as_deref()
    }
    /// <p>The value returned by the DNS for a query to that hostname and record type.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`DnsRecord`](crate::model::DnsRecord).
pub mod dns_record {

    /// A builder for [`DnsRecord`](crate::model::DnsRecord).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) hostname: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The RFC 1035 record type. Possible values: <code>CNAME</code>, <code>A</code>, <code>MX</code>.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The RFC 1035 record type. Possible values: <code>CNAME</code>, <code>A</code>, <code>MX</code>.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The DNS hostname.- For example, <code>domain.example.com</code>.</p>
        pub fn hostname(mut self, input: impl Into<std::string::String>) -> Self {
            self.hostname = Some(input.into());
            self
        }
        /// <p>The DNS hostname.- For example, <code>domain.example.com</code>.</p>
        pub fn set_hostname(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.hostname = input;
            self
        }
        /// <p>The value returned by the DNS for a query to that hostname and record type.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value returned by the DNS for a query to that hostname and record type.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`DnsRecord`](crate::model::DnsRecord).
        pub fn build(self) -> crate::model::DnsRecord {
            crate::model::DnsRecord {
                r#type: self.r#type,
                hostname: self.hostname,
                value: self.value,
            }
        }
    }
}
impl DnsRecord {
    /// Creates a new builder-style object to manufacture [`DnsRecord`](crate::model::DnsRecord).
    pub fn builder() -> crate::model::dns_record::Builder {
        crate::model::dns_record::Builder::default()
    }
}

/// <p>The impersonation rule that matched the input.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImpersonationMatchedRule {
    /// <p>The ID of the rule that matched the input</p>
    #[doc(hidden)]
    pub impersonation_rule_id: std::option::Option<std::string::String>,
    /// <p>The name of the rule that matched the input.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl ImpersonationMatchedRule {
    /// <p>The ID of the rule that matched the input</p>
    pub fn impersonation_rule_id(&self) -> std::option::Option<&str> {
        self.impersonation_rule_id.as_deref()
    }
    /// <p>The name of the rule that matched the input.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
/// See [`ImpersonationMatchedRule`](crate::model::ImpersonationMatchedRule).
pub mod impersonation_matched_rule {

    /// A builder for [`ImpersonationMatchedRule`](crate::model::ImpersonationMatchedRule).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) impersonation_rule_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the rule that matched the input</p>
        pub fn impersonation_rule_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.impersonation_rule_id = Some(input.into());
            self
        }
        /// <p>The ID of the rule that matched the input</p>
        pub fn set_impersonation_rule_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.impersonation_rule_id = input;
            self
        }
        /// <p>The name of the rule that matched the input.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the rule that matched the input.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`ImpersonationMatchedRule`](crate::model::ImpersonationMatchedRule).
        pub fn build(self) -> crate::model::ImpersonationMatchedRule {
            crate::model::ImpersonationMatchedRule {
                impersonation_rule_id: self.impersonation_rule_id,
                name: self.name,
            }
        }
    }
}
impl ImpersonationMatchedRule {
    /// Creates a new builder-style object to manufacture [`ImpersonationMatchedRule`](crate::model::ImpersonationMatchedRule).
    pub fn builder() -> crate::model::impersonation_matched_rule::Builder {
        crate::model::impersonation_matched_rule::Builder::default()
    }
}

/// <p>The domain to associate with an WorkMail organization.</p>
/// <p>When you configure a domain hosted in Amazon Route 53 (Route 53), all recommended DNS records are added to the organization when you create it. For more information, see <a href="https://docs.aws.amazon.com/workmail/latest/adminguide/add_domain.html">Adding a domain</a> in the <i>WorkMail Administrator Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Domain {
    /// <p>The fully qualified domain name.</p>
    #[doc(hidden)]
    pub domain_name: std::option::Option<std::string::String>,
    /// <p>The hosted zone ID for a domain hosted in Route 53. Required when configuring a domain hosted in Route 53.</p>
    #[doc(hidden)]
    pub hosted_zone_id: std::option::Option<std::string::String>,
}
impl Domain {
    /// <p>The fully qualified domain name.</p>
    pub fn domain_name(&self) -> std::option::Option<&str> {
        self.domain_name.as_deref()
    }
    /// <p>The hosted zone ID for a domain hosted in Route 53. Required when configuring a domain hosted in Route 53.</p>
    pub fn hosted_zone_id(&self) -> std::option::Option<&str> {
        self.hosted_zone_id.as_deref()
    }
}
/// See [`Domain`](crate::model::Domain).
pub mod domain {

    /// A builder for [`Domain`](crate::model::Domain).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) domain_name: std::option::Option<std::string::String>,
        pub(crate) hosted_zone_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The fully qualified domain name.</p>
        pub fn domain_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.domain_name = Some(input.into());
            self
        }
        /// <p>The fully qualified domain name.</p>
        pub fn set_domain_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.domain_name = input;
            self
        }
        /// <p>The hosted zone ID for a domain hosted in Route 53. Required when configuring a domain hosted in Route 53.</p>
        pub fn hosted_zone_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.hosted_zone_id = Some(input.into());
            self
        }
        /// <p>The hosted zone ID for a domain hosted in Route 53. Required when configuring a domain hosted in Route 53.</p>
        pub fn set_hosted_zone_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.hosted_zone_id = input;
            self
        }
        /// Consumes the builder and constructs a [`Domain`](crate::model::Domain).
        pub fn build(self) -> crate::model::Domain {
            crate::model::Domain {
                domain_name: self.domain_name,
                hosted_zone_id: self.hosted_zone_id,
            }
        }
    }
}
impl Domain {
    /// Creates a new builder-style object to manufacture [`Domain`](crate::model::Domain).
    pub fn builder() -> crate::model::domain::Builder {
        crate::model::domain::Builder::default()
    }
}
