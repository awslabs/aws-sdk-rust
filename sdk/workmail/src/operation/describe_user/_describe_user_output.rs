// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct DescribeUserOutput {
    /// <p>The identifier for the described user.</p>
    pub user_id: ::std::option::Option<::std::string::String>,
    /// <p>The name for the user.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The email of the user.</p>
    pub email: ::std::option::Option<::std::string::String>,
    /// <p>The display name of the user.</p>
    pub display_name: ::std::option::Option<::std::string::String>,
    /// <p>The state of a user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).</p>
    pub state: ::std::option::Option<crate::types::EntityState>,
    /// <p>In certain cases, other entities are modeled as users. If interoperability is enabled, resources are imported into WorkMail as users. Because different WorkMail organizations rely on different directory types, administrators can distinguish between an unregistered user (account is disabled and has a user role) and the directory administrators. The values are USER, RESOURCE, SYSTEM_USER, and REMOTE_USER.</p>
    pub user_role: ::std::option::Option<crate::types::UserRole>,
    /// <p>The date and time at which the user was enabled for WorkMailusage, in UNIX epoch time format.</p>
    pub enabled_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The date and time at which the user was disabled for WorkMail usage, in UNIX epoch time format.</p>
    pub disabled_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The date when the mailbox was created for the user.</p>
    pub mailbox_provisioned_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The date when the mailbox was removed for the user.</p>
    pub mailbox_deprovisioned_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>First name of the user.</p>
    pub first_name: ::std::option::Option<::std::string::String>,
    /// <p>Last name of the user.</p>
    pub last_name: ::std::option::Option<::std::string::String>,
    /// <p>If enabled, the user is hidden from the global address list.</p>
    pub hidden_from_global_address_list: bool,
    /// <p>Initials of the user.</p>
    pub initials: ::std::option::Option<::std::string::String>,
    /// <p>User's contact number.</p>
    pub telephone: ::std::option::Option<::std::string::String>,
    /// <p>Street where the user is located.</p>
    pub street: ::std::option::Option<::std::string::String>,
    /// <p>Job title of the user.</p>
    pub job_title: ::std::option::Option<::std::string::String>,
    /// <p>City where the user is located.</p>
    pub city: ::std::option::Option<::std::string::String>,
    /// <p>Company of the user.</p>
    pub company: ::std::option::Option<::std::string::String>,
    /// <p>Zip code of the user.</p>
    pub zip_code: ::std::option::Option<::std::string::String>,
    /// <p>Department of the user.</p>
    pub department: ::std::option::Option<::std::string::String>,
    /// <p>Country where the user is located.</p>
    pub country: ::std::option::Option<::std::string::String>,
    /// <p>Office where the user is located.</p>
    pub office: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl DescribeUserOutput {
    /// <p>The identifier for the described user.</p>
    pub fn user_id(&self) -> ::std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The name for the user.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The email of the user.</p>
    pub fn email(&self) -> ::std::option::Option<&str> {
        self.email.as_deref()
    }
    /// <p>The display name of the user.</p>
    pub fn display_name(&self) -> ::std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The state of a user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).</p>
    pub fn state(&self) -> ::std::option::Option<&crate::types::EntityState> {
        self.state.as_ref()
    }
    /// <p>In certain cases, other entities are modeled as users. If interoperability is enabled, resources are imported into WorkMail as users. Because different WorkMail organizations rely on different directory types, administrators can distinguish between an unregistered user (account is disabled and has a user role) and the directory administrators. The values are USER, RESOURCE, SYSTEM_USER, and REMOTE_USER.</p>
    pub fn user_role(&self) -> ::std::option::Option<&crate::types::UserRole> {
        self.user_role.as_ref()
    }
    /// <p>The date and time at which the user was enabled for WorkMailusage, in UNIX epoch time format.</p>
    pub fn enabled_date(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.enabled_date.as_ref()
    }
    /// <p>The date and time at which the user was disabled for WorkMail usage, in UNIX epoch time format.</p>
    pub fn disabled_date(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.disabled_date.as_ref()
    }
    /// <p>The date when the mailbox was created for the user.</p>
    pub fn mailbox_provisioned_date(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.mailbox_provisioned_date.as_ref()
    }
    /// <p>The date when the mailbox was removed for the user.</p>
    pub fn mailbox_deprovisioned_date(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.mailbox_deprovisioned_date.as_ref()
    }
    /// <p>First name of the user.</p>
    pub fn first_name(&self) -> ::std::option::Option<&str> {
        self.first_name.as_deref()
    }
    /// <p>Last name of the user.</p>
    pub fn last_name(&self) -> ::std::option::Option<&str> {
        self.last_name.as_deref()
    }
    /// <p>If enabled, the user is hidden from the global address list.</p>
    pub fn hidden_from_global_address_list(&self) -> bool {
        self.hidden_from_global_address_list
    }
    /// <p>Initials of the user.</p>
    pub fn initials(&self) -> ::std::option::Option<&str> {
        self.initials.as_deref()
    }
    /// <p>User's contact number.</p>
    pub fn telephone(&self) -> ::std::option::Option<&str> {
        self.telephone.as_deref()
    }
    /// <p>Street where the user is located.</p>
    pub fn street(&self) -> ::std::option::Option<&str> {
        self.street.as_deref()
    }
    /// <p>Job title of the user.</p>
    pub fn job_title(&self) -> ::std::option::Option<&str> {
        self.job_title.as_deref()
    }
    /// <p>City where the user is located.</p>
    pub fn city(&self) -> ::std::option::Option<&str> {
        self.city.as_deref()
    }
    /// <p>Company of the user.</p>
    pub fn company(&self) -> ::std::option::Option<&str> {
        self.company.as_deref()
    }
    /// <p>Zip code of the user.</p>
    pub fn zip_code(&self) -> ::std::option::Option<&str> {
        self.zip_code.as_deref()
    }
    /// <p>Department of the user.</p>
    pub fn department(&self) -> ::std::option::Option<&str> {
        self.department.as_deref()
    }
    /// <p>Country where the user is located.</p>
    pub fn country(&self) -> ::std::option::Option<&str> {
        self.country.as_deref()
    }
    /// <p>Office where the user is located.</p>
    pub fn office(&self) -> ::std::option::Option<&str> {
        self.office.as_deref()
    }
}
impl ::std::fmt::Debug for DescribeUserOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeUserOutput");
        formatter.field("user_id", &self.user_id);
        formatter.field("name", &self.name);
        formatter.field("email", &self.email);
        formatter.field("display_name", &"*** Sensitive Data Redacted ***");
        formatter.field("state", &self.state);
        formatter.field("user_role", &self.user_role);
        formatter.field("enabled_date", &self.enabled_date);
        formatter.field("disabled_date", &self.disabled_date);
        formatter.field("mailbox_provisioned_date", &self.mailbox_provisioned_date);
        formatter.field("mailbox_deprovisioned_date", &self.mailbox_deprovisioned_date);
        formatter.field("first_name", &"*** Sensitive Data Redacted ***");
        formatter.field("last_name", &"*** Sensitive Data Redacted ***");
        formatter.field("hidden_from_global_address_list", &self.hidden_from_global_address_list);
        formatter.field("initials", &"*** Sensitive Data Redacted ***");
        formatter.field("telephone", &"*** Sensitive Data Redacted ***");
        formatter.field("street", &"*** Sensitive Data Redacted ***");
        formatter.field("job_title", &"*** Sensitive Data Redacted ***");
        formatter.field("city", &"*** Sensitive Data Redacted ***");
        formatter.field("company", &"*** Sensitive Data Redacted ***");
        formatter.field("zip_code", &"*** Sensitive Data Redacted ***");
        formatter.field("department", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &"*** Sensitive Data Redacted ***");
        formatter.field("office", &"*** Sensitive Data Redacted ***");
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
impl ::aws_types::request_id::RequestId for DescribeUserOutput {
    fn request_id(&self) -> Option<&str> {
        self._request_id.as_deref()
    }
}
impl DescribeUserOutput {
    /// Creates a new builder-style object to manufacture [`DescribeUserOutput`](crate::operation::describe_user::DescribeUserOutput).
    pub fn builder() -> crate::operation::describe_user::builders::DescribeUserOutputBuilder {
        crate::operation::describe_user::builders::DescribeUserOutputBuilder::default()
    }
}

/// A builder for [`DescribeUserOutput`](crate::operation::describe_user::DescribeUserOutput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct DescribeUserOutputBuilder {
    pub(crate) user_id: ::std::option::Option<::std::string::String>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) email: ::std::option::Option<::std::string::String>,
    pub(crate) display_name: ::std::option::Option<::std::string::String>,
    pub(crate) state: ::std::option::Option<crate::types::EntityState>,
    pub(crate) user_role: ::std::option::Option<crate::types::UserRole>,
    pub(crate) enabled_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) disabled_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) mailbox_provisioned_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) mailbox_deprovisioned_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) first_name: ::std::option::Option<::std::string::String>,
    pub(crate) last_name: ::std::option::Option<::std::string::String>,
    pub(crate) hidden_from_global_address_list: ::std::option::Option<bool>,
    pub(crate) initials: ::std::option::Option<::std::string::String>,
    pub(crate) telephone: ::std::option::Option<::std::string::String>,
    pub(crate) street: ::std::option::Option<::std::string::String>,
    pub(crate) job_title: ::std::option::Option<::std::string::String>,
    pub(crate) city: ::std::option::Option<::std::string::String>,
    pub(crate) company: ::std::option::Option<::std::string::String>,
    pub(crate) zip_code: ::std::option::Option<::std::string::String>,
    pub(crate) department: ::std::option::Option<::std::string::String>,
    pub(crate) country: ::std::option::Option<::std::string::String>,
    pub(crate) office: ::std::option::Option<::std::string::String>,
    _request_id: Option<String>,
}
impl DescribeUserOutputBuilder {
    /// <p>The identifier for the described user.</p>
    pub fn user_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.user_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The identifier for the described user.</p>
    pub fn set_user_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.user_id = input;
        self
    }
    /// <p>The identifier for the described user.</p>
    pub fn get_user_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.user_id
    }
    /// <p>The name for the user.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name for the user.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name for the user.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The email of the user.</p>
    pub fn email(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.email = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The email of the user.</p>
    pub fn set_email(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.email = input;
        self
    }
    /// <p>The email of the user.</p>
    pub fn get_email(&self) -> &::std::option::Option<::std::string::String> {
        &self.email
    }
    /// <p>The display name of the user.</p>
    pub fn display_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.display_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The display name of the user.</p>
    pub fn set_display_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.display_name = input;
        self
    }
    /// <p>The display name of the user.</p>
    pub fn get_display_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.display_name
    }
    /// <p>The state of a user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).</p>
    pub fn state(mut self, input: crate::types::EntityState) -> Self {
        self.state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The state of a user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).</p>
    pub fn set_state(mut self, input: ::std::option::Option<crate::types::EntityState>) -> Self {
        self.state = input;
        self
    }
    /// <p>The state of a user: enabled (registered to WorkMail) or disabled (deregistered or never registered to WorkMail).</p>
    pub fn get_state(&self) -> &::std::option::Option<crate::types::EntityState> {
        &self.state
    }
    /// <p>In certain cases, other entities are modeled as users. If interoperability is enabled, resources are imported into WorkMail as users. Because different WorkMail organizations rely on different directory types, administrators can distinguish between an unregistered user (account is disabled and has a user role) and the directory administrators. The values are USER, RESOURCE, SYSTEM_USER, and REMOTE_USER.</p>
    pub fn user_role(mut self, input: crate::types::UserRole) -> Self {
        self.user_role = ::std::option::Option::Some(input);
        self
    }
    /// <p>In certain cases, other entities are modeled as users. If interoperability is enabled, resources are imported into WorkMail as users. Because different WorkMail organizations rely on different directory types, administrators can distinguish between an unregistered user (account is disabled and has a user role) and the directory administrators. The values are USER, RESOURCE, SYSTEM_USER, and REMOTE_USER.</p>
    pub fn set_user_role(mut self, input: ::std::option::Option<crate::types::UserRole>) -> Self {
        self.user_role = input;
        self
    }
    /// <p>In certain cases, other entities are modeled as users. If interoperability is enabled, resources are imported into WorkMail as users. Because different WorkMail organizations rely on different directory types, administrators can distinguish between an unregistered user (account is disabled and has a user role) and the directory administrators. The values are USER, RESOURCE, SYSTEM_USER, and REMOTE_USER.</p>
    pub fn get_user_role(&self) -> &::std::option::Option<crate::types::UserRole> {
        &self.user_role
    }
    /// <p>The date and time at which the user was enabled for WorkMailusage, in UNIX epoch time format.</p>
    pub fn enabled_date(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.enabled_date = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time at which the user was enabled for WorkMailusage, in UNIX epoch time format.</p>
    pub fn set_enabled_date(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.enabled_date = input;
        self
    }
    /// <p>The date and time at which the user was enabled for WorkMailusage, in UNIX epoch time format.</p>
    pub fn get_enabled_date(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.enabled_date
    }
    /// <p>The date and time at which the user was disabled for WorkMail usage, in UNIX epoch time format.</p>
    pub fn disabled_date(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.disabled_date = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date and time at which the user was disabled for WorkMail usage, in UNIX epoch time format.</p>
    pub fn set_disabled_date(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.disabled_date = input;
        self
    }
    /// <p>The date and time at which the user was disabled for WorkMail usage, in UNIX epoch time format.</p>
    pub fn get_disabled_date(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.disabled_date
    }
    /// <p>The date when the mailbox was created for the user.</p>
    pub fn mailbox_provisioned_date(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.mailbox_provisioned_date = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date when the mailbox was created for the user.</p>
    pub fn set_mailbox_provisioned_date(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.mailbox_provisioned_date = input;
        self
    }
    /// <p>The date when the mailbox was created for the user.</p>
    pub fn get_mailbox_provisioned_date(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.mailbox_provisioned_date
    }
    /// <p>The date when the mailbox was removed for the user.</p>
    pub fn mailbox_deprovisioned_date(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.mailbox_deprovisioned_date = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date when the mailbox was removed for the user.</p>
    pub fn set_mailbox_deprovisioned_date(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.mailbox_deprovisioned_date = input;
        self
    }
    /// <p>The date when the mailbox was removed for the user.</p>
    pub fn get_mailbox_deprovisioned_date(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.mailbox_deprovisioned_date
    }
    /// <p>First name of the user.</p>
    pub fn first_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.first_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>First name of the user.</p>
    pub fn set_first_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.first_name = input;
        self
    }
    /// <p>First name of the user.</p>
    pub fn get_first_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.first_name
    }
    /// <p>Last name of the user.</p>
    pub fn last_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.last_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Last name of the user.</p>
    pub fn set_last_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.last_name = input;
        self
    }
    /// <p>Last name of the user.</p>
    pub fn get_last_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.last_name
    }
    /// <p>If enabled, the user is hidden from the global address list.</p>
    pub fn hidden_from_global_address_list(mut self, input: bool) -> Self {
        self.hidden_from_global_address_list = ::std::option::Option::Some(input);
        self
    }
    /// <p>If enabled, the user is hidden from the global address list.</p>
    pub fn set_hidden_from_global_address_list(mut self, input: ::std::option::Option<bool>) -> Self {
        self.hidden_from_global_address_list = input;
        self
    }
    /// <p>If enabled, the user is hidden from the global address list.</p>
    pub fn get_hidden_from_global_address_list(&self) -> &::std::option::Option<bool> {
        &self.hidden_from_global_address_list
    }
    /// <p>Initials of the user.</p>
    pub fn initials(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.initials = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Initials of the user.</p>
    pub fn set_initials(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.initials = input;
        self
    }
    /// <p>Initials of the user.</p>
    pub fn get_initials(&self) -> &::std::option::Option<::std::string::String> {
        &self.initials
    }
    /// <p>User's contact number.</p>
    pub fn telephone(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.telephone = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>User's contact number.</p>
    pub fn set_telephone(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.telephone = input;
        self
    }
    /// <p>User's contact number.</p>
    pub fn get_telephone(&self) -> &::std::option::Option<::std::string::String> {
        &self.telephone
    }
    /// <p>Street where the user is located.</p>
    pub fn street(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.street = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Street where the user is located.</p>
    pub fn set_street(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.street = input;
        self
    }
    /// <p>Street where the user is located.</p>
    pub fn get_street(&self) -> &::std::option::Option<::std::string::String> {
        &self.street
    }
    /// <p>Job title of the user.</p>
    pub fn job_title(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.job_title = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Job title of the user.</p>
    pub fn set_job_title(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.job_title = input;
        self
    }
    /// <p>Job title of the user.</p>
    pub fn get_job_title(&self) -> &::std::option::Option<::std::string::String> {
        &self.job_title
    }
    /// <p>City where the user is located.</p>
    pub fn city(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.city = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>City where the user is located.</p>
    pub fn set_city(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.city = input;
        self
    }
    /// <p>City where the user is located.</p>
    pub fn get_city(&self) -> &::std::option::Option<::std::string::String> {
        &self.city
    }
    /// <p>Company of the user.</p>
    pub fn company(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.company = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Company of the user.</p>
    pub fn set_company(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.company = input;
        self
    }
    /// <p>Company of the user.</p>
    pub fn get_company(&self) -> &::std::option::Option<::std::string::String> {
        &self.company
    }
    /// <p>Zip code of the user.</p>
    pub fn zip_code(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.zip_code = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Zip code of the user.</p>
    pub fn set_zip_code(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.zip_code = input;
        self
    }
    /// <p>Zip code of the user.</p>
    pub fn get_zip_code(&self) -> &::std::option::Option<::std::string::String> {
        &self.zip_code
    }
    /// <p>Department of the user.</p>
    pub fn department(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.department = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Department of the user.</p>
    pub fn set_department(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.department = input;
        self
    }
    /// <p>Department of the user.</p>
    pub fn get_department(&self) -> &::std::option::Option<::std::string::String> {
        &self.department
    }
    /// <p>Country where the user is located.</p>
    pub fn country(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.country = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Country where the user is located.</p>
    pub fn set_country(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.country = input;
        self
    }
    /// <p>Country where the user is located.</p>
    pub fn get_country(&self) -> &::std::option::Option<::std::string::String> {
        &self.country
    }
    /// <p>Office where the user is located.</p>
    pub fn office(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.office = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Office where the user is located.</p>
    pub fn set_office(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.office = input;
        self
    }
    /// <p>Office where the user is located.</p>
    pub fn get_office(&self) -> &::std::option::Option<::std::string::String> {
        &self.office
    }
    pub(crate) fn _request_id(mut self, request_id: impl Into<String>) -> Self {
        self._request_id = Some(request_id.into());
        self
    }

    pub(crate) fn _set_request_id(&mut self, request_id: Option<String>) -> &mut Self {
        self._request_id = request_id;
        self
    }
    /// Consumes the builder and constructs a [`DescribeUserOutput`](crate::operation::describe_user::DescribeUserOutput).
    pub fn build(self) -> crate::operation::describe_user::DescribeUserOutput {
        crate::operation::describe_user::DescribeUserOutput {
            user_id: self.user_id,
            name: self.name,
            email: self.email,
            display_name: self.display_name,
            state: self.state,
            user_role: self.user_role,
            enabled_date: self.enabled_date,
            disabled_date: self.disabled_date,
            mailbox_provisioned_date: self.mailbox_provisioned_date,
            mailbox_deprovisioned_date: self.mailbox_deprovisioned_date,
            first_name: self.first_name,
            last_name: self.last_name,
            hidden_from_global_address_list: self.hidden_from_global_address_list.unwrap_or_default(),
            initials: self.initials,
            telephone: self.telephone,
            street: self.street,
            job_title: self.job_title,
            city: self.city,
            company: self.company,
            zip_code: self.zip_code,
            department: self.department,
            country: self.country,
            office: self.office,
            _request_id: self._request_id,
        }
    }
}
impl ::std::fmt::Debug for DescribeUserOutputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeUserOutputBuilder");
        formatter.field("user_id", &self.user_id);
        formatter.field("name", &self.name);
        formatter.field("email", &self.email);
        formatter.field("display_name", &"*** Sensitive Data Redacted ***");
        formatter.field("state", &self.state);
        formatter.field("user_role", &self.user_role);
        formatter.field("enabled_date", &self.enabled_date);
        formatter.field("disabled_date", &self.disabled_date);
        formatter.field("mailbox_provisioned_date", &self.mailbox_provisioned_date);
        formatter.field("mailbox_deprovisioned_date", &self.mailbox_deprovisioned_date);
        formatter.field("first_name", &"*** Sensitive Data Redacted ***");
        formatter.field("last_name", &"*** Sensitive Data Redacted ***");
        formatter.field("hidden_from_global_address_list", &self.hidden_from_global_address_list);
        formatter.field("initials", &"*** Sensitive Data Redacted ***");
        formatter.field("telephone", &"*** Sensitive Data Redacted ***");
        formatter.field("street", &"*** Sensitive Data Redacted ***");
        formatter.field("job_title", &"*** Sensitive Data Redacted ***");
        formatter.field("city", &"*** Sensitive Data Redacted ***");
        formatter.field("company", &"*** Sensitive Data Redacted ***");
        formatter.field("zip_code", &"*** Sensitive Data Redacted ***");
        formatter.field("department", &"*** Sensitive Data Redacted ***");
        formatter.field("country", &"*** Sensitive Data Redacted ***");
        formatter.field("office", &"*** Sensitive Data Redacted ***");
        formatter.field("_request_id", &self._request_id);
        formatter.finish()
    }
}
