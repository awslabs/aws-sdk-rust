// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_access_point(&self) -> fluent_builders::CreateAccessPoint<C> {
        fluent_builders::CreateAccessPoint::new(self.handle.clone())
    }
    pub fn create_file_system(&self) -> fluent_builders::CreateFileSystem<C> {
        fluent_builders::CreateFileSystem::new(self.handle.clone())
    }
    pub fn create_mount_target(&self) -> fluent_builders::CreateMountTarget<C> {
        fluent_builders::CreateMountTarget::new(self.handle.clone())
    }
    pub fn create_tags(&self) -> fluent_builders::CreateTags<C> {
        fluent_builders::CreateTags::new(self.handle.clone())
    }
    pub fn delete_access_point(&self) -> fluent_builders::DeleteAccessPoint<C> {
        fluent_builders::DeleteAccessPoint::new(self.handle.clone())
    }
    pub fn delete_file_system(&self) -> fluent_builders::DeleteFileSystem<C> {
        fluent_builders::DeleteFileSystem::new(self.handle.clone())
    }
    pub fn delete_file_system_policy(&self) -> fluent_builders::DeleteFileSystemPolicy<C> {
        fluent_builders::DeleteFileSystemPolicy::new(self.handle.clone())
    }
    pub fn delete_mount_target(&self) -> fluent_builders::DeleteMountTarget<C> {
        fluent_builders::DeleteMountTarget::new(self.handle.clone())
    }
    pub fn delete_tags(&self) -> fluent_builders::DeleteTags<C> {
        fluent_builders::DeleteTags::new(self.handle.clone())
    }
    pub fn describe_access_points(&self) -> fluent_builders::DescribeAccessPoints<C> {
        fluent_builders::DescribeAccessPoints::new(self.handle.clone())
    }
    pub fn describe_account_preferences(&self) -> fluent_builders::DescribeAccountPreferences<C> {
        fluent_builders::DescribeAccountPreferences::new(self.handle.clone())
    }
    pub fn describe_backup_policy(&self) -> fluent_builders::DescribeBackupPolicy<C> {
        fluent_builders::DescribeBackupPolicy::new(self.handle.clone())
    }
    pub fn describe_file_system_policy(&self) -> fluent_builders::DescribeFileSystemPolicy<C> {
        fluent_builders::DescribeFileSystemPolicy::new(self.handle.clone())
    }
    pub fn describe_file_systems(&self) -> fluent_builders::DescribeFileSystems<C> {
        fluent_builders::DescribeFileSystems::new(self.handle.clone())
    }
    pub fn describe_lifecycle_configuration(
        &self,
    ) -> fluent_builders::DescribeLifecycleConfiguration<C> {
        fluent_builders::DescribeLifecycleConfiguration::new(self.handle.clone())
    }
    pub fn describe_mount_targets(&self) -> fluent_builders::DescribeMountTargets<C> {
        fluent_builders::DescribeMountTargets::new(self.handle.clone())
    }
    pub fn describe_mount_target_security_groups(
        &self,
    ) -> fluent_builders::DescribeMountTargetSecurityGroups<C> {
        fluent_builders::DescribeMountTargetSecurityGroups::new(self.handle.clone())
    }
    pub fn describe_tags(&self) -> fluent_builders::DescribeTags<C> {
        fluent_builders::DescribeTags::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn modify_mount_target_security_groups(
        &self,
    ) -> fluent_builders::ModifyMountTargetSecurityGroups<C> {
        fluent_builders::ModifyMountTargetSecurityGroups::new(self.handle.clone())
    }
    pub fn put_account_preferences(&self) -> fluent_builders::PutAccountPreferences<C> {
        fluent_builders::PutAccountPreferences::new(self.handle.clone())
    }
    pub fn put_backup_policy(&self) -> fluent_builders::PutBackupPolicy<C> {
        fluent_builders::PutBackupPolicy::new(self.handle.clone())
    }
    pub fn put_file_system_policy(&self) -> fluent_builders::PutFileSystemPolicy<C> {
        fluent_builders::PutFileSystemPolicy::new(self.handle.clone())
    }
    pub fn put_lifecycle_configuration(&self) -> fluent_builders::PutLifecycleConfiguration<C> {
        fluent_builders::PutLifecycleConfiguration::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_file_system(&self) -> fluent_builders::UpdateFileSystem<C> {
        fluent_builders::UpdateFileSystem::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateAccessPoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_access_point_input::Builder,
    }
    impl<C> CreateAccessPoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAccessPointOutput,
            smithy_http::result::SdkError<crate::error::CreateAccessPointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent
        /// creation.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>Creates tags associated with the access point. Each tag is a key-value pair.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The ID of the EFS file system that the access point provides access to.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
        /// <p>The operating system user and
        /// group applied to all file system requests made using the access point.</p>
        pub fn posix_user(mut self, input: crate::model::PosixUser) -> Self {
            self.inner = self.inner.posix_user(input);
            self
        }
        pub fn set_posix_user(
            mut self,
            input: std::option::Option<crate::model::PosixUser>,
        ) -> Self {
            self.inner = self.inner.set_posix_user(input);
            self
        }
        /// <p>Specifies the directory on the Amazon EFS file system that the access point exposes as
        /// the root directory of your file system to NFS clients using the access point.
        /// The clients using the access point can only access the root directory and below.
        /// If the <code>RootDirectory</code> > <code>Path</code> specified does not exist,
        /// EFS creates it and applies the <code>CreationInfo</code> settings when a client connects to an access point.
        /// When specifying a <code>RootDirectory</code>, you need to provide the <code>Path</code>, and the <code>CreationInfo</code>.</p>
        /// <p>Amazon EFS creates a root directory only if you have provided the  CreationInfo: OwnUid, OwnGID, and permissions for the directory.
        /// If  you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount
        /// using the access point will fail.</p>
        pub fn root_directory(mut self, input: crate::model::RootDirectory) -> Self {
            self.inner = self.inner.root_directory(input);
            self
        }
        pub fn set_root_directory(
            mut self,
            input: std::option::Option<crate::model::RootDirectory>,
        ) -> Self {
            self.inner = self.inner.set_root_directory(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateFileSystem<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_file_system_input::Builder,
    }
    impl<C> CreateFileSystem<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateFileSystemOutput,
            smithy_http::result::SdkError<crate::error::CreateFileSystemError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A string of up to 64 ASCII characters. Amazon EFS uses this to ensure idempotent
        /// creation.</p>
        pub fn creation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creation_token(input);
            self
        }
        pub fn set_creation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creation_token(input);
            self
        }
        /// <p>The performance mode of the file system. We recommend <code>generalPurpose</code>
        /// performance mode for most file systems. File systems using the <code>maxIO</code> performance
        /// mode can scale to higher levels of aggregate throughput and operations per second with a
        /// tradeoff of slightly higher latencies for most file operations. The performance mode
        /// can't be changed after the file system has been created.</p>
        /// <note>
        /// <p>The <code>maxIO</code> mode is not supported on file systems using One Zone storage classes.</p>
        /// </note>
        pub fn performance_mode(mut self, input: crate::model::PerformanceMode) -> Self {
            self.inner = self.inner.performance_mode(input);
            self
        }
        pub fn set_performance_mode(
            mut self,
            input: std::option::Option<crate::model::PerformanceMode>,
        ) -> Self {
            self.inner = self.inner.set_performance_mode(input);
            self
        }
        /// <p>A Boolean value that, if true, creates an encrypted file system. When creating an
        /// encrypted file system, you have the option of specifying <a>CreateFileSystemRequest$KmsKeyId</a> for an existing AWS Key Management Service (AWS
        /// KMS) customer master key (CMK). If you don't specify a CMK, then the default CMK for
        /// Amazon EFS, <code>/aws/elasticfilesystem</code>, is used to protect the encrypted file system.
        /// </p>
        pub fn encrypted(mut self, input: bool) -> Self {
            self.inner = self.inner.encrypted(input);
            self
        }
        pub fn set_encrypted(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_encrypted(input);
            self
        }
        /// <p>The ID of the AWS KMS CMK that you want to use to protect the encrypted file system. This
        /// parameter is only required if you want to use a non-default KMS key. If this parameter is not
        /// specified, the default CMK for Amazon EFS is used. This ID can be in one of the following
        /// formats:</p>
        /// <ul>
        /// <li>
        /// <p>Key ID - A unique identifier of the key, for example
        /// <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
        /// </li>
        /// <li>
        /// <p>ARN - An Amazon Resource Name (ARN) for the key, for example
        /// <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p>
        /// </li>
        /// <li>
        /// <p>Key alias - A previously created display name for a key, for example
        /// <code>alias/projectKey1</code>.</p>
        /// </li>
        /// <li>
        /// <p>Key alias ARN - An ARN for a key alias, for example
        /// <code>arn:aws:kms:us-west-2:444455556666:alias/projectKey1</code>.</p>
        /// </li>
        /// </ul>
        /// <p>If <code>KmsKeyId</code> is specified, the <a>CreateFileSystemRequest$Encrypted</a> parameter must be set to true.</p>
        /// <important>
        /// <p>EFS accepts only symmetric KMS keys. You cannot use asymmetric KMS keys with EFS file systems.</p>
        /// </important>
        pub fn kms_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(input);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>Specifies the throughput mode for the file system, either <code>bursting</code> or
        /// <code>provisioned</code>. If you set <code>ThroughputMode</code> to
        /// <code>provisioned</code>, you must also set a value for
        /// <code>ProvisionedThroughputInMibps</code>. After you create the file system, you can
        /// decrease your file system's throughput in Provisioned Throughput mode or change between
        /// the throughput modes, as long as it’s been more than 24 hours since the last decrease or
        /// throughput mode change. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput">Specifying throughput with
        /// provisioned mode</a> in the <i>Amazon EFS User Guide</i>. </p>
        /// <p>Default is <code>bursting</code>.</p>
        pub fn throughput_mode(mut self, input: crate::model::ThroughputMode) -> Self {
            self.inner = self.inner.throughput_mode(input);
            self
        }
        pub fn set_throughput_mode(
            mut self,
            input: std::option::Option<crate::model::ThroughputMode>,
        ) -> Self {
            self.inner = self.inner.set_throughput_mode(input);
            self
        }
        /// <p>The throughput, measured in MiB/s, that you want to provision for a file system that
        /// you're creating. Valid values are 1-1024. Required if <code>ThroughputMode</code> is set
        /// to <code>provisioned</code>. The upper limit for throughput is 1024 MiB/s. To increase this
        /// limit, contact AWS Support. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits">Amazon EFS quotas that you can increase</a>
        /// in the <i>Amazon EFS User Guide</i>.</p>
        pub fn provisioned_throughput_in_mibps(mut self, input: f64) -> Self {
            self.inner = self.inner.provisioned_throughput_in_mibps(input);
            self
        }
        pub fn set_provisioned_throughput_in_mibps(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.inner = self.inner.set_provisioned_throughput_in_mibps(input);
            self
        }
        /// <p>Used to create a file system that uses One Zone storage classes. It specifies the AWS
        /// Availability Zone in which to create the file system. Use the format <code>us-east-1a</code>
        /// to specify the Availability Zone. For
        /// more information about One Zone storage classes, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes</a> in the <i>Amazon EFS User Guide</i>.</p>
        /// <note>
        /// <p>One Zone storage classes are not available in all Availability Zones in AWS Regions where
        /// Amazon EFS is available.</p>
        /// </note>
        pub fn availability_zone_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.availability_zone_name(input);
            self
        }
        pub fn set_availability_zone_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_availability_zone_name(input);
            self
        }
        /// <p>Specifies whether automatic backups are enabled on the file system that you are creating.
        /// Set the value to <code>true</code> to enable automatic backups. If you are creating a file
        /// system that uses One Zone storage classes, automatic backups are enabled by default. For more
        /// information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups">Automatic backups</a> in the
        /// <i>Amazon EFS User Guide</i>.</p>
        /// <p>Default is <code>false</code>. However, if you specify an <code>AvailabilityZoneName</code>,
        /// the default is <code>true</code>.</p>
        /// <note>
        /// <p>AWS Backup is not available in all AWS Regions where Amazon EFS is available.</p>
        /// </note>
        pub fn backup(mut self, input: bool) -> Self {
            self.inner = self.inner.backup(input);
            self
        }
        pub fn set_backup(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_backup(input);
            self
        }
        /// <p>A value that specifies to create one or more tags associated with the file system. Each
        /// tag is a user-defined key-value pair. Name your file system on creation by including a
        /// <code>"Key":"Name","Value":"{value}"</code> key-value pair.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateMountTarget<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_mount_target_input::Builder,
    }
    impl<C> CreateMountTarget<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateMountTargetOutput,
            smithy_http::result::SdkError<crate::error::CreateMountTargetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the file system for which to create the mount target.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
        /// <p>The ID of the subnet to add the mount target in. For file systems that use One Zone storage classes, use the subnet
        /// that is associated with the file system's Availability Zone.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.subnet_id(input);
            self
        }
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_subnet_id(input);
            self
        }
        /// <p>Valid IPv4 address within the address range of the specified subnet.</p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ip_address(input);
            self
        }
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ip_address(input);
            self
        }
        /// <p>Up to five VPC security group IDs, of the form <code>sg-xxxxxxxx</code>. These must be
        /// for the same VPC as subnet specified.</p>
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_tags_input::Builder,
    }
    impl<C> CreateTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateTagsOutput,
            smithy_http::result::SdkError<crate::error::CreateTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the file system whose tags you want to modify (String). This operation modifies
        /// the tags only, not the file system.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
        /// <p>An array of <code>Tag</code> objects to add. Each <code>Tag</code> object is a key-value
        /// pair. </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccessPoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_access_point_input::Builder,
    }
    impl<C> DeleteAccessPoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAccessPointOutput,
            smithy_http::result::SdkError<crate::error::DeleteAccessPointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the access point that you want to delete.</p>
        pub fn access_point_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_point_id(input);
            self
        }
        pub fn set_access_point_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_access_point_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFileSystem<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_file_system_input::Builder,
    }
    impl<C> DeleteFileSystem<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFileSystemOutput,
            smithy_http::result::SdkError<crate::error::DeleteFileSystemError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the file system you want to delete.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFileSystemPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_file_system_policy_input::Builder,
    }
    impl<C> DeleteFileSystemPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFileSystemPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteFileSystemPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the EFS file system for which to delete the <code>FileSystemPolicy</code>.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteMountTarget<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_mount_target_input::Builder,
    }
    impl<C> DeleteMountTarget<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteMountTargetOutput,
            smithy_http::result::SdkError<crate::error::DeleteMountTargetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the mount target to delete (String).</p>
        pub fn mount_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.mount_target_id(input);
            self
        }
        pub fn set_mount_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_mount_target_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_tags_input::Builder,
    }
    impl<C> DeleteTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteTagsOutput,
            smithy_http::result::SdkError<crate::error::DeleteTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the file system whose tags you want to delete (String).</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
        /// <p>A list of tag keys to delete.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccessPoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_access_points_input::Builder,
    }
    impl<C> DescribeAccessPoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccessPointsOutput,
            smithy_http::result::SdkError<crate::error::DescribeAccessPointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>(Optional) When retrieving all access points for a file system,
        /// you can optionally specify the <code>MaxItems</code> parameter to limit the number of objects returned in a response.  
        /// The default value is 100. </p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>
        /// <code>NextToken</code> is present if the response is paginated. You can use <code>NextMarker</code> in the subsequent request to fetch the next page of access point descriptions.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>(Optional) Specifies an EFS access point to describe in the response; mutually exclusive with <code>FileSystemId</code>.</p>
        pub fn access_point_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_point_id(input);
            self
        }
        pub fn set_access_point_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_access_point_id(input);
            self
        }
        /// <p>(Optional) If you provide a <code>FileSystemId</code>, EFS returns all access points for that file system; mutually exclusive with <code>AccessPointId</code>.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeAccountPreferences<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_account_preferences_input::Builder,
    }
    impl<C> DescribeAccountPreferences<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeAccountPreferencesOutput,
            smithy_http::result::SdkError<crate::error::DescribeAccountPreferencesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Token used for pagination.
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// Max results used for pagination.
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeBackupPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_backup_policy_input::Builder,
    }
    impl<C> DescribeBackupPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeBackupPolicyOutput,
            smithy_http::result::SdkError<crate::error::DescribeBackupPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies which EFS file system to retrieve the <code>BackupPolicy</code> for.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFileSystemPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_file_system_policy_input::Builder,
    }
    impl<C> DescribeFileSystemPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFileSystemPolicyOutput,
            smithy_http::result::SdkError<crate::error::DescribeFileSystemPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies which EFS file system to retrieve the <code>FileSystemPolicy</code> for.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeFileSystems<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_file_systems_input::Builder,
    }
    impl<C> DescribeFileSystems<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeFileSystemsOutput,
            smithy_http::result::SdkError<crate::error::DescribeFileSystemsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>(Optional) Specifies the maximum number of file systems to return in the response
        /// (integer). This number is automatically set to 100. The response is paginated at 100 per page if you have more than 100 file systems.
        /// </p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>(Optional) Opaque pagination token returned from a previous
        /// <code>DescribeFileSystems</code> operation (String). If present, specifies to continue the
        /// list from where the returning call had left off. </p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>(Optional) Restricts the list to the file system with this creation token (String). You
        /// specify a creation token when you create an Amazon EFS file system.</p>
        pub fn creation_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.creation_token(input);
            self
        }
        pub fn set_creation_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_creation_token(input);
            self
        }
        /// <p>(Optional) ID of the file system whose description you want to retrieve
        /// (String).</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeLifecycleConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_lifecycle_configuration_input::Builder,
    }
    impl<C> DescribeLifecycleConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeLifecycleConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DescribeLifecycleConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the file system whose <code>LifecycleConfiguration</code> object you want to
        /// retrieve (String).</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMountTargets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_mount_targets_input::Builder,
    }
    impl<C> DescribeMountTargets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMountTargetsOutput,
            smithy_http::result::SdkError<crate::error::DescribeMountTargetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>(Optional) Maximum number of mount targets to return in the response. Currently, this
        /// number is automatically set to
        /// 10, and other values are ignored. The response is paginated at 100 per page if you have more than 100 mount targets.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>(Optional) Opaque pagination token returned from a previous
        /// <code>DescribeMountTargets</code> operation (String). If present, it specifies to continue
        /// the list from where the previous returning call left off.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>(Optional) ID of the file system whose mount targets you want to list (String). It must
        /// be included in your request if an <code>AccessPointId</code> or <code>MountTargetId</code> is not included. Accepts either a file system ID or ARN as input.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
        /// <p>(Optional) ID of the mount target that you want to have described (String). It must be
        /// included in your request if <code>FileSystemId</code> is not included. Accepts either a mount target ID or ARN as input.</p>
        pub fn mount_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.mount_target_id(input);
            self
        }
        pub fn set_mount_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_mount_target_id(input);
            self
        }
        /// <p>(Optional) The ID of the access point whose mount targets that you want to list. It must be included in your request if a
        /// <code>FileSystemId</code> or <code>MountTargetId</code> is not included in your request. Accepts either an access point ID or ARN as input.</p>
        pub fn access_point_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.access_point_id(input);
            self
        }
        pub fn set_access_point_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_access_point_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMountTargetSecurityGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_mount_target_security_groups_input::Builder,
    }
    impl<C> DescribeMountTargetSecurityGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMountTargetSecurityGroupsOutput,
            smithy_http::result::SdkError<crate::error::DescribeMountTargetSecurityGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the mount target whose security groups you want to retrieve.</p>
        pub fn mount_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.mount_target_id(input);
            self
        }
        pub fn set_mount_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_mount_target_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeTags<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_tags_input::Builder,
    }
    impl<C> DescribeTags<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeTagsOutput,
            smithy_http::result::SdkError<crate::error::DescribeTagsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>(Optional) The maximum number of file system tags to return in the response. Currently,
        /// this number is automatically set to
        /// 100, and other values are ignored. The response is paginated at 100 per page if you have more than 100 tags.</p>
        pub fn max_items(mut self, input: i32) -> Self {
            self.inner = self.inner.max_items(input);
            self
        }
        pub fn set_max_items(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_items(input);
            self
        }
        /// <p>(Optional) An opaque pagination token returned from a previous
        /// <code>DescribeTags</code> operation (String). If present, it specifies to continue the list
        /// from where the previous call left off.</p>
        pub fn marker(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.marker(input);
            self
        }
        pub fn set_marker(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_marker(input);
            self
        }
        /// <p>The ID of the file system whose tag set you want to retrieve.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the EFS resource you want to retrieve tags for. You can retrieve tags for EFS file systems and access points using this API endpoint.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>(Optional) Specifies the maximum number of tag objects to return in the response. The default value is 100.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>(Optional) You can use <code>NextToken</code> in a subsequent request to fetch the next page of access point descriptions if the response payload was paginated.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ModifyMountTargetSecurityGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::modify_mount_target_security_groups_input::Builder,
    }
    impl<C> ModifyMountTargetSecurityGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ModifyMountTargetSecurityGroupsOutput,
            smithy_http::result::SdkError<crate::error::ModifyMountTargetSecurityGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the mount target whose security groups you want to modify.</p>
        pub fn mount_target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.mount_target_id(input);
            self
        }
        pub fn set_mount_target_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_mount_target_id(input);
            self
        }
        /// <p>An array of up to five VPC security group IDs.</p>
        pub fn security_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.security_groups(inp);
            self
        }
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_security_groups(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAccountPreferences<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_account_preferences_input::Builder,
    }
    impl<C> PutAccountPreferences<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAccountPreferencesOutput,
            smithy_http::result::SdkError<crate::error::PutAccountPreferencesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// A preference indicating a choice to use 63bit/32bit IDs for all applicable resources.
        pub fn resource_id_type(mut self, input: crate::model::ResourceIdType) -> Self {
            self.inner = self.inner.resource_id_type(input);
            self
        }
        pub fn set_resource_id_type(
            mut self,
            input: std::option::Option<crate::model::ResourceIdType>,
        ) -> Self {
            self.inner = self.inner.set_resource_id_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBackupPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_backup_policy_input::Builder,
    }
    impl<C> PutBackupPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutBackupPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutBackupPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies which EFS file system to update the backup policy for.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
        /// <p>The backup policy included in the <code>PutBackupPolicy</code> request.</p>
        pub fn backup_policy(mut self, input: crate::model::BackupPolicy) -> Self {
            self.inner = self.inner.backup_policy(input);
            self
        }
        pub fn set_backup_policy(
            mut self,
            input: std::option::Option<crate::model::BackupPolicy>,
        ) -> Self {
            self.inner = self.inner.set_backup_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutFileSystemPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_file_system_policy_input::Builder,
    }
    impl<C> PutFileSystemPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutFileSystemPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutFileSystemPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the EFS file system that you want to create or update the <code>FileSystemPolicy</code> for.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
        /// <p>The <code>FileSystemPolicy</code> that you're creating. Accepts a JSON formatted policy definition.
        /// EFS file system policies have a 20,000 character limit.
        /// To find out more about the elements that make up a file system policy, see
        /// <a href="https://docs.aws.amazon.com/efs/latest/ug/access-control-overview.html#access-control-manage-access-intro-resource-policies">EFS Resource-based Policies</a>.
        /// </p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
        /// <p>(Optional) A flag to indicate whether to bypass the <code>FileSystemPolicy</code> lockout safety check. The policy lockout safety check
        /// determines whether the policy in the request will prevent the principal making the request will be locked out from making future <code>PutFileSystemPolicy</code> requests on the file system.
        /// Set <code>BypassPolicyLockoutSafetyCheck</code> to <code>True</code> only when you intend to prevent
        /// the principal that is making the request from making a subsequent <code>PutFileSystemPolicy</code> request on the file system.
        /// The default value is False.
        /// </p>
        pub fn bypass_policy_lockout_safety_check(mut self, input: bool) -> Self {
            self.inner = self.inner.bypass_policy_lockout_safety_check(input);
            self
        }
        pub fn set_bypass_policy_lockout_safety_check(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_bypass_policy_lockout_safety_check(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutLifecycleConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_lifecycle_configuration_input::Builder,
    }
    impl<C> PutLifecycleConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutLifecycleConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutLifecycleConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the file system for which you are creating the
        /// <code>LifecycleConfiguration</code> object (String).</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
        /// <p>An array of <code>LifecyclePolicy</code> objects that define the file system's
        /// <code>LifecycleConfiguration</code> object. A <code>LifecycleConfiguration</code> object
        /// tells lifecycle management when to transition files from the Standard storage class to the
        /// Infrequent Access storage class.</p>
        pub fn lifecycle_policies(mut self, inp: impl Into<crate::model::LifecyclePolicy>) -> Self {
            self.inner = self.inner.lifecycle_policies(inp);
            self
        }
        pub fn set_lifecycle_policies(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LifecyclePolicy>>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_policies(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID specifying the EFS resource that you want to create a tag for.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>An array of <code>Tag</code> objects to add. Each <code>Tag</code> object is a key-value
        /// pair.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the EFS resource that you want to remove tags from.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_id(input);
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_id(input);
            self
        }
        /// <p>The keys of the key-value tag pairs that you want to remove from the specified EFS
        /// resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateFileSystem<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_file_system_input::Builder,
    }
    impl<C> UpdateFileSystem<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateFileSystemOutput,
            smithy_http::result::SdkError<crate::error::UpdateFileSystemError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the file system that you want to update.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_system_id(input);
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_file_system_id(input);
            self
        }
        /// <p>(Optional) Updates the file system's throughput mode. If you're not
        /// updating your throughput mode, you don't need to provide this value in your
        /// request. If you are changing the <code>ThroughputMode</code> to <code>provisioned</code>,
        /// you must also set a value for <code>ProvisionedThroughputInMibps</code>.</p>
        pub fn throughput_mode(mut self, input: crate::model::ThroughputMode) -> Self {
            self.inner = self.inner.throughput_mode(input);
            self
        }
        pub fn set_throughput_mode(
            mut self,
            input: std::option::Option<crate::model::ThroughputMode>,
        ) -> Self {
            self.inner = self.inner.set_throughput_mode(input);
            self
        }
        /// <p>(Optional) Sets the amount of provisioned throughput, in MiB/s, for the file
        /// system. Valid values are 1-1024. If you are changing the throughput mode to provisioned, you must also
        /// provide the amount of provisioned throughput. Required if <code>ThroughputMode</code> is changed
        /// to <code>provisioned</code> on update.</p>
        pub fn provisioned_throughput_in_mibps(mut self, input: f64) -> Self {
            self.inner = self.inner.provisioned_throughput_in_mibps(input);
            self
        }
        pub fn set_provisioned_throughput_in_mibps(
            mut self,
            input: std::option::Option<f64>,
        ) -> Self {
            self.inner = self.inner.set_provisioned_throughput_in_mibps(input);
            self
        }
    }
}
