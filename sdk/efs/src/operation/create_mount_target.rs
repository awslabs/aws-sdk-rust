// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl CreateMountTargetInput {
    /// Consumes the builder and constructs an Operation<[`CreateMountTarget`](crate::operation::create_mount_target::CreateMountTarget)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::create_mount_target::CreateMountTarget,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::operation::create_mount_target::CreateMountTargetInput,
                output: &mut String,
            ) -> std::result::Result<(), aws_smithy_http::operation::error::BuildError>
            {
                write!(output, "/2015-02-01/mount-targets").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::create_mount_target::CreateMountTargetInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/json",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_mount_target::ser_create_mount_target_input(&self)?,
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::meta::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::create_mount_target::CreateMountTarget::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateMountTarget",
            "efs",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `CreateMountTarget`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct CreateMountTarget;
impl CreateMountTarget {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateMountTarget {
    type Output = std::result::Result<
        crate::operation::create_mount_target::CreateMountTargetOutput,
        crate::operation::create_mount_target::CreateMountTargetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::protocol_serde::shape_create_mount_target::de_create_mount_target_http_error(
                response,
            )
        } else {
            crate::protocol_serde::shape_create_mount_target::de_create_mount_target_http_response(
                response,
            )
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateMountTargetErrorKind = CreateMountTargetError;
/// Error type for the `CreateMountTargetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateMountTargetError {
    /// <p>Returned if the Availability Zone that was specified for a mount target is different from the Availability Zone that was specified for One Zone storage. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/availability-durability.html">Regional and One Zone storage redundancy</a>.</p>
    AvailabilityZonesMismatch(crate::types::error::AvailabilityZonesMismatch),
    /// <p>Returned if the request is malformed or contains an error such as an invalid parameter value or a missing required parameter.</p>
    BadRequest(crate::types::error::BadRequest),
    /// <p>Returned if the specified <code>FileSystemId</code> value doesn't exist in the requester's Amazon Web Services account.</p>
    FileSystemNotFound(crate::types::error::FileSystemNotFound),
    /// <p>Returned if the file system's lifecycle state is not "available".</p>
    IncorrectFileSystemLifeCycleState(crate::types::error::IncorrectFileSystemLifeCycleState),
    /// <p>Returned if an error occurred on the server side.</p>
    InternalServerError(crate::types::error::InternalServerError),
    /// <p>Returned if the request specified an <code>IpAddress</code> that is already in use in the subnet.</p>
    IpAddressInUse(crate::types::error::IpAddressInUse),
    /// <p>Returned if the mount target would violate one of the specified restrictions based on the file system's existing mount targets.</p>
    MountTargetConflict(crate::types::error::MountTargetConflict),
    /// <p>The calling account has reached the limit for elastic network interfaces for the specific Amazon Web Services Region. Either delete some network interfaces or request that the account quota be raised. For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Appendix_Limits.html">Amazon VPC Quotas</a> in the <i>Amazon VPC User Guide</i> (see the <b>Network interfaces per Region</b> entry in the <b>Network interfaces</b> table). </p>
    NetworkInterfaceLimitExceeded(crate::types::error::NetworkInterfaceLimitExceeded),
    /// <p>Returned if <code>IpAddress</code> was not specified in the request and there are no free IP addresses in the subnet.</p>
    NoFreeAddressesInSubnet(crate::types::error::NoFreeAddressesInSubnet),
    /// <p>Returned if the size of <code>SecurityGroups</code> specified in the request is greater than five.</p>
    SecurityGroupLimitExceeded(crate::types::error::SecurityGroupLimitExceeded),
    /// <p>Returned if one of the specified security groups doesn't exist in the subnet's virtual private cloud (VPC).</p>
    SecurityGroupNotFound(crate::types::error::SecurityGroupNotFound),
    /// <p>Returned if there is no subnet with ID <code>SubnetId</code> provided in the request.</p>
    SubnetNotFound(crate::types::error::SubnetNotFound),
    /// <p>Returned if the requested Amazon EFS functionality is not available in the specified Availability Zone.</p>
    UnsupportedAvailabilityZone(crate::types::error::UnsupportedAvailabilityZone),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateMountTargetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: std::option::Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateMountTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AvailabilityZonesMismatch(_inner) => _inner.fmt(f),
            Self::BadRequest(_inner) => _inner.fmt(f),
            Self::FileSystemNotFound(_inner) => _inner.fmt(f),
            Self::IncorrectFileSystemLifeCycleState(_inner) => _inner.fmt(f),
            Self::InternalServerError(_inner) => _inner.fmt(f),
            Self::IpAddressInUse(_inner) => _inner.fmt(f),
            Self::MountTargetConflict(_inner) => _inner.fmt(f),
            Self::NetworkInterfaceLimitExceeded(_inner) => _inner.fmt(f),
            Self::NoFreeAddressesInSubnet(_inner) => _inner.fmt(f),
            Self::SecurityGroupLimitExceeded(_inner) => _inner.fmt(f),
            Self::SecurityGroupNotFound(_inner) => _inner.fmt(f),
            Self::SubnetNotFound(_inner) => _inner.fmt(f),
            Self::UnsupportedAvailabilityZone(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateMountTargetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AvailabilityZonesMismatch(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BadRequest(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileSystemNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IncorrectFileSystemLifeCycleState(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InternalServerError(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IpAddressInUse(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MountTargetConflict(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NetworkInterfaceLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoFreeAddressesInSubnet(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SecurityGroupLimitExceeded(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SecurityGroupNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SubnetNotFound(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedAvailabilityZone(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::operation::create_mount_target::CreateMountTargetError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateMountTargetError {
    fn code(&self) -> std::option::Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> std::option::Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateMountTargetError {
    /// Creates the `CreateMountTargetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateMountTargetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AvailabilityZonesMismatch(e) => e.meta(),
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncorrectFileSystemLifeCycleState(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::IpAddressInUse(e) => e.meta(),
            Self::MountTargetConflict(e) => e.meta(),
            Self::NetworkInterfaceLimitExceeded(e) => e.meta(),
            Self::NoFreeAddressesInSubnet(e) => e.meta(),
            Self::SecurityGroupLimitExceeded(e) => e.meta(),
            Self::SecurityGroupNotFound(e) => e.meta(),
            Self::SubnetNotFound(e) => e.meta(),
            Self::UnsupportedAvailabilityZone(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::AvailabilityZonesMismatch`.
    pub fn is_availability_zones_mismatch(&self) -> bool {
        matches!(self, Self::AvailabilityZonesMismatch(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::IncorrectFileSystemLifeCycleState`.
    pub fn is_incorrect_file_system_life_cycle_state(&self) -> bool {
        matches!(self, Self::IncorrectFileSystemLifeCycleState(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::IpAddressInUse`.
    pub fn is_ip_address_in_use(&self) -> bool {
        matches!(self, Self::IpAddressInUse(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::MountTargetConflict`.
    pub fn is_mount_target_conflict(&self) -> bool {
        matches!(self, Self::MountTargetConflict(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::NetworkInterfaceLimitExceeded`.
    pub fn is_network_interface_limit_exceeded(&self) -> bool {
        matches!(self, Self::NetworkInterfaceLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::NoFreeAddressesInSubnet`.
    pub fn is_no_free_addresses_in_subnet(&self) -> bool {
        matches!(self, Self::NoFreeAddressesInSubnet(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::SecurityGroupLimitExceeded`.
    pub fn is_security_group_limit_exceeded(&self) -> bool {
        matches!(self, Self::SecurityGroupLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::SecurityGroupNotFound`.
    pub fn is_security_group_not_found(&self) -> bool {
        matches!(self, Self::SecurityGroupNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::SubnetNotFound`.
    pub fn is_subnet_not_found(&self) -> bool {
        matches!(self, Self::SubnetNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateMountTargetError::UnsupportedAvailabilityZone`.
    pub fn is_unsupported_availability_zone(&self) -> bool {
        matches!(self, Self::UnsupportedAvailabilityZone(_))
    }
}
impl std::error::Error for CreateMountTargetError {
    fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AvailabilityZonesMismatch(_inner) => Some(_inner),
            Self::BadRequest(_inner) => Some(_inner),
            Self::FileSystemNotFound(_inner) => Some(_inner),
            Self::IncorrectFileSystemLifeCycleState(_inner) => Some(_inner),
            Self::InternalServerError(_inner) => Some(_inner),
            Self::IpAddressInUse(_inner) => Some(_inner),
            Self::MountTargetConflict(_inner) => Some(_inner),
            Self::NetworkInterfaceLimitExceeded(_inner) => Some(_inner),
            Self::NoFreeAddressesInSubnet(_inner) => Some(_inner),
            Self::SecurityGroupLimitExceeded(_inner) => Some(_inner),
            Self::SecurityGroupNotFound(_inner) => Some(_inner),
            Self::SubnetNotFound(_inner) => Some(_inner),
            Self::UnsupportedAvailabilityZone(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

pub use crate::operation::create_mount_target::_create_mount_target_output::CreateMountTargetOutput;

pub use crate::operation::create_mount_target::_create_mount_target_input::CreateMountTargetInput;

mod _create_mount_target_input;

mod _create_mount_target_output;

/// Builders
pub mod builders;
