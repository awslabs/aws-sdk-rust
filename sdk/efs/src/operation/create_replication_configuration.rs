// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl CreateReplicationConfigurationInput {
    /// Consumes the builder and constructs an Operation<[`CreateReplicationConfiguration`](crate::operation::create_replication_configuration::CreateReplicationConfiguration)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::create_replication_configuration::CreateReplicationConfiguration, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::operation::create_replication_configuration::CreateReplicationConfigurationInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                let input_1 = &_input.source_file_system_id;
                let input_1 = input_1.as_ref().ok_or_else(|| aws_smithy_http::operation::error::BuildError::missing_field("source_file_system_id", "cannot be empty or unset"))?;
                let source_file_system_id = aws_smithy_http::label::fmt_string(input_1, aws_smithy_http::label::EncodingStrategy::Default);
                if source_file_system_id.is_empty() {
                                return Err(aws_smithy_http::operation::error::BuildError::missing_field("source_file_system_id", "cannot be empty or unset"))
                            }
                write!(output, "/2015-02-01/file-systems/{SourceFileSystemId}/replication-configuration", SourceFileSystemId = source_file_system_id).expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::operation::create_replication_configuration::CreateReplicationConfigurationInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/json");
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_replication_configuration::ser_create_replication_configuration_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::meta::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::create_replication_configuration::CreateReplicationConfiguration::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateReplicationConfiguration", "efs"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `CreateReplicationConfiguration`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct CreateReplicationConfiguration;
impl CreateReplicationConfiguration {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateReplicationConfiguration {
                type Output = std::result::Result<crate::operation::create_replication_configuration::CreateReplicationConfigurationOutput, crate::operation::create_replication_configuration::CreateReplicationConfigurationError>;
                fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
                     tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
                     if !response.status().is_success() && response.status().as_u16() != 200 {
                        crate::protocol_serde::shape_create_replication_configuration::de_create_replication_configuration_http_error(response)
                     } else {
                        crate::protocol_serde::shape_create_replication_configuration::de_create_replication_configuration_http_response(response)
                     }
                }
            }

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CreateReplicationConfigurationErrorKind = CreateReplicationConfigurationError;
/// Error type for the `CreateReplicationConfigurationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateReplicationConfigurationError {
    /// <p>Returned if the request is malformed or contains an error such as an invalid parameter value or a missing required parameter.</p>
    BadRequest(crate::types::error::BadRequest),
    /// <p>Returned if the Amazon Web Services account has already created the maximum number of file systems allowed per account.</p>
    FileSystemLimitExceeded(crate::types::error::FileSystemLimitExceeded),
    /// <p>Returned if the specified <code>FileSystemId</code> value doesn't exist in the requester's Amazon Web Services account.</p>
    FileSystemNotFound(crate::types::error::FileSystemNotFound),
    /// <p>Returned if the file system's lifecycle state is not "available".</p>
    IncorrectFileSystemLifeCycleState(crate::types::error::IncorrectFileSystemLifeCycleState),
    /// <p>Returned if there's not enough capacity to provision additional throughput. This value might be returned when you try to create a file system in provisioned throughput mode, when you attempt to increase the provisioned throughput of an existing file system, or when you attempt to change an existing file system from Bursting Throughput to Provisioned Throughput mode. Try again later.</p>
    InsufficientThroughputCapacity(crate::types::error::InsufficientThroughputCapacity),
    /// <p>Returned if an error occurred on the server side.</p>
    InternalServerError(crate::types::error::InternalServerError),
    /// <p>Returned if the specified file system does not have a replication configuration.</p>
    ReplicationNotFound(crate::types::error::ReplicationNotFound),
    /// <p>Returned if the throughput mode or amount of provisioned throughput can't be changed because the throughput limit of 1024 MiB/s has been reached.</p>
    ThroughputLimitExceeded(crate::types::error::ThroughputLimitExceeded),
    /// <p>Returned if the requested Amazon EFS functionality is not available in the specified Availability Zone.</p>
    UnsupportedAvailabilityZone(crate::types::error::UnsupportedAvailabilityZone),
    /// <p>Returned if the Backup service is not available in the Amazon Web Services Region in which the request was made.</p>
    ValidationException(crate::types::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateReplicationConfigurationError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CreateReplicationConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BadRequest(_inner) =>
            _inner.fmt(f)
            ,
            Self::FileSystemLimitExceeded(_inner) =>
            _inner.fmt(f)
            ,
            Self::FileSystemNotFound(_inner) =>
            _inner.fmt(f)
            ,
            Self::IncorrectFileSystemLifeCycleState(_inner) =>
            _inner.fmt(f)
            ,
            Self::InsufficientThroughputCapacity(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalServerError(_inner) =>
            _inner.fmt(f)
            ,
            Self::ReplicationNotFound(_inner) =>
            _inner.fmt(f)
            ,
            Self::ThroughputLimitExceeded(_inner) =>
            _inner.fmt(f)
            ,
            Self::UnsupportedAvailabilityZone(_inner) =>
            _inner.fmt(f)
            ,
            Self::ValidationException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateReplicationConfigurationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BadRequest(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::FileSystemLimitExceeded(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::FileSystemNotFound(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::IncorrectFileSystemLifeCycleState(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InsufficientThroughputCapacity(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalServerError(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ReplicationNotFound(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ThroughputLimitExceeded(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::UnsupportedAvailabilityZone(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ValidationException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::operation::create_replication_configuration::CreateReplicationConfigurationError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CreateReplicationConfigurationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateReplicationConfigurationError {
    /// Creates the `CreateReplicationConfigurationError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CreateReplicationConfigurationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BadRequest(e) => e.meta(),
            Self::FileSystemLimitExceeded(e) => e.meta(),
            Self::FileSystemNotFound(e) => e.meta(),
            Self::IncorrectFileSystemLifeCycleState(e) => e.meta(),
            Self::InsufficientThroughputCapacity(e) => e.meta(),
            Self::InternalServerError(e) => e.meta(),
            Self::ReplicationNotFound(e) => e.meta(),
            Self::ThroughputLimitExceeded(e) => e.meta(),
            Self::UnsupportedAvailabilityZone(e) => e.meta(),
            Self::ValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateReplicationConfigurationError::BadRequest`.
    pub fn is_bad_request(&self) -> bool {
        matches!(self, Self::BadRequest(_))
    }
    /// Returns `true` if the error kind is `CreateReplicationConfigurationError::FileSystemLimitExceeded`.
    pub fn is_file_system_limit_exceeded(&self) -> bool {
        matches!(self, Self::FileSystemLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateReplicationConfigurationError::FileSystemNotFound`.
    pub fn is_file_system_not_found(&self) -> bool {
        matches!(self, Self::FileSystemNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateReplicationConfigurationError::IncorrectFileSystemLifeCycleState`.
    pub fn is_incorrect_file_system_life_cycle_state(&self) -> bool {
        matches!(self, Self::IncorrectFileSystemLifeCycleState(_))
    }
    /// Returns `true` if the error kind is `CreateReplicationConfigurationError::InsufficientThroughputCapacity`.
    pub fn is_insufficient_throughput_capacity(&self) -> bool {
        matches!(self, Self::InsufficientThroughputCapacity(_))
    }
    /// Returns `true` if the error kind is `CreateReplicationConfigurationError::InternalServerError`.
    pub fn is_internal_server_error(&self) -> bool {
        matches!(self, Self::InternalServerError(_))
    }
    /// Returns `true` if the error kind is `CreateReplicationConfigurationError::ReplicationNotFound`.
    pub fn is_replication_not_found(&self) -> bool {
        matches!(self, Self::ReplicationNotFound(_))
    }
    /// Returns `true` if the error kind is `CreateReplicationConfigurationError::ThroughputLimitExceeded`.
    pub fn is_throughput_limit_exceeded(&self) -> bool {
        matches!(self, Self::ThroughputLimitExceeded(_))
    }
    /// Returns `true` if the error kind is `CreateReplicationConfigurationError::UnsupportedAvailabilityZone`.
    pub fn is_unsupported_availability_zone(&self) -> bool {
        matches!(self, Self::UnsupportedAvailabilityZone(_))
    }
    /// Returns `true` if the error kind is `CreateReplicationConfigurationError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(self, Self::ValidationException(_))
    }
}
impl std::error::Error for CreateReplicationConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BadRequest(_inner) =>
            Some(_inner)
            ,
            Self::FileSystemLimitExceeded(_inner) =>
            Some(_inner)
            ,
            Self::FileSystemNotFound(_inner) =>
            Some(_inner)
            ,
            Self::IncorrectFileSystemLifeCycleState(_inner) =>
            Some(_inner)
            ,
            Self::InsufficientThroughputCapacity(_inner) =>
            Some(_inner)
            ,
            Self::InternalServerError(_inner) =>
            Some(_inner)
            ,
            Self::ReplicationNotFound(_inner) =>
            Some(_inner)
            ,
            Self::ThroughputLimitExceeded(_inner) =>
            Some(_inner)
            ,
            Self::UnsupportedAvailabilityZone(_inner) =>
            Some(_inner)
            ,
            Self::ValidationException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

pub use crate::operation::create_replication_configuration::_create_replication_configuration_output::CreateReplicationConfigurationOutput;

pub use crate::operation::create_replication_configuration::_create_replication_configuration_input::CreateReplicationConfigurationInput;

mod _create_replication_configuration_input;

mod _create_replication_configuration_output;

/// Builders
pub mod builders;

