// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>Returned if the access point that you are trying to create already exists, with the creation token you provided in the request.</p>
    AccessPointAlreadyExists(crate::error::AccessPointAlreadyExists),
    /// <p>Returned if the Amazon Web Services account has already created the maximum number of access points allowed per file system. For more informaton, see <a href="https://docs.aws.amazon.com/efs/latest/ug/limits.html#limits-efs-resources-per-account-per-region">https://docs.aws.amazon.com/efs/latest/ug/limits.html#limits-efs-resources-per-account-per-region</a>.</p>
    AccessPointLimitExceeded(crate::error::AccessPointLimitExceeded),
    /// <p>Returned if the specified <code>AccessPointId</code> value doesn't exist in the requester's Amazon Web Services account.</p>
    AccessPointNotFound(crate::error::AccessPointNotFound),
    /// <p>Returned if the Availability Zone that was specified for a mount target is different from the Availability Zone that was specified for One Zone storage. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/availability-durability.html">Regional and One Zone storage redundancy</a>.</p>
    AvailabilityZonesMismatch(crate::error::AvailabilityZonesMismatch),
    /// <p>Returned if the request is malformed or contains an error such as an invalid parameter value or a missing required parameter.</p>
    BadRequest(crate::error::BadRequest),
    /// <p>The service timed out trying to fulfill the request, and the client should try the call again.</p>
    DependencyTimeout(crate::error::DependencyTimeout),
    /// <p>Returned if the file system you are trying to create already exists, with the creation token you provided.</p>
    FileSystemAlreadyExists(crate::error::FileSystemAlreadyExists),
    /// <p>Returned if a file system has mount targets.</p>
    FileSystemInUse(crate::error::FileSystemInUse),
    /// <p>Returned if the Amazon Web Services account has already created the maximum number of file systems allowed per account.</p>
    FileSystemLimitExceeded(crate::error::FileSystemLimitExceeded),
    /// <p>Returned if the specified <code>FileSystemId</code> value doesn't exist in the requester's Amazon Web Services account.</p>
    FileSystemNotFound(crate::error::FileSystemNotFound),
    /// <p>Returned if the file system's lifecycle state is not "available".</p>
    IncorrectFileSystemLifeCycleState(crate::error::IncorrectFileSystemLifeCycleState),
    /// <p>Returned if the mount target is not in the correct state for the operation.</p>
    IncorrectMountTargetState(crate::error::IncorrectMountTargetState),
    /// <p>Returned if there's not enough capacity to provision additional throughput. This value might be returned when you try to create a file system in provisioned throughput mode, when you attempt to increase the provisioned throughput of an existing file system, or when you attempt to change an existing file system from Bursting Throughput to Provisioned Throughput mode. Try again later.</p>
    InsufficientThroughputCapacity(crate::error::InsufficientThroughputCapacity),
    /// <p>Returned if an error occurred on the server side.</p>
    InternalServerError(crate::error::InternalServerError),
    /// <p>Returned if the <code>FileSystemPolicy</code> is malformed or contains an error such as a parameter value that is not valid or a missing required parameter. Returned in the case of a policy lockout safety check error.</p>
    InvalidPolicyException(crate::error::InvalidPolicyException),
    /// <p>Returned if the request specified an <code>IpAddress</code> that is already in use in the subnet.</p>
    IpAddressInUse(crate::error::IpAddressInUse),
    /// <p>Returned if the mount target would violate one of the specified restrictions based on the file system's existing mount targets.</p>
    MountTargetConflict(crate::error::MountTargetConflict),
    /// <p>Returned if there is no mount target with the specified ID found in the caller's Amazon Web Services account.</p>
    MountTargetNotFound(crate::error::MountTargetNotFound),
    /// <p>The calling account has reached the limit for elastic network interfaces for the specific Amazon Web Services Region. Either delete some network interfaces or request that the account quota be raised. For more information, see <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Appendix_Limits.html">Amazon VPC Quotas</a> in the <i>Amazon VPC User Guide</i> (see the <b>Network interfaces per Region</b> entry in the <b>Network interfaces</b> table). </p>
    NetworkInterfaceLimitExceeded(crate::error::NetworkInterfaceLimitExceeded),
    /// <p>Returned if <code>IpAddress</code> was not specified in the request and there are no free IP addresses in the subnet.</p>
    NoFreeAddressesInSubnet(crate::error::NoFreeAddressesInSubnet),
    /// <p>Returned if the default file system policy is in effect for the EFS file system specified.</p>
    PolicyNotFound(crate::error::PolicyNotFound),
    /// <p>Returned if the specified file system does not have a replication configuration.</p>
    ReplicationNotFound(crate::error::ReplicationNotFound),
    /// <p>Returned if the size of <code>SecurityGroups</code> specified in the request is greater than five.</p>
    SecurityGroupLimitExceeded(crate::error::SecurityGroupLimitExceeded),
    /// <p>Returned if one of the specified security groups doesn't exist in the subnet's virtual private cloud (VPC).</p>
    SecurityGroupNotFound(crate::error::SecurityGroupNotFound),
    /// <p>Returned if there is no subnet with ID <code>SubnetId</code> provided in the request.</p>
    SubnetNotFound(crate::error::SubnetNotFound),
    /// <p>Returned when the <code>CreateAccessPoint</code> API action is called too quickly and the number of Access Points on the file system is nearing the <a href="https://docs.aws.amazon.com/efs/latest/ug/limits.html#limits-efs-resources-per-account-per-region">limit of 120</a>.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>Returned if the throughput mode or amount of provisioned throughput can't be changed because the throughput limit of 1024 MiB/s has been reached.</p>
    ThroughputLimitExceeded(crate::error::ThroughputLimitExceeded),
    /// <p>Returned if you donâ€™t wait at least 24 hours before either changing the throughput mode, or decreasing the Provisioned Throughput value.</p>
    TooManyRequests(crate::error::TooManyRequests),
    /// <p>Returned if the requested Amazon EFS functionality is not available in the specified Availability Zone.</p>
    UnsupportedAvailabilityZone(crate::error::UnsupportedAvailabilityZone),
    /// <p>Returned if the Backup service is not available in the Amazon Web Services Region in which the request was made.</p>
    ValidationException(crate::error::ValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AccessPointAlreadyExists(inner) => inner.fmt(f),
            Error::AccessPointLimitExceeded(inner) => inner.fmt(f),
            Error::AccessPointNotFound(inner) => inner.fmt(f),
            Error::AvailabilityZonesMismatch(inner) => inner.fmt(f),
            Error::BadRequest(inner) => inner.fmt(f),
            Error::DependencyTimeout(inner) => inner.fmt(f),
            Error::FileSystemAlreadyExists(inner) => inner.fmt(f),
            Error::FileSystemInUse(inner) => inner.fmt(f),
            Error::FileSystemLimitExceeded(inner) => inner.fmt(f),
            Error::FileSystemNotFound(inner) => inner.fmt(f),
            Error::IncorrectFileSystemLifeCycleState(inner) => inner.fmt(f),
            Error::IncorrectMountTargetState(inner) => inner.fmt(f),
            Error::InsufficientThroughputCapacity(inner) => inner.fmt(f),
            Error::InternalServerError(inner) => inner.fmt(f),
            Error::InvalidPolicyException(inner) => inner.fmt(f),
            Error::IpAddressInUse(inner) => inner.fmt(f),
            Error::MountTargetConflict(inner) => inner.fmt(f),
            Error::MountTargetNotFound(inner) => inner.fmt(f),
            Error::NetworkInterfaceLimitExceeded(inner) => inner.fmt(f),
            Error::NoFreeAddressesInSubnet(inner) => inner.fmt(f),
            Error::PolicyNotFound(inner) => inner.fmt(f),
            Error::ReplicationNotFound(inner) => inner.fmt(f),
            Error::SecurityGroupLimitExceeded(inner) => inner.fmt(f),
            Error::SecurityGroupNotFound(inner) => inner.fmt(f),
            Error::SubnetNotFound(inner) => inner.fmt(f),
            Error::ThrottlingException(inner) => inner.fmt(f),
            Error::ThroughputLimitExceeded(inner) => inner.fmt(f),
            Error::TooManyRequests(inner) => inner.fmt(f),
            Error::UnsupportedAvailabilityZone(inner) => inner.fmt(f),
            Error::ValidationException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateAccessPointError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateAccessPointError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateAccessPointError> for Error {
    fn from(err: crate::error::CreateAccessPointError) -> Self {
        match err {
            crate::error::CreateAccessPointError::AccessPointAlreadyExists(inner) => {
                Error::AccessPointAlreadyExists(inner)
            }
            crate::error::CreateAccessPointError::AccessPointLimitExceeded(inner) => {
                Error::AccessPointLimitExceeded(inner)
            }
            crate::error::CreateAccessPointError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::CreateAccessPointError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::CreateAccessPointError::IncorrectFileSystemLifeCycleState(inner) => {
                Error::IncorrectFileSystemLifeCycleState(inner)
            }
            crate::error::CreateAccessPointError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::CreateAccessPointError::ThrottlingException(inner) => {
                Error::ThrottlingException(inner)
            }
            crate::error::CreateAccessPointError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateFileSystemError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateFileSystemError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateFileSystemError> for Error {
    fn from(err: crate::error::CreateFileSystemError) -> Self {
        match err {
            crate::error::CreateFileSystemError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::CreateFileSystemError::FileSystemAlreadyExists(inner) => {
                Error::FileSystemAlreadyExists(inner)
            }
            crate::error::CreateFileSystemError::FileSystemLimitExceeded(inner) => {
                Error::FileSystemLimitExceeded(inner)
            }
            crate::error::CreateFileSystemError::InsufficientThroughputCapacity(inner) => {
                Error::InsufficientThroughputCapacity(inner)
            }
            crate::error::CreateFileSystemError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::CreateFileSystemError::ThroughputLimitExceeded(inner) => {
                Error::ThroughputLimitExceeded(inner)
            }
            crate::error::CreateFileSystemError::UnsupportedAvailabilityZone(inner) => {
                Error::UnsupportedAvailabilityZone(inner)
            }
            crate::error::CreateFileSystemError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateMountTargetError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateMountTargetError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateMountTargetError> for Error {
    fn from(err: crate::error::CreateMountTargetError) -> Self {
        match err {
            crate::error::CreateMountTargetError::AvailabilityZonesMismatch(inner) => {
                Error::AvailabilityZonesMismatch(inner)
            }
            crate::error::CreateMountTargetError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::CreateMountTargetError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::CreateMountTargetError::IncorrectFileSystemLifeCycleState(inner) => {
                Error::IncorrectFileSystemLifeCycleState(inner)
            }
            crate::error::CreateMountTargetError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::CreateMountTargetError::IpAddressInUse(inner) => {
                Error::IpAddressInUse(inner)
            }
            crate::error::CreateMountTargetError::MountTargetConflict(inner) => {
                Error::MountTargetConflict(inner)
            }
            crate::error::CreateMountTargetError::NetworkInterfaceLimitExceeded(inner) => {
                Error::NetworkInterfaceLimitExceeded(inner)
            }
            crate::error::CreateMountTargetError::NoFreeAddressesInSubnet(inner) => {
                Error::NoFreeAddressesInSubnet(inner)
            }
            crate::error::CreateMountTargetError::SecurityGroupLimitExceeded(inner) => {
                Error::SecurityGroupLimitExceeded(inner)
            }
            crate::error::CreateMountTargetError::SecurityGroupNotFound(inner) => {
                Error::SecurityGroupNotFound(inner)
            }
            crate::error::CreateMountTargetError::SubnetNotFound(inner) => {
                Error::SubnetNotFound(inner)
            }
            crate::error::CreateMountTargetError::UnsupportedAvailabilityZone(inner) => {
                Error::UnsupportedAvailabilityZone(inner)
            }
            crate::error::CreateMountTargetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::CreateReplicationConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::CreateReplicationConfigurationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateReplicationConfigurationError> for Error {
    fn from(err: crate::error::CreateReplicationConfigurationError) -> Self {
        match err {
            crate::error::CreateReplicationConfigurationError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::CreateReplicationConfigurationError::FileSystemLimitExceeded(inner) => Error::FileSystemLimitExceeded(inner),
            crate::error::CreateReplicationConfigurationError::FileSystemNotFound(inner) => Error::FileSystemNotFound(inner),
            crate::error::CreateReplicationConfigurationError::IncorrectFileSystemLifeCycleState(inner) => Error::IncorrectFileSystemLifeCycleState(inner),
            crate::error::CreateReplicationConfigurationError::InsufficientThroughputCapacity(inner) => Error::InsufficientThroughputCapacity(inner),
            crate::error::CreateReplicationConfigurationError::InternalServerError(inner) => Error::InternalServerError(inner),
            crate::error::CreateReplicationConfigurationError::ReplicationNotFound(inner) => Error::ReplicationNotFound(inner),
            crate::error::CreateReplicationConfigurationError::ThroughputLimitExceeded(inner) => Error::ThroughputLimitExceeded(inner),
            crate::error::CreateReplicationConfigurationError::UnsupportedAvailabilityZone(inner) => Error::UnsupportedAvailabilityZone(inner),
            crate::error::CreateReplicationConfigurationError::ValidationException(inner) => Error::ValidationException(inner),
            crate::error::CreateReplicationConfigurationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateTagsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateTagsError> for Error {
    fn from(err: crate::error::CreateTagsError) -> Self {
        match err {
            crate::error::CreateTagsError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::CreateTagsError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::CreateTagsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::CreateTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteAccessPointError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteAccessPointError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteAccessPointError> for Error {
    fn from(err: crate::error::DeleteAccessPointError) -> Self {
        match err {
            crate::error::DeleteAccessPointError::AccessPointNotFound(inner) => {
                Error::AccessPointNotFound(inner)
            }
            crate::error::DeleteAccessPointError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::DeleteAccessPointError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DeleteAccessPointError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteFileSystemError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteFileSystemError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteFileSystemError> for Error {
    fn from(err: crate::error::DeleteFileSystemError) -> Self {
        match err {
            crate::error::DeleteFileSystemError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::DeleteFileSystemError::FileSystemInUse(inner) => {
                Error::FileSystemInUse(inner)
            }
            crate::error::DeleteFileSystemError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DeleteFileSystemError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DeleteFileSystemError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteFileSystemPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteFileSystemPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteFileSystemPolicyError> for Error {
    fn from(err: crate::error::DeleteFileSystemPolicyError) -> Self {
        match err {
            crate::error::DeleteFileSystemPolicyError::BadRequest(inner) => {
                Error::BadRequest(inner)
            }
            crate::error::DeleteFileSystemPolicyError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DeleteFileSystemPolicyError::IncorrectFileSystemLifeCycleState(inner) => {
                Error::IncorrectFileSystemLifeCycleState(inner)
            }
            crate::error::DeleteFileSystemPolicyError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DeleteFileSystemPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteMountTargetError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteMountTargetError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteMountTargetError> for Error {
    fn from(err: crate::error::DeleteMountTargetError) -> Self {
        match err {
            crate::error::DeleteMountTargetError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::DeleteMountTargetError::DependencyTimeout(inner) => {
                Error::DependencyTimeout(inner)
            }
            crate::error::DeleteMountTargetError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DeleteMountTargetError::MountTargetNotFound(inner) => {
                Error::MountTargetNotFound(inner)
            }
            crate::error::DeleteMountTargetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DeleteReplicationConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DeleteReplicationConfigurationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteReplicationConfigurationError> for Error {
    fn from(err: crate::error::DeleteReplicationConfigurationError) -> Self {
        match err {
            crate::error::DeleteReplicationConfigurationError::BadRequest(inner) => {
                Error::BadRequest(inner)
            }
            crate::error::DeleteReplicationConfigurationError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DeleteReplicationConfigurationError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DeleteReplicationConfigurationError::ReplicationNotFound(inner) => {
                Error::ReplicationNotFound(inner)
            }
            crate::error::DeleteReplicationConfigurationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteTagsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteTagsError> for Error {
    fn from(err: crate::error::DeleteTagsError) -> Self {
        match err {
            crate::error::DeleteTagsError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::DeleteTagsError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DeleteTagsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DeleteTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeAccessPointsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeAccessPointsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeAccessPointsError> for Error {
    fn from(err: crate::error::DescribeAccessPointsError) -> Self {
        match err {
            crate::error::DescribeAccessPointsError::AccessPointNotFound(inner) => {
                Error::AccessPointNotFound(inner)
            }
            crate::error::DescribeAccessPointsError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::DescribeAccessPointsError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DescribeAccessPointsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeAccessPointsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeAccountPreferencesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeAccountPreferencesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeAccountPreferencesError> for Error {
    fn from(err: crate::error::DescribeAccountPreferencesError) -> Self {
        match err {
            crate::error::DescribeAccountPreferencesError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeAccountPreferencesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeBackupPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeBackupPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeBackupPolicyError> for Error {
    fn from(err: crate::error::DescribeBackupPolicyError) -> Self {
        match err {
            crate::error::DescribeBackupPolicyError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::DescribeBackupPolicyError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DescribeBackupPolicyError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeBackupPolicyError::PolicyNotFound(inner) => {
                Error::PolicyNotFound(inner)
            }
            crate::error::DescribeBackupPolicyError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::error::DescribeBackupPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeFileSystemPolicyError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeFileSystemPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeFileSystemPolicyError> for Error {
    fn from(err: crate::error::DescribeFileSystemPolicyError) -> Self {
        match err {
            crate::error::DescribeFileSystemPolicyError::BadRequest(inner) => {
                Error::BadRequest(inner)
            }
            crate::error::DescribeFileSystemPolicyError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DescribeFileSystemPolicyError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeFileSystemPolicyError::PolicyNotFound(inner) => {
                Error::PolicyNotFound(inner)
            }
            crate::error::DescribeFileSystemPolicyError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeFileSystemsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeFileSystemsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeFileSystemsError> for Error {
    fn from(err: crate::error::DescribeFileSystemsError) -> Self {
        match err {
            crate::error::DescribeFileSystemsError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::DescribeFileSystemsError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DescribeFileSystemsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeFileSystemsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeLifecycleConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeLifecycleConfigurationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeLifecycleConfigurationError> for Error {
    fn from(err: crate::error::DescribeLifecycleConfigurationError) -> Self {
        match err {
            crate::error::DescribeLifecycleConfigurationError::BadRequest(inner) => {
                Error::BadRequest(inner)
            }
            crate::error::DescribeLifecycleConfigurationError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DescribeLifecycleConfigurationError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeLifecycleConfigurationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeMountTargetsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DescribeMountTargetsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeMountTargetsError> for Error {
    fn from(err: crate::error::DescribeMountTargetsError) -> Self {
        match err {
            crate::error::DescribeMountTargetsError::AccessPointNotFound(inner) => {
                Error::AccessPointNotFound(inner)
            }
            crate::error::DescribeMountTargetsError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::DescribeMountTargetsError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DescribeMountTargetsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeMountTargetsError::MountTargetNotFound(inner) => {
                Error::MountTargetNotFound(inner)
            }
            crate::error::DescribeMountTargetsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeMountTargetSecurityGroupsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeMountTargetSecurityGroupsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeMountTargetSecurityGroupsError> for Error {
    fn from(err: crate::error::DescribeMountTargetSecurityGroupsError) -> Self {
        match err {
            crate::error::DescribeMountTargetSecurityGroupsError::BadRequest(inner) => {
                Error::BadRequest(inner)
            }
            crate::error::DescribeMountTargetSecurityGroupsError::IncorrectMountTargetState(
                inner,
            ) => Error::IncorrectMountTargetState(inner),
            crate::error::DescribeMountTargetSecurityGroupsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeMountTargetSecurityGroupsError::MountTargetNotFound(inner) => {
                Error::MountTargetNotFound(inner)
            }
            crate::error::DescribeMountTargetSecurityGroupsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::DescribeReplicationConfigurationsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::DescribeReplicationConfigurationsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeReplicationConfigurationsError> for Error {
    fn from(err: crate::error::DescribeReplicationConfigurationsError) -> Self {
        match err {
            crate::error::DescribeReplicationConfigurationsError::BadRequest(inner) => {
                Error::BadRequest(inner)
            }
            crate::error::DescribeReplicationConfigurationsError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DescribeReplicationConfigurationsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeReplicationConfigurationsError::ReplicationNotFound(inner) => {
                Error::ReplicationNotFound(inner)
            }
            crate::error::DescribeReplicationConfigurationsError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::error::DescribeReplicationConfigurationsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeTagsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeTagsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DescribeTagsError> for Error {
    fn from(err: crate::error::DescribeTagsError) -> Self {
        match err {
            crate::error::DescribeTagsError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::DescribeTagsError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::DescribeTagsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::DescribeTagsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err {
            crate::error::ListTagsForResourceError::AccessPointNotFound(inner) => {
                Error::AccessPointNotFound(inner)
            }
            crate::error::ListTagsForResourceError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::ListTagsForResourceError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::ListTagsForResourceError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::ModifyMountTargetSecurityGroupsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::ModifyMountTargetSecurityGroupsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ModifyMountTargetSecurityGroupsError> for Error {
    fn from(err: crate::error::ModifyMountTargetSecurityGroupsError) -> Self {
        match err {
            crate::error::ModifyMountTargetSecurityGroupsError::BadRequest(inner) => {
                Error::BadRequest(inner)
            }
            crate::error::ModifyMountTargetSecurityGroupsError::IncorrectMountTargetState(
                inner,
            ) => Error::IncorrectMountTargetState(inner),
            crate::error::ModifyMountTargetSecurityGroupsError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::ModifyMountTargetSecurityGroupsError::MountTargetNotFound(inner) => {
                Error::MountTargetNotFound(inner)
            }
            crate::error::ModifyMountTargetSecurityGroupsError::SecurityGroupLimitExceeded(
                inner,
            ) => Error::SecurityGroupLimitExceeded(inner),
            crate::error::ModifyMountTargetSecurityGroupsError::SecurityGroupNotFound(inner) => {
                Error::SecurityGroupNotFound(inner)
            }
            crate::error::ModifyMountTargetSecurityGroupsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutAccountPreferencesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::PutAccountPreferencesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PutAccountPreferencesError> for Error {
    fn from(err: crate::error::PutAccountPreferencesError) -> Self {
        match err {
            crate::error::PutAccountPreferencesError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::PutAccountPreferencesError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::PutAccountPreferencesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutBackupPolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutBackupPolicyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PutBackupPolicyError> for Error {
    fn from(err: crate::error::PutBackupPolicyError) -> Self {
        match err {
            crate::error::PutBackupPolicyError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::PutBackupPolicyError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::PutBackupPolicyError::IncorrectFileSystemLifeCycleState(inner) => {
                Error::IncorrectFileSystemLifeCycleState(inner)
            }
            crate::error::PutBackupPolicyError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::PutBackupPolicyError::ValidationException(inner) => {
                Error::ValidationException(inner)
            }
            crate::error::PutBackupPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutFileSystemPolicyError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::PutFileSystemPolicyError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PutFileSystemPolicyError> for Error {
    fn from(err: crate::error::PutFileSystemPolicyError) -> Self {
        match err {
            crate::error::PutFileSystemPolicyError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::PutFileSystemPolicyError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::PutFileSystemPolicyError::IncorrectFileSystemLifeCycleState(inner) => {
                Error::IncorrectFileSystemLifeCycleState(inner)
            }
            crate::error::PutFileSystemPolicyError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::PutFileSystemPolicyError::InvalidPolicyException(inner) => {
                Error::InvalidPolicyException(inner)
            }
            crate::error::PutFileSystemPolicyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutLifecycleConfigurationError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::PutLifecycleConfigurationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PutLifecycleConfigurationError> for Error {
    fn from(err: crate::error::PutLifecycleConfigurationError) -> Self {
        match err {
            crate::error::PutLifecycleConfigurationError::BadRequest(inner) => {
                Error::BadRequest(inner)
            }
            crate::error::PutLifecycleConfigurationError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::PutLifecycleConfigurationError::IncorrectFileSystemLifeCycleState(
                inner,
            ) => Error::IncorrectFileSystemLifeCycleState(inner),
            crate::error::PutLifecycleConfigurationError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::PutLifecycleConfigurationError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err {
            crate::error::TagResourceError::AccessPointNotFound(inner) => {
                Error::AccessPointNotFound(inner)
            }
            crate::error::TagResourceError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::TagResourceError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::TagResourceError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err {
            crate::error::UntagResourceError::AccessPointNotFound(inner) => {
                Error::AccessPointNotFound(inner)
            }
            crate::error::UntagResourceError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::UntagResourceError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::UntagResourceError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateFileSystemError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateFileSystemError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateFileSystemError> for Error {
    fn from(err: crate::error::UpdateFileSystemError) -> Self {
        match err {
            crate::error::UpdateFileSystemError::BadRequest(inner) => Error::BadRequest(inner),
            crate::error::UpdateFileSystemError::FileSystemNotFound(inner) => {
                Error::FileSystemNotFound(inner)
            }
            crate::error::UpdateFileSystemError::IncorrectFileSystemLifeCycleState(inner) => {
                Error::IncorrectFileSystemLifeCycleState(inner)
            }
            crate::error::UpdateFileSystemError::InsufficientThroughputCapacity(inner) => {
                Error::InsufficientThroughputCapacity(inner)
            }
            crate::error::UpdateFileSystemError::InternalServerError(inner) => {
                Error::InternalServerError(inner)
            }
            crate::error::UpdateFileSystemError::ThroughputLimitExceeded(inner) => {
                Error::ThroughputLimitExceeded(inner)
            }
            crate::error::UpdateFileSystemError::TooManyRequests(inner) => {
                Error::TooManyRequests(inner)
            }
            crate::error::UpdateFileSystemError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AccessPointAlreadyExists(e) => e.request_id(),
            Self::AccessPointLimitExceeded(e) => e.request_id(),
            Self::AccessPointNotFound(e) => e.request_id(),
            Self::AvailabilityZonesMismatch(e) => e.request_id(),
            Self::BadRequest(e) => e.request_id(),
            Self::DependencyTimeout(e) => e.request_id(),
            Self::FileSystemAlreadyExists(e) => e.request_id(),
            Self::FileSystemInUse(e) => e.request_id(),
            Self::FileSystemLimitExceeded(e) => e.request_id(),
            Self::FileSystemNotFound(e) => e.request_id(),
            Self::IncorrectFileSystemLifeCycleState(e) => e.request_id(),
            Self::IncorrectMountTargetState(e) => e.request_id(),
            Self::InsufficientThroughputCapacity(e) => e.request_id(),
            Self::InternalServerError(e) => e.request_id(),
            Self::InvalidPolicyException(e) => e.request_id(),
            Self::IpAddressInUse(e) => e.request_id(),
            Self::MountTargetConflict(e) => e.request_id(),
            Self::MountTargetNotFound(e) => e.request_id(),
            Self::NetworkInterfaceLimitExceeded(e) => e.request_id(),
            Self::NoFreeAddressesInSubnet(e) => e.request_id(),
            Self::PolicyNotFound(e) => e.request_id(),
            Self::ReplicationNotFound(e) => e.request_id(),
            Self::SecurityGroupLimitExceeded(e) => e.request_id(),
            Self::SecurityGroupNotFound(e) => e.request_id(),
            Self::SubnetNotFound(e) => e.request_id(),
            Self::ThrottlingException(e) => e.request_id(),
            Self::ThroughputLimitExceeded(e) => e.request_id(),
            Self::TooManyRequests(e) => e.request_id(),
            Self::UnsupportedAvailabilityZone(e) => e.request_id(),
            Self::ValidationException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
