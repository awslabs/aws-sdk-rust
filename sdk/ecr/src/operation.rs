// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Checks the availability of one or more image layers in a repository.</p>
/// <p>When an image is pushed to a repository, each image layer is checked to verify if it
/// has been uploaded before. If it has been uploaded, then the image layer is
/// skipped.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by
/// customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchCheckLayerAvailability {
    _private: (),
}
impl BatchCheckLayerAvailability {
    /// Creates a new builder-style object to manufacture [`BatchCheckLayerAvailabilityInput`](crate::input::BatchCheckLayerAvailabilityInput)
    pub fn builder() -> crate::input::batch_check_layer_availability_input::Builder {
        crate::input::batch_check_layer_availability_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchCheckLayerAvailability {
    type Output = std::result::Result<
        crate::output::BatchCheckLayerAvailabilityOutput,
        crate::error::BatchCheckLayerAvailabilityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_check_layer_availability_error(response)
        } else {
            crate::operation_deser::parse_batch_check_layer_availability_response(response)
        }
    }
}

/// <p>Deletes a list of specified images within a repository. Images are specified with
/// either an <code>imageTag</code> or <code>imageDigest</code>.</p>
/// <p>You can remove a tag from an image by specifying the image's tag in your request. When
/// you remove the last tag from an image, the image is deleted from your repository.</p>
/// <p>You can completely delete an image (and all of its tags) by specifying the image's
/// digest in your request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDeleteImage {
    _private: (),
}
impl BatchDeleteImage {
    /// Creates a new builder-style object to manufacture [`BatchDeleteImageInput`](crate::input::BatchDeleteImageInput)
    pub fn builder() -> crate::input::batch_delete_image_input::Builder {
        crate::input::batch_delete_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDeleteImage {
    type Output = std::result::Result<
        crate::output::BatchDeleteImageOutput,
        crate::error::BatchDeleteImageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_delete_image_error(response)
        } else {
            crate::operation_deser::parse_batch_delete_image_response(response)
        }
    }
}

/// <p>Gets detailed information for an image. Images are specified with either an
/// <code>imageTag</code> or <code>imageDigest</code>.</p>
/// <p>When an image is pulled, the BatchGetImage API is called once to retrieve the image
/// manifest.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetImage {
    _private: (),
}
impl BatchGetImage {
    /// Creates a new builder-style object to manufacture [`BatchGetImageInput`](crate::input::BatchGetImageInput)
    pub fn builder() -> crate::input::batch_get_image_input::Builder {
        crate::input::batch_get_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetImage {
    type Output =
        std::result::Result<crate::output::BatchGetImageOutput, crate::error::BatchGetImageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_image_error(response)
        } else {
            crate::operation_deser::parse_batch_get_image_response(response)
        }
    }
}

/// <p>Informs Amazon ECR that the image layer upload has completed for a specified registry,
/// repository name, and upload ID. You can optionally provide a <code>sha256</code> digest
/// of the image layer for data validation purposes.</p>
/// <p>When an image is pushed, the CompleteLayerUpload API is called once per each new image
/// layer to verify that the upload has completed.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by
/// customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CompleteLayerUpload {
    _private: (),
}
impl CompleteLayerUpload {
    /// Creates a new builder-style object to manufacture [`CompleteLayerUploadInput`](crate::input::CompleteLayerUploadInput)
    pub fn builder() -> crate::input::complete_layer_upload_input::Builder {
        crate::input::complete_layer_upload_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CompleteLayerUpload {
    type Output = std::result::Result<
        crate::output::CompleteLayerUploadOutput,
        crate::error::CompleteLayerUploadError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_complete_layer_upload_error(response)
        } else {
            crate::operation_deser::parse_complete_layer_upload_response(response)
        }
    }
}

/// <p>Creates a repository. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Repositories.html">Amazon ECR repositories</a> in the
/// <i>Amazon Elastic Container Registry User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRepository {
    _private: (),
}
impl CreateRepository {
    /// Creates a new builder-style object to manufacture [`CreateRepositoryInput`](crate::input::CreateRepositoryInput)
    pub fn builder() -> crate::input::create_repository_input::Builder {
        crate::input::create_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRepository {
    type Output = std::result::Result<
        crate::output::CreateRepositoryOutput,
        crate::error::CreateRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_repository_error(response)
        } else {
            crate::operation_deser::parse_create_repository_response(response)
        }
    }
}

/// <p>Deletes the lifecycle policy associated with the specified repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteLifecyclePolicy {
    _private: (),
}
impl DeleteLifecyclePolicy {
    /// Creates a new builder-style object to manufacture [`DeleteLifecyclePolicyInput`](crate::input::DeleteLifecyclePolicyInput)
    pub fn builder() -> crate::input::delete_lifecycle_policy_input::Builder {
        crate::input::delete_lifecycle_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteLifecyclePolicy {
    type Output = std::result::Result<
        crate::output::DeleteLifecyclePolicyOutput,
        crate::error::DeleteLifecyclePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_lifecycle_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_lifecycle_policy_response(response)
        }
    }
}

/// <p>Deletes the registry permissions policy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRegistryPolicy {
    _private: (),
}
impl DeleteRegistryPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteRegistryPolicyInput`](crate::input::DeleteRegistryPolicyInput)
    pub fn builder() -> crate::input::delete_registry_policy_input::Builder {
        crate::input::delete_registry_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRegistryPolicy {
    type Output = std::result::Result<
        crate::output::DeleteRegistryPolicyOutput,
        crate::error::DeleteRegistryPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_registry_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_registry_policy_response(response)
        }
    }
}

/// <p>Deletes a repository. If the repository contains images, you must either delete all
/// images in the repository or use the <code>force</code> option to delete the
/// repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRepository {
    _private: (),
}
impl DeleteRepository {
    /// Creates a new builder-style object to manufacture [`DeleteRepositoryInput`](crate::input::DeleteRepositoryInput)
    pub fn builder() -> crate::input::delete_repository_input::Builder {
        crate::input::delete_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRepository {
    type Output = std::result::Result<
        crate::output::DeleteRepositoryOutput,
        crate::error::DeleteRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_repository_error(response)
        } else {
            crate::operation_deser::parse_delete_repository_response(response)
        }
    }
}

/// <p>Deletes the repository policy associated with the specified repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRepositoryPolicy {
    _private: (),
}
impl DeleteRepositoryPolicy {
    /// Creates a new builder-style object to manufacture [`DeleteRepositoryPolicyInput`](crate::input::DeleteRepositoryPolicyInput)
    pub fn builder() -> crate::input::delete_repository_policy_input::Builder {
        crate::input::delete_repository_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRepositoryPolicy {
    type Output = std::result::Result<
        crate::output::DeleteRepositoryPolicyOutput,
        crate::error::DeleteRepositoryPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_repository_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_repository_policy_response(response)
        }
    }
}

/// <p>Returns metadata about the images in a repository.</p>
/// <note>
/// <p>Beginning with Docker version 1.9, the Docker client compresses image layers
/// before pushing them to a V2 Docker registry. The output of the <code>docker
/// images</code> command shows the uncompressed image size, so it may return a
/// larger image size than the image sizes returned by <a>DescribeImages</a>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeImages {
    _private: (),
}
impl DescribeImages {
    /// Creates a new builder-style object to manufacture [`DescribeImagesInput`](crate::input::DescribeImagesInput)
    pub fn builder() -> crate::input::describe_images_input::Builder {
        crate::input::describe_images_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeImages {
    type Output =
        std::result::Result<crate::output::DescribeImagesOutput, crate::error::DescribeImagesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_images_error(response)
        } else {
            crate::operation_deser::parse_describe_images_response(response)
        }
    }
}

/// <p>Returns the scan findings for the specified image.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeImageScanFindings {
    _private: (),
}
impl DescribeImageScanFindings {
    /// Creates a new builder-style object to manufacture [`DescribeImageScanFindingsInput`](crate::input::DescribeImageScanFindingsInput)
    pub fn builder() -> crate::input::describe_image_scan_findings_input::Builder {
        crate::input::describe_image_scan_findings_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeImageScanFindings {
    type Output = std::result::Result<
        crate::output::DescribeImageScanFindingsOutput,
        crate::error::DescribeImageScanFindingsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_image_scan_findings_error(response)
        } else {
            crate::operation_deser::parse_describe_image_scan_findings_response(response)
        }
    }
}

/// <p>Describes the settings for a registry. The replication configuration for a repository
/// can be created or updated with the <a>PutReplicationConfiguration</a> API
/// action.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRegistry {
    _private: (),
}
impl DescribeRegistry {
    /// Creates a new builder-style object to manufacture [`DescribeRegistryInput`](crate::input::DescribeRegistryInput)
    pub fn builder() -> crate::input::describe_registry_input::Builder {
        crate::input::describe_registry_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRegistry {
    type Output = std::result::Result<
        crate::output::DescribeRegistryOutput,
        crate::error::DescribeRegistryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_registry_error(response)
        } else {
            crate::operation_deser::parse_describe_registry_response(response)
        }
    }
}

/// <p>Describes image repositories in a registry.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeRepositories {
    _private: (),
}
impl DescribeRepositories {
    /// Creates a new builder-style object to manufacture [`DescribeRepositoriesInput`](crate::input::DescribeRepositoriesInput)
    pub fn builder() -> crate::input::describe_repositories_input::Builder {
        crate::input::describe_repositories_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeRepositories {
    type Output = std::result::Result<
        crate::output::DescribeRepositoriesOutput,
        crate::error::DescribeRepositoriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_repositories_error(response)
        } else {
            crate::operation_deser::parse_describe_repositories_response(response)
        }
    }
}

/// <p>Retrieves an authorization token. An authorization token represents your IAM
/// authentication credentials and can be used to access any Amazon ECR registry that your IAM
/// principal has access to. The authorization token is valid for 12 hours.</p>
/// <p>The <code>authorizationToken</code> returned is a base64 encoded string that can be
/// decoded and used in a <code>docker login</code> command to authenticate to a registry.
/// The CLI offers an <code>get-login-password</code> command that simplifies the login
/// process. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html#registry_auth">Registry
/// authentication</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetAuthorizationToken {
    _private: (),
}
impl GetAuthorizationToken {
    /// Creates a new builder-style object to manufacture [`GetAuthorizationTokenInput`](crate::input::GetAuthorizationTokenInput)
    pub fn builder() -> crate::input::get_authorization_token_input::Builder {
        crate::input::get_authorization_token_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetAuthorizationToken {
    type Output = std::result::Result<
        crate::output::GetAuthorizationTokenOutput,
        crate::error::GetAuthorizationTokenError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_authorization_token_error(response)
        } else {
            crate::operation_deser::parse_get_authorization_token_response(response)
        }
    }
}

/// <p>Retrieves the pre-signed Amazon S3 download URL corresponding to an image layer. You can
/// only get URLs for image layers that are referenced in an image.</p>
/// <p>When an image is pulled, the GetDownloadUrlForLayer API is called once per image layer
/// that is not already cached.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by
/// customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDownloadUrlForLayer {
    _private: (),
}
impl GetDownloadUrlForLayer {
    /// Creates a new builder-style object to manufacture [`GetDownloadUrlForLayerInput`](crate::input::GetDownloadUrlForLayerInput)
    pub fn builder() -> crate::input::get_download_url_for_layer_input::Builder {
        crate::input::get_download_url_for_layer_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDownloadUrlForLayer {
    type Output = std::result::Result<
        crate::output::GetDownloadUrlForLayerOutput,
        crate::error::GetDownloadUrlForLayerError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_download_url_for_layer_error(response)
        } else {
            crate::operation_deser::parse_get_download_url_for_layer_response(response)
        }
    }
}

/// <p>Retrieves the lifecycle policy for the specified repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLifecyclePolicy {
    _private: (),
}
impl GetLifecyclePolicy {
    /// Creates a new builder-style object to manufacture [`GetLifecyclePolicyInput`](crate::input::GetLifecyclePolicyInput)
    pub fn builder() -> crate::input::get_lifecycle_policy_input::Builder {
        crate::input::get_lifecycle_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLifecyclePolicy {
    type Output = std::result::Result<
        crate::output::GetLifecyclePolicyOutput,
        crate::error::GetLifecyclePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_lifecycle_policy_error(response)
        } else {
            crate::operation_deser::parse_get_lifecycle_policy_response(response)
        }
    }
}

/// <p>Retrieves the results of the lifecycle policy preview request for the specified
/// repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetLifecyclePolicyPreview {
    _private: (),
}
impl GetLifecyclePolicyPreview {
    /// Creates a new builder-style object to manufacture [`GetLifecyclePolicyPreviewInput`](crate::input::GetLifecyclePolicyPreviewInput)
    pub fn builder() -> crate::input::get_lifecycle_policy_preview_input::Builder {
        crate::input::get_lifecycle_policy_preview_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetLifecyclePolicyPreview {
    type Output = std::result::Result<
        crate::output::GetLifecyclePolicyPreviewOutput,
        crate::error::GetLifecyclePolicyPreviewError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_lifecycle_policy_preview_error(response)
        } else {
            crate::operation_deser::parse_get_lifecycle_policy_preview_response(response)
        }
    }
}

/// <p>Retrieves the permissions policy for a registry.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRegistryPolicy {
    _private: (),
}
impl GetRegistryPolicy {
    /// Creates a new builder-style object to manufacture [`GetRegistryPolicyInput`](crate::input::GetRegistryPolicyInput)
    pub fn builder() -> crate::input::get_registry_policy_input::Builder {
        crate::input::get_registry_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRegistryPolicy {
    type Output = std::result::Result<
        crate::output::GetRegistryPolicyOutput,
        crate::error::GetRegistryPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_registry_policy_error(response)
        } else {
            crate::operation_deser::parse_get_registry_policy_response(response)
        }
    }
}

/// <p>Retrieves the repository policy for the specified repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRepositoryPolicy {
    _private: (),
}
impl GetRepositoryPolicy {
    /// Creates a new builder-style object to manufacture [`GetRepositoryPolicyInput`](crate::input::GetRepositoryPolicyInput)
    pub fn builder() -> crate::input::get_repository_policy_input::Builder {
        crate::input::get_repository_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRepositoryPolicy {
    type Output = std::result::Result<
        crate::output::GetRepositoryPolicyOutput,
        crate::error::GetRepositoryPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_repository_policy_error(response)
        } else {
            crate::operation_deser::parse_get_repository_policy_response(response)
        }
    }
}

/// <p>Notifies Amazon ECR that you intend to upload an image layer.</p>
/// <p>When an image is pushed, the InitiateLayerUpload API is called once per image layer
/// that has not already been uploaded. Whether or not an image layer has been uploaded is
/// determined by the BatchCheckLayerAvailability API action.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by
/// customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct InitiateLayerUpload {
    _private: (),
}
impl InitiateLayerUpload {
    /// Creates a new builder-style object to manufacture [`InitiateLayerUploadInput`](crate::input::InitiateLayerUploadInput)
    pub fn builder() -> crate::input::initiate_layer_upload_input::Builder {
        crate::input::initiate_layer_upload_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for InitiateLayerUpload {
    type Output = std::result::Result<
        crate::output::InitiateLayerUploadOutput,
        crate::error::InitiateLayerUploadError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_initiate_layer_upload_error(response)
        } else {
            crate::operation_deser::parse_initiate_layer_upload_response(response)
        }
    }
}

/// <p>Lists all the image IDs for the specified repository.</p>
/// <p>You can filter images based on whether or not they are tagged by using the
/// <code>tagStatus</code> filter and specifying either <code>TAGGED</code>,
/// <code>UNTAGGED</code> or <code>ANY</code>. For example, you can filter your results
/// to return only <code>UNTAGGED</code> images and then pipe that result to a <a>BatchDeleteImage</a> operation to delete them. Or, you can filter your
/// results to return only <code>TAGGED</code> images to list all of the tags in your
/// repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListImages {
    _private: (),
}
impl ListImages {
    /// Creates a new builder-style object to manufacture [`ListImagesInput`](crate::input::ListImagesInput)
    pub fn builder() -> crate::input::list_images_input::Builder {
        crate::input::list_images_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListImages {
    type Output =
        std::result::Result<crate::output::ListImagesOutput, crate::error::ListImagesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_images_error(response)
        } else {
            crate::operation_deser::parse_list_images_response(response)
        }
    }
}

/// <p>List the tags for an Amazon ECR resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Creates or updates the image manifest and tags associated with an image.</p>
/// <p>When an image is pushed and all new image layers have been uploaded, the PutImage API
/// is called once to create or update the image manifest and the tags associated with the
/// image.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by
/// customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutImage {
    _private: (),
}
impl PutImage {
    /// Creates a new builder-style object to manufacture [`PutImageInput`](crate::input::PutImageInput)
    pub fn builder() -> crate::input::put_image_input::Builder {
        crate::input::put_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutImage {
    type Output = std::result::Result<crate::output::PutImageOutput, crate::error::PutImageError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_image_error(response)
        } else {
            crate::operation_deser::parse_put_image_response(response)
        }
    }
}

/// <p>Updates the image scanning configuration for the specified repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutImageScanningConfiguration {
    _private: (),
}
impl PutImageScanningConfiguration {
    /// Creates a new builder-style object to manufacture [`PutImageScanningConfigurationInput`](crate::input::PutImageScanningConfigurationInput)
    pub fn builder() -> crate::input::put_image_scanning_configuration_input::Builder {
        crate::input::put_image_scanning_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutImageScanningConfiguration {
    type Output = std::result::Result<
        crate::output::PutImageScanningConfigurationOutput,
        crate::error::PutImageScanningConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_image_scanning_configuration_error(response)
        } else {
            crate::operation_deser::parse_put_image_scanning_configuration_response(response)
        }
    }
}

/// <p>Updates the image tag mutability settings for the specified repository. For more
/// information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-tag-mutability.html">Image tag
/// mutability</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutImageTagMutability {
    _private: (),
}
impl PutImageTagMutability {
    /// Creates a new builder-style object to manufacture [`PutImageTagMutabilityInput`](crate::input::PutImageTagMutabilityInput)
    pub fn builder() -> crate::input::put_image_tag_mutability_input::Builder {
        crate::input::put_image_tag_mutability_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutImageTagMutability {
    type Output = std::result::Result<
        crate::output::PutImageTagMutabilityOutput,
        crate::error::PutImageTagMutabilityError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_image_tag_mutability_error(response)
        } else {
            crate::operation_deser::parse_put_image_tag_mutability_response(response)
        }
    }
}

/// <p>Creates or updates the lifecycle policy for the specified repository. For more
/// information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html">Lifecycle policy
/// template</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutLifecyclePolicy {
    _private: (),
}
impl PutLifecyclePolicy {
    /// Creates a new builder-style object to manufacture [`PutLifecyclePolicyInput`](crate::input::PutLifecyclePolicyInput)
    pub fn builder() -> crate::input::put_lifecycle_policy_input::Builder {
        crate::input::put_lifecycle_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutLifecyclePolicy {
    type Output = std::result::Result<
        crate::output::PutLifecyclePolicyOutput,
        crate::error::PutLifecyclePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_lifecycle_policy_error(response)
        } else {
            crate::operation_deser::parse_put_lifecycle_policy_response(response)
        }
    }
}

/// <p>Creates or updates the permissions policy for your registry.</p>
/// <p>A registry policy is used to specify permissions for another Amazon Web Services account and is used
/// when configuring cross-account replication. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry-permissions.html">Registry permissions</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRegistryPolicy {
    _private: (),
}
impl PutRegistryPolicy {
    /// Creates a new builder-style object to manufacture [`PutRegistryPolicyInput`](crate::input::PutRegistryPolicyInput)
    pub fn builder() -> crate::input::put_registry_policy_input::Builder {
        crate::input::put_registry_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRegistryPolicy {
    type Output = std::result::Result<
        crate::output::PutRegistryPolicyOutput,
        crate::error::PutRegistryPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_registry_policy_error(response)
        } else {
            crate::operation_deser::parse_put_registry_policy_response(response)
        }
    }
}

/// <p>Creates or updates the replication configuration for a registry. The existing
/// replication configuration for a repository can be retrieved with the <a>DescribeRegistry</a> API action. The first time the
/// PutReplicationConfiguration API is called, a service-linked IAM role is created in
/// your account for the replication process. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/using-service-linked-roles.html">Using
/// service-linked roles for Amazon ECR</a> in the
/// <i>Amazon Elastic Container Registry User Guide</i>.</p>
/// <note>
/// <p>When configuring cross-account replication, the destination account must grant the
/// source account permission to replicate. This permission is controlled using a
/// registry permissions policy. For more information, see <a>PutRegistryPolicy</a>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutReplicationConfiguration {
    _private: (),
}
impl PutReplicationConfiguration {
    /// Creates a new builder-style object to manufacture [`PutReplicationConfigurationInput`](crate::input::PutReplicationConfigurationInput)
    pub fn builder() -> crate::input::put_replication_configuration_input::Builder {
        crate::input::put_replication_configuration_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutReplicationConfiguration {
    type Output = std::result::Result<
        crate::output::PutReplicationConfigurationOutput,
        crate::error::PutReplicationConfigurationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_replication_configuration_error(response)
        } else {
            crate::operation_deser::parse_put_replication_configuration_response(response)
        }
    }
}

/// <p>Applies a repository policy to the specified repository to control access permissions.
/// For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policies.html">Amazon ECR Repository
/// policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SetRepositoryPolicy {
    _private: (),
}
impl SetRepositoryPolicy {
    /// Creates a new builder-style object to manufacture [`SetRepositoryPolicyInput`](crate::input::SetRepositoryPolicyInput)
    pub fn builder() -> crate::input::set_repository_policy_input::Builder {
        crate::input::set_repository_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SetRepositoryPolicy {
    type Output = std::result::Result<
        crate::output::SetRepositoryPolicyOutput,
        crate::error::SetRepositoryPolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_set_repository_policy_error(response)
        } else {
            crate::operation_deser::parse_set_repository_policy_response(response)
        }
    }
}

/// <p>Starts an image vulnerability scan. An image scan can only be started once per 24
/// hours on an individual image. This limit includes if an image was scanned on initial
/// push. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html">Image scanning</a> in the
/// <i>Amazon Elastic Container Registry User Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartImageScan {
    _private: (),
}
impl StartImageScan {
    /// Creates a new builder-style object to manufacture [`StartImageScanInput`](crate::input::StartImageScanInput)
    pub fn builder() -> crate::input::start_image_scan_input::Builder {
        crate::input::start_image_scan_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartImageScan {
    type Output =
        std::result::Result<crate::output::StartImageScanOutput, crate::error::StartImageScanError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_image_scan_error(response)
        } else {
            crate::operation_deser::parse_start_image_scan_response(response)
        }
    }
}

/// <p>Starts a preview of a lifecycle policy for the specified repository. This allows you
/// to see the results before associating the lifecycle policy with the repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartLifecyclePolicyPreview {
    _private: (),
}
impl StartLifecyclePolicyPreview {
    /// Creates a new builder-style object to manufacture [`StartLifecyclePolicyPreviewInput`](crate::input::StartLifecyclePolicyPreviewInput)
    pub fn builder() -> crate::input::start_lifecycle_policy_preview_input::Builder {
        crate::input::start_lifecycle_policy_preview_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartLifecyclePolicyPreview {
    type Output = std::result::Result<
        crate::output::StartLifecyclePolicyPreviewOutput,
        crate::error::StartLifecyclePolicyPreviewError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_lifecycle_policy_preview_error(response)
        } else {
            crate::operation_deser::parse_start_lifecycle_policy_preview_response(response)
        }
    }
}

/// <p>Adds specified tags to a resource with the specified ARN. Existing tags on a resource
/// are not changed if they are not specified in the request parameters.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Deletes specified tags from a resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Uploads an image layer part to Amazon ECR.</p>
/// <p>When an image is pushed, each new image layer is uploaded in parts. The maximum size
/// of each image layer part can be 20971520 bytes (or about 20MB). The UploadLayerPart API
/// is called once per each new image layer part.</p>
/// <note>
/// <p>This operation is used by the Amazon ECR proxy and is not generally used by
/// customers for pulling and pushing images. In most cases, you should use the <code>docker</code> CLI to pull, tag, and push images.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UploadLayerPart {
    _private: (),
}
impl UploadLayerPart {
    /// Creates a new builder-style object to manufacture [`UploadLayerPartInput`](crate::input::UploadLayerPartInput)
    pub fn builder() -> crate::input::upload_layer_part_input::Builder {
        crate::input::upload_layer_part_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UploadLayerPart {
    type Output = std::result::Result<
        crate::output::UploadLayerPartOutput,
        crate::error::UploadLayerPartError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_upload_layer_part_error(response)
        } else {
            crate::operation_deser::parse_upload_layer_part_response(response)
        }
    }
}
