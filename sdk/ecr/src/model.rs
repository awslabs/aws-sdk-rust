// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>The metadata that you apply to a resource to help you categorize and organize them.
/// Each tag consists of a key and an optional value, both of which you define.
/// Tag keys can have a maximum character length of 128 characters, and tag values can have
/// a maximum length of 256 characters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Tag {
    /// <p>One part of a key-value pair that make up a tag. A <code>key</code> is a general label
    /// that acts like a category for more specific tag values.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The optional part of a key-value pair that make up a tag. A <code>value</code> acts as
    /// a descriptor within a tag category (key).</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Tag");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Tag`](crate::model::Tag)
pub mod tag {
    /// A builder for [`Tag`](crate::model::Tag)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>One part of a key-value pair that make up a tag. A <code>key</code> is a general label
        /// that acts like a category for more specific tag values.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The optional part of a key-value pair that make up a tag. A <code>value</code> acts as
        /// a descriptor within a tag category (key).</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag)
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag)
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LifecyclePolicyPreviewStatus {
    Complete,
    Expired,
    Failed,
    InProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LifecyclePolicyPreviewStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETE" => LifecyclePolicyPreviewStatus::Complete,
            "EXPIRED" => LifecyclePolicyPreviewStatus::Expired,
            "FAILED" => LifecyclePolicyPreviewStatus::Failed,
            "IN_PROGRESS" => LifecyclePolicyPreviewStatus::InProgress,
            other => LifecyclePolicyPreviewStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LifecyclePolicyPreviewStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LifecyclePolicyPreviewStatus::from(s))
    }
}
impl LifecyclePolicyPreviewStatus {
    pub fn as_str(&self) -> &str {
        match self {
            LifecyclePolicyPreviewStatus::Complete => "COMPLETE",
            LifecyclePolicyPreviewStatus::Expired => "EXPIRED",
            LifecyclePolicyPreviewStatus::Failed => "FAILED",
            LifecyclePolicyPreviewStatus::InProgress => "IN_PROGRESS",
            LifecyclePolicyPreviewStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for LifecyclePolicyPreviewStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The current status of an image scan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageScanStatus {
    /// <p>The current state of an image scan.</p>
    pub status: std::option::Option<crate::model::ScanStatus>,
    /// <p>The description of the image scan status.</p>
    pub description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImageScanStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageScanStatus");
        formatter.field("status", &self.status);
        formatter.field("description", &self.description);
        formatter.finish()
    }
}
/// See [`ImageScanStatus`](crate::model::ImageScanStatus)
pub mod image_scan_status {
    /// A builder for [`ImageScanStatus`](crate::model::ImageScanStatus)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::ScanStatus>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The current state of an image scan.</p>
        pub fn status(mut self, input: crate::model::ScanStatus) -> Self {
            self.status = Some(input);
            self
        }
        pub fn set_status(mut self, input: std::option::Option<crate::model::ScanStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The description of the image scan status.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageScanStatus`](crate::model::ImageScanStatus)
        pub fn build(self) -> crate::model::ImageScanStatus {
            crate::model::ImageScanStatus {
                status: self.status,
                description: self.description,
            }
        }
    }
}
impl ImageScanStatus {
    /// Creates a new builder-style object to manufacture [`ImageScanStatus`](crate::model::ImageScanStatus)
    pub fn builder() -> crate::model::image_scan_status::Builder {
        crate::model::image_scan_status::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScanStatus {
    Complete,
    Failed,
    InProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ScanStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETE" => ScanStatus::Complete,
            "FAILED" => ScanStatus::Failed,
            "IN_PROGRESS" => ScanStatus::InProgress,
            other => ScanStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ScanStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScanStatus::from(s))
    }
}
impl ScanStatus {
    pub fn as_str(&self) -> &str {
        match self {
            ScanStatus::Complete => "COMPLETE",
            ScanStatus::Failed => "FAILED",
            ScanStatus::InProgress => "IN_PROGRESS",
            ScanStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ScanStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object with identifying information for an Amazon ECR image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageIdentifier {
    /// <p>The <code>sha256</code> digest of the image manifest.</p>
    pub image_digest: std::option::Option<std::string::String>,
    /// <p>The tag used for the image.</p>
    pub image_tag: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImageIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageIdentifier");
        formatter.field("image_digest", &self.image_digest);
        formatter.field("image_tag", &self.image_tag);
        formatter.finish()
    }
}
/// See [`ImageIdentifier`](crate::model::ImageIdentifier)
pub mod image_identifier {
    /// A builder for [`ImageIdentifier`](crate::model::ImageIdentifier)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_digest: std::option::Option<std::string::String>,
        pub(crate) image_tag: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>sha256</code> digest of the image manifest.</p>
        pub fn image_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_digest = Some(input.into());
            self
        }
        pub fn set_image_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_digest = input;
            self
        }
        /// <p>The tag used for the image.</p>
        pub fn image_tag(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_tag = Some(input.into());
            self
        }
        pub fn set_image_tag(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_tag = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageIdentifier`](crate::model::ImageIdentifier)
        pub fn build(self) -> crate::model::ImageIdentifier {
            crate::model::ImageIdentifier {
                image_digest: self.image_digest,
                image_tag: self.image_tag,
            }
        }
    }
}
impl ImageIdentifier {
    /// Creates a new builder-style object to manufacture [`ImageIdentifier`](crate::model::ImageIdentifier)
    pub fn builder() -> crate::model::image_identifier::Builder {
        crate::model::image_identifier::Builder::default()
    }
}

/// <p>The replication configuration for a registry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicationConfiguration {
    /// <p>An array of objects representing the replication rules for a replication
    /// configuration. A replication configuration may contain only one replication rule but the
    /// rule may contain one or more replication destinations.</p>
    pub rules: std::option::Option<std::vec::Vec<crate::model::ReplicationRule>>,
}
impl std::fmt::Debug for ReplicationConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicationConfiguration");
        formatter.field("rules", &self.rules);
        formatter.finish()
    }
}
/// See [`ReplicationConfiguration`](crate::model::ReplicationConfiguration)
pub mod replication_configuration {
    /// A builder for [`ReplicationConfiguration`](crate::model::ReplicationConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rules: std::option::Option<std::vec::Vec<crate::model::ReplicationRule>>,
    }
    impl Builder {
        pub fn rules(mut self, input: impl Into<crate::model::ReplicationRule>) -> Self {
            let mut v = self.rules.unwrap_or_default();
            v.push(input.into());
            self.rules = Some(v);
            self
        }
        pub fn set_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReplicationRule>>,
        ) -> Self {
            self.rules = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationConfiguration`](crate::model::ReplicationConfiguration)
        pub fn build(self) -> crate::model::ReplicationConfiguration {
            crate::model::ReplicationConfiguration { rules: self.rules }
        }
    }
}
impl ReplicationConfiguration {
    /// Creates a new builder-style object to manufacture [`ReplicationConfiguration`](crate::model::ReplicationConfiguration)
    pub fn builder() -> crate::model::replication_configuration::Builder {
        crate::model::replication_configuration::Builder::default()
    }
}

/// <p>An array of objects representing the replication destinations for a replication
/// configuration. A replication configuration may contain only one replication rule but the
/// rule may contain one or more replication destinations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicationRule {
    /// <p>An array of objects representing the details of a replication destination.</p>
    pub destinations: std::option::Option<std::vec::Vec<crate::model::ReplicationDestination>>,
}
impl std::fmt::Debug for ReplicationRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicationRule");
        formatter.field("destinations", &self.destinations);
        formatter.finish()
    }
}
/// See [`ReplicationRule`](crate::model::ReplicationRule)
pub mod replication_rule {
    /// A builder for [`ReplicationRule`](crate::model::ReplicationRule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destinations:
            std::option::Option<std::vec::Vec<crate::model::ReplicationDestination>>,
    }
    impl Builder {
        pub fn destinations(
            mut self,
            input: impl Into<crate::model::ReplicationDestination>,
        ) -> Self {
            let mut v = self.destinations.unwrap_or_default();
            v.push(input.into());
            self.destinations = Some(v);
            self
        }
        pub fn set_destinations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReplicationDestination>>,
        ) -> Self {
            self.destinations = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationRule`](crate::model::ReplicationRule)
        pub fn build(self) -> crate::model::ReplicationRule {
            crate::model::ReplicationRule {
                destinations: self.destinations,
            }
        }
    }
}
impl ReplicationRule {
    /// Creates a new builder-style object to manufacture [`ReplicationRule`](crate::model::ReplicationRule)
    pub fn builder() -> crate::model::replication_rule::Builder {
        crate::model::replication_rule::Builder::default()
    }
}

/// <p>An array of objects representing the details of a replication destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicationDestination {
    /// <p>A Region to replicate to.</p>
    pub region: std::option::Option<std::string::String>,
    /// <p>The account ID of the destination registry to replicate to.</p>
    pub registry_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplicationDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicationDestination");
        formatter.field("region", &self.region);
        formatter.field("registry_id", &self.registry_id);
        formatter.finish()
    }
}
/// See [`ReplicationDestination`](crate::model::ReplicationDestination)
pub mod replication_destination {
    /// A builder for [`ReplicationDestination`](crate::model::ReplicationDestination)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) registry_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A Region to replicate to.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>The account ID of the destination registry to replicate to.</p>
        pub fn registry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_id = Some(input.into());
            self
        }
        pub fn set_registry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registry_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplicationDestination`](crate::model::ReplicationDestination)
        pub fn build(self) -> crate::model::ReplicationDestination {
            crate::model::ReplicationDestination {
                region: self.region,
                registry_id: self.registry_id,
            }
        }
    }
}
impl ReplicationDestination {
    /// Creates a new builder-style object to manufacture [`ReplicationDestination`](crate::model::ReplicationDestination)
    pub fn builder() -> crate::model::replication_destination::Builder {
        crate::model::replication_destination::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageTagMutability {
    Immutable,
    Mutable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageTagMutability {
    fn from(s: &str) -> Self {
        match s {
            "IMMUTABLE" => ImageTagMutability::Immutable,
            "MUTABLE" => ImageTagMutability::Mutable,
            other => ImageTagMutability::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageTagMutability {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageTagMutability::from(s))
    }
}
impl ImageTagMutability {
    pub fn as_str(&self) -> &str {
        match self {
            ImageTagMutability::Immutable => "IMMUTABLE",
            ImageTagMutability::Mutable => "MUTABLE",
            ImageTagMutability::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ImageTagMutability {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The image scanning configuration for a repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageScanningConfiguration {
    /// <p>The setting that determines whether images are scanned after being pushed to a
    /// repository. If set to <code>true</code>, images will be scanned after being pushed. If
    /// this parameter is not specified, it will default to <code>false</code> and images will
    /// not be scanned unless a scan is manually started with the <a>StartImageScan</a> API.</p>
    pub scan_on_push: bool,
}
impl std::fmt::Debug for ImageScanningConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageScanningConfiguration");
        formatter.field("scan_on_push", &self.scan_on_push);
        formatter.finish()
    }
}
/// See [`ImageScanningConfiguration`](crate::model::ImageScanningConfiguration)
pub mod image_scanning_configuration {
    /// A builder for [`ImageScanningConfiguration`](crate::model::ImageScanningConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) scan_on_push: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The setting that determines whether images are scanned after being pushed to a
        /// repository. If set to <code>true</code>, images will be scanned after being pushed. If
        /// this parameter is not specified, it will default to <code>false</code> and images will
        /// not be scanned unless a scan is manually started with the <a>StartImageScan</a> API.</p>
        pub fn scan_on_push(mut self, input: bool) -> Self {
            self.scan_on_push = Some(input);
            self
        }
        pub fn set_scan_on_push(mut self, input: std::option::Option<bool>) -> Self {
            self.scan_on_push = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageScanningConfiguration`](crate::model::ImageScanningConfiguration)
        pub fn build(self) -> crate::model::ImageScanningConfiguration {
            crate::model::ImageScanningConfiguration {
                scan_on_push: self.scan_on_push.unwrap_or_default(),
            }
        }
    }
}
impl ImageScanningConfiguration {
    /// Creates a new builder-style object to manufacture [`ImageScanningConfiguration`](crate::model::ImageScanningConfiguration)
    pub fn builder() -> crate::model::image_scanning_configuration::Builder {
        crate::model::image_scanning_configuration::Builder::default()
    }
}

/// <p>An object representing an Amazon ECR image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Image {
    /// <p>The AWS account ID associated with the registry containing the image.</p>
    pub registry_id: std::option::Option<std::string::String>,
    /// <p>The name of the repository associated with the image.</p>
    pub repository_name: std::option::Option<std::string::String>,
    /// <p>An object containing the image tag and image digest associated with an image.</p>
    pub image_id: std::option::Option<crate::model::ImageIdentifier>,
    /// <p>The image manifest associated with the image.</p>
    pub image_manifest: std::option::Option<std::string::String>,
    /// <p>The manifest media type of the image.</p>
    pub image_manifest_media_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Image");
        formatter.field("registry_id", &self.registry_id);
        formatter.field("repository_name", &self.repository_name);
        formatter.field("image_id", &self.image_id);
        formatter.field("image_manifest", &self.image_manifest);
        formatter.field("image_manifest_media_type", &self.image_manifest_media_type);
        formatter.finish()
    }
}
/// See [`Image`](crate::model::Image)
pub mod image {
    /// A builder for [`Image`](crate::model::Image)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) registry_id: std::option::Option<std::string::String>,
        pub(crate) repository_name: std::option::Option<std::string::String>,
        pub(crate) image_id: std::option::Option<crate::model::ImageIdentifier>,
        pub(crate) image_manifest: std::option::Option<std::string::String>,
        pub(crate) image_manifest_media_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The AWS account ID associated with the registry containing the image.</p>
        pub fn registry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_id = Some(input.into());
            self
        }
        pub fn set_registry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registry_id = input;
            self
        }
        /// <p>The name of the repository associated with the image.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_name = Some(input.into());
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_name = input;
            self
        }
        /// <p>An object containing the image tag and image digest associated with an image.</p>
        pub fn image_id(mut self, input: crate::model::ImageIdentifier) -> Self {
            self.image_id = Some(input);
            self
        }
        pub fn set_image_id(
            mut self,
            input: std::option::Option<crate::model::ImageIdentifier>,
        ) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The image manifest associated with the image.</p>
        pub fn image_manifest(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_manifest = Some(input.into());
            self
        }
        pub fn set_image_manifest(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_manifest = input;
            self
        }
        /// <p>The manifest media type of the image.</p>
        pub fn image_manifest_media_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_manifest_media_type = Some(input.into());
            self
        }
        pub fn set_image_manifest_media_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_manifest_media_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Image`](crate::model::Image)
        pub fn build(self) -> crate::model::Image {
            crate::model::Image {
                registry_id: self.registry_id,
                repository_name: self.repository_name,
                image_id: self.image_id,
                image_manifest: self.image_manifest,
                image_manifest_media_type: self.image_manifest_media_type,
            }
        }
    }
}
impl Image {
    /// Creates a new builder-style object to manufacture [`Image`](crate::model::Image)
    pub fn builder() -> crate::model::image::Builder {
        crate::model::image::Builder::default()
    }
}

/// <p>An object representing a filter on a <a>ListImages</a> operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListImagesFilter {
    /// <p>The tag status with which to filter your <a>ListImages</a> results. You can
    /// filter results based on whether they are <code>TAGGED</code> or
    /// <code>UNTAGGED</code>.</p>
    pub tag_status: std::option::Option<crate::model::TagStatus>,
}
impl std::fmt::Debug for ListImagesFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListImagesFilter");
        formatter.field("tag_status", &self.tag_status);
        formatter.finish()
    }
}
/// See [`ListImagesFilter`](crate::model::ListImagesFilter)
pub mod list_images_filter {
    /// A builder for [`ListImagesFilter`](crate::model::ListImagesFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_status: std::option::Option<crate::model::TagStatus>,
    }
    impl Builder {
        /// <p>The tag status with which to filter your <a>ListImages</a> results. You can
        /// filter results based on whether they are <code>TAGGED</code> or
        /// <code>UNTAGGED</code>.</p>
        pub fn tag_status(mut self, input: crate::model::TagStatus) -> Self {
            self.tag_status = Some(input);
            self
        }
        pub fn set_tag_status(
            mut self,
            input: std::option::Option<crate::model::TagStatus>,
        ) -> Self {
            self.tag_status = input;
            self
        }
        /// Consumes the builder and constructs a [`ListImagesFilter`](crate::model::ListImagesFilter)
        pub fn build(self) -> crate::model::ListImagesFilter {
            crate::model::ListImagesFilter {
                tag_status: self.tag_status,
            }
        }
    }
}
impl ListImagesFilter {
    /// Creates a new builder-style object to manufacture [`ListImagesFilter`](crate::model::ListImagesFilter)
    pub fn builder() -> crate::model::list_images_filter::Builder {
        crate::model::list_images_filter::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TagStatus {
    Any,
    Tagged,
    Untagged,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TagStatus {
    fn from(s: &str) -> Self {
        match s {
            "ANY" => TagStatus::Any,
            "TAGGED" => TagStatus::Tagged,
            "UNTAGGED" => TagStatus::Untagged,
            other => TagStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TagStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TagStatus::from(s))
    }
}
impl TagStatus {
    pub fn as_str(&self) -> &str {
        match self {
            TagStatus::Any => "ANY",
            TagStatus::Tagged => "TAGGED",
            TagStatus::Untagged => "UNTAGGED",
            TagStatus::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for TagStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The summary of the lifecycle policy preview request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LifecyclePolicyPreviewSummary {
    /// <p>The number of expiring images.</p>
    pub expiring_image_total_count: std::option::Option<i32>,
}
impl std::fmt::Debug for LifecyclePolicyPreviewSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LifecyclePolicyPreviewSummary");
        formatter.field(
            "expiring_image_total_count",
            &self.expiring_image_total_count,
        );
        formatter.finish()
    }
}
/// See [`LifecyclePolicyPreviewSummary`](crate::model::LifecyclePolicyPreviewSummary)
pub mod lifecycle_policy_preview_summary {
    /// A builder for [`LifecyclePolicyPreviewSummary`](crate::model::LifecyclePolicyPreviewSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) expiring_image_total_count: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The number of expiring images.</p>
        pub fn expiring_image_total_count(mut self, input: i32) -> Self {
            self.expiring_image_total_count = Some(input);
            self
        }
        pub fn set_expiring_image_total_count(mut self, input: std::option::Option<i32>) -> Self {
            self.expiring_image_total_count = input;
            self
        }
        /// Consumes the builder and constructs a [`LifecyclePolicyPreviewSummary`](crate::model::LifecyclePolicyPreviewSummary)
        pub fn build(self) -> crate::model::LifecyclePolicyPreviewSummary {
            crate::model::LifecyclePolicyPreviewSummary {
                expiring_image_total_count: self.expiring_image_total_count,
            }
        }
    }
}
impl LifecyclePolicyPreviewSummary {
    /// Creates a new builder-style object to manufacture [`LifecyclePolicyPreviewSummary`](crate::model::LifecyclePolicyPreviewSummary)
    pub fn builder() -> crate::model::lifecycle_policy_preview_summary::Builder {
        crate::model::lifecycle_policy_preview_summary::Builder::default()
    }
}

/// <p>The result of the lifecycle policy preview.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LifecyclePolicyPreviewResult {
    /// <p>The list of tags associated with this image.</p>
    pub image_tags: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The <code>sha256</code> digest of the image manifest.</p>
    pub image_digest: std::option::Option<std::string::String>,
    /// <p>The date and time, expressed in standard JavaScript date format, at which the current
    /// image was pushed to the repository.</p>
    pub image_pushed_at: std::option::Option<smithy_types::Instant>,
    /// <p>The type of action to be taken.</p>
    pub action: std::option::Option<crate::model::LifecyclePolicyRuleAction>,
    /// <p>The priority of the applied rule.</p>
    pub applied_rule_priority: std::option::Option<i32>,
}
impl std::fmt::Debug for LifecyclePolicyPreviewResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LifecyclePolicyPreviewResult");
        formatter.field("image_tags", &self.image_tags);
        formatter.field("image_digest", &self.image_digest);
        formatter.field("image_pushed_at", &self.image_pushed_at);
        formatter.field("action", &self.action);
        formatter.field("applied_rule_priority", &self.applied_rule_priority);
        formatter.finish()
    }
}
/// See [`LifecyclePolicyPreviewResult`](crate::model::LifecyclePolicyPreviewResult)
pub mod lifecycle_policy_preview_result {
    /// A builder for [`LifecyclePolicyPreviewResult`](crate::model::LifecyclePolicyPreviewResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_tags: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) image_digest: std::option::Option<std::string::String>,
        pub(crate) image_pushed_at: std::option::Option<smithy_types::Instant>,
        pub(crate) action: std::option::Option<crate::model::LifecyclePolicyRuleAction>,
        pub(crate) applied_rule_priority: std::option::Option<i32>,
    }
    impl Builder {
        pub fn image_tags(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.image_tags.unwrap_or_default();
            v.push(input.into());
            self.image_tags = Some(v);
            self
        }
        pub fn set_image_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.image_tags = input;
            self
        }
        /// <p>The <code>sha256</code> digest of the image manifest.</p>
        pub fn image_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_digest = Some(input.into());
            self
        }
        pub fn set_image_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_digest = input;
            self
        }
        /// <p>The date and time, expressed in standard JavaScript date format, at which the current
        /// image was pushed to the repository.</p>
        pub fn image_pushed_at(mut self, input: smithy_types::Instant) -> Self {
            self.image_pushed_at = Some(input);
            self
        }
        pub fn set_image_pushed_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.image_pushed_at = input;
            self
        }
        /// <p>The type of action to be taken.</p>
        pub fn action(mut self, input: crate::model::LifecyclePolicyRuleAction) -> Self {
            self.action = Some(input);
            self
        }
        pub fn set_action(
            mut self,
            input: std::option::Option<crate::model::LifecyclePolicyRuleAction>,
        ) -> Self {
            self.action = input;
            self
        }
        /// <p>The priority of the applied rule.</p>
        pub fn applied_rule_priority(mut self, input: i32) -> Self {
            self.applied_rule_priority = Some(input);
            self
        }
        pub fn set_applied_rule_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.applied_rule_priority = input;
            self
        }
        /// Consumes the builder and constructs a [`LifecyclePolicyPreviewResult`](crate::model::LifecyclePolicyPreviewResult)
        pub fn build(self) -> crate::model::LifecyclePolicyPreviewResult {
            crate::model::LifecyclePolicyPreviewResult {
                image_tags: self.image_tags,
                image_digest: self.image_digest,
                image_pushed_at: self.image_pushed_at,
                action: self.action,
                applied_rule_priority: self.applied_rule_priority,
            }
        }
    }
}
impl LifecyclePolicyPreviewResult {
    /// Creates a new builder-style object to manufacture [`LifecyclePolicyPreviewResult`](crate::model::LifecyclePolicyPreviewResult)
    pub fn builder() -> crate::model::lifecycle_policy_preview_result::Builder {
        crate::model::lifecycle_policy_preview_result::Builder::default()
    }
}

/// <p>The type of action to be taken.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LifecyclePolicyRuleAction {
    /// <p>The type of action to be taken.</p>
    pub r#type: std::option::Option<crate::model::ImageActionType>,
}
impl std::fmt::Debug for LifecyclePolicyRuleAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LifecyclePolicyRuleAction");
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`LifecyclePolicyRuleAction`](crate::model::LifecyclePolicyRuleAction)
pub mod lifecycle_policy_rule_action {
    /// A builder for [`LifecyclePolicyRuleAction`](crate::model::LifecyclePolicyRuleAction)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::ImageActionType>,
    }
    impl Builder {
        /// <p>The type of action to be taken.</p>
        pub fn r#type(mut self, input: crate::model::ImageActionType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ImageActionType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`LifecyclePolicyRuleAction`](crate::model::LifecyclePolicyRuleAction)
        pub fn build(self) -> crate::model::LifecyclePolicyRuleAction {
            crate::model::LifecyclePolicyRuleAction {
                r#type: self.r#type,
            }
        }
    }
}
impl LifecyclePolicyRuleAction {
    /// Creates a new builder-style object to manufacture [`LifecyclePolicyRuleAction`](crate::model::LifecyclePolicyRuleAction)
    pub fn builder() -> crate::model::lifecycle_policy_rule_action::Builder {
        crate::model::lifecycle_policy_rule_action::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageActionType {
    Expire,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageActionType {
    fn from(s: &str) -> Self {
        match s {
            "EXPIRE" => ImageActionType::Expire,
            other => ImageActionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageActionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageActionType::from(s))
    }
}
impl ImageActionType {
    pub fn as_str(&self) -> &str {
        match self {
            ImageActionType::Expire => "EXPIRE",
            ImageActionType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ImageActionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The filter for the lifecycle policy preview.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LifecyclePolicyPreviewFilter {
    /// <p>The tag status of the image.</p>
    pub tag_status: std::option::Option<crate::model::TagStatus>,
}
impl std::fmt::Debug for LifecyclePolicyPreviewFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LifecyclePolicyPreviewFilter");
        formatter.field("tag_status", &self.tag_status);
        formatter.finish()
    }
}
/// See [`LifecyclePolicyPreviewFilter`](crate::model::LifecyclePolicyPreviewFilter)
pub mod lifecycle_policy_preview_filter {
    /// A builder for [`LifecyclePolicyPreviewFilter`](crate::model::LifecyclePolicyPreviewFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_status: std::option::Option<crate::model::TagStatus>,
    }
    impl Builder {
        /// <p>The tag status of the image.</p>
        pub fn tag_status(mut self, input: crate::model::TagStatus) -> Self {
            self.tag_status = Some(input);
            self
        }
        pub fn set_tag_status(
            mut self,
            input: std::option::Option<crate::model::TagStatus>,
        ) -> Self {
            self.tag_status = input;
            self
        }
        /// Consumes the builder and constructs a [`LifecyclePolicyPreviewFilter`](crate::model::LifecyclePolicyPreviewFilter)
        pub fn build(self) -> crate::model::LifecyclePolicyPreviewFilter {
            crate::model::LifecyclePolicyPreviewFilter {
                tag_status: self.tag_status,
            }
        }
    }
}
impl LifecyclePolicyPreviewFilter {
    /// Creates a new builder-style object to manufacture [`LifecyclePolicyPreviewFilter`](crate::model::LifecyclePolicyPreviewFilter)
    pub fn builder() -> crate::model::lifecycle_policy_preview_filter::Builder {
        crate::model::lifecycle_policy_preview_filter::Builder::default()
    }
}

/// <p>An object representing authorization data for an Amazon ECR registry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorizationData {
    /// <p>A base64-encoded string that contains authorization data for the specified Amazon ECR
    /// registry. When the string is decoded, it is presented in the format
    /// <code>user:password</code> for private registry authentication using <code>docker
    /// login</code>.</p>
    pub authorization_token: std::option::Option<std::string::String>,
    /// <p>The Unix time in seconds and milliseconds when the authorization token expires.
    /// Authorization tokens are valid for 12 hours.</p>
    pub expires_at: std::option::Option<smithy_types::Instant>,
    /// <p>The registry URL to use for this authorization token in a <code>docker login</code>
    /// command. The Amazon ECR registry URL format is
    /// <code>https://aws_account_id.dkr.ecr.region.amazonaws.com</code>. For example,
    /// <code>https://012345678910.dkr.ecr.us-east-1.amazonaws.com</code>.. </p>
    pub proxy_endpoint: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorizationData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorizationData");
        formatter.field("authorization_token", &self.authorization_token);
        formatter.field("expires_at", &self.expires_at);
        formatter.field("proxy_endpoint", &self.proxy_endpoint);
        formatter.finish()
    }
}
/// See [`AuthorizationData`](crate::model::AuthorizationData)
pub mod authorization_data {
    /// A builder for [`AuthorizationData`](crate::model::AuthorizationData)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) authorization_token: std::option::Option<std::string::String>,
        pub(crate) expires_at: std::option::Option<smithy_types::Instant>,
        pub(crate) proxy_endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A base64-encoded string that contains authorization data for the specified Amazon ECR
        /// registry. When the string is decoded, it is presented in the format
        /// <code>user:password</code> for private registry authentication using <code>docker
        /// login</code>.</p>
        pub fn authorization_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.authorization_token = Some(input.into());
            self
        }
        pub fn set_authorization_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.authorization_token = input;
            self
        }
        /// <p>The Unix time in seconds and milliseconds when the authorization token expires.
        /// Authorization tokens are valid for 12 hours.</p>
        pub fn expires_at(mut self, input: smithy_types::Instant) -> Self {
            self.expires_at = Some(input);
            self
        }
        pub fn set_expires_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expires_at = input;
            self
        }
        /// <p>The registry URL to use for this authorization token in a <code>docker login</code>
        /// command. The Amazon ECR registry URL format is
        /// <code>https://aws_account_id.dkr.ecr.region.amazonaws.com</code>. For example,
        /// <code>https://012345678910.dkr.ecr.us-east-1.amazonaws.com</code>.. </p>
        pub fn proxy_endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.proxy_endpoint = Some(input.into());
            self
        }
        pub fn set_proxy_endpoint(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.proxy_endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorizationData`](crate::model::AuthorizationData)
        pub fn build(self) -> crate::model::AuthorizationData {
            crate::model::AuthorizationData {
                authorization_token: self.authorization_token,
                expires_at: self.expires_at,
                proxy_endpoint: self.proxy_endpoint,
            }
        }
    }
}
impl AuthorizationData {
    /// Creates a new builder-style object to manufacture [`AuthorizationData`](crate::model::AuthorizationData)
    pub fn builder() -> crate::model::authorization_data::Builder {
        crate::model::authorization_data::Builder::default()
    }
}

/// <p>An object representing a repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Repository {
    /// <p>The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the <code>arn:aws:ecr</code> namespace, followed by the region of the
    /// repository, AWS account ID of the repository owner, repository namespace, and repository name.
    /// For example, <code>arn:aws:ecr:region:012345678910:repository/test</code>.</p>
    pub repository_arn: std::option::Option<std::string::String>,
    /// <p>The AWS account ID associated with the registry that contains the repository.</p>
    pub registry_id: std::option::Option<std::string::String>,
    /// <p>The name of the repository.</p>
    pub repository_name: std::option::Option<std::string::String>,
    /// <p>The URI for the repository. You can use this URI for container image <code>push</code>
    /// and <code>pull</code> operations.</p>
    pub repository_uri: std::option::Option<std::string::String>,
    /// <p>The date and time, in JavaScript date format, when the repository was created.</p>
    pub created_at: std::option::Option<smithy_types::Instant>,
    /// <p>The tag mutability setting for the repository.</p>
    pub image_tag_mutability: std::option::Option<crate::model::ImageTagMutability>,
    /// <p>The image scanning configuration for a repository.</p>
    pub image_scanning_configuration: std::option::Option<crate::model::ImageScanningConfiguration>,
    /// <p>The encryption configuration for the repository. This determines how the contents of
    /// your repository are encrypted at rest.</p>
    pub encryption_configuration: std::option::Option<crate::model::EncryptionConfiguration>,
}
impl std::fmt::Debug for Repository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Repository");
        formatter.field("repository_arn", &self.repository_arn);
        formatter.field("registry_id", &self.registry_id);
        formatter.field("repository_name", &self.repository_name);
        formatter.field("repository_uri", &self.repository_uri);
        formatter.field("created_at", &self.created_at);
        formatter.field("image_tag_mutability", &self.image_tag_mutability);
        formatter.field(
            "image_scanning_configuration",
            &self.image_scanning_configuration,
        );
        formatter.field("encryption_configuration", &self.encryption_configuration);
        formatter.finish()
    }
}
/// See [`Repository`](crate::model::Repository)
pub mod repository {
    /// A builder for [`Repository`](crate::model::Repository)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) repository_arn: std::option::Option<std::string::String>,
        pub(crate) registry_id: std::option::Option<std::string::String>,
        pub(crate) repository_name: std::option::Option<std::string::String>,
        pub(crate) repository_uri: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<smithy_types::Instant>,
        pub(crate) image_tag_mutability: std::option::Option<crate::model::ImageTagMutability>,
        pub(crate) image_scanning_configuration:
            std::option::Option<crate::model::ImageScanningConfiguration>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::EncryptionConfiguration>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the <code>arn:aws:ecr</code> namespace, followed by the region of the
        /// repository, AWS account ID of the repository owner, repository namespace, and repository name.
        /// For example, <code>arn:aws:ecr:region:012345678910:repository/test</code>.</p>
        pub fn repository_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_arn = Some(input.into());
            self
        }
        pub fn set_repository_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_arn = input;
            self
        }
        /// <p>The AWS account ID associated with the registry that contains the repository.</p>
        pub fn registry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_id = Some(input.into());
            self
        }
        pub fn set_registry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registry_id = input;
            self
        }
        /// <p>The name of the repository.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_name = Some(input.into());
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_name = input;
            self
        }
        /// <p>The URI for the repository. You can use this URI for container image <code>push</code>
        /// and <code>pull</code> operations.</p>
        pub fn repository_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_uri = Some(input.into());
            self
        }
        pub fn set_repository_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_uri = input;
            self
        }
        /// <p>The date and time, in JavaScript date format, when the repository was created.</p>
        pub fn created_at(mut self, input: smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        pub fn set_created_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The tag mutability setting for the repository.</p>
        pub fn image_tag_mutability(mut self, input: crate::model::ImageTagMutability) -> Self {
            self.image_tag_mutability = Some(input);
            self
        }
        pub fn set_image_tag_mutability(
            mut self,
            input: std::option::Option<crate::model::ImageTagMutability>,
        ) -> Self {
            self.image_tag_mutability = input;
            self
        }
        /// <p>The image scanning configuration for a repository.</p>
        pub fn image_scanning_configuration(
            mut self,
            input: crate::model::ImageScanningConfiguration,
        ) -> Self {
            self.image_scanning_configuration = Some(input);
            self
        }
        pub fn set_image_scanning_configuration(
            mut self,
            input: std::option::Option<crate::model::ImageScanningConfiguration>,
        ) -> Self {
            self.image_scanning_configuration = input;
            self
        }
        /// <p>The encryption configuration for the repository. This determines how the contents of
        /// your repository are encrypted at rest.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::EncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::EncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`Repository`](crate::model::Repository)
        pub fn build(self) -> crate::model::Repository {
            crate::model::Repository {
                repository_arn: self.repository_arn,
                registry_id: self.registry_id,
                repository_name: self.repository_name,
                repository_uri: self.repository_uri,
                created_at: self.created_at,
                image_tag_mutability: self.image_tag_mutability,
                image_scanning_configuration: self.image_scanning_configuration,
                encryption_configuration: self.encryption_configuration,
            }
        }
    }
}
impl Repository {
    /// Creates a new builder-style object to manufacture [`Repository`](crate::model::Repository)
    pub fn builder() -> crate::model::repository::Builder {
        crate::model::repository::Builder::default()
    }
}

/// <p>The encryption configuration for the repository. This determines how the contents of
/// your repository are encrypted at rest.</p>
/// <p>By default, when no encryption configuration is set or the <code>AES256</code>
/// encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption
/// keys which encrypts your data at rest using an AES-256 encryption algorithm. This does
/// not require any action on your part.</p>
/// <p>For more control over the encryption of the contents of your repository, you can use
/// server-side encryption with customer master keys (CMKs) stored in AWS Key Management Service (AWS KMS) to
/// encrypt your images. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html">Amazon ECR encryption at
/// rest</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionConfiguration {
    /// <p>The encryption type to use.</p>
    /// <p>If you use the <code>KMS</code> encryption type, the contents of the repository will
    /// be encrypted using server-side encryption with customer master keys (CMKs) stored in
    /// AWS KMS. When you use AWS KMS to encrypt your data, you can either use the default AWS
    /// managed CMK for Amazon ECR, or specify your own CMK, which you already created. For more
    /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">Protecting Data Using Server-Side
    /// Encryption with CMKs Stored in AWS Key Management Service (SSE-KMS)</a> in the
    /// <i>Amazon Simple Storage Service Console Developer Guide.</i>.</p>
    /// <p>If you use the <code>AES256</code> encryption type, Amazon ECR uses server-side encryption
    /// with Amazon S3-managed encryption keys which encrypts the images in the repository using an
    /// AES-256 encryption algorithm. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html">Protecting Data Using
    /// Server-Side Encryption with Amazon S3-Managed Encryption Keys (SSE-S3)</a> in
    /// the <i>Amazon Simple Storage Service Console Developer Guide.</i>.</p>
    pub encryption_type: std::option::Option<crate::model::EncryptionType>,
    /// <p>If you use the <code>KMS</code> encryption type, specify the CMK to use for
    /// encryption. The alias, key ID, or full ARN of the CMK can be specified. The key must
    /// exist in the same Region as the repository. If no key is specified, the default AWS
    /// managed CMK for Amazon ECR will be used.</p>
    pub kms_key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionConfiguration");
        formatter.field("encryption_type", &self.encryption_type);
        formatter.field("kms_key", &self.kms_key);
        formatter.finish()
    }
}
/// See [`EncryptionConfiguration`](crate::model::EncryptionConfiguration)
pub mod encryption_configuration {
    /// A builder for [`EncryptionConfiguration`](crate::model::EncryptionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) encryption_type: std::option::Option<crate::model::EncryptionType>,
        pub(crate) kms_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The encryption type to use.</p>
        /// <p>If you use the <code>KMS</code> encryption type, the contents of the repository will
        /// be encrypted using server-side encryption with customer master keys (CMKs) stored in
        /// AWS KMS. When you use AWS KMS to encrypt your data, you can either use the default AWS
        /// managed CMK for Amazon ECR, or specify your own CMK, which you already created. For more
        /// information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">Protecting Data Using Server-Side
        /// Encryption with CMKs Stored in AWS Key Management Service (SSE-KMS)</a> in the
        /// <i>Amazon Simple Storage Service Console Developer Guide.</i>.</p>
        /// <p>If you use the <code>AES256</code> encryption type, Amazon ECR uses server-side encryption
        /// with Amazon S3-managed encryption keys which encrypts the images in the repository using an
        /// AES-256 encryption algorithm. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html">Protecting Data Using
        /// Server-Side Encryption with Amazon S3-Managed Encryption Keys (SSE-S3)</a> in
        /// the <i>Amazon Simple Storage Service Console Developer Guide.</i>.</p>
        pub fn encryption_type(mut self, input: crate::model::EncryptionType) -> Self {
            self.encryption_type = Some(input);
            self
        }
        pub fn set_encryption_type(
            mut self,
            input: std::option::Option<crate::model::EncryptionType>,
        ) -> Self {
            self.encryption_type = input;
            self
        }
        /// <p>If you use the <code>KMS</code> encryption type, specify the CMK to use for
        /// encryption. The alias, key ID, or full ARN of the CMK can be specified. The key must
        /// exist in the same Region as the repository. If no key is specified, the default AWS
        /// managed CMK for Amazon ECR will be used.</p>
        pub fn kms_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.kms_key = Some(input.into());
            self
        }
        pub fn set_kms_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kms_key = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionConfiguration`](crate::model::EncryptionConfiguration)
        pub fn build(self) -> crate::model::EncryptionConfiguration {
            crate::model::EncryptionConfiguration {
                encryption_type: self.encryption_type,
                kms_key: self.kms_key,
            }
        }
    }
}
impl EncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`EncryptionConfiguration`](crate::model::EncryptionConfiguration)
    pub fn builder() -> crate::model::encryption_configuration::Builder {
        crate::model::encryption_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EncryptionType {
    Aes256,
    Kms,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EncryptionType {
    fn from(s: &str) -> Self {
        match s {
            "AES256" => EncryptionType::Aes256,
            "KMS" => EncryptionType::Kms,
            other => EncryptionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EncryptionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EncryptionType::from(s))
    }
}
impl EncryptionType {
    pub fn as_str(&self) -> &str {
        match self {
            EncryptionType::Aes256 => "AES256",
            EncryptionType::Kms => "KMS",
            EncryptionType::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for EncryptionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The details of an image scan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageScanFindings {
    /// <p>The time of the last completed image scan.</p>
    pub image_scan_completed_at: std::option::Option<smithy_types::Instant>,
    /// <p>The time when the vulnerability data was last scanned.</p>
    pub vulnerability_source_updated_at: std::option::Option<smithy_types::Instant>,
    /// <p>The findings from the image scan.</p>
    pub findings: std::option::Option<std::vec::Vec<crate::model::ImageScanFinding>>,
    /// <p>The image vulnerability counts, sorted by severity.</p>
    pub finding_severity_counts:
        std::option::Option<std::collections::HashMap<crate::model::FindingSeverity, i32>>,
}
impl std::fmt::Debug for ImageScanFindings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageScanFindings");
        formatter.field("image_scan_completed_at", &self.image_scan_completed_at);
        formatter.field(
            "vulnerability_source_updated_at",
            &self.vulnerability_source_updated_at,
        );
        formatter.field("findings", &self.findings);
        formatter.field("finding_severity_counts", &self.finding_severity_counts);
        formatter.finish()
    }
}
/// See [`ImageScanFindings`](crate::model::ImageScanFindings)
pub mod image_scan_findings {
    /// A builder for [`ImageScanFindings`](crate::model::ImageScanFindings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_scan_completed_at: std::option::Option<smithy_types::Instant>,
        pub(crate) vulnerability_source_updated_at: std::option::Option<smithy_types::Instant>,
        pub(crate) findings: std::option::Option<std::vec::Vec<crate::model::ImageScanFinding>>,
        pub(crate) finding_severity_counts:
            std::option::Option<std::collections::HashMap<crate::model::FindingSeverity, i32>>,
    }
    impl Builder {
        /// <p>The time of the last completed image scan.</p>
        pub fn image_scan_completed_at(mut self, input: smithy_types::Instant) -> Self {
            self.image_scan_completed_at = Some(input);
            self
        }
        pub fn set_image_scan_completed_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.image_scan_completed_at = input;
            self
        }
        /// <p>The time when the vulnerability data was last scanned.</p>
        pub fn vulnerability_source_updated_at(mut self, input: smithy_types::Instant) -> Self {
            self.vulnerability_source_updated_at = Some(input);
            self
        }
        pub fn set_vulnerability_source_updated_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.vulnerability_source_updated_at = input;
            self
        }
        pub fn findings(mut self, input: impl Into<crate::model::ImageScanFinding>) -> Self {
            let mut v = self.findings.unwrap_or_default();
            v.push(input.into());
            self.findings = Some(v);
            self
        }
        pub fn set_findings(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ImageScanFinding>>,
        ) -> Self {
            self.findings = input;
            self
        }
        pub fn finding_severity_counts(
            mut self,
            k: impl Into<crate::model::FindingSeverity>,
            v: impl Into<i32>,
        ) -> Self {
            let mut hash_map = self.finding_severity_counts.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.finding_severity_counts = Some(hash_map);
            self
        }
        pub fn set_finding_severity_counts(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::FindingSeverity, i32>,
            >,
        ) -> Self {
            self.finding_severity_counts = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageScanFindings`](crate::model::ImageScanFindings)
        pub fn build(self) -> crate::model::ImageScanFindings {
            crate::model::ImageScanFindings {
                image_scan_completed_at: self.image_scan_completed_at,
                vulnerability_source_updated_at: self.vulnerability_source_updated_at,
                findings: self.findings,
                finding_severity_counts: self.finding_severity_counts,
            }
        }
    }
}
impl ImageScanFindings {
    /// Creates a new builder-style object to manufacture [`ImageScanFindings`](crate::model::ImageScanFindings)
    pub fn builder() -> crate::model::image_scan_findings::Builder {
        crate::model::image_scan_findings::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FindingSeverity {
    Critical,
    High,
    Informational,
    Low,
    Medium,
    Undefined,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FindingSeverity {
    fn from(s: &str) -> Self {
        match s {
            "CRITICAL" => FindingSeverity::Critical,
            "HIGH" => FindingSeverity::High,
            "INFORMATIONAL" => FindingSeverity::Informational,
            "LOW" => FindingSeverity::Low,
            "MEDIUM" => FindingSeverity::Medium,
            "UNDEFINED" => FindingSeverity::Undefined,
            other => FindingSeverity::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FindingSeverity {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FindingSeverity::from(s))
    }
}
impl FindingSeverity {
    pub fn as_str(&self) -> &str {
        match self {
            FindingSeverity::Critical => "CRITICAL",
            FindingSeverity::High => "HIGH",
            FindingSeverity::Informational => "INFORMATIONAL",
            FindingSeverity::Low => "LOW",
            FindingSeverity::Medium => "MEDIUM",
            FindingSeverity::Undefined => "UNDEFINED",
            FindingSeverity::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for FindingSeverity {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Contains information about an image scan finding.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageScanFinding {
    /// <p>The name associated with the finding, usually a CVE number.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the finding.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A link containing additional details about the security vulnerability.</p>
    pub uri: std::option::Option<std::string::String>,
    /// <p>The finding severity.</p>
    pub severity: std::option::Option<crate::model::FindingSeverity>,
    /// <p>A collection of attributes of the host from which the finding is generated.</p>
    pub attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
}
impl std::fmt::Debug for ImageScanFinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageScanFinding");
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("uri", &self.uri);
        formatter.field("severity", &self.severity);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}
/// See [`ImageScanFinding`](crate::model::ImageScanFinding)
pub mod image_scan_finding {
    /// A builder for [`ImageScanFinding`](crate::model::ImageScanFinding)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) uri: std::option::Option<std::string::String>,
        pub(crate) severity: std::option::Option<crate::model::FindingSeverity>,
        pub(crate) attributes: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
    }
    impl Builder {
        /// <p>The name associated with the finding, usually a CVE number.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the finding.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A link containing additional details about the security vulnerability.</p>
        pub fn uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.uri = Some(input.into());
            self
        }
        pub fn set_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.uri = input;
            self
        }
        /// <p>The finding severity.</p>
        pub fn severity(mut self, input: crate::model::FindingSeverity) -> Self {
            self.severity = Some(input);
            self
        }
        pub fn set_severity(
            mut self,
            input: std::option::Option<crate::model::FindingSeverity>,
        ) -> Self {
            self.severity = input;
            self
        }
        pub fn attributes(mut self, input: impl Into<crate::model::Attribute>) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input.into());
            self.attributes = Some(v);
            self
        }
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Attribute>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageScanFinding`](crate::model::ImageScanFinding)
        pub fn build(self) -> crate::model::ImageScanFinding {
            crate::model::ImageScanFinding {
                name: self.name,
                description: self.description,
                uri: self.uri,
                severity: self.severity,
                attributes: self.attributes,
            }
        }
    }
}
impl ImageScanFinding {
    /// Creates a new builder-style object to manufacture [`ImageScanFinding`](crate::model::ImageScanFinding)
    pub fn builder() -> crate::model::image_scan_finding::Builder {
        crate::model::image_scan_finding::Builder::default()
    }
}

/// <p>This data type is used in the <a>ImageScanFinding</a> data type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Attribute {
    /// <p>The attribute key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The value assigned to the attribute key.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Attribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Attribute");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`Attribute`](crate::model::Attribute)
pub mod attribute {
    /// A builder for [`Attribute`](crate::model::Attribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The attribute key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value assigned to the attribute key.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Attribute`](crate::model::Attribute)
        pub fn build(self) -> crate::model::Attribute {
            crate::model::Attribute {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Attribute {
    /// Creates a new builder-style object to manufacture [`Attribute`](crate::model::Attribute)
    pub fn builder() -> crate::model::attribute::Builder {
        crate::model::attribute::Builder::default()
    }
}

/// <p>An object that describes an image returned by a <a>DescribeImages</a>
/// operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageDetail {
    /// <p>The AWS account ID associated with the registry to which this image belongs.</p>
    pub registry_id: std::option::Option<std::string::String>,
    /// <p>The name of the repository to which this image belongs.</p>
    pub repository_name: std::option::Option<std::string::String>,
    /// <p>The <code>sha256</code> digest of the image manifest.</p>
    pub image_digest: std::option::Option<std::string::String>,
    /// <p>The list of tags associated with this image.</p>
    pub image_tags: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The size, in bytes, of the image in the repository.</p>
    /// <p>If the image is a manifest list, this will be the max size of all manifests in the
    /// list.</p>
    /// <note>
    /// <p>Beginning with Docker version 1.9, the Docker client compresses image layers
    /// before pushing them to a V2 Docker registry. The output of the <code>docker
    /// images</code> command shows the uncompressed image size, so it may return a
    /// larger image size than the image sizes returned by <a>DescribeImages</a>.</p>
    /// </note>
    pub image_size_in_bytes: std::option::Option<i64>,
    /// <p>The date and time, expressed in standard JavaScript date format, at which the current
    /// image was pushed to the repository. </p>
    pub image_pushed_at: std::option::Option<smithy_types::Instant>,
    /// <p>The current state of the scan.</p>
    pub image_scan_status: std::option::Option<crate::model::ImageScanStatus>,
    /// <p>A summary of the last completed image scan.</p>
    pub image_scan_findings_summary: std::option::Option<crate::model::ImageScanFindingsSummary>,
    /// <p>The media type of the image manifest.</p>
    pub image_manifest_media_type: std::option::Option<std::string::String>,
    /// <p>The artifact media type of the image.</p>
    pub artifact_media_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImageDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageDetail");
        formatter.field("registry_id", &self.registry_id);
        formatter.field("repository_name", &self.repository_name);
        formatter.field("image_digest", &self.image_digest);
        formatter.field("image_tags", &self.image_tags);
        formatter.field("image_size_in_bytes", &self.image_size_in_bytes);
        formatter.field("image_pushed_at", &self.image_pushed_at);
        formatter.field("image_scan_status", &self.image_scan_status);
        formatter.field(
            "image_scan_findings_summary",
            &self.image_scan_findings_summary,
        );
        formatter.field("image_manifest_media_type", &self.image_manifest_media_type);
        formatter.field("artifact_media_type", &self.artifact_media_type);
        formatter.finish()
    }
}
/// See [`ImageDetail`](crate::model::ImageDetail)
pub mod image_detail {
    /// A builder for [`ImageDetail`](crate::model::ImageDetail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) registry_id: std::option::Option<std::string::String>,
        pub(crate) repository_name: std::option::Option<std::string::String>,
        pub(crate) image_digest: std::option::Option<std::string::String>,
        pub(crate) image_tags: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) image_size_in_bytes: std::option::Option<i64>,
        pub(crate) image_pushed_at: std::option::Option<smithy_types::Instant>,
        pub(crate) image_scan_status: std::option::Option<crate::model::ImageScanStatus>,
        pub(crate) image_scan_findings_summary:
            std::option::Option<crate::model::ImageScanFindingsSummary>,
        pub(crate) image_manifest_media_type: std::option::Option<std::string::String>,
        pub(crate) artifact_media_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The AWS account ID associated with the registry to which this image belongs.</p>
        pub fn registry_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.registry_id = Some(input.into());
            self
        }
        pub fn set_registry_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.registry_id = input;
            self
        }
        /// <p>The name of the repository to which this image belongs.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.repository_name = Some(input.into());
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.repository_name = input;
            self
        }
        /// <p>The <code>sha256</code> digest of the image manifest.</p>
        pub fn image_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_digest = Some(input.into());
            self
        }
        pub fn set_image_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_digest = input;
            self
        }
        pub fn image_tags(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.image_tags.unwrap_or_default();
            v.push(input.into());
            self.image_tags = Some(v);
            self
        }
        pub fn set_image_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.image_tags = input;
            self
        }
        /// <p>The size, in bytes, of the image in the repository.</p>
        /// <p>If the image is a manifest list, this will be the max size of all manifests in the
        /// list.</p>
        /// <note>
        /// <p>Beginning with Docker version 1.9, the Docker client compresses image layers
        /// before pushing them to a V2 Docker registry. The output of the <code>docker
        /// images</code> command shows the uncompressed image size, so it may return a
        /// larger image size than the image sizes returned by <a>DescribeImages</a>.</p>
        /// </note>
        pub fn image_size_in_bytes(mut self, input: i64) -> Self {
            self.image_size_in_bytes = Some(input);
            self
        }
        pub fn set_image_size_in_bytes(mut self, input: std::option::Option<i64>) -> Self {
            self.image_size_in_bytes = input;
            self
        }
        /// <p>The date and time, expressed in standard JavaScript date format, at which the current
        /// image was pushed to the repository. </p>
        pub fn image_pushed_at(mut self, input: smithy_types::Instant) -> Self {
            self.image_pushed_at = Some(input);
            self
        }
        pub fn set_image_pushed_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.image_pushed_at = input;
            self
        }
        /// <p>The current state of the scan.</p>
        pub fn image_scan_status(mut self, input: crate::model::ImageScanStatus) -> Self {
            self.image_scan_status = Some(input);
            self
        }
        pub fn set_image_scan_status(
            mut self,
            input: std::option::Option<crate::model::ImageScanStatus>,
        ) -> Self {
            self.image_scan_status = input;
            self
        }
        /// <p>A summary of the last completed image scan.</p>
        pub fn image_scan_findings_summary(
            mut self,
            input: crate::model::ImageScanFindingsSummary,
        ) -> Self {
            self.image_scan_findings_summary = Some(input);
            self
        }
        pub fn set_image_scan_findings_summary(
            mut self,
            input: std::option::Option<crate::model::ImageScanFindingsSummary>,
        ) -> Self {
            self.image_scan_findings_summary = input;
            self
        }
        /// <p>The media type of the image manifest.</p>
        pub fn image_manifest_media_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_manifest_media_type = Some(input.into());
            self
        }
        pub fn set_image_manifest_media_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_manifest_media_type = input;
            self
        }
        /// <p>The artifact media type of the image.</p>
        pub fn artifact_media_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.artifact_media_type = Some(input.into());
            self
        }
        pub fn set_artifact_media_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.artifact_media_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageDetail`](crate::model::ImageDetail)
        pub fn build(self) -> crate::model::ImageDetail {
            crate::model::ImageDetail {
                registry_id: self.registry_id,
                repository_name: self.repository_name,
                image_digest: self.image_digest,
                image_tags: self.image_tags,
                image_size_in_bytes: self.image_size_in_bytes,
                image_pushed_at: self.image_pushed_at,
                image_scan_status: self.image_scan_status,
                image_scan_findings_summary: self.image_scan_findings_summary,
                image_manifest_media_type: self.image_manifest_media_type,
                artifact_media_type: self.artifact_media_type,
            }
        }
    }
}
impl ImageDetail {
    /// Creates a new builder-style object to manufacture [`ImageDetail`](crate::model::ImageDetail)
    pub fn builder() -> crate::model::image_detail::Builder {
        crate::model::image_detail::Builder::default()
    }
}

/// <p>A summary of the last completed image scan.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageScanFindingsSummary {
    /// <p>The time of the last completed image scan.</p>
    pub image_scan_completed_at: std::option::Option<smithy_types::Instant>,
    /// <p>The time when the vulnerability data was last scanned.</p>
    pub vulnerability_source_updated_at: std::option::Option<smithy_types::Instant>,
    /// <p>The image vulnerability counts, sorted by severity.</p>
    pub finding_severity_counts:
        std::option::Option<std::collections::HashMap<crate::model::FindingSeverity, i32>>,
}
impl std::fmt::Debug for ImageScanFindingsSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageScanFindingsSummary");
        formatter.field("image_scan_completed_at", &self.image_scan_completed_at);
        formatter.field(
            "vulnerability_source_updated_at",
            &self.vulnerability_source_updated_at,
        );
        formatter.field("finding_severity_counts", &self.finding_severity_counts);
        formatter.finish()
    }
}
/// See [`ImageScanFindingsSummary`](crate::model::ImageScanFindingsSummary)
pub mod image_scan_findings_summary {
    /// A builder for [`ImageScanFindingsSummary`](crate::model::ImageScanFindingsSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_scan_completed_at: std::option::Option<smithy_types::Instant>,
        pub(crate) vulnerability_source_updated_at: std::option::Option<smithy_types::Instant>,
        pub(crate) finding_severity_counts:
            std::option::Option<std::collections::HashMap<crate::model::FindingSeverity, i32>>,
    }
    impl Builder {
        /// <p>The time of the last completed image scan.</p>
        pub fn image_scan_completed_at(mut self, input: smithy_types::Instant) -> Self {
            self.image_scan_completed_at = Some(input);
            self
        }
        pub fn set_image_scan_completed_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.image_scan_completed_at = input;
            self
        }
        /// <p>The time when the vulnerability data was last scanned.</p>
        pub fn vulnerability_source_updated_at(mut self, input: smithy_types::Instant) -> Self {
            self.vulnerability_source_updated_at = Some(input);
            self
        }
        pub fn set_vulnerability_source_updated_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.vulnerability_source_updated_at = input;
            self
        }
        pub fn finding_severity_counts(
            mut self,
            k: impl Into<crate::model::FindingSeverity>,
            v: impl Into<i32>,
        ) -> Self {
            let mut hash_map = self.finding_severity_counts.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.finding_severity_counts = Some(hash_map);
            self
        }
        pub fn set_finding_severity_counts(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<crate::model::FindingSeverity, i32>,
            >,
        ) -> Self {
            self.finding_severity_counts = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageScanFindingsSummary`](crate::model::ImageScanFindingsSummary)
        pub fn build(self) -> crate::model::ImageScanFindingsSummary {
            crate::model::ImageScanFindingsSummary {
                image_scan_completed_at: self.image_scan_completed_at,
                vulnerability_source_updated_at: self.vulnerability_source_updated_at,
                finding_severity_counts: self.finding_severity_counts,
            }
        }
    }
}
impl ImageScanFindingsSummary {
    /// Creates a new builder-style object to manufacture [`ImageScanFindingsSummary`](crate::model::ImageScanFindingsSummary)
    pub fn builder() -> crate::model::image_scan_findings_summary::Builder {
        crate::model::image_scan_findings_summary::Builder::default()
    }
}

/// <p>An object representing a filter on a <a>DescribeImages</a>
/// operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeImagesFilter {
    /// <p>The tag status with which to filter your <a>DescribeImages</a> results. You
    /// can filter results based on whether they are <code>TAGGED</code> or
    /// <code>UNTAGGED</code>.</p>
    pub tag_status: std::option::Option<crate::model::TagStatus>,
}
impl std::fmt::Debug for DescribeImagesFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeImagesFilter");
        formatter.field("tag_status", &self.tag_status);
        formatter.finish()
    }
}
/// See [`DescribeImagesFilter`](crate::model::DescribeImagesFilter)
pub mod describe_images_filter {
    /// A builder for [`DescribeImagesFilter`](crate::model::DescribeImagesFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tag_status: std::option::Option<crate::model::TagStatus>,
    }
    impl Builder {
        /// <p>The tag status with which to filter your <a>DescribeImages</a> results. You
        /// can filter results based on whether they are <code>TAGGED</code> or
        /// <code>UNTAGGED</code>.</p>
        pub fn tag_status(mut self, input: crate::model::TagStatus) -> Self {
            self.tag_status = Some(input);
            self
        }
        pub fn set_tag_status(
            mut self,
            input: std::option::Option<crate::model::TagStatus>,
        ) -> Self {
            self.tag_status = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeImagesFilter`](crate::model::DescribeImagesFilter)
        pub fn build(self) -> crate::model::DescribeImagesFilter {
            crate::model::DescribeImagesFilter {
                tag_status: self.tag_status,
            }
        }
    }
}
impl DescribeImagesFilter {
    /// Creates a new builder-style object to manufacture [`DescribeImagesFilter`](crate::model::DescribeImagesFilter)
    pub fn builder() -> crate::model::describe_images_filter::Builder {
        crate::model::describe_images_filter::Builder::default()
    }
}

/// <p>An object representing an Amazon ECR image failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImageFailure {
    /// <p>The image ID associated with the failure.</p>
    pub image_id: std::option::Option<crate::model::ImageIdentifier>,
    /// <p>The code associated with the failure.</p>
    pub failure_code: std::option::Option<crate::model::ImageFailureCode>,
    /// <p>The reason for the failure.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImageFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImageFailure");
        formatter.field("image_id", &self.image_id);
        formatter.field("failure_code", &self.failure_code);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`ImageFailure`](crate::model::ImageFailure)
pub mod image_failure {
    /// A builder for [`ImageFailure`](crate::model::ImageFailure)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_id: std::option::Option<crate::model::ImageIdentifier>,
        pub(crate) failure_code: std::option::Option<crate::model::ImageFailureCode>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The image ID associated with the failure.</p>
        pub fn image_id(mut self, input: crate::model::ImageIdentifier) -> Self {
            self.image_id = Some(input);
            self
        }
        pub fn set_image_id(
            mut self,
            input: std::option::Option<crate::model::ImageIdentifier>,
        ) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The code associated with the failure.</p>
        pub fn failure_code(mut self, input: crate::model::ImageFailureCode) -> Self {
            self.failure_code = Some(input);
            self
        }
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::ImageFailureCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// <p>The reason for the failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageFailure`](crate::model::ImageFailure)
        pub fn build(self) -> crate::model::ImageFailure {
            crate::model::ImageFailure {
                image_id: self.image_id,
                failure_code: self.failure_code,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl ImageFailure {
    /// Creates a new builder-style object to manufacture [`ImageFailure`](crate::model::ImageFailure)
    pub fn builder() -> crate::model::image_failure::Builder {
        crate::model::image_failure::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageFailureCode {
    ImageNotFound,
    ImageReferencedByManifestList,
    ImageTagDoesNotMatchDigest,
    InvalidImageDigest,
    InvalidImageTag,
    KmsError,
    MissingDigestAndTag,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ImageFailureCode {
    fn from(s: &str) -> Self {
        match s {
            "ImageNotFound" => ImageFailureCode::ImageNotFound,
            "ImageReferencedByManifestList" => ImageFailureCode::ImageReferencedByManifestList,
            "ImageTagDoesNotMatchDigest" => ImageFailureCode::ImageTagDoesNotMatchDigest,
            "InvalidImageDigest" => ImageFailureCode::InvalidImageDigest,
            "InvalidImageTag" => ImageFailureCode::InvalidImageTag,
            "KmsError" => ImageFailureCode::KmsError,
            "MissingDigestAndTag" => ImageFailureCode::MissingDigestAndTag,
            other => ImageFailureCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ImageFailureCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageFailureCode::from(s))
    }
}
impl ImageFailureCode {
    pub fn as_str(&self) -> &str {
        match self {
            ImageFailureCode::ImageNotFound => "ImageNotFound",
            ImageFailureCode::ImageReferencedByManifestList => "ImageReferencedByManifestList",
            ImageFailureCode::ImageTagDoesNotMatchDigest => "ImageTagDoesNotMatchDigest",
            ImageFailureCode::InvalidImageDigest => "InvalidImageDigest",
            ImageFailureCode::InvalidImageTag => "InvalidImageTag",
            ImageFailureCode::KmsError => "KmsError",
            ImageFailureCode::MissingDigestAndTag => "MissingDigestAndTag",
            ImageFailureCode::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for ImageFailureCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object representing an Amazon ECR image layer failure.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LayerFailure {
    /// <p>The layer digest associated with the failure.</p>
    pub layer_digest: std::option::Option<std::string::String>,
    /// <p>The failure code associated with the failure.</p>
    pub failure_code: std::option::Option<crate::model::LayerFailureCode>,
    /// <p>The reason for the failure.</p>
    pub failure_reason: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LayerFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LayerFailure");
        formatter.field("layer_digest", &self.layer_digest);
        formatter.field("failure_code", &self.failure_code);
        formatter.field("failure_reason", &self.failure_reason);
        formatter.finish()
    }
}
/// See [`LayerFailure`](crate::model::LayerFailure)
pub mod layer_failure {
    /// A builder for [`LayerFailure`](crate::model::LayerFailure)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) layer_digest: std::option::Option<std::string::String>,
        pub(crate) failure_code: std::option::Option<crate::model::LayerFailureCode>,
        pub(crate) failure_reason: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The layer digest associated with the failure.</p>
        pub fn layer_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.layer_digest = Some(input.into());
            self
        }
        pub fn set_layer_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.layer_digest = input;
            self
        }
        /// <p>The failure code associated with the failure.</p>
        pub fn failure_code(mut self, input: crate::model::LayerFailureCode) -> Self {
            self.failure_code = Some(input);
            self
        }
        pub fn set_failure_code(
            mut self,
            input: std::option::Option<crate::model::LayerFailureCode>,
        ) -> Self {
            self.failure_code = input;
            self
        }
        /// <p>The reason for the failure.</p>
        pub fn failure_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.failure_reason = Some(input.into());
            self
        }
        pub fn set_failure_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.failure_reason = input;
            self
        }
        /// Consumes the builder and constructs a [`LayerFailure`](crate::model::LayerFailure)
        pub fn build(self) -> crate::model::LayerFailure {
            crate::model::LayerFailure {
                layer_digest: self.layer_digest,
                failure_code: self.failure_code,
                failure_reason: self.failure_reason,
            }
        }
    }
}
impl LayerFailure {
    /// Creates a new builder-style object to manufacture [`LayerFailure`](crate::model::LayerFailure)
    pub fn builder() -> crate::model::layer_failure::Builder {
        crate::model::layer_failure::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LayerFailureCode {
    InvalidLayerDigest,
    MissingLayerDigest,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LayerFailureCode {
    fn from(s: &str) -> Self {
        match s {
            "InvalidLayerDigest" => LayerFailureCode::InvalidLayerDigest,
            "MissingLayerDigest" => LayerFailureCode::MissingLayerDigest,
            other => LayerFailureCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LayerFailureCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LayerFailureCode::from(s))
    }
}
impl LayerFailureCode {
    pub fn as_str(&self) -> &str {
        match self {
            LayerFailureCode::InvalidLayerDigest => "InvalidLayerDigest",
            LayerFailureCode::MissingLayerDigest => "MissingLayerDigest",
            LayerFailureCode::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for LayerFailureCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object representing an Amazon ECR image layer.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Layer {
    /// <p>The <code>sha256</code> digest of the image layer.</p>
    pub layer_digest: std::option::Option<std::string::String>,
    /// <p>The availability status of the image layer.</p>
    pub layer_availability: std::option::Option<crate::model::LayerAvailability>,
    /// <p>The size, in bytes, of the image layer.</p>
    pub layer_size: std::option::Option<i64>,
    /// <p>The media type of the layer, such as
    /// <code>application/vnd.docker.image.rootfs.diff.tar.gzip</code> or
    /// <code>application/vnd.oci.image.layer.v1.tar+gzip</code>.</p>
    pub media_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Layer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Layer");
        formatter.field("layer_digest", &self.layer_digest);
        formatter.field("layer_availability", &self.layer_availability);
        formatter.field("layer_size", &self.layer_size);
        formatter.field("media_type", &self.media_type);
        formatter.finish()
    }
}
/// See [`Layer`](crate::model::Layer)
pub mod layer {
    /// A builder for [`Layer`](crate::model::Layer)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) layer_digest: std::option::Option<std::string::String>,
        pub(crate) layer_availability: std::option::Option<crate::model::LayerAvailability>,
        pub(crate) layer_size: std::option::Option<i64>,
        pub(crate) media_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <code>sha256</code> digest of the image layer.</p>
        pub fn layer_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.layer_digest = Some(input.into());
            self
        }
        pub fn set_layer_digest(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.layer_digest = input;
            self
        }
        /// <p>The availability status of the image layer.</p>
        pub fn layer_availability(mut self, input: crate::model::LayerAvailability) -> Self {
            self.layer_availability = Some(input);
            self
        }
        pub fn set_layer_availability(
            mut self,
            input: std::option::Option<crate::model::LayerAvailability>,
        ) -> Self {
            self.layer_availability = input;
            self
        }
        /// <p>The size, in bytes, of the image layer.</p>
        pub fn layer_size(mut self, input: i64) -> Self {
            self.layer_size = Some(input);
            self
        }
        pub fn set_layer_size(mut self, input: std::option::Option<i64>) -> Self {
            self.layer_size = input;
            self
        }
        /// <p>The media type of the layer, such as
        /// <code>application/vnd.docker.image.rootfs.diff.tar.gzip</code> or
        /// <code>application/vnd.oci.image.layer.v1.tar+gzip</code>.</p>
        pub fn media_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_type = Some(input.into());
            self
        }
        pub fn set_media_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.media_type = input;
            self
        }
        /// Consumes the builder and constructs a [`Layer`](crate::model::Layer)
        pub fn build(self) -> crate::model::Layer {
            crate::model::Layer {
                layer_digest: self.layer_digest,
                layer_availability: self.layer_availability,
                layer_size: self.layer_size,
                media_type: self.media_type,
            }
        }
    }
}
impl Layer {
    /// Creates a new builder-style object to manufacture [`Layer`](crate::model::Layer)
    pub fn builder() -> crate::model::layer::Builder {
        crate::model::layer::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LayerAvailability {
    Available,
    Unavailable,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LayerAvailability {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => LayerAvailability::Available,
            "UNAVAILABLE" => LayerAvailability::Unavailable,
            other => LayerAvailability::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LayerAvailability {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LayerAvailability::from(s))
    }
}
impl LayerAvailability {
    pub fn as_str(&self) -> &str {
        match self {
            LayerAvailability::Available => "AVAILABLE",
            LayerAvailability::Unavailable => "UNAVAILABLE",
            LayerAvailability::Unknown(s) => s.as_ref(),
        }
    }
}
impl AsRef<str> for LayerAvailability {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
