// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateAppError {
    pub kind: CreateAppErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateAppErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateAppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateAppErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateAppErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateAppError {
    fn code(&self) -> Option<&str> {
        CreateAppError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateAppError {
    pub fn new(kind: CreateAppErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateAppErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateAppErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateAppErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::MethodNotAllowedException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::PayloadTooLargeException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, CreateAppErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for CreateAppError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateAppErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateAppErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateAppErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateAppErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreateAppErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateAppErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            CreateAppErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateAppErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCampaignError {
    pub kind: CreateCampaignErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCampaignErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCampaignError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCampaignErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateCampaignErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateCampaignErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateCampaignErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreateCampaignErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateCampaignErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            CreateCampaignErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateCampaignErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCampaignError {
    fn code(&self) -> Option<&str> {
        CreateCampaignError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCampaignError {
    pub fn new(kind: CreateCampaignErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCampaignErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCampaignErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateCampaignErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateCampaignErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCampaignErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCampaignErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateCampaignErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCampaignErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCampaignErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateCampaignError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCampaignErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateCampaignErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateCampaignErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateCampaignErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreateCampaignErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateCampaignErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            CreateCampaignErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateCampaignErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEmailTemplateError {
    pub kind: CreateEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEmailTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEmailTemplateError {
    fn code(&self) -> Option<&str> {
        CreateEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateEmailTemplateError {
    pub fn new(kind: CreateEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEmailTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateExportJobError {
    pub kind: CreateExportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateExportJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateExportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateExportJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateExportJobErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateExportJobErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateExportJobErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreateExportJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateExportJobErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            CreateExportJobErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateExportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateExportJobError {
    fn code(&self) -> Option<&str> {
        CreateExportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateExportJobError {
    pub fn new(kind: CreateExportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateExportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateExportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateExportJobErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateExportJobErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportJobErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportJobErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateExportJobErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportJobErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateExportJobErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateExportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateExportJobErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateExportJobErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateExportJobErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateExportJobErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreateExportJobErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateExportJobErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            CreateExportJobErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateExportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateImportJobError {
    pub kind: CreateImportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateImportJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateImportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateImportJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateImportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateImportJobError {
    fn code(&self) -> Option<&str> {
        CreateImportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateImportJobError {
    pub fn new(kind: CreateImportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateImportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateImportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateImportJobErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateImportJobErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateImportJobErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateImportJobErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateImportJobErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateImportJobErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateImportJobErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateImportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateImportJobErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateImportJobErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateImportJobErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateImportJobErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreateImportJobErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateImportJobErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            CreateImportJobErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateImportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInAppTemplateError {
    pub kind: CreateInAppTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInAppTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInAppTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInAppTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateInAppTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateInAppTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateInAppTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreateInAppTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateInAppTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInAppTemplateError {
    fn code(&self) -> Option<&str> {
        CreateInAppTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInAppTemplateError {
    pub fn new(kind: CreateInAppTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInAppTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInAppTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInAppTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInAppTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInAppTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInAppTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInAppTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateInAppTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInAppTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateInAppTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateInAppTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateInAppTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreateInAppTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateInAppTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateJourneyError {
    pub kind: CreateJourneyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateJourneyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateJourneyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateJourneyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateJourneyErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateJourneyErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateJourneyErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreateJourneyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateJourneyErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            CreateJourneyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateJourneyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateJourneyError {
    fn code(&self) -> Option<&str> {
        CreateJourneyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateJourneyError {
    pub fn new(kind: CreateJourneyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateJourneyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateJourneyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateJourneyErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateJourneyErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJourneyErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJourneyErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateJourneyErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJourneyErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateJourneyErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateJourneyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateJourneyErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateJourneyErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateJourneyErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateJourneyErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreateJourneyErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateJourneyErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            CreateJourneyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateJourneyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePushTemplateError {
    pub kind: CreatePushTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePushTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePushTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePushTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreatePushTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreatePushTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreatePushTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreatePushTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreatePushTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePushTemplateError {
    fn code(&self) -> Option<&str> {
        CreatePushTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePushTemplateError {
    pub fn new(kind: CreatePushTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePushTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePushTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePushTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePushTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePushTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePushTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePushTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreatePushTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePushTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            CreatePushTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreatePushTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreatePushTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreatePushTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreatePushTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRecommenderConfigurationError {
    pub kind: CreateRecommenderConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRecommenderConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRecommenderConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRecommenderConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateRecommenderConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateRecommenderConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            CreateRecommenderConfigurationErrorKind::MethodNotAllowedException(_inner) => {
                _inner.fmt(f)
            }
            CreateRecommenderConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateRecommenderConfigurationErrorKind::PayloadTooLargeException(_inner) => {
                _inner.fmt(f)
            }
            CreateRecommenderConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            CreateRecommenderConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRecommenderConfigurationError {
    fn code(&self) -> Option<&str> {
        CreateRecommenderConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRecommenderConfigurationError {
    pub fn new(kind: CreateRecommenderConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRecommenderConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRecommenderConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommenderConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommenderConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommenderConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommenderConfigurationErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommenderConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommenderConfigurationErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRecommenderConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateRecommenderConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRecommenderConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateRecommenderConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateRecommenderConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            CreateRecommenderConfigurationErrorKind::MethodNotAllowedException(_inner) => {
                Some(_inner)
            }
            CreateRecommenderConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateRecommenderConfigurationErrorKind::PayloadTooLargeException(_inner) => {
                Some(_inner)
            }
            CreateRecommenderConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            CreateRecommenderConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSegmentError {
    pub kind: CreateSegmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSegmentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSegmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSegmentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateSegmentErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateSegmentErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateSegmentErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreateSegmentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            CreateSegmentErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            CreateSegmentErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateSegmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSegmentError {
    fn code(&self) -> Option<&str> {
        CreateSegmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSegmentError {
    pub fn new(kind: CreateSegmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSegmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSegmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, CreateSegmentErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, CreateSegmentErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSegmentErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSegmentErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, CreateSegmentErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSegmentErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSegmentErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateSegmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSegmentErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateSegmentErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateSegmentErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateSegmentErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreateSegmentErrorKind::NotFoundException(_inner) => Some(_inner),
            CreateSegmentErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            CreateSegmentErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateSegmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSmsTemplateError {
    pub kind: CreateSmsTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSmsTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSmsTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSmsTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateSmsTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateSmsTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateSmsTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreateSmsTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateSmsTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSmsTemplateError {
    fn code(&self) -> Option<&str> {
        CreateSmsTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSmsTemplateError {
    pub fn new(kind: CreateSmsTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSmsTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSmsTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSmsTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSmsTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSmsTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSmsTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateSmsTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateSmsTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSmsTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateSmsTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateSmsTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateSmsTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreateSmsTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateSmsTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateVoiceTemplateError {
    pub kind: CreateVoiceTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateVoiceTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateVoiceTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateVoiceTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            CreateVoiceTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            CreateVoiceTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            CreateVoiceTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            CreateVoiceTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            CreateVoiceTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateVoiceTemplateError {
    fn code(&self) -> Option<&str> {
        CreateVoiceTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateVoiceTemplateError {
    pub fn new(kind: CreateVoiceTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateVoiceTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateVoiceTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateVoiceTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for CreateVoiceTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateVoiceTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            CreateVoiceTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            CreateVoiceTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            CreateVoiceTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            CreateVoiceTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            CreateVoiceTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAdmChannelError {
    pub kind: DeleteAdmChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAdmChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAdmChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAdmChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAdmChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteAdmChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteAdmChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteAdmChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteAdmChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteAdmChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteAdmChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAdmChannelError {
    fn code(&self) -> Option<&str> {
        DeleteAdmChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAdmChannelError {
    pub fn new(kind: DeleteAdmChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAdmChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAdmChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAdmChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteAdmChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAdmChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAdmChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteAdmChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAdmChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAdmChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteAdmChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAdmChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAdmChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteAdmChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteAdmChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteAdmChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteAdmChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteAdmChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteAdmChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApnsChannelError {
    pub kind: DeleteApnsChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApnsChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApnsChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApnsChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteApnsChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteApnsChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteApnsChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteApnsChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteApnsChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteApnsChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteApnsChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteApnsChannelError {
    fn code(&self) -> Option<&str> {
        DeleteApnsChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApnsChannelError {
    pub fn new(kind: DeleteApnsChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApnsChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApnsChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteApnsChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteApnsChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApnsChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteApnsChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteApnsChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteApnsChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteApnsChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteApnsChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteApnsChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteApnsChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApnsSandboxChannelError {
    pub kind: DeleteApnsSandboxChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApnsSandboxChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApnsSandboxChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApnsSandboxChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteApnsSandboxChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteApnsSandboxChannelErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DeleteApnsSandboxChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteApnsSandboxChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteApnsSandboxChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteApnsSandboxChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteApnsSandboxChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteApnsSandboxChannelError {
    fn code(&self) -> Option<&str> {
        DeleteApnsSandboxChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApnsSandboxChannelError {
    pub fn new(kind: DeleteApnsSandboxChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApnsSandboxChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApnsSandboxChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsSandboxChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsSandboxChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsSandboxChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsSandboxChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsSandboxChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsSandboxChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsSandboxChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteApnsSandboxChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApnsSandboxChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteApnsSandboxChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteApnsSandboxChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteApnsSandboxChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteApnsSandboxChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteApnsSandboxChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteApnsSandboxChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteApnsSandboxChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApnsVoipChannelError {
    pub kind: DeleteApnsVoipChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApnsVoipChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApnsVoipChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApnsVoipChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteApnsVoipChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteApnsVoipChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteApnsVoipChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteApnsVoipChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteApnsVoipChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteApnsVoipChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteApnsVoipChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteApnsVoipChannelError {
    fn code(&self) -> Option<&str> {
        DeleteApnsVoipChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApnsVoipChannelError {
    pub fn new(kind: DeleteApnsVoipChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApnsVoipChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApnsVoipChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteApnsVoipChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApnsVoipChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteApnsVoipChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteApnsVoipChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteApnsVoipChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteApnsVoipChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteApnsVoipChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteApnsVoipChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteApnsVoipChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApnsVoipSandboxChannelError {
    pub kind: DeleteApnsVoipSandboxChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApnsVoipSandboxChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApnsVoipSandboxChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApnsVoipSandboxChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteApnsVoipSandboxChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteApnsVoipSandboxChannelErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DeleteApnsVoipSandboxChannelErrorKind::MethodNotAllowedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteApnsVoipSandboxChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteApnsVoipSandboxChannelErrorKind::PayloadTooLargeException(_inner) => {
                _inner.fmt(f)
            }
            DeleteApnsVoipSandboxChannelErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DeleteApnsVoipSandboxChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteApnsVoipSandboxChannelError {
    fn code(&self) -> Option<&str> {
        DeleteApnsVoipSandboxChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApnsVoipSandboxChannelError {
    pub fn new(kind: DeleteApnsVoipSandboxChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApnsVoipSandboxChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApnsVoipSandboxChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipSandboxChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipSandboxChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipSandboxChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipSandboxChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipSandboxChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipSandboxChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApnsVoipSandboxChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteApnsVoipSandboxChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApnsVoipSandboxChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteApnsVoipSandboxChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteApnsVoipSandboxChannelErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DeleteApnsVoipSandboxChannelErrorKind::MethodNotAllowedException(_inner) => {
                Some(_inner)
            }
            DeleteApnsVoipSandboxChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteApnsVoipSandboxChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteApnsVoipSandboxChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteApnsVoipSandboxChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteAppError {
    pub kind: DeleteAppErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteAppErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteAppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteAppErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteAppErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteAppError {
    fn code(&self) -> Option<&str> {
        DeleteAppError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteAppError {
    pub fn new(kind: DeleteAppErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteAppErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteAppErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteAppErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::MethodNotAllowedException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::PayloadTooLargeException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, DeleteAppErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for DeleteAppError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteAppErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteAppErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteAppErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteAppErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteAppErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteAppErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteAppErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteAppErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBaiduChannelError {
    pub kind: DeleteBaiduChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBaiduChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBaiduChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBaiduChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteBaiduChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteBaiduChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteBaiduChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteBaiduChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteBaiduChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteBaiduChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteBaiduChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBaiduChannelError {
    fn code(&self) -> Option<&str> {
        DeleteBaiduChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBaiduChannelError {
    pub fn new(kind: DeleteBaiduChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBaiduChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBaiduChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBaiduChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBaiduChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBaiduChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBaiduChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBaiduChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBaiduChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBaiduChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteBaiduChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBaiduChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteBaiduChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteBaiduChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteBaiduChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteBaiduChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteBaiduChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteBaiduChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteBaiduChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCampaignError {
    pub kind: DeleteCampaignErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCampaignErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCampaignError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCampaignErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteCampaignErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteCampaignErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteCampaignErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteCampaignErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteCampaignErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteCampaignErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteCampaignErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCampaignError {
    fn code(&self) -> Option<&str> {
        DeleteCampaignError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCampaignError {
    pub fn new(kind: DeleteCampaignErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCampaignErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCampaignErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteCampaignErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteCampaignErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCampaignErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCampaignErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteCampaignErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCampaignErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCampaignErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteCampaignError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCampaignErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteCampaignErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteCampaignErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteCampaignErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteCampaignErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteCampaignErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteCampaignErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteCampaignErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEmailChannelError {
    pub kind: DeleteEmailChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEmailChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEmailChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEmailChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteEmailChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteEmailChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteEmailChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteEmailChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteEmailChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteEmailChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteEmailChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEmailChannelError {
    fn code(&self) -> Option<&str> {
        DeleteEmailChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEmailChannelError {
    pub fn new(kind: DeleteEmailChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEmailChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEmailChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteEmailChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEmailChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteEmailChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteEmailChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteEmailChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteEmailChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteEmailChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteEmailChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteEmailChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEmailTemplateError {
    pub kind: DeleteEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEmailTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEmailTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEmailTemplateError {
    pub fn new(kind: DeleteEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEmailTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEndpointError {
    pub kind: DeleteEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEndpointErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEndpointErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteEndpointErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteEndpointErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteEndpointErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteEndpointErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteEndpointErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteEndpointErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEndpointError {
    fn code(&self) -> Option<&str> {
        DeleteEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEndpointError {
    pub fn new(kind: DeleteEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteEndpointErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteEndpointErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEndpointErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEndpointErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteEndpointErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEndpointErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEndpointErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEndpointErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteEndpointErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteEndpointErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteEndpointErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteEndpointErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteEndpointErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteEndpointErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEventStreamError {
    pub kind: DeleteEventStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEventStreamErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEventStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEventStreamErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteEventStreamErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteEventStreamErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteEventStreamErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteEventStreamErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteEventStreamErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteEventStreamErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteEventStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEventStreamError {
    fn code(&self) -> Option<&str> {
        DeleteEventStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteEventStreamError {
    pub fn new(kind: DeleteEventStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEventStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEventStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventStreamErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventStreamErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventStreamErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventStreamErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteEventStreamErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventStreamErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEventStreamErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteEventStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEventStreamErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteEventStreamErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteEventStreamErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteEventStreamErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteEventStreamErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteEventStreamErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteEventStreamErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteEventStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteGcmChannelError {
    pub kind: DeleteGcmChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGcmChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteGcmChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteGcmChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteGcmChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteGcmChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteGcmChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteGcmChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteGcmChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteGcmChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteGcmChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteGcmChannelError {
    fn code(&self) -> Option<&str> {
        DeleteGcmChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGcmChannelError {
    pub fn new(kind: DeleteGcmChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteGcmChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteGcmChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGcmChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteGcmChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGcmChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGcmChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteGcmChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGcmChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteGcmChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteGcmChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteGcmChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteGcmChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteGcmChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteGcmChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteGcmChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteGcmChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteGcmChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteGcmChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInAppTemplateError {
    pub kind: DeleteInAppTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInAppTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInAppTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInAppTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteInAppTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteInAppTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteInAppTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteInAppTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteInAppTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteInAppTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteInAppTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInAppTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteInAppTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInAppTemplateError {
    pub fn new(kind: DeleteInAppTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInAppTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInAppTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInAppTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInAppTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInAppTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInAppTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInAppTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInAppTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInAppTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteInAppTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInAppTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteInAppTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteInAppTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteInAppTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteInAppTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteInAppTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteInAppTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteInAppTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteJourneyError {
    pub kind: DeleteJourneyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteJourneyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteJourneyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteJourneyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteJourneyErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteJourneyErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteJourneyErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteJourneyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteJourneyErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteJourneyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteJourneyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteJourneyError {
    fn code(&self) -> Option<&str> {
        DeleteJourneyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteJourneyError {
    pub fn new(kind: DeleteJourneyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteJourneyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteJourneyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteJourneyErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteJourneyErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJourneyErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJourneyErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteJourneyErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJourneyErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteJourneyErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteJourneyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteJourneyErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteJourneyErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteJourneyErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteJourneyErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteJourneyErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteJourneyErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteJourneyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteJourneyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePushTemplateError {
    pub kind: DeletePushTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePushTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePushTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePushTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeletePushTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeletePushTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeletePushTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeletePushTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeletePushTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeletePushTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeletePushTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePushTemplateError {
    fn code(&self) -> Option<&str> {
        DeletePushTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePushTemplateError {
    pub fn new(kind: DeletePushTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePushTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePushTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePushTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePushTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePushTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePushTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePushTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePushTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePushTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeletePushTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePushTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            DeletePushTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeletePushTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeletePushTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeletePushTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            DeletePushTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeletePushTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeletePushTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRecommenderConfigurationError {
    pub kind: DeleteRecommenderConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRecommenderConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRecommenderConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRecommenderConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteRecommenderConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteRecommenderConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRecommenderConfigurationErrorKind::MethodNotAllowedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRecommenderConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteRecommenderConfigurationErrorKind::PayloadTooLargeException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRecommenderConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRecommenderConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRecommenderConfigurationError {
    fn code(&self) -> Option<&str> {
        DeleteRecommenderConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRecommenderConfigurationError {
    pub fn new(kind: DeleteRecommenderConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRecommenderConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRecommenderConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommenderConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommenderConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommenderConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommenderConfigurationErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommenderConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommenderConfigurationErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRecommenderConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteRecommenderConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRecommenderConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteRecommenderConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteRecommenderConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            DeleteRecommenderConfigurationErrorKind::MethodNotAllowedException(_inner) => {
                Some(_inner)
            }
            DeleteRecommenderConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteRecommenderConfigurationErrorKind::PayloadTooLargeException(_inner) => {
                Some(_inner)
            }
            DeleteRecommenderConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            DeleteRecommenderConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSegmentError {
    pub kind: DeleteSegmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSegmentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSegmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSegmentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteSegmentErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteSegmentErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteSegmentErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteSegmentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteSegmentErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteSegmentErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteSegmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSegmentError {
    fn code(&self) -> Option<&str> {
        DeleteSegmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSegmentError {
    pub fn new(kind: DeleteSegmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSegmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSegmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, DeleteSegmentErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteSegmentErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSegmentErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSegmentErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteSegmentErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSegmentErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSegmentErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteSegmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSegmentErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteSegmentErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteSegmentErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteSegmentErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteSegmentErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteSegmentErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteSegmentErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteSegmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSmsChannelError {
    pub kind: DeleteSmsChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSmsChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSmsChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSmsChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteSmsChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteSmsChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteSmsChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteSmsChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteSmsChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteSmsChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteSmsChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSmsChannelError {
    fn code(&self) -> Option<&str> {
        DeleteSmsChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSmsChannelError {
    pub fn new(kind: DeleteSmsChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSmsChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSmsChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, DeleteSmsChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteSmsChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteSmsChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSmsChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteSmsChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteSmsChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteSmsChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteSmsChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteSmsChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteSmsChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteSmsChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSmsTemplateError {
    pub kind: DeleteSmsTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSmsTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSmsTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSmsTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteSmsTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteSmsTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteSmsTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteSmsTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteSmsTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteSmsTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteSmsTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSmsTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteSmsTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSmsTemplateError {
    pub fn new(kind: DeleteSmsTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSmsTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSmsTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, DeleteSmsTemplateErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteSmsTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteSmsTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSmsTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteSmsTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteSmsTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteSmsTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteSmsTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteSmsTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteSmsTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteSmsTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteUserEndpointsError {
    pub kind: DeleteUserEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteUserEndpointsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteUserEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteUserEndpointsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteUserEndpointsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteUserEndpointsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteUserEndpointsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteUserEndpointsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteUserEndpointsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteUserEndpointsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteUserEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteUserEndpointsError {
    fn code(&self) -> Option<&str> {
        DeleteUserEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteUserEndpointsError {
    pub fn new(kind: DeleteUserEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteUserEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteUserEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserEndpointsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserEndpointsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserEndpointsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserEndpointsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserEndpointsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserEndpointsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteUserEndpointsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteUserEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteUserEndpointsErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteUserEndpointsErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteUserEndpointsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteUserEndpointsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteUserEndpointsErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteUserEndpointsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteUserEndpointsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteUserEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceChannelError {
    pub kind: DeleteVoiceChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVoiceChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteVoiceChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteVoiceChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteVoiceChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteVoiceChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVoiceChannelError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceChannelError {
    pub fn new(kind: DeleteVoiceChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteVoiceChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteVoiceChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteVoiceChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteVoiceChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVoiceTemplateError {
    pub kind: DeleteVoiceTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVoiceTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVoiceTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVoiceTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            DeleteVoiceTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            DeleteVoiceTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            DeleteVoiceTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            DeleteVoiceTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            DeleteVoiceTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            DeleteVoiceTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            DeleteVoiceTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVoiceTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteVoiceTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVoiceTemplateError {
    pub fn new(kind: DeleteVoiceTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVoiceTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVoiceTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVoiceTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for DeleteVoiceTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVoiceTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            DeleteVoiceTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            DeleteVoiceTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            DeleteVoiceTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            DeleteVoiceTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            DeleteVoiceTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            DeleteVoiceTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            DeleteVoiceTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAdmChannelError {
    pub kind: GetAdmChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAdmChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAdmChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAdmChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAdmChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetAdmChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetAdmChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetAdmChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAdmChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetAdmChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetAdmChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAdmChannelError {
    fn code(&self) -> Option<&str> {
        GetAdmChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAdmChannelError {
    pub fn new(kind: GetAdmChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAdmChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAdmChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetAdmChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetAdmChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAdmChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAdmChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAdmChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAdmChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAdmChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetAdmChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAdmChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAdmChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetAdmChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetAdmChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetAdmChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAdmChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetAdmChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetAdmChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApnsChannelError {
    pub kind: GetApnsChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApnsChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApnsChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApnsChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetApnsChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetApnsChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetApnsChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetApnsChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetApnsChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetApnsChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetApnsChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApnsChannelError {
    fn code(&self) -> Option<&str> {
        GetApnsChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApnsChannelError {
    pub fn new(kind: GetApnsChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApnsChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApnsChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetApnsChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetApnsChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetApnsChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetApnsChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApnsChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetApnsChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetApnsChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetApnsChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetApnsChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetApnsChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetApnsChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetApnsChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApnsSandboxChannelError {
    pub kind: GetApnsSandboxChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApnsSandboxChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApnsSandboxChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApnsSandboxChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetApnsSandboxChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetApnsSandboxChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetApnsSandboxChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetApnsSandboxChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetApnsSandboxChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetApnsSandboxChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetApnsSandboxChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApnsSandboxChannelError {
    fn code(&self) -> Option<&str> {
        GetApnsSandboxChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApnsSandboxChannelError {
    pub fn new(kind: GetApnsSandboxChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApnsSandboxChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApnsSandboxChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsSandboxChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsSandboxChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsSandboxChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsSandboxChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsSandboxChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsSandboxChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsSandboxChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetApnsSandboxChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApnsSandboxChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetApnsSandboxChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetApnsSandboxChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetApnsSandboxChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetApnsSandboxChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetApnsSandboxChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetApnsSandboxChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetApnsSandboxChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApnsVoipChannelError {
    pub kind: GetApnsVoipChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApnsVoipChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApnsVoipChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApnsVoipChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetApnsVoipChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetApnsVoipChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetApnsVoipChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetApnsVoipChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetApnsVoipChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetApnsVoipChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetApnsVoipChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApnsVoipChannelError {
    fn code(&self) -> Option<&str> {
        GetApnsVoipChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApnsVoipChannelError {
    pub fn new(kind: GetApnsVoipChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApnsVoipChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApnsVoipChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetApnsVoipChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApnsVoipChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetApnsVoipChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetApnsVoipChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetApnsVoipChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetApnsVoipChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetApnsVoipChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetApnsVoipChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetApnsVoipChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApnsVoipSandboxChannelError {
    pub kind: GetApnsVoipSandboxChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApnsVoipSandboxChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApnsVoipSandboxChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApnsVoipSandboxChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetApnsVoipSandboxChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetApnsVoipSandboxChannelErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetApnsVoipSandboxChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetApnsVoipSandboxChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetApnsVoipSandboxChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetApnsVoipSandboxChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetApnsVoipSandboxChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApnsVoipSandboxChannelError {
    fn code(&self) -> Option<&str> {
        GetApnsVoipSandboxChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApnsVoipSandboxChannelError {
    pub fn new(kind: GetApnsVoipSandboxChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApnsVoipSandboxChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApnsVoipSandboxChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipSandboxChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipSandboxChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipSandboxChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipSandboxChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipSandboxChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipSandboxChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApnsVoipSandboxChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetApnsVoipSandboxChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApnsVoipSandboxChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetApnsVoipSandboxChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetApnsVoipSandboxChannelErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            GetApnsVoipSandboxChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetApnsVoipSandboxChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetApnsVoipSandboxChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetApnsVoipSandboxChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetApnsVoipSandboxChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAppError {
    pub kind: GetAppErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAppErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAppError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAppErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAppErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetAppErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetAppErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetAppErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAppErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetAppErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetAppErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAppError {
    fn code(&self) -> Option<&str> {
        GetAppError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAppError {
    pub fn new(kind: GetAppErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAppErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAppErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetAppErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetAppErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(&self.kind, GetAppErrorKind::InternalServerErrorException(_))
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(&self.kind, GetAppErrorKind::MethodNotAllowedException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAppErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(&self.kind, GetAppErrorKind::PayloadTooLargeException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetAppErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetAppError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAppErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAppErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetAppErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetAppErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetAppErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAppErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetAppErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetAppErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApplicationDateRangeKpiError {
    pub kind: GetApplicationDateRangeKpiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApplicationDateRangeKpiErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApplicationDateRangeKpiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApplicationDateRangeKpiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetApplicationDateRangeKpiErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetApplicationDateRangeKpiErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetApplicationDateRangeKpiErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetApplicationDateRangeKpiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetApplicationDateRangeKpiErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetApplicationDateRangeKpiErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetApplicationDateRangeKpiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApplicationDateRangeKpiError {
    fn code(&self) -> Option<&str> {
        GetApplicationDateRangeKpiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApplicationDateRangeKpiError {
    pub fn new(kind: GetApplicationDateRangeKpiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApplicationDateRangeKpiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApplicationDateRangeKpiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationDateRangeKpiErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationDateRangeKpiErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationDateRangeKpiErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationDateRangeKpiErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationDateRangeKpiErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationDateRangeKpiErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationDateRangeKpiErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetApplicationDateRangeKpiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApplicationDateRangeKpiErrorKind::BadRequestException(_inner) => Some(_inner),
            GetApplicationDateRangeKpiErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetApplicationDateRangeKpiErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            GetApplicationDateRangeKpiErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetApplicationDateRangeKpiErrorKind::NotFoundException(_inner) => Some(_inner),
            GetApplicationDateRangeKpiErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetApplicationDateRangeKpiErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetApplicationDateRangeKpiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApplicationSettingsError {
    pub kind: GetApplicationSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApplicationSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApplicationSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApplicationSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetApplicationSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetApplicationSettingsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetApplicationSettingsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetApplicationSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetApplicationSettingsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetApplicationSettingsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetApplicationSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApplicationSettingsError {
    fn code(&self) -> Option<&str> {
        GetApplicationSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApplicationSettingsError {
    pub fn new(kind: GetApplicationSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApplicationSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApplicationSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationSettingsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationSettingsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationSettingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationSettingsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApplicationSettingsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetApplicationSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApplicationSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetApplicationSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetApplicationSettingsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetApplicationSettingsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetApplicationSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetApplicationSettingsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetApplicationSettingsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetApplicationSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAppsError {
    pub kind: GetAppsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAppsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAppsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAppsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetAppsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetAppsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetAppsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetAppsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetAppsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetAppsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetAppsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAppsError {
    fn code(&self) -> Option<&str> {
        GetAppsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetAppsError {
    pub fn new(kind: GetAppsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAppsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAppsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetAppsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetAppsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAppsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(&self.kind, GetAppsErrorKind::MethodNotAllowedException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetAppsErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(&self.kind, GetAppsErrorKind::PayloadTooLargeException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetAppsErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetAppsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAppsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetAppsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetAppsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetAppsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetAppsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetAppsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetAppsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetAppsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBaiduChannelError {
    pub kind: GetBaiduChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBaiduChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBaiduChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBaiduChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetBaiduChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetBaiduChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetBaiduChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetBaiduChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetBaiduChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetBaiduChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetBaiduChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBaiduChannelError {
    fn code(&self) -> Option<&str> {
        GetBaiduChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBaiduChannelError {
    pub fn new(kind: GetBaiduChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBaiduChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBaiduChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetBaiduChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetBaiduChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBaiduChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBaiduChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetBaiduChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBaiduChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBaiduChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetBaiduChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBaiduChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetBaiduChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetBaiduChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetBaiduChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetBaiduChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetBaiduChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetBaiduChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetBaiduChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCampaignError {
    pub kind: GetCampaignErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCampaignErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCampaignError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCampaignErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetCampaignErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetCampaignErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetCampaignErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetCampaignErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCampaignErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetCampaignErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetCampaignErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCampaignError {
    fn code(&self) -> Option<&str> {
        GetCampaignError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCampaignError {
    pub fn new(kind: GetCampaignErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCampaignErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCampaignErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetCampaignErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetCampaignErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetCampaignErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetCampaignError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCampaignErrorKind::BadRequestException(_inner) => Some(_inner),
            GetCampaignErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetCampaignErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetCampaignErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetCampaignErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCampaignErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetCampaignErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetCampaignErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCampaignActivitiesError {
    pub kind: GetCampaignActivitiesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCampaignActivitiesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCampaignActivitiesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCampaignActivitiesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetCampaignActivitiesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetCampaignActivitiesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetCampaignActivitiesErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetCampaignActivitiesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCampaignActivitiesErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetCampaignActivitiesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetCampaignActivitiesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCampaignActivitiesError {
    fn code(&self) -> Option<&str> {
        GetCampaignActivitiesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCampaignActivitiesError {
    pub fn new(kind: GetCampaignActivitiesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCampaignActivitiesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCampaignActivitiesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignActivitiesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignActivitiesErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignActivitiesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignActivitiesErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignActivitiesErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignActivitiesErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignActivitiesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetCampaignActivitiesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCampaignActivitiesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetCampaignActivitiesErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetCampaignActivitiesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetCampaignActivitiesErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetCampaignActivitiesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCampaignActivitiesErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetCampaignActivitiesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetCampaignActivitiesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCampaignDateRangeKpiError {
    pub kind: GetCampaignDateRangeKpiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCampaignDateRangeKpiErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCampaignDateRangeKpiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCampaignDateRangeKpiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetCampaignDateRangeKpiErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetCampaignDateRangeKpiErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetCampaignDateRangeKpiErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetCampaignDateRangeKpiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCampaignDateRangeKpiErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetCampaignDateRangeKpiErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetCampaignDateRangeKpiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCampaignDateRangeKpiError {
    fn code(&self) -> Option<&str> {
        GetCampaignDateRangeKpiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCampaignDateRangeKpiError {
    pub fn new(kind: GetCampaignDateRangeKpiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCampaignDateRangeKpiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCampaignDateRangeKpiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignDateRangeKpiErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignDateRangeKpiErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignDateRangeKpiErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignDateRangeKpiErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignDateRangeKpiErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignDateRangeKpiErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignDateRangeKpiErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetCampaignDateRangeKpiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCampaignDateRangeKpiErrorKind::BadRequestException(_inner) => Some(_inner),
            GetCampaignDateRangeKpiErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetCampaignDateRangeKpiErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetCampaignDateRangeKpiErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetCampaignDateRangeKpiErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCampaignDateRangeKpiErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetCampaignDateRangeKpiErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetCampaignDateRangeKpiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCampaignsError {
    pub kind: GetCampaignsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCampaignsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCampaignsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCampaignsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetCampaignsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetCampaignsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetCampaignsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetCampaignsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCampaignsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetCampaignsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetCampaignsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCampaignsError {
    fn code(&self) -> Option<&str> {
        GetCampaignsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCampaignsError {
    pub fn new(kind: GetCampaignsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCampaignsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCampaignsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetCampaignsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetCampaignsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetCampaignsErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetCampaignsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCampaignsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetCampaignsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetCampaignsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetCampaignsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetCampaignsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCampaignsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetCampaignsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetCampaignsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCampaignVersionError {
    pub kind: GetCampaignVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCampaignVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCampaignVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCampaignVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetCampaignVersionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetCampaignVersionErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetCampaignVersionErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetCampaignVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCampaignVersionErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetCampaignVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetCampaignVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCampaignVersionError {
    fn code(&self) -> Option<&str> {
        GetCampaignVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCampaignVersionError {
    pub fn new(kind: GetCampaignVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCampaignVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCampaignVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetCampaignVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCampaignVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            GetCampaignVersionErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetCampaignVersionErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetCampaignVersionErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetCampaignVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCampaignVersionErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetCampaignVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetCampaignVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCampaignVersionsError {
    pub kind: GetCampaignVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCampaignVersionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCampaignVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCampaignVersionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetCampaignVersionsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetCampaignVersionsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetCampaignVersionsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetCampaignVersionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetCampaignVersionsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetCampaignVersionsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetCampaignVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCampaignVersionsError {
    fn code(&self) -> Option<&str> {
        GetCampaignVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCampaignVersionsError {
    pub fn new(kind: GetCampaignVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCampaignVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCampaignVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCampaignVersionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetCampaignVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCampaignVersionsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetCampaignVersionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetCampaignVersionsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetCampaignVersionsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetCampaignVersionsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetCampaignVersionsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetCampaignVersionsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetCampaignVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetChannelsError {
    pub kind: GetChannelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetChannelsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetChannelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetChannelsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetChannelsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetChannelsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetChannelsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetChannelsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetChannelsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetChannelsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetChannelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetChannelsError {
    fn code(&self) -> Option<&str> {
        GetChannelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetChannelsError {
    pub fn new(kind: GetChannelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetChannelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetChannelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetChannelsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetChannelsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetChannelsErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetChannelsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetChannelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetChannelsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetChannelsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetChannelsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetChannelsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetChannelsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetChannelsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetChannelsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetChannelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEmailChannelError {
    pub kind: GetEmailChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEmailChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEmailChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEmailChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetEmailChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetEmailChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetEmailChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetEmailChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetEmailChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetEmailChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetEmailChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEmailChannelError {
    fn code(&self) -> Option<&str> {
        GetEmailChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEmailChannelError {
    pub fn new(kind: GetEmailChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEmailChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEmailChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetEmailChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetEmailChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetEmailChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetEmailChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEmailChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetEmailChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetEmailChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetEmailChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetEmailChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetEmailChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetEmailChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetEmailChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEmailTemplateError {
    pub kind: GetEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEmailTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEmailTemplateError {
    fn code(&self) -> Option<&str> {
        GetEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEmailTemplateError {
    pub fn new(kind: GetEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetEmailTemplateErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetEmailTemplateErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEmailTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEndpointError {
    pub kind: GetEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEndpointErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEndpointErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetEndpointErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetEndpointErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetEndpointErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetEndpointErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetEndpointErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetEndpointErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEndpointError {
    fn code(&self) -> Option<&str> {
        GetEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEndpointError {
    pub fn new(kind: GetEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetEndpointErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetEndpointErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEndpointErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEndpointErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetEndpointErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEndpointErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEndpointErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEndpointErrorKind::BadRequestException(_inner) => Some(_inner),
            GetEndpointErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetEndpointErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetEndpointErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetEndpointErrorKind::NotFoundException(_inner) => Some(_inner),
            GetEndpointErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetEndpointErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEventStreamError {
    pub kind: GetEventStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEventStreamErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEventStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEventStreamErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetEventStreamErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetEventStreamErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetEventStreamErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetEventStreamErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetEventStreamErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetEventStreamErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetEventStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEventStreamError {
    fn code(&self) -> Option<&str> {
        GetEventStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetEventStreamError {
    pub fn new(kind: GetEventStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEventStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEventStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetEventStreamErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetEventStreamErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventStreamErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventStreamErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetEventStreamErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventStreamErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEventStreamErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetEventStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEventStreamErrorKind::BadRequestException(_inner) => Some(_inner),
            GetEventStreamErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetEventStreamErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetEventStreamErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetEventStreamErrorKind::NotFoundException(_inner) => Some(_inner),
            GetEventStreamErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetEventStreamErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetEventStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetExportJobError {
    pub kind: GetExportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetExportJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetExportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetExportJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetExportJobErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetExportJobErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetExportJobErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetExportJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetExportJobErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetExportJobErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetExportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetExportJobError {
    fn code(&self) -> Option<&str> {
        GetExportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetExportJobError {
    pub fn new(kind: GetExportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetExportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetExportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetExportJobErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetExportJobErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportJobErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportJobErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetExportJobErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportJobErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportJobErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetExportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetExportJobErrorKind::BadRequestException(_inner) => Some(_inner),
            GetExportJobErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetExportJobErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetExportJobErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetExportJobErrorKind::NotFoundException(_inner) => Some(_inner),
            GetExportJobErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetExportJobErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetExportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetExportJobsError {
    pub kind: GetExportJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetExportJobsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetExportJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetExportJobsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetExportJobsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetExportJobsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetExportJobsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetExportJobsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetExportJobsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetExportJobsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetExportJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetExportJobsError {
    fn code(&self) -> Option<&str> {
        GetExportJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetExportJobsError {
    pub fn new(kind: GetExportJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetExportJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetExportJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetExportJobsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetExportJobsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportJobsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportJobsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetExportJobsErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportJobsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetExportJobsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetExportJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetExportJobsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetExportJobsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetExportJobsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetExportJobsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetExportJobsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetExportJobsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetExportJobsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetExportJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetGcmChannelError {
    pub kind: GetGcmChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetGcmChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetGcmChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetGcmChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetGcmChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetGcmChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetGcmChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetGcmChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetGcmChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetGcmChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetGcmChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetGcmChannelError {
    fn code(&self) -> Option<&str> {
        GetGcmChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetGcmChannelError {
    pub fn new(kind: GetGcmChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetGcmChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetGcmChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetGcmChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetGcmChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGcmChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGcmChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetGcmChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGcmChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetGcmChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetGcmChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetGcmChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetGcmChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetGcmChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetGcmChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetGcmChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetGcmChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetGcmChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetGcmChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetImportJobError {
    pub kind: GetImportJobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetImportJobErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetImportJobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetImportJobErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetImportJobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetImportJobError {
    fn code(&self) -> Option<&str> {
        GetImportJobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetImportJobError {
    pub fn new(kind: GetImportJobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetImportJobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetImportJobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetImportJobErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetImportJobErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetImportJobErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetImportJobErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetImportJobErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetImportJobErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetImportJobErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetImportJobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetImportJobErrorKind::BadRequestException(_inner) => Some(_inner),
            GetImportJobErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetImportJobErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetImportJobErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetImportJobErrorKind::NotFoundException(_inner) => Some(_inner),
            GetImportJobErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetImportJobErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetImportJobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetImportJobsError {
    pub kind: GetImportJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetImportJobsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetImportJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetImportJobsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetImportJobsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetImportJobsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetImportJobsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetImportJobsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetImportJobsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetImportJobsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetImportJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetImportJobsError {
    fn code(&self) -> Option<&str> {
        GetImportJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetImportJobsError {
    pub fn new(kind: GetImportJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetImportJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetImportJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetImportJobsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetImportJobsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetImportJobsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetImportJobsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetImportJobsErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetImportJobsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetImportJobsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetImportJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetImportJobsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetImportJobsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetImportJobsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetImportJobsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetImportJobsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetImportJobsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetImportJobsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetImportJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInAppMessagesError {
    pub kind: GetInAppMessagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInAppMessagesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInAppMessagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInAppMessagesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetInAppMessagesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetInAppMessagesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetInAppMessagesErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetInAppMessagesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInAppMessagesErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetInAppMessagesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetInAppMessagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInAppMessagesError {
    fn code(&self) -> Option<&str> {
        GetInAppMessagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInAppMessagesError {
    pub fn new(kind: GetInAppMessagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInAppMessagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInAppMessagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInAppMessagesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetInAppMessagesErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInAppMessagesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInAppMessagesErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetInAppMessagesErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInAppMessagesErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInAppMessagesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetInAppMessagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInAppMessagesErrorKind::BadRequestException(_inner) => Some(_inner),
            GetInAppMessagesErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetInAppMessagesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetInAppMessagesErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetInAppMessagesErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInAppMessagesErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetInAppMessagesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetInAppMessagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetInAppTemplateError {
    pub kind: GetInAppTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetInAppTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetInAppTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetInAppTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetInAppTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetInAppTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetInAppTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetInAppTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetInAppTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetInAppTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetInAppTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetInAppTemplateError {
    fn code(&self) -> Option<&str> {
        GetInAppTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetInAppTemplateError {
    pub fn new(kind: GetInAppTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetInAppTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetInAppTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInAppTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetInAppTemplateErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInAppTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInAppTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetInAppTemplateErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInAppTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetInAppTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetInAppTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetInAppTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            GetInAppTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetInAppTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetInAppTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetInAppTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            GetInAppTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetInAppTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetInAppTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJourneyError {
    pub kind: GetJourneyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJourneyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJourneyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJourneyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetJourneyErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetJourneyErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetJourneyErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetJourneyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetJourneyErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetJourneyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetJourneyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJourneyError {
    fn code(&self) -> Option<&str> {
        GetJourneyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJourneyError {
    pub fn new(kind: GetJourneyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJourneyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJourneyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetJourneyErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetJourneyErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetJourneyErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(&self.kind, GetJourneyErrorKind::PayloadTooLargeException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetJourneyErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetJourneyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJourneyErrorKind::BadRequestException(_inner) => Some(_inner),
            GetJourneyErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetJourneyErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetJourneyErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetJourneyErrorKind::NotFoundException(_inner) => Some(_inner),
            GetJourneyErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetJourneyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetJourneyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJourneyDateRangeKpiError {
    pub kind: GetJourneyDateRangeKpiErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJourneyDateRangeKpiErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJourneyDateRangeKpiError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJourneyDateRangeKpiErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetJourneyDateRangeKpiErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetJourneyDateRangeKpiErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetJourneyDateRangeKpiErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetJourneyDateRangeKpiErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetJourneyDateRangeKpiErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetJourneyDateRangeKpiErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetJourneyDateRangeKpiErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJourneyDateRangeKpiError {
    fn code(&self) -> Option<&str> {
        GetJourneyDateRangeKpiError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJourneyDateRangeKpiError {
    pub fn new(kind: GetJourneyDateRangeKpiErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJourneyDateRangeKpiErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJourneyDateRangeKpiErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyDateRangeKpiErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyDateRangeKpiErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyDateRangeKpiErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyDateRangeKpiErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyDateRangeKpiErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyDateRangeKpiErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyDateRangeKpiErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetJourneyDateRangeKpiError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJourneyDateRangeKpiErrorKind::BadRequestException(_inner) => Some(_inner),
            GetJourneyDateRangeKpiErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetJourneyDateRangeKpiErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetJourneyDateRangeKpiErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetJourneyDateRangeKpiErrorKind::NotFoundException(_inner) => Some(_inner),
            GetJourneyDateRangeKpiErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetJourneyDateRangeKpiErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetJourneyDateRangeKpiErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJourneyExecutionActivityMetricsError {
    pub kind: GetJourneyExecutionActivityMetricsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJourneyExecutionActivityMetricsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJourneyExecutionActivityMetricsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJourneyExecutionActivityMetricsErrorKind::BadRequestException(_inner) => {
                _inner.fmt(f)
            }
            GetJourneyExecutionActivityMetricsErrorKind::ForbiddenException(_inner) => {
                _inner.fmt(f)
            }
            GetJourneyExecutionActivityMetricsErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetJourneyExecutionActivityMetricsErrorKind::MethodNotAllowedException(_inner) => {
                _inner.fmt(f)
            }
            GetJourneyExecutionActivityMetricsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetJourneyExecutionActivityMetricsErrorKind::PayloadTooLargeException(_inner) => {
                _inner.fmt(f)
            }
            GetJourneyExecutionActivityMetricsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            GetJourneyExecutionActivityMetricsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJourneyExecutionActivityMetricsError {
    fn code(&self) -> Option<&str> {
        GetJourneyExecutionActivityMetricsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJourneyExecutionActivityMetricsError {
    pub fn new(
        kind: GetJourneyExecutionActivityMetricsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJourneyExecutionActivityMetricsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJourneyExecutionActivityMetricsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionActivityMetricsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionActivityMetricsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionActivityMetricsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionActivityMetricsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionActivityMetricsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionActivityMetricsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionActivityMetricsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetJourneyExecutionActivityMetricsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJourneyExecutionActivityMetricsErrorKind::BadRequestException(_inner) => {
                Some(_inner)
            }
            GetJourneyExecutionActivityMetricsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetJourneyExecutionActivityMetricsErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            GetJourneyExecutionActivityMetricsErrorKind::MethodNotAllowedException(_inner) => {
                Some(_inner)
            }
            GetJourneyExecutionActivityMetricsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetJourneyExecutionActivityMetricsErrorKind::PayloadTooLargeException(_inner) => {
                Some(_inner)
            }
            GetJourneyExecutionActivityMetricsErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            GetJourneyExecutionActivityMetricsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetJourneyExecutionMetricsError {
    pub kind: GetJourneyExecutionMetricsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetJourneyExecutionMetricsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetJourneyExecutionMetricsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetJourneyExecutionMetricsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetJourneyExecutionMetricsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetJourneyExecutionMetricsErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetJourneyExecutionMetricsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetJourneyExecutionMetricsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetJourneyExecutionMetricsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetJourneyExecutionMetricsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetJourneyExecutionMetricsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetJourneyExecutionMetricsError {
    fn code(&self) -> Option<&str> {
        GetJourneyExecutionMetricsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetJourneyExecutionMetricsError {
    pub fn new(kind: GetJourneyExecutionMetricsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetJourneyExecutionMetricsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetJourneyExecutionMetricsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionMetricsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionMetricsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionMetricsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionMetricsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionMetricsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionMetricsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetJourneyExecutionMetricsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetJourneyExecutionMetricsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetJourneyExecutionMetricsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetJourneyExecutionMetricsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetJourneyExecutionMetricsErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            GetJourneyExecutionMetricsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetJourneyExecutionMetricsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetJourneyExecutionMetricsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetJourneyExecutionMetricsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetJourneyExecutionMetricsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPushTemplateError {
    pub kind: GetPushTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPushTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPushTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPushTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetPushTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetPushTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetPushTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetPushTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetPushTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetPushTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetPushTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPushTemplateError {
    fn code(&self) -> Option<&str> {
        GetPushTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPushTemplateError {
    pub fn new(kind: GetPushTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPushTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPushTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetPushTemplateErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetPushTemplateErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPushTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPushTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetPushTemplateErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPushTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPushTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetPushTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPushTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            GetPushTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetPushTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetPushTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetPushTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            GetPushTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetPushTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetPushTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRecommenderConfigurationError {
    pub kind: GetRecommenderConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRecommenderConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRecommenderConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRecommenderConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetRecommenderConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetRecommenderConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetRecommenderConfigurationErrorKind::MethodNotAllowedException(_inner) => {
                _inner.fmt(f)
            }
            GetRecommenderConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRecommenderConfigurationErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetRecommenderConfigurationErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetRecommenderConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRecommenderConfigurationError {
    fn code(&self) -> Option<&str> {
        GetRecommenderConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRecommenderConfigurationError {
    pub fn new(kind: GetRecommenderConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRecommenderConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRecommenderConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetRecommenderConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRecommenderConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            GetRecommenderConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetRecommenderConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            GetRecommenderConfigurationErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetRecommenderConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRecommenderConfigurationErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetRecommenderConfigurationErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetRecommenderConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRecommenderConfigurationsError {
    pub kind: GetRecommenderConfigurationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRecommenderConfigurationsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRecommenderConfigurationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRecommenderConfigurationsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetRecommenderConfigurationsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetRecommenderConfigurationsErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            GetRecommenderConfigurationsErrorKind::MethodNotAllowedException(_inner) => {
                _inner.fmt(f)
            }
            GetRecommenderConfigurationsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetRecommenderConfigurationsErrorKind::PayloadTooLargeException(_inner) => {
                _inner.fmt(f)
            }
            GetRecommenderConfigurationsErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            GetRecommenderConfigurationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRecommenderConfigurationsError {
    fn code(&self) -> Option<&str> {
        GetRecommenderConfigurationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRecommenderConfigurationsError {
    pub fn new(kind: GetRecommenderConfigurationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRecommenderConfigurationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRecommenderConfigurationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRecommenderConfigurationsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetRecommenderConfigurationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRecommenderConfigurationsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetRecommenderConfigurationsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetRecommenderConfigurationsErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            GetRecommenderConfigurationsErrorKind::MethodNotAllowedException(_inner) => {
                Some(_inner)
            }
            GetRecommenderConfigurationsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetRecommenderConfigurationsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetRecommenderConfigurationsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetRecommenderConfigurationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSegmentError {
    pub kind: GetSegmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSegmentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSegmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSegmentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSegmentErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSegmentErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetSegmentErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetSegmentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSegmentErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetSegmentErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSegmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSegmentError {
    fn code(&self) -> Option<&str> {
        GetSegmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSegmentError {
    pub fn new(kind: GetSegmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSegmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSegmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSegmentErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetSegmentErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSegmentErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(&self.kind, GetSegmentErrorKind::PayloadTooLargeException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, GetSegmentErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for GetSegmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSegmentErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSegmentErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSegmentErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetSegmentErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetSegmentErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSegmentErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetSegmentErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSegmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSegmentExportJobsError {
    pub kind: GetSegmentExportJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSegmentExportJobsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSegmentExportJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSegmentExportJobsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSegmentExportJobsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSegmentExportJobsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetSegmentExportJobsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetSegmentExportJobsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSegmentExportJobsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetSegmentExportJobsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSegmentExportJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSegmentExportJobsError {
    fn code(&self) -> Option<&str> {
        GetSegmentExportJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSegmentExportJobsError {
    pub fn new(kind: GetSegmentExportJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSegmentExportJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSegmentExportJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentExportJobsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentExportJobsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentExportJobsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentExportJobsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentExportJobsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentExportJobsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentExportJobsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetSegmentExportJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSegmentExportJobsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSegmentExportJobsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSegmentExportJobsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetSegmentExportJobsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetSegmentExportJobsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSegmentExportJobsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetSegmentExportJobsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSegmentExportJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSegmentImportJobsError {
    pub kind: GetSegmentImportJobsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSegmentImportJobsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSegmentImportJobsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSegmentImportJobsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSegmentImportJobsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSegmentImportJobsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetSegmentImportJobsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetSegmentImportJobsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSegmentImportJobsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetSegmentImportJobsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSegmentImportJobsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSegmentImportJobsError {
    fn code(&self) -> Option<&str> {
        GetSegmentImportJobsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSegmentImportJobsError {
    pub fn new(kind: GetSegmentImportJobsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSegmentImportJobsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSegmentImportJobsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentImportJobsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentImportJobsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentImportJobsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentImportJobsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentImportJobsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentImportJobsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentImportJobsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetSegmentImportJobsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSegmentImportJobsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSegmentImportJobsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSegmentImportJobsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetSegmentImportJobsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetSegmentImportJobsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSegmentImportJobsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetSegmentImportJobsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSegmentImportJobsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSegmentsError {
    pub kind: GetSegmentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSegmentsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSegmentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSegmentsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSegmentsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSegmentsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetSegmentsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetSegmentsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSegmentsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetSegmentsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSegmentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSegmentsError {
    fn code(&self) -> Option<&str> {
        GetSegmentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSegmentsError {
    pub fn new(kind: GetSegmentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSegmentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSegmentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSegmentsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetSegmentsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSegmentsErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetSegmentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSegmentsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSegmentsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSegmentsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetSegmentsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetSegmentsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSegmentsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetSegmentsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSegmentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSegmentVersionError {
    pub kind: GetSegmentVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSegmentVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSegmentVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSegmentVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSegmentVersionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSegmentVersionErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetSegmentVersionErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetSegmentVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSegmentVersionErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetSegmentVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSegmentVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSegmentVersionError {
    fn code(&self) -> Option<&str> {
        GetSegmentVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSegmentVersionError {
    pub fn new(kind: GetSegmentVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSegmentVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSegmentVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSegmentVersionErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetSegmentVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSegmentVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSegmentVersionErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSegmentVersionErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetSegmentVersionErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetSegmentVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSegmentVersionErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetSegmentVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSegmentVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSegmentVersionsError {
    pub kind: GetSegmentVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSegmentVersionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSegmentVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSegmentVersionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSegmentVersionsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSegmentVersionsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetSegmentVersionsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetSegmentVersionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSegmentVersionsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetSegmentVersionsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSegmentVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSegmentVersionsError {
    fn code(&self) -> Option<&str> {
        GetSegmentVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSegmentVersionsError {
    pub fn new(kind: GetSegmentVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSegmentVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSegmentVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSegmentVersionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetSegmentVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSegmentVersionsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSegmentVersionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSegmentVersionsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetSegmentVersionsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetSegmentVersionsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSegmentVersionsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetSegmentVersionsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSegmentVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSmsChannelError {
    pub kind: GetSmsChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSmsChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSmsChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSmsChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSmsChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSmsChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetSmsChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetSmsChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSmsChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetSmsChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSmsChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSmsChannelError {
    fn code(&self) -> Option<&str> {
        GetSmsChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSmsChannelError {
    pub fn new(kind: GetSmsChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSmsChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSmsChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSmsChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetSmsChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSmsChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSmsChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSmsChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSmsChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSmsChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetSmsChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSmsChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSmsChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSmsChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetSmsChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetSmsChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSmsChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetSmsChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSmsChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSmsTemplateError {
    pub kind: GetSmsTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSmsTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSmsTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSmsTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetSmsTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetSmsTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetSmsTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetSmsTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetSmsTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetSmsTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetSmsTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSmsTemplateError {
    fn code(&self) -> Option<&str> {
        GetSmsTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSmsTemplateError {
    pub fn new(kind: GetSmsTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSmsTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSmsTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetSmsTemplateErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetSmsTemplateErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSmsTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSmsTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetSmsTemplateErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSmsTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetSmsTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetSmsTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSmsTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            GetSmsTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetSmsTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetSmsTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetSmsTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            GetSmsTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetSmsTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetSmsTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetUserEndpointsError {
    pub kind: GetUserEndpointsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetUserEndpointsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetUserEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetUserEndpointsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetUserEndpointsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetUserEndpointsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetUserEndpointsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetUserEndpointsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetUserEndpointsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetUserEndpointsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetUserEndpointsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetUserEndpointsError {
    fn code(&self) -> Option<&str> {
        GetUserEndpointsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetUserEndpointsError {
    pub fn new(kind: GetUserEndpointsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetUserEndpointsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetUserEndpointsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserEndpointsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetUserEndpointsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserEndpointsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserEndpointsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetUserEndpointsErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserEndpointsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetUserEndpointsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetUserEndpointsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetUserEndpointsErrorKind::BadRequestException(_inner) => Some(_inner),
            GetUserEndpointsErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetUserEndpointsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetUserEndpointsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetUserEndpointsErrorKind::NotFoundException(_inner) => Some(_inner),
            GetUserEndpointsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetUserEndpointsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetUserEndpointsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceChannelError {
    pub kind: GetVoiceChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetVoiceChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetVoiceChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetVoiceChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetVoiceChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceChannelError {
    fn code(&self) -> Option<&str> {
        GetVoiceChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceChannelError {
    pub fn new(kind: GetVoiceChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceChannelErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetVoiceChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetVoiceChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetVoiceChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetVoiceChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetVoiceChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetVoiceTemplateError {
    pub kind: GetVoiceTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetVoiceTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetVoiceTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetVoiceTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            GetVoiceTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            GetVoiceTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            GetVoiceTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            GetVoiceTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            GetVoiceTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            GetVoiceTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            GetVoiceTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetVoiceTemplateError {
    fn code(&self) -> Option<&str> {
        GetVoiceTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetVoiceTemplateError {
    pub fn new(kind: GetVoiceTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetVoiceTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetVoiceTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceTemplateErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, GetVoiceTemplateErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetVoiceTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for GetVoiceTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetVoiceTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            GetVoiceTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            GetVoiceTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            GetVoiceTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            GetVoiceTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            GetVoiceTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            GetVoiceTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            GetVoiceTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListJourneysError {
    pub kind: ListJourneysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListJourneysErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListJourneysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListJourneysErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListJourneysErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListJourneysErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListJourneysErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            ListJourneysErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListJourneysErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            ListJourneysErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListJourneysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListJourneysError {
    fn code(&self) -> Option<&str> {
        ListJourneysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListJourneysError {
    pub fn new(kind: ListJourneysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListJourneysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListJourneysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListJourneysErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListJourneysErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJourneysErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJourneysErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListJourneysErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJourneysErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListJourneysErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListJourneysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListJourneysErrorKind::BadRequestException(_inner) => Some(_inner),
            ListJourneysErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListJourneysErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListJourneysErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            ListJourneysErrorKind::NotFoundException(_inner) => Some(_inner),
            ListJourneysErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            ListJourneysErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListJourneysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTemplatesError {
    pub kind: ListTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTemplatesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTemplatesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTemplatesError {
    fn code(&self) -> Option<&str> {
        ListTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTemplatesError {
    pub fn new(kind: ListTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, ListTemplatesErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, ListTemplatesErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplatesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplatesErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplatesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTemplatesErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTemplatesErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListTemplatesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListTemplatesErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            ListTemplatesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTemplateVersionsError {
    pub kind: ListTemplateVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTemplateVersionsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTemplateVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTemplateVersionsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            ListTemplateVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTemplateVersionsError {
    fn code(&self) -> Option<&str> {
        ListTemplateVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTemplateVersionsError {
    pub fn new(kind: ListTemplateVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTemplateVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTemplateVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTemplateVersionsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for ListTemplateVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTemplateVersionsErrorKind::BadRequestException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::ForbiddenException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::NotFoundException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            ListTemplateVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PhoneNumberValidateError {
    pub kind: PhoneNumberValidateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PhoneNumberValidateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PhoneNumberValidateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PhoneNumberValidateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PhoneNumberValidateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PhoneNumberValidateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            PhoneNumberValidateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            PhoneNumberValidateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PhoneNumberValidateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            PhoneNumberValidateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PhoneNumberValidateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PhoneNumberValidateError {
    fn code(&self) -> Option<&str> {
        PhoneNumberValidateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PhoneNumberValidateError {
    pub fn new(kind: PhoneNumberValidateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PhoneNumberValidateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PhoneNumberValidateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PhoneNumberValidateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            PhoneNumberValidateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            PhoneNumberValidateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PhoneNumberValidateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PhoneNumberValidateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            PhoneNumberValidateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PhoneNumberValidateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PhoneNumberValidateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PhoneNumberValidateErrorKind::BadRequestException(_inner) => Some(_inner),
            PhoneNumberValidateErrorKind::ForbiddenException(_inner) => Some(_inner),
            PhoneNumberValidateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            PhoneNumberValidateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            PhoneNumberValidateErrorKind::NotFoundException(_inner) => Some(_inner),
            PhoneNumberValidateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            PhoneNumberValidateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PhoneNumberValidateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEventsError {
    pub kind: PutEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEventsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEventsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutEventsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutEventsErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            PutEventsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            PutEventsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutEventsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            PutEventsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEventsError {
    fn code(&self) -> Option<&str> {
        PutEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEventsError {
    pub fn new(kind: PutEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutEventsErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutEventsErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(&self.kind, PutEventsErrorKind::MethodNotAllowedException(_))
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutEventsErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(&self.kind, PutEventsErrorKind::PayloadTooLargeException(_))
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(&self.kind, PutEventsErrorKind::TooManyRequestsException(_))
    }
}
impl std::error::Error for PutEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEventsErrorKind::BadRequestException(_inner) => Some(_inner),
            PutEventsErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutEventsErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            PutEventsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            PutEventsErrorKind::NotFoundException(_inner) => Some(_inner),
            PutEventsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            PutEventsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutEventStreamError {
    pub kind: PutEventStreamErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutEventStreamErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutEventStreamError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutEventStreamErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            PutEventStreamErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            PutEventStreamErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            PutEventStreamErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            PutEventStreamErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            PutEventStreamErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            PutEventStreamErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            PutEventStreamErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutEventStreamError {
    fn code(&self) -> Option<&str> {
        PutEventStreamError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutEventStreamError {
    pub fn new(kind: PutEventStreamErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutEventStreamErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutEventStreamErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, PutEventStreamErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, PutEventStreamErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventStreamErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventStreamErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, PutEventStreamErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventStreamErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutEventStreamErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for PutEventStreamError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutEventStreamErrorKind::BadRequestException(_inner) => Some(_inner),
            PutEventStreamErrorKind::ForbiddenException(_inner) => Some(_inner),
            PutEventStreamErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            PutEventStreamErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            PutEventStreamErrorKind::NotFoundException(_inner) => Some(_inner),
            PutEventStreamErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            PutEventStreamErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            PutEventStreamErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveAttributesError {
    pub kind: RemoveAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveAttributesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveAttributesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            RemoveAttributesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            RemoveAttributesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            RemoveAttributesErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            RemoveAttributesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            RemoveAttributesErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            RemoveAttributesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            RemoveAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveAttributesError {
    fn code(&self) -> Option<&str> {
        RemoveAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveAttributesError {
    pub fn new(kind: RemoveAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveAttributesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, RemoveAttributesErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveAttributesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveAttributesErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, RemoveAttributesErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveAttributesErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            RemoveAttributesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for RemoveAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveAttributesErrorKind::BadRequestException(_inner) => Some(_inner),
            RemoveAttributesErrorKind::ForbiddenException(_inner) => Some(_inner),
            RemoveAttributesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            RemoveAttributesErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            RemoveAttributesErrorKind::NotFoundException(_inner) => Some(_inner),
            RemoveAttributesErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            RemoveAttributesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            RemoveAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendMessagesError {
    pub kind: SendMessagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendMessagesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendMessagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendMessagesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            SendMessagesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            SendMessagesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            SendMessagesErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            SendMessagesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            SendMessagesErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            SendMessagesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            SendMessagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendMessagesError {
    fn code(&self) -> Option<&str> {
        SendMessagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendMessagesError {
    pub fn new(kind: SendMessagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendMessagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendMessagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, SendMessagesErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, SendMessagesErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendMessagesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendMessagesErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, SendMessagesErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendMessagesErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendMessagesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for SendMessagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendMessagesErrorKind::BadRequestException(_inner) => Some(_inner),
            SendMessagesErrorKind::ForbiddenException(_inner) => Some(_inner),
            SendMessagesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            SendMessagesErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            SendMessagesErrorKind::NotFoundException(_inner) => Some(_inner),
            SendMessagesErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            SendMessagesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            SendMessagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendUsersMessagesError {
    pub kind: SendUsersMessagesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendUsersMessagesErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendUsersMessagesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendUsersMessagesErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            SendUsersMessagesErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            SendUsersMessagesErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            SendUsersMessagesErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            SendUsersMessagesErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            SendUsersMessagesErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            SendUsersMessagesErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            SendUsersMessagesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendUsersMessagesError {
    fn code(&self) -> Option<&str> {
        SendUsersMessagesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendUsersMessagesError {
    pub fn new(kind: SendUsersMessagesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendUsersMessagesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendUsersMessagesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendUsersMessagesErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendUsersMessagesErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendUsersMessagesErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendUsersMessagesErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, SendUsersMessagesErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendUsersMessagesErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendUsersMessagesErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for SendUsersMessagesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendUsersMessagesErrorKind::BadRequestException(_inner) => Some(_inner),
            SendUsersMessagesErrorKind::ForbiddenException(_inner) => Some(_inner),
            SendUsersMessagesErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            SendUsersMessagesErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            SendUsersMessagesErrorKind::NotFoundException(_inner) => Some(_inner),
            SendUsersMessagesErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            SendUsersMessagesErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            SendUsersMessagesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAdmChannelError {
    pub kind: UpdateAdmChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAdmChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAdmChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAdmChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateAdmChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateAdmChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateAdmChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateAdmChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateAdmChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateAdmChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateAdmChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAdmChannelError {
    fn code(&self) -> Option<&str> {
        UpdateAdmChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateAdmChannelError {
    pub fn new(kind: UpdateAdmChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAdmChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAdmChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAdmChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateAdmChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAdmChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAdmChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateAdmChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAdmChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAdmChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateAdmChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAdmChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateAdmChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateAdmChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateAdmChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateAdmChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateAdmChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateAdmChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateAdmChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApnsChannelError {
    pub kind: UpdateApnsChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApnsChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApnsChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApnsChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateApnsChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateApnsChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateApnsChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateApnsChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateApnsChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateApnsChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateApnsChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApnsChannelError {
    fn code(&self) -> Option<&str> {
        UpdateApnsChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApnsChannelError {
    pub fn new(kind: UpdateApnsChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApnsChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApnsChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateApnsChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateApnsChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApnsChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateApnsChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateApnsChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateApnsChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateApnsChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateApnsChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateApnsChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateApnsChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApnsSandboxChannelError {
    pub kind: UpdateApnsSandboxChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApnsSandboxChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApnsSandboxChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApnsSandboxChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateApnsSandboxChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateApnsSandboxChannelErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateApnsSandboxChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateApnsSandboxChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateApnsSandboxChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateApnsSandboxChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateApnsSandboxChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApnsSandboxChannelError {
    fn code(&self) -> Option<&str> {
        UpdateApnsSandboxChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApnsSandboxChannelError {
    pub fn new(kind: UpdateApnsSandboxChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApnsSandboxChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApnsSandboxChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsSandboxChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsSandboxChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsSandboxChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsSandboxChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsSandboxChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsSandboxChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsSandboxChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateApnsSandboxChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApnsSandboxChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateApnsSandboxChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateApnsSandboxChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateApnsSandboxChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateApnsSandboxChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateApnsSandboxChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateApnsSandboxChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateApnsSandboxChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApnsVoipChannelError {
    pub kind: UpdateApnsVoipChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApnsVoipChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApnsVoipChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApnsVoipChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateApnsVoipChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateApnsVoipChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateApnsVoipChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateApnsVoipChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateApnsVoipChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateApnsVoipChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateApnsVoipChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApnsVoipChannelError {
    fn code(&self) -> Option<&str> {
        UpdateApnsVoipChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApnsVoipChannelError {
    pub fn new(kind: UpdateApnsVoipChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApnsVoipChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApnsVoipChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateApnsVoipChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApnsVoipChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateApnsVoipChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateApnsVoipChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateApnsVoipChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateApnsVoipChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateApnsVoipChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateApnsVoipChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateApnsVoipChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApnsVoipSandboxChannelError {
    pub kind: UpdateApnsVoipSandboxChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApnsVoipSandboxChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApnsVoipSandboxChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApnsVoipSandboxChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateApnsVoipSandboxChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateApnsVoipSandboxChannelErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateApnsVoipSandboxChannelErrorKind::MethodNotAllowedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateApnsVoipSandboxChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateApnsVoipSandboxChannelErrorKind::PayloadTooLargeException(_inner) => {
                _inner.fmt(f)
            }
            UpdateApnsVoipSandboxChannelErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            UpdateApnsVoipSandboxChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApnsVoipSandboxChannelError {
    fn code(&self) -> Option<&str> {
        UpdateApnsVoipSandboxChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApnsVoipSandboxChannelError {
    pub fn new(kind: UpdateApnsVoipSandboxChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApnsVoipSandboxChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApnsVoipSandboxChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipSandboxChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipSandboxChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipSandboxChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipSandboxChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipSandboxChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipSandboxChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApnsVoipSandboxChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateApnsVoipSandboxChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApnsVoipSandboxChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateApnsVoipSandboxChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateApnsVoipSandboxChannelErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            UpdateApnsVoipSandboxChannelErrorKind::MethodNotAllowedException(_inner) => {
                Some(_inner)
            }
            UpdateApnsVoipSandboxChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateApnsVoipSandboxChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateApnsVoipSandboxChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateApnsVoipSandboxChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApplicationSettingsError {
    pub kind: UpdateApplicationSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApplicationSettingsErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApplicationSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApplicationSettingsErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateApplicationSettingsErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateApplicationSettingsErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateApplicationSettingsErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateApplicationSettingsErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateApplicationSettingsErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateApplicationSettingsErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateApplicationSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApplicationSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateApplicationSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApplicationSettingsError {
    pub fn new(kind: UpdateApplicationSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApplicationSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApplicationSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApplicationSettingsErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApplicationSettingsErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApplicationSettingsErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApplicationSettingsErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApplicationSettingsErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApplicationSettingsErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApplicationSettingsErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateApplicationSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApplicationSettingsErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateApplicationSettingsErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateApplicationSettingsErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            UpdateApplicationSettingsErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateApplicationSettingsErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateApplicationSettingsErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateApplicationSettingsErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateApplicationSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateBaiduChannelError {
    pub kind: UpdateBaiduChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateBaiduChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateBaiduChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateBaiduChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateBaiduChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateBaiduChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateBaiduChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateBaiduChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateBaiduChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateBaiduChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateBaiduChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateBaiduChannelError {
    fn code(&self) -> Option<&str> {
        UpdateBaiduChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateBaiduChannelError {
    pub fn new(kind: UpdateBaiduChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateBaiduChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateBaiduChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBaiduChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBaiduChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBaiduChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBaiduChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBaiduChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBaiduChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateBaiduChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateBaiduChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateBaiduChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateBaiduChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateBaiduChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateBaiduChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateBaiduChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateBaiduChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateBaiduChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateBaiduChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCampaignError {
    pub kind: UpdateCampaignErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCampaignErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCampaignError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCampaignErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateCampaignErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateCampaignErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateCampaignErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateCampaignErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateCampaignErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateCampaignErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateCampaignErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCampaignError {
    fn code(&self) -> Option<&str> {
        UpdateCampaignError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCampaignError {
    pub fn new(kind: UpdateCampaignErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCampaignErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCampaignErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateCampaignErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateCampaignErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCampaignErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCampaignErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateCampaignErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCampaignErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCampaignErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateCampaignError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCampaignErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateCampaignErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateCampaignErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateCampaignErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateCampaignErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateCampaignErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateCampaignErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateCampaignErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEmailChannelError {
    pub kind: UpdateEmailChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEmailChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEmailChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEmailChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateEmailChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateEmailChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateEmailChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateEmailChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateEmailChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateEmailChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateEmailChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEmailChannelError {
    fn code(&self) -> Option<&str> {
        UpdateEmailChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEmailChannelError {
    pub fn new(kind: UpdateEmailChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEmailChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEmailChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateEmailChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEmailChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateEmailChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateEmailChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateEmailChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateEmailChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateEmailChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateEmailChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateEmailChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEmailTemplateError {
    pub kind: UpdateEmailTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEmailTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEmailTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEmailTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateEmailTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEmailTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateEmailTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEmailTemplateError {
    pub fn new(kind: UpdateEmailTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEmailTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEmailTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEmailTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateEmailTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEmailTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateEmailTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEndpointError {
    pub kind: UpdateEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEndpointErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEndpointErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateEndpointErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateEndpointErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateEndpointErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateEndpointErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateEndpointErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateEndpointErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEndpointError {
    fn code(&self) -> Option<&str> {
        UpdateEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEndpointError {
    pub fn new(kind: UpdateEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateEndpointErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateEndpointErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateEndpointErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEndpointErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateEndpointErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateEndpointErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateEndpointErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateEndpointErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateEndpointErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateEndpointErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEndpointsBatchError {
    pub kind: UpdateEndpointsBatchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEndpointsBatchErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEndpointsBatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEndpointsBatchErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateEndpointsBatchErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateEndpointsBatchErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateEndpointsBatchErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateEndpointsBatchErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateEndpointsBatchErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateEndpointsBatchErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateEndpointsBatchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEndpointsBatchError {
    fn code(&self) -> Option<&str> {
        UpdateEndpointsBatchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateEndpointsBatchError {
    pub fn new(kind: UpdateEndpointsBatchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEndpointsBatchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEndpointsBatchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointsBatchErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointsBatchErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointsBatchErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointsBatchErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointsBatchErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointsBatchErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEndpointsBatchErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateEndpointsBatchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEndpointsBatchErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateEndpointsBatchErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateEndpointsBatchErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateEndpointsBatchErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateEndpointsBatchErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateEndpointsBatchErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateEndpointsBatchErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateEndpointsBatchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateGcmChannelError {
    pub kind: UpdateGcmChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateGcmChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateGcmChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateGcmChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateGcmChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateGcmChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateGcmChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateGcmChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateGcmChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateGcmChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateGcmChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateGcmChannelError {
    fn code(&self) -> Option<&str> {
        UpdateGcmChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateGcmChannelError {
    pub fn new(kind: UpdateGcmChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateGcmChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateGcmChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGcmChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateGcmChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGcmChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGcmChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateGcmChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGcmChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateGcmChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateGcmChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateGcmChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateGcmChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateGcmChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateGcmChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateGcmChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateGcmChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateGcmChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateGcmChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateInAppTemplateError {
    pub kind: UpdateInAppTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateInAppTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateInAppTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateInAppTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateInAppTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateInAppTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateInAppTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateInAppTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateInAppTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateInAppTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateInAppTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateInAppTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateInAppTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateInAppTemplateError {
    pub fn new(kind: UpdateInAppTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateInAppTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateInAppTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInAppTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInAppTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInAppTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInAppTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInAppTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInAppTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateInAppTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateInAppTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateInAppTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateInAppTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateInAppTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateInAppTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateInAppTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateInAppTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateInAppTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateInAppTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateJourneyError {
    pub kind: UpdateJourneyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateJourneyErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ConflictException(crate::error::ConflictException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateJourneyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateJourneyErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateJourneyErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateJourneyErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateJourneyErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateJourneyErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateJourneyErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateJourneyErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateJourneyErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateJourneyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateJourneyError {
    fn code(&self) -> Option<&str> {
        UpdateJourneyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateJourneyError {
    pub fn new(kind: UpdateJourneyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateJourneyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateJourneyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateJourneyErrorKind::BadRequestException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateJourneyErrorKind::ConflictException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateJourneyErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateJourneyErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateJourneyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateJourneyErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateJourneyErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateJourneyErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateJourneyErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateJourneyErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateJourneyErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateJourneyErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateJourneyErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateJourneyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateJourneyStateError {
    pub kind: UpdateJourneyStateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateJourneyStateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateJourneyStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateJourneyStateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateJourneyStateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateJourneyStateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateJourneyStateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateJourneyStateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateJourneyStateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateJourneyStateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateJourneyStateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateJourneyStateError {
    fn code(&self) -> Option<&str> {
        UpdateJourneyStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateJourneyStateError {
    pub fn new(kind: UpdateJourneyStateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateJourneyStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateJourneyStateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyStateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyStateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyStateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyStateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyStateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyStateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateJourneyStateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateJourneyStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateJourneyStateErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateJourneyStateErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateJourneyStateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateJourneyStateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateJourneyStateErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateJourneyStateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateJourneyStateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateJourneyStateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePushTemplateError {
    pub kind: UpdatePushTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePushTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePushTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePushTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdatePushTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdatePushTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdatePushTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdatePushTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdatePushTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdatePushTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdatePushTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePushTemplateError {
    fn code(&self) -> Option<&str> {
        UpdatePushTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePushTemplateError {
    pub fn new(kind: UpdatePushTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePushTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePushTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePushTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePushTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePushTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePushTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePushTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePushTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePushTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdatePushTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePushTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdatePushTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdatePushTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdatePushTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdatePushTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdatePushTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdatePushTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdatePushTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRecommenderConfigurationError {
    pub kind: UpdateRecommenderConfigurationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRecommenderConfigurationErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRecommenderConfigurationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRecommenderConfigurationErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateRecommenderConfigurationErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateRecommenderConfigurationErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRecommenderConfigurationErrorKind::MethodNotAllowedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRecommenderConfigurationErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateRecommenderConfigurationErrorKind::PayloadTooLargeException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRecommenderConfigurationErrorKind::TooManyRequestsException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRecommenderConfigurationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRecommenderConfigurationError {
    fn code(&self) -> Option<&str> {
        UpdateRecommenderConfigurationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRecommenderConfigurationError {
    pub fn new(kind: UpdateRecommenderConfigurationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRecommenderConfigurationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRecommenderConfigurationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecommenderConfigurationErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecommenderConfigurationErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecommenderConfigurationErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecommenderConfigurationErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecommenderConfigurationErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecommenderConfigurationErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRecommenderConfigurationErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateRecommenderConfigurationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRecommenderConfigurationErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateRecommenderConfigurationErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateRecommenderConfigurationErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            UpdateRecommenderConfigurationErrorKind::MethodNotAllowedException(_inner) => {
                Some(_inner)
            }
            UpdateRecommenderConfigurationErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateRecommenderConfigurationErrorKind::PayloadTooLargeException(_inner) => {
                Some(_inner)
            }
            UpdateRecommenderConfigurationErrorKind::TooManyRequestsException(_inner) => {
                Some(_inner)
            }
            UpdateRecommenderConfigurationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSegmentError {
    pub kind: UpdateSegmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSegmentErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSegmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSegmentErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateSegmentErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateSegmentErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateSegmentErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateSegmentErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateSegmentErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateSegmentErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateSegmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSegmentError {
    fn code(&self) -> Option<&str> {
        UpdateSegmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSegmentError {
    pub fn new(kind: UpdateSegmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSegmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSegmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self.kind, UpdateSegmentErrorKind::BadRequestException(_))
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateSegmentErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSegmentErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSegmentErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateSegmentErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSegmentErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSegmentErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateSegmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSegmentErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateSegmentErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateSegmentErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateSegmentErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateSegmentErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateSegmentErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateSegmentErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateSegmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSmsChannelError {
    pub kind: UpdateSmsChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSmsChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSmsChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSmsChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateSmsChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateSmsChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateSmsChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateSmsChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateSmsChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateSmsChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateSmsChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSmsChannelError {
    fn code(&self) -> Option<&str> {
        UpdateSmsChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSmsChannelError {
    pub fn new(kind: UpdateSmsChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSmsChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSmsChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(&self.kind, UpdateSmsChannelErrorKind::ForbiddenException(_))
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateSmsChannelErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateSmsChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSmsChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateSmsChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateSmsChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateSmsChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateSmsChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateSmsChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateSmsChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateSmsChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSmsTemplateError {
    pub kind: UpdateSmsTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSmsTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSmsTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSmsTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateSmsTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateSmsTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateSmsTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateSmsTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateSmsTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateSmsTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateSmsTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSmsTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateSmsTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSmsTemplateError {
    pub fn new(kind: UpdateSmsTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSmsTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSmsTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(&self.kind, UpdateSmsTemplateErrorKind::NotFoundException(_))
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSmsTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateSmsTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSmsTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateSmsTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateSmsTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateSmsTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateSmsTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateSmsTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateSmsTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateSmsTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateTemplateActiveVersionError {
    pub kind: UpdateTemplateActiveVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateTemplateActiveVersionErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateTemplateActiveVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateTemplateActiveVersionErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateTemplateActiveVersionErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateTemplateActiveVersionErrorKind::InternalServerErrorException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTemplateActiveVersionErrorKind::MethodNotAllowedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateTemplateActiveVersionErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateTemplateActiveVersionErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateTemplateActiveVersionErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateTemplateActiveVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateTemplateActiveVersionError {
    fn code(&self) -> Option<&str> {
        UpdateTemplateActiveVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateTemplateActiveVersionError {
    pub fn new(kind: UpdateTemplateActiveVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateTemplateActiveVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateTemplateActiveVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateActiveVersionErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateActiveVersionErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateActiveVersionErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateActiveVersionErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateActiveVersionErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateActiveVersionErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateTemplateActiveVersionErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateTemplateActiveVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateTemplateActiveVersionErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateTemplateActiveVersionErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateTemplateActiveVersionErrorKind::InternalServerErrorException(_inner) => {
                Some(_inner)
            }
            UpdateTemplateActiveVersionErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateTemplateActiveVersionErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateTemplateActiveVersionErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateTemplateActiveVersionErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateTemplateActiveVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVoiceChannelError {
    pub kind: UpdateVoiceChannelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVoiceChannelErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVoiceChannelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVoiceChannelErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVoiceChannelErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateVoiceChannelErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateVoiceChannelErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateVoiceChannelErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVoiceChannelErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateVoiceChannelErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateVoiceChannelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVoiceChannelError {
    fn code(&self) -> Option<&str> {
        UpdateVoiceChannelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVoiceChannelError {
    pub fn new(kind: UpdateVoiceChannelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVoiceChannelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVoiceChannelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceChannelErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceChannelErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceChannelErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceChannelErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceChannelErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceChannelErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceChannelErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateVoiceChannelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVoiceChannelErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVoiceChannelErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateVoiceChannelErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateVoiceChannelErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateVoiceChannelErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVoiceChannelErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateVoiceChannelErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateVoiceChannelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVoiceTemplateError {
    pub kind: UpdateVoiceTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVoiceTemplateErrorKind {
    BadRequestException(crate::error::BadRequestException),
    ForbiddenException(crate::error::ForbiddenException),
    InternalServerErrorException(crate::error::InternalServerErrorException),
    MethodNotAllowedException(crate::error::MethodNotAllowedException),
    NotFoundException(crate::error::NotFoundException),
    PayloadTooLargeException(crate::error::PayloadTooLargeException),
    TooManyRequestsException(crate::error::TooManyRequestsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVoiceTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVoiceTemplateErrorKind::BadRequestException(_inner) => _inner.fmt(f),
            UpdateVoiceTemplateErrorKind::ForbiddenException(_inner) => _inner.fmt(f),
            UpdateVoiceTemplateErrorKind::InternalServerErrorException(_inner) => _inner.fmt(f),
            UpdateVoiceTemplateErrorKind::MethodNotAllowedException(_inner) => _inner.fmt(f),
            UpdateVoiceTemplateErrorKind::NotFoundException(_inner) => _inner.fmt(f),
            UpdateVoiceTemplateErrorKind::PayloadTooLargeException(_inner) => _inner.fmt(f),
            UpdateVoiceTemplateErrorKind::TooManyRequestsException(_inner) => _inner.fmt(f),
            UpdateVoiceTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVoiceTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateVoiceTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVoiceTemplateError {
    pub fn new(kind: UpdateVoiceTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVoiceTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVoiceTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceTemplateErrorKind::BadRequestException(_)
        )
    }
    pub fn is_forbidden_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceTemplateErrorKind::ForbiddenException(_)
        )
    }
    pub fn is_internal_server_error_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceTemplateErrorKind::InternalServerErrorException(_)
        )
    }
    pub fn is_method_not_allowed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceTemplateErrorKind::MethodNotAllowedException(_)
        )
    }
    pub fn is_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceTemplateErrorKind::NotFoundException(_)
        )
    }
    pub fn is_payload_too_large_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceTemplateErrorKind::PayloadTooLargeException(_)
        )
    }
    pub fn is_too_many_requests_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVoiceTemplateErrorKind::TooManyRequestsException(_)
        )
    }
}
impl std::error::Error for UpdateVoiceTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVoiceTemplateErrorKind::BadRequestException(_inner) => Some(_inner),
            UpdateVoiceTemplateErrorKind::ForbiddenException(_inner) => Some(_inner),
            UpdateVoiceTemplateErrorKind::InternalServerErrorException(_inner) => Some(_inner),
            UpdateVoiceTemplateErrorKind::MethodNotAllowedException(_inner) => Some(_inner),
            UpdateVoiceTemplateErrorKind::NotFoundException(_inner) => Some(_inner),
            UpdateVoiceTemplateErrorKind::PayloadTooLargeException(_inner) => Some(_inner),
            UpdateVoiceTemplateErrorKind::TooManyRequestsException(_inner) => Some(_inner),
            UpdateVoiceTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>Provides information about an API request or response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyRequestsException {
    /// <p>The message that's returned from the API.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request or response.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyRequestsException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl TooManyRequestsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyRequestsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyRequestsException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyRequestsException {}
/// See [`TooManyRequestsException`](crate::error::TooManyRequestsException)
pub mod too_many_requests_exception {
    /// A builder for [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message that's returned from the API.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request or response.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyRequestsException`](crate::error::TooManyRequestsException)
        pub fn build(self) -> crate::error::TooManyRequestsException {
            crate::error::TooManyRequestsException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl TooManyRequestsException {
    /// Creates a new builder-style object to manufacture [`TooManyRequestsException`](crate::error::TooManyRequestsException)
    pub fn builder() -> crate::error::too_many_requests_exception::Builder {
        crate::error::too_many_requests_exception::Builder::default()
    }
}

/// <p>Provides information about an API request or response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PayloadTooLargeException {
    /// <p>The message that's returned from the API.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request or response.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PayloadTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PayloadTooLargeException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl PayloadTooLargeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PayloadTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PayloadTooLargeException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for PayloadTooLargeException {}
/// See [`PayloadTooLargeException`](crate::error::PayloadTooLargeException)
pub mod payload_too_large_exception {
    /// A builder for [`PayloadTooLargeException`](crate::error::PayloadTooLargeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message that's returned from the API.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request or response.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PayloadTooLargeException`](crate::error::PayloadTooLargeException)
        pub fn build(self) -> crate::error::PayloadTooLargeException {
            crate::error::PayloadTooLargeException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl PayloadTooLargeException {
    /// Creates a new builder-style object to manufacture [`PayloadTooLargeException`](crate::error::PayloadTooLargeException)
    pub fn builder() -> crate::error::payload_too_large_exception::Builder {
        crate::error::payload_too_large_exception::Builder::default()
    }
}

/// <p>Provides information about an API request or response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotFoundException {
    /// <p>The message that's returned from the API.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request or response.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotFoundException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl NotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for NotFoundException {}
/// See [`NotFoundException`](crate::error::NotFoundException)
pub mod not_found_exception {
    /// A builder for [`NotFoundException`](crate::error::NotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message that's returned from the API.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request or response.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NotFoundException`](crate::error::NotFoundException)
        pub fn build(self) -> crate::error::NotFoundException {
            crate::error::NotFoundException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl NotFoundException {
    /// Creates a new builder-style object to manufacture [`NotFoundException`](crate::error::NotFoundException)
    pub fn builder() -> crate::error::not_found_exception::Builder {
        crate::error::not_found_exception::Builder::default()
    }
}

/// <p>Provides information about an API request or response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MethodNotAllowedException {
    /// <p>The message that's returned from the API.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request or response.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MethodNotAllowedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MethodNotAllowedException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl MethodNotAllowedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MethodNotAllowedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MethodNotAllowedException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for MethodNotAllowedException {}
/// See [`MethodNotAllowedException`](crate::error::MethodNotAllowedException)
pub mod method_not_allowed_exception {
    /// A builder for [`MethodNotAllowedException`](crate::error::MethodNotAllowedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message that's returned from the API.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request or response.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MethodNotAllowedException`](crate::error::MethodNotAllowedException)
        pub fn build(self) -> crate::error::MethodNotAllowedException {
            crate::error::MethodNotAllowedException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl MethodNotAllowedException {
    /// Creates a new builder-style object to manufacture [`MethodNotAllowedException`](crate::error::MethodNotAllowedException)
    pub fn builder() -> crate::error::method_not_allowed_exception::Builder {
        crate::error::method_not_allowed_exception::Builder::default()
    }
}

/// <p>Provides information about an API request or response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerErrorException {
    /// <p>The message that's returned from the API.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request or response.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerErrorException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl InternalServerErrorException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerErrorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerErrorException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerErrorException {}
/// See [`InternalServerErrorException`](crate::error::InternalServerErrorException)
pub mod internal_server_error_exception {
    /// A builder for [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message that's returned from the API.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request or response.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerErrorException`](crate::error::InternalServerErrorException)
        pub fn build(self) -> crate::error::InternalServerErrorException {
            crate::error::InternalServerErrorException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl InternalServerErrorException {
    /// Creates a new builder-style object to manufacture [`InternalServerErrorException`](crate::error::InternalServerErrorException)
    pub fn builder() -> crate::error::internal_server_error_exception::Builder {
        crate::error::internal_server_error_exception::Builder::default()
    }
}

/// <p>Provides information about an API request or response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ForbiddenException {
    /// <p>The message that's returned from the API.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request or response.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ForbiddenException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl ForbiddenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ForbiddenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ForbiddenException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ForbiddenException {}
/// See [`ForbiddenException`](crate::error::ForbiddenException)
pub mod forbidden_exception {
    /// A builder for [`ForbiddenException`](crate::error::ForbiddenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message that's returned from the API.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request or response.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ForbiddenException`](crate::error::ForbiddenException)
        pub fn build(self) -> crate::error::ForbiddenException {
            crate::error::ForbiddenException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl ForbiddenException {
    /// Creates a new builder-style object to manufacture [`ForbiddenException`](crate::error::ForbiddenException)
    pub fn builder() -> crate::error::forbidden_exception::Builder {
        crate::error::forbidden_exception::Builder::default()
    }
}

/// <p>Provides information about an API request or response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    /// <p>The message that's returned from the API.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request or response.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl BadRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message that's returned from the API.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request or response.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// <p>Provides information about an API request or response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    /// <p>The message that's returned from the API.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request or response.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message that's returned from the API.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request or response.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}
