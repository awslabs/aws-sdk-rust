// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Provides information about an API request or response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MessageBody {
    /// <p>The message that's returned from the API.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request or response.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MessageBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MessageBody");
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
/// See [`MessageBody`](crate::model::MessageBody)
pub mod message_body {
    /// A builder for [`MessageBody`](crate::model::MessageBody)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message that's returned from the API.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that's returned from the API.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request or response.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the request or response.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageBody`](crate::model::MessageBody)
        pub fn build(self) -> crate::model::MessageBody {
            crate::model::MessageBody {
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl MessageBody {
    /// Creates a new builder-style object to manufacture [`MessageBody`](crate::model::MessageBody)
    pub fn builder() -> crate::model::message_body::Builder {
        crate::model::message_body::Builder::default()
    }
}

/// <p>Specifies the content and settings for a message template that can be used in messages that are sent through the voice channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VoiceTemplateRequest {
    /// <p>The text of the script to use in messages that are based on the message template, in plain text format.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
    pub default_substitutions: std::option::Option<std::string::String>,
    /// <p>The code for the language to use when synthesizing the text of the script in messages that are based on the message template. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    pub language_code: std::option::Option<std::string::String>,
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A custom description of the message template.</p>
    pub template_description: std::option::Option<std::string::String>,
    /// <p>The name of the voice to use when delivering messages that are based on the message template. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    pub voice_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VoiceTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VoiceTemplateRequest");
        formatter.field("body", &self.body);
        formatter.field("default_substitutions", &self.default_substitutions);
        formatter.field("language_code", &self.language_code);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.field("voice_id", &self.voice_id);
        formatter.finish()
    }
}
/// See [`VoiceTemplateRequest`](crate::model::VoiceTemplateRequest)
pub mod voice_template_request {
    /// A builder for [`VoiceTemplateRequest`](crate::model::VoiceTemplateRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) default_substitutions: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
        pub(crate) voice_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The text of the script to use in messages that are based on the message template, in plain text format.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The text of the script to use in messages that are based on the message template, in plain text format.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
        pub fn default_substitutions(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_substitutions = Some(input.into());
            self
        }
        /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
        pub fn set_default_substitutions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_substitutions = input;
            self
        }
        /// <p>The code for the language to use when synthesizing the text of the script in messages that are based on the message template. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn language_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_code = Some(input.into());
            self
        }
        /// <p>The code for the language to use when synthesizing the text of the script in messages that are based on the message template. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>A custom description of the message template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>A custom description of the message template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// <p>The name of the voice to use when delivering messages that are based on the message template. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn voice_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_id = Some(input.into());
            self
        }
        /// <p>The name of the voice to use when delivering messages that are based on the message template. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn set_voice_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.voice_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceTemplateRequest`](crate::model::VoiceTemplateRequest)
        pub fn build(self) -> crate::model::VoiceTemplateRequest {
            crate::model::VoiceTemplateRequest {
                body: self.body,
                default_substitutions: self.default_substitutions,
                language_code: self.language_code,
                tags: self.tags,
                template_description: self.template_description,
                voice_id: self.voice_id,
            }
        }
    }
}
impl VoiceTemplateRequest {
    /// Creates a new builder-style object to manufacture [`VoiceTemplateRequest`](crate::model::VoiceTemplateRequest)
    pub fn builder() -> crate::model::voice_template_request::Builder {
        crate::model::voice_template_request::Builder::default()
    }
}

/// <p>Provides information about the status and settings of the voice channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VoiceChannelResponse {
    /// <p>The unique identifier for the application that the voice channel applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when the voice channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>Specifies whether the voice channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>(Deprecated) An identifier for the voice channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the voice channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the voice channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when the voice channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The type of messaging or notification platform for the channel. For the voice channel, this value is VOICE.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current version of the voice channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for VoiceChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VoiceChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("enabled", &self.enabled);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("id", &self.id);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("platform", &self.platform);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`VoiceChannelResponse`](crate::model::VoiceChannelResponse)
pub mod voice_channel_response {
    /// A builder for [`VoiceChannelResponse`](crate::model::VoiceChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the voice channel applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the voice channel applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the voice channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the voice channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>Specifies whether the voice channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the voice channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>(Deprecated) An identifier for the voice channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the voice channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the voice channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the voice channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the voice channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the voice channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the voice channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the voice channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the voice channel, this value is VOICE.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the voice channel, this value is VOICE.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current version of the voice channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the voice channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceChannelResponse`](crate::model::VoiceChannelResponse)
        pub fn build(self) -> crate::model::VoiceChannelResponse {
            crate::model::VoiceChannelResponse {
                application_id: self.application_id,
                creation_date: self.creation_date,
                enabled: self.enabled.unwrap_or_default(),
                has_credential: self.has_credential.unwrap_or_default(),
                id: self.id,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                platform: self.platform,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl VoiceChannelResponse {
    /// Creates a new builder-style object to manufacture [`VoiceChannelResponse`](crate::model::VoiceChannelResponse)
    pub fn builder() -> crate::model::voice_channel_response::Builder {
        crate::model::voice_channel_response::Builder::default()
    }
}

/// <p>Specifies the status and settings of the voice channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VoiceChannelRequest {
    /// <p>Specifies whether to enable the voice channel for the application.</p>
    pub enabled: bool,
}
impl std::fmt::Debug for VoiceChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VoiceChannelRequest");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`VoiceChannelRequest`](crate::model::VoiceChannelRequest)
pub mod voice_channel_request {
    /// A builder for [`VoiceChannelRequest`](crate::model::VoiceChannelRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Specifies whether to enable the voice channel for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether to enable the voice channel for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceChannelRequest`](crate::model::VoiceChannelRequest)
        pub fn build(self) -> crate::model::VoiceChannelRequest {
            crate::model::VoiceChannelRequest {
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl VoiceChannelRequest {
    /// Creates a new builder-style object to manufacture [`VoiceChannelRequest`](crate::model::VoiceChannelRequest)
    pub fn builder() -> crate::model::voice_channel_request::Builder {
        crate::model::voice_channel_request::Builder::default()
    }
}

/// <p>Specifies which version of a message template to use as the active version of the template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TemplateActiveVersionRequest {
    /// <p>The version of the message template to use as the active version of the template. Valid values are: latest, for the most recent version of the template; or, the unique identifier for any existing version of the template. If you specify an identifier, the value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TemplateActiveVersionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TemplateActiveVersionRequest");
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`TemplateActiveVersionRequest`](crate::model::TemplateActiveVersionRequest)
pub mod template_active_version_request {
    /// A builder for [`TemplateActiveVersionRequest`](crate::model::TemplateActiveVersionRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version of the message template to use as the active version of the template. Valid values are: latest, for the most recent version of the template; or, the unique identifier for any existing version of the template. If you specify an identifier, the value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version of the message template to use as the active version of the template. Valid values are: latest, for the most recent version of the template; or, the unique identifier for any existing version of the template. If you specify an identifier, the value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateActiveVersionRequest`](crate::model::TemplateActiveVersionRequest)
        pub fn build(self) -> crate::model::TemplateActiveVersionRequest {
            crate::model::TemplateActiveVersionRequest {
                version: self.version,
            }
        }
    }
}
impl TemplateActiveVersionRequest {
    /// Creates a new builder-style object to manufacture [`TemplateActiveVersionRequest`](crate::model::TemplateActiveVersionRequest)
    pub fn builder() -> crate::model::template_active_version_request::Builder {
        crate::model::template_active_version_request::Builder::default()
    }
}

/// <p>Specifies the content and settings for a message template that can be used in text messages that are sent through the SMS channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SmsTemplateRequest {
    /// <p>The message body to use in text messages that are based on the message template.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
    pub default_substitutions: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
    pub recommender_id: std::option::Option<std::string::String>,
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A custom description of the message template.</p>
    pub template_description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SmsTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SmsTemplateRequest");
        formatter.field("body", &self.body);
        formatter.field("default_substitutions", &self.default_substitutions);
        formatter.field("recommender_id", &self.recommender_id);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.finish()
    }
}
/// See [`SmsTemplateRequest`](crate::model::SmsTemplateRequest)
pub mod sms_template_request {
    /// A builder for [`SmsTemplateRequest`](crate::model::SmsTemplateRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) default_substitutions: std::option::Option<std::string::String>,
        pub(crate) recommender_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message body to use in text messages that are based on the message template.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The message body to use in text messages that are based on the message template.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
        pub fn default_substitutions(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_substitutions = Some(input.into());
            self
        }
        /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
        pub fn set_default_substitutions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_substitutions = input;
            self
        }
        /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
        pub fn recommender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommender_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
        pub fn set_recommender_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommender_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>A custom description of the message template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>A custom description of the message template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// Consumes the builder and constructs a [`SmsTemplateRequest`](crate::model::SmsTemplateRequest)
        pub fn build(self) -> crate::model::SmsTemplateRequest {
            crate::model::SmsTemplateRequest {
                body: self.body,
                default_substitutions: self.default_substitutions,
                recommender_id: self.recommender_id,
                tags: self.tags,
                template_description: self.template_description,
            }
        }
    }
}
impl SmsTemplateRequest {
    /// Creates a new builder-style object to manufacture [`SmsTemplateRequest`](crate::model::SmsTemplateRequest)
    pub fn builder() -> crate::model::sms_template_request::Builder {
        crate::model::sms_template_request::Builder::default()
    }
}

/// <p>Provides information about the status and settings of the SMS channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SmsChannelResponse {
    /// <p>The unique identifier for the application that the SMS channel applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when the SMS channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>Specifies whether the SMS channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>(Deprecated) An identifier for the SMS channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the SMS channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the SMS channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when the SMS channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The type of messaging or notification platform for the channel. For the SMS channel, this value is SMS.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The maximum number of promotional messages that you can send through the SMS channel each second.</p>
    pub promotional_messages_per_second: i32,
    /// <p>The identity that displays on recipients' devices when they receive messages from the SMS channel.</p>
    pub sender_id: std::option::Option<std::string::String>,
    /// <p>The registered short code to use when you send messages through the SMS channel.</p>
    pub short_code: std::option::Option<std::string::String>,
    /// <p>The maximum number of transactional messages that you can send through the SMS channel each second.</p>
    pub transactional_messages_per_second: i32,
    /// <p>The current version of the SMS channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for SmsChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SmsChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("enabled", &self.enabled);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("id", &self.id);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("platform", &self.platform);
        formatter.field(
            "promotional_messages_per_second",
            &self.promotional_messages_per_second,
        );
        formatter.field("sender_id", &self.sender_id);
        formatter.field("short_code", &self.short_code);
        formatter.field(
            "transactional_messages_per_second",
            &self.transactional_messages_per_second,
        );
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`SmsChannelResponse`](crate::model::SmsChannelResponse)
pub mod sms_channel_response {
    /// A builder for [`SmsChannelResponse`](crate::model::SmsChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) promotional_messages_per_second: std::option::Option<i32>,
        pub(crate) sender_id: std::option::Option<std::string::String>,
        pub(crate) short_code: std::option::Option<std::string::String>,
        pub(crate) transactional_messages_per_second: std::option::Option<i32>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the SMS channel applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the SMS channel applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the SMS channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the SMS channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>Specifies whether the SMS channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the SMS channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>(Deprecated) An identifier for the SMS channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the SMS channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the SMS channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the SMS channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the SMS channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the SMS channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the SMS channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the SMS channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the SMS channel, this value is SMS.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the SMS channel, this value is SMS.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The maximum number of promotional messages that you can send through the SMS channel each second.</p>
        pub fn promotional_messages_per_second(mut self, input: i32) -> Self {
            self.promotional_messages_per_second = Some(input);
            self
        }
        /// <p>The maximum number of promotional messages that you can send through the SMS channel each second.</p>
        pub fn set_promotional_messages_per_second(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.promotional_messages_per_second = input;
            self
        }
        /// <p>The identity that displays on recipients' devices when they receive messages from the SMS channel.</p>
        pub fn sender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sender_id = Some(input.into());
            self
        }
        /// <p>The identity that displays on recipients' devices when they receive messages from the SMS channel.</p>
        pub fn set_sender_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sender_id = input;
            self
        }
        /// <p>The registered short code to use when you send messages through the SMS channel.</p>
        pub fn short_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.short_code = Some(input.into());
            self
        }
        /// <p>The registered short code to use when you send messages through the SMS channel.</p>
        pub fn set_short_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.short_code = input;
            self
        }
        /// <p>The maximum number of transactional messages that you can send through the SMS channel each second.</p>
        pub fn transactional_messages_per_second(mut self, input: i32) -> Self {
            self.transactional_messages_per_second = Some(input);
            self
        }
        /// <p>The maximum number of transactional messages that you can send through the SMS channel each second.</p>
        pub fn set_transactional_messages_per_second(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.transactional_messages_per_second = input;
            self
        }
        /// <p>The current version of the SMS channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the SMS channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`SmsChannelResponse`](crate::model::SmsChannelResponse)
        pub fn build(self) -> crate::model::SmsChannelResponse {
            crate::model::SmsChannelResponse {
                application_id: self.application_id,
                creation_date: self.creation_date,
                enabled: self.enabled.unwrap_or_default(),
                has_credential: self.has_credential.unwrap_or_default(),
                id: self.id,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                platform: self.platform,
                promotional_messages_per_second: self
                    .promotional_messages_per_second
                    .unwrap_or_default(),
                sender_id: self.sender_id,
                short_code: self.short_code,
                transactional_messages_per_second: self
                    .transactional_messages_per_second
                    .unwrap_or_default(),
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl SmsChannelResponse {
    /// Creates a new builder-style object to manufacture [`SmsChannelResponse`](crate::model::SmsChannelResponse)
    pub fn builder() -> crate::model::sms_channel_response::Builder {
        crate::model::sms_channel_response::Builder::default()
    }
}

/// <p>Specifies the status and settings of the SMS channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SmsChannelRequest {
    /// <p>Specifies whether to enable the SMS channel for the application.</p>
    pub enabled: bool,
    /// <p>The identity that you want to display on recipients' devices when they receive messages from the SMS channel.</p>
    pub sender_id: std::option::Option<std::string::String>,
    /// <p>The registered short code that you want to use when you send messages through the SMS channel.</p>
    pub short_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SmsChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SmsChannelRequest");
        formatter.field("enabled", &self.enabled);
        formatter.field("sender_id", &self.sender_id);
        formatter.field("short_code", &self.short_code);
        formatter.finish()
    }
}
/// See [`SmsChannelRequest`](crate::model::SmsChannelRequest)
pub mod sms_channel_request {
    /// A builder for [`SmsChannelRequest`](crate::model::SmsChannelRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) sender_id: std::option::Option<std::string::String>,
        pub(crate) short_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies whether to enable the SMS channel for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether to enable the SMS channel for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The identity that you want to display on recipients' devices when they receive messages from the SMS channel.</p>
        pub fn sender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sender_id = Some(input.into());
            self
        }
        /// <p>The identity that you want to display on recipients' devices when they receive messages from the SMS channel.</p>
        pub fn set_sender_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sender_id = input;
            self
        }
        /// <p>The registered short code that you want to use when you send messages through the SMS channel.</p>
        pub fn short_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.short_code = Some(input.into());
            self
        }
        /// <p>The registered short code that you want to use when you send messages through the SMS channel.</p>
        pub fn set_short_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.short_code = input;
            self
        }
        /// Consumes the builder and constructs a [`SmsChannelRequest`](crate::model::SmsChannelRequest)
        pub fn build(self) -> crate::model::SmsChannelRequest {
            crate::model::SmsChannelRequest {
                enabled: self.enabled.unwrap_or_default(),
                sender_id: self.sender_id,
                short_code: self.short_code,
            }
        }
    }
}
impl SmsChannelRequest {
    /// Creates a new builder-style object to manufacture [`SmsChannelRequest`](crate::model::SmsChannelRequest)
    pub fn builder() -> crate::model::sms_channel_request::Builder {
        crate::model::sms_channel_request::Builder::default()
    }
}

/// <p>Provides information about the configuration, dimension, and other settings for a segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentResponse {
    /// <p>The unique identifier for the application that the segment is associated with.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the segment.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The date and time when the segment was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The dimension settings for the segment.</p>
    pub dimensions: std::option::Option<crate::model::SegmentDimensions>,
    /// <p>The unique identifier for the segment.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The settings for the import job that's associated with the segment.</p>
    pub import_definition: std::option::Option<crate::model::SegmentImportResource>,
    /// <p>The date and time when the segment was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The name of the segment.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A list of one or more segment groups that apply to the segment. Each segment group consists of zero or more base segments and the dimensions that are applied to those base segments.</p>
    pub segment_groups: std::option::Option<crate::model::SegmentGroupList>,
    /// <p>The segment type. Valid values are:</p> <ul><li><p>DIMENSIONAL - A dynamic segment, which is a segment that uses selection criteria that you specify and is based on endpoint data that's reported by your app. Dynamic segments can change over time.</p></li> <li><p>IMPORT - A static segment, which is a segment that uses selection criteria that you specify and is based on endpoint definitions that you import from a file. Imported segments are static; they don't change over time.</p></li></ul>
    pub segment_type: std::option::Option<crate::model::SegmentType>,
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the segment. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The version number of the segment.</p>
    pub version: i32,
}
impl std::fmt::Debug for SegmentResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("arn", &self.arn);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("dimensions", &self.dimensions);
        formatter.field("id", &self.id);
        formatter.field("import_definition", &self.import_definition);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("name", &self.name);
        formatter.field("segment_groups", &self.segment_groups);
        formatter.field("segment_type", &self.segment_type);
        formatter.field("tags", &self.tags);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`SegmentResponse`](crate::model::SegmentResponse)
pub mod segment_response {
    /// A builder for [`SegmentResponse`](crate::model::SegmentResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) dimensions: std::option::Option<crate::model::SegmentDimensions>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) import_definition: std::option::Option<crate::model::SegmentImportResource>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) segment_groups: std::option::Option<crate::model::SegmentGroupList>,
        pub(crate) segment_type: std::option::Option<crate::model::SegmentType>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the segment is associated with.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the segment is associated with.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the segment.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the segment.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The date and time when the segment was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time when the segment was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The dimension settings for the segment.</p>
        pub fn dimensions(mut self, input: crate::model::SegmentDimensions) -> Self {
            self.dimensions = Some(input);
            self
        }
        /// <p>The dimension settings for the segment.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::SegmentDimensions>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The unique identifier for the segment.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the segment.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The settings for the import job that's associated with the segment.</p>
        pub fn import_definition(mut self, input: crate::model::SegmentImportResource) -> Self {
            self.import_definition = Some(input);
            self
        }
        /// <p>The settings for the import job that's associated with the segment.</p>
        pub fn set_import_definition(
            mut self,
            input: std::option::Option<crate::model::SegmentImportResource>,
        ) -> Self {
            self.import_definition = input;
            self
        }
        /// <p>The date and time when the segment was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time when the segment was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The name of the segment.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the segment.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>A list of one or more segment groups that apply to the segment. Each segment group consists of zero or more base segments and the dimensions that are applied to those base segments.</p>
        pub fn segment_groups(mut self, input: crate::model::SegmentGroupList) -> Self {
            self.segment_groups = Some(input);
            self
        }
        /// <p>A list of one or more segment groups that apply to the segment. Each segment group consists of zero or more base segments and the dimensions that are applied to those base segments.</p>
        pub fn set_segment_groups(
            mut self,
            input: std::option::Option<crate::model::SegmentGroupList>,
        ) -> Self {
            self.segment_groups = input;
            self
        }
        /// <p>The segment type. Valid values are:</p> <ul><li><p>DIMENSIONAL - A dynamic segment, which is a segment that uses selection criteria that you specify and is based on endpoint data that's reported by your app. Dynamic segments can change over time.</p></li> <li><p>IMPORT - A static segment, which is a segment that uses selection criteria that you specify and is based on endpoint definitions that you import from a file. Imported segments are static; they don't change over time.</p></li></ul>
        pub fn segment_type(mut self, input: crate::model::SegmentType) -> Self {
            self.segment_type = Some(input);
            self
        }
        /// <p>The segment type. Valid values are:</p> <ul><li><p>DIMENSIONAL - A dynamic segment, which is a segment that uses selection criteria that you specify and is based on endpoint data that's reported by your app. Dynamic segments can change over time.</p></li> <li><p>IMPORT - A static segment, which is a segment that uses selection criteria that you specify and is based on endpoint definitions that you import from a file. Imported segments are static; they don't change over time.</p></li></ul>
        pub fn set_segment_type(
            mut self,
            input: std::option::Option<crate::model::SegmentType>,
        ) -> Self {
            self.segment_type = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the segment. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the segment. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The version number of the segment.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version number of the segment.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentResponse`](crate::model::SegmentResponse)
        pub fn build(self) -> crate::model::SegmentResponse {
            crate::model::SegmentResponse {
                application_id: self.application_id,
                arn: self.arn,
                creation_date: self.creation_date,
                dimensions: self.dimensions,
                id: self.id,
                import_definition: self.import_definition,
                last_modified_date: self.last_modified_date,
                name: self.name,
                segment_groups: self.segment_groups,
                segment_type: self.segment_type,
                tags: self.tags,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl SegmentResponse {
    /// Creates a new builder-style object to manufacture [`SegmentResponse`](crate::model::SegmentResponse)
    pub fn builder() -> crate::model::segment_response::Builder {
        crate::model::segment_response::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SegmentType {
    #[allow(missing_docs)] // documentation missing in model
    Dimensional,
    #[allow(missing_docs)] // documentation missing in model
    Import,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SegmentType {
    fn from(s: &str) -> Self {
        match s {
            "DIMENSIONAL" => SegmentType::Dimensional,
            "IMPORT" => SegmentType::Import,
            other => SegmentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SegmentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SegmentType::from(s))
    }
}
impl SegmentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SegmentType::Dimensional => "DIMENSIONAL",
            SegmentType::Import => "IMPORT",
            SegmentType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DIMENSIONAL", "IMPORT"]
    }
}
impl AsRef<str> for SegmentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the settings that define the relationships between segment groups for a segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentGroupList {
    /// <p>An array that defines the set of segment criteria to evaluate when handling segment groups for the segment.</p>
    pub groups: std::option::Option<std::vec::Vec<crate::model::SegmentGroup>>,
    /// <p>Specifies how to handle multiple segment groups for the segment. For example, if the segment includes three segment groups, whether the resulting segment includes endpoints that match all, any, or none of the segment groups.</p>
    pub include: std::option::Option<crate::model::Include>,
}
impl std::fmt::Debug for SegmentGroupList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentGroupList");
        formatter.field("groups", &self.groups);
        formatter.field("include", &self.include);
        formatter.finish()
    }
}
/// See [`SegmentGroupList`](crate::model::SegmentGroupList)
pub mod segment_group_list {
    /// A builder for [`SegmentGroupList`](crate::model::SegmentGroupList)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) groups: std::option::Option<std::vec::Vec<crate::model::SegmentGroup>>,
        pub(crate) include: std::option::Option<crate::model::Include>,
    }
    impl Builder {
        /// Appends an item to `groups`.
        ///
        /// To override the contents of this collection use [`set_groups`](Self::set_groups).
        ///
        /// <p>An array that defines the set of segment criteria to evaluate when handling segment groups for the segment.</p>
        pub fn groups(mut self, input: impl Into<crate::model::SegmentGroup>) -> Self {
            let mut v = self.groups.unwrap_or_default();
            v.push(input.into());
            self.groups = Some(v);
            self
        }
        /// <p>An array that defines the set of segment criteria to evaluate when handling segment groups for the segment.</p>
        pub fn set_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentGroup>>,
        ) -> Self {
            self.groups = input;
            self
        }
        /// <p>Specifies how to handle multiple segment groups for the segment. For example, if the segment includes three segment groups, whether the resulting segment includes endpoints that match all, any, or none of the segment groups.</p>
        pub fn include(mut self, input: crate::model::Include) -> Self {
            self.include = Some(input);
            self
        }
        /// <p>Specifies how to handle multiple segment groups for the segment. For example, if the segment includes three segment groups, whether the resulting segment includes endpoints that match all, any, or none of the segment groups.</p>
        pub fn set_include(mut self, input: std::option::Option<crate::model::Include>) -> Self {
            self.include = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentGroupList`](crate::model::SegmentGroupList)
        pub fn build(self) -> crate::model::SegmentGroupList {
            crate::model::SegmentGroupList {
                groups: self.groups,
                include: self.include,
            }
        }
    }
}
impl SegmentGroupList {
    /// Creates a new builder-style object to manufacture [`SegmentGroupList`](crate::model::SegmentGroupList)
    pub fn builder() -> crate::model::segment_group_list::Builder {
        crate::model::segment_group_list::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Include {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Any,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Include {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => Include::All,
            "ANY" => Include::Any,
            "NONE" => Include::None,
            other => Include::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Include {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Include::from(s))
    }
}
impl Include {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Include::All => "ALL",
            Include::Any => "ANY",
            Include::None => "NONE",
            Include::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ALL", "ANY", "NONE"]
    }
}
impl AsRef<str> for Include {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the base segments and dimensions for a segment, and the relationships between these base segments and dimensions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentGroup {
    /// <p>An array that defines the dimensions for the segment.</p>
    pub dimensions: std::option::Option<std::vec::Vec<crate::model::SegmentDimensions>>,
    /// <p>The base segment to build the segment on. A base segment, also referred to as a <i>source segment</i>, defines the initial population of endpoints for a segment. When you add dimensions to a segment, Amazon Pinpoint filters the base segment by using the dimensions that you specify.</p> <p>You can specify more than one dimensional segment or only one imported segment. If you specify an imported segment, the Amazon Pinpoint console displays a segment size estimate that indicates the size of the imported segment without any filters applied to it.</p>
    pub source_segments: std::option::Option<std::vec::Vec<crate::model::SegmentReference>>,
    /// <p>Specifies how to handle multiple base segments for the segment. For example, if you specify three base segments for the segment, whether the resulting segment is based on all, any, or none of the base segments.</p>
    pub source_type: std::option::Option<crate::model::SourceType>,
    /// <p>Specifies how to handle multiple dimensions for the segment. For example, if you specify three dimensions for the segment, whether the resulting segment includes endpoints that match all, any, or none of the dimensions.</p>
    pub r#type: std::option::Option<crate::model::Type>,
}
impl std::fmt::Debug for SegmentGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentGroup");
        formatter.field("dimensions", &self.dimensions);
        formatter.field("source_segments", &self.source_segments);
        formatter.field("source_type", &self.source_type);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`SegmentGroup`](crate::model::SegmentGroup)
pub mod segment_group {
    /// A builder for [`SegmentGroup`](crate::model::SegmentGroup)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimensions: std::option::Option<std::vec::Vec<crate::model::SegmentDimensions>>,
        pub(crate) source_segments:
            std::option::Option<std::vec::Vec<crate::model::SegmentReference>>,
        pub(crate) source_type: std::option::Option<crate::model::SourceType>,
        pub(crate) r#type: std::option::Option<crate::model::Type>,
    }
    impl Builder {
        /// Appends an item to `dimensions`.
        ///
        /// To override the contents of this collection use [`set_dimensions`](Self::set_dimensions).
        ///
        /// <p>An array that defines the dimensions for the segment.</p>
        pub fn dimensions(mut self, input: impl Into<crate::model::SegmentDimensions>) -> Self {
            let mut v = self.dimensions.unwrap_or_default();
            v.push(input.into());
            self.dimensions = Some(v);
            self
        }
        /// <p>An array that defines the dimensions for the segment.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentDimensions>>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// Appends an item to `source_segments`.
        ///
        /// To override the contents of this collection use [`set_source_segments`](Self::set_source_segments).
        ///
        /// <p>The base segment to build the segment on. A base segment, also referred to as a <i>source segment</i>, defines the initial population of endpoints for a segment. When you add dimensions to a segment, Amazon Pinpoint filters the base segment by using the dimensions that you specify.</p> <p>You can specify more than one dimensional segment or only one imported segment. If you specify an imported segment, the Amazon Pinpoint console displays a segment size estimate that indicates the size of the imported segment without any filters applied to it.</p>
        pub fn source_segments(mut self, input: impl Into<crate::model::SegmentReference>) -> Self {
            let mut v = self.source_segments.unwrap_or_default();
            v.push(input.into());
            self.source_segments = Some(v);
            self
        }
        /// <p>The base segment to build the segment on. A base segment, also referred to as a <i>source segment</i>, defines the initial population of endpoints for a segment. When you add dimensions to a segment, Amazon Pinpoint filters the base segment by using the dimensions that you specify.</p> <p>You can specify more than one dimensional segment or only one imported segment. If you specify an imported segment, the Amazon Pinpoint console displays a segment size estimate that indicates the size of the imported segment without any filters applied to it.</p>
        pub fn set_source_segments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentReference>>,
        ) -> Self {
            self.source_segments = input;
            self
        }
        /// <p>Specifies how to handle multiple base segments for the segment. For example, if you specify three base segments for the segment, whether the resulting segment is based on all, any, or none of the base segments.</p>
        pub fn source_type(mut self, input: crate::model::SourceType) -> Self {
            self.source_type = Some(input);
            self
        }
        /// <p>Specifies how to handle multiple base segments for the segment. For example, if you specify three base segments for the segment, whether the resulting segment is based on all, any, or none of the base segments.</p>
        pub fn set_source_type(
            mut self,
            input: std::option::Option<crate::model::SourceType>,
        ) -> Self {
            self.source_type = input;
            self
        }
        /// <p>Specifies how to handle multiple dimensions for the segment. For example, if you specify three dimensions for the segment, whether the resulting segment includes endpoints that match all, any, or none of the dimensions.</p>
        pub fn r#type(mut self, input: crate::model::Type) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Specifies how to handle multiple dimensions for the segment. For example, if you specify three dimensions for the segment, whether the resulting segment includes endpoints that match all, any, or none of the dimensions.</p>
        pub fn set_type(mut self, input: std::option::Option<crate::model::Type>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentGroup`](crate::model::SegmentGroup)
        pub fn build(self) -> crate::model::SegmentGroup {
            crate::model::SegmentGroup {
                dimensions: self.dimensions,
                source_segments: self.source_segments,
                source_type: self.source_type,
                r#type: self.r#type,
            }
        }
    }
}
impl SegmentGroup {
    /// Creates a new builder-style object to manufacture [`SegmentGroup`](crate::model::SegmentGroup)
    pub fn builder() -> crate::model::segment_group::Builder {
        crate::model::segment_group::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Type {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Any,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Type {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => Type::All,
            "ANY" => Type::Any,
            "NONE" => Type::None,
            other => Type::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Type {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Type::from(s))
    }
}
impl Type {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Type::All => "ALL",
            Type::Any => "ANY",
            Type::None => "NONE",
            Type::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ALL", "ANY", "NONE"]
    }
}
impl AsRef<str> for Type {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SourceType {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Any,
    #[allow(missing_docs)] // documentation missing in model
    None,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for SourceType {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => SourceType::All,
            "ANY" => SourceType::Any,
            "NONE" => SourceType::None,
            other => SourceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for SourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SourceType::from(s))
    }
}
impl SourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SourceType::All => "ALL",
            SourceType::Any => "ANY",
            SourceType::None => "NONE",
            SourceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ALL", "ANY", "NONE"]
    }
}
impl AsRef<str> for SourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the segment identifier and version of a segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentReference {
    /// <p>The unique identifier for the segment.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The version number of the segment.</p>
    pub version: i32,
}
impl std::fmt::Debug for SegmentReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentReference");
        formatter.field("id", &self.id);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`SegmentReference`](crate::model::SegmentReference)
pub mod segment_reference {
    /// A builder for [`SegmentReference`](crate::model::SegmentReference)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the segment.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the segment.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The version number of the segment.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version number of the segment.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentReference`](crate::model::SegmentReference)
        pub fn build(self) -> crate::model::SegmentReference {
            crate::model::SegmentReference {
                id: self.id,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl SegmentReference {
    /// Creates a new builder-style object to manufacture [`SegmentReference`](crate::model::SegmentReference)
    pub fn builder() -> crate::model::segment_reference::Builder {
        crate::model::segment_reference::Builder::default()
    }
}

/// <p>Specifies the dimension settings for a segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentDimensions {
    /// <p>One or more custom attributes to use as criteria for the segment.</p>
    pub attributes: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeDimension>,
    >,
    /// <p>The behavior-based criteria, such as how recently users have used your app, for the segment.</p>
    pub behavior: std::option::Option<crate::model::SegmentBehaviors>,
    /// <p>The demographic-based criteria, such as device platform, for the segment.</p>
    pub demographic: std::option::Option<crate::model::SegmentDemographics>,
    /// <p>The location-based criteria, such as region or GPS coordinates, for the segment.</p>
    pub location: std::option::Option<crate::model::SegmentLocation>,
    /// <p>One or more custom metrics to use as criteria for the segment.</p>
    pub metrics: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::MetricDimension>,
    >,
    /// <p>One or more custom user attributes to use as criteria for the segment.</p>
    pub user_attributes: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeDimension>,
    >,
}
impl std::fmt::Debug for SegmentDimensions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentDimensions");
        formatter.field("attributes", &self.attributes);
        formatter.field("behavior", &self.behavior);
        formatter.field("demographic", &self.demographic);
        formatter.field("location", &self.location);
        formatter.field("metrics", &self.metrics);
        formatter.field("user_attributes", &self.user_attributes);
        formatter.finish()
    }
}
/// See [`SegmentDimensions`](crate::model::SegmentDimensions)
pub mod segment_dimensions {
    /// A builder for [`SegmentDimensions`](crate::model::SegmentDimensions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeDimension>,
        >,
        pub(crate) behavior: std::option::Option<crate::model::SegmentBehaviors>,
        pub(crate) demographic: std::option::Option<crate::model::SegmentDemographics>,
        pub(crate) location: std::option::Option<crate::model::SegmentLocation>,
        pub(crate) metrics: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::MetricDimension>,
        >,
        pub(crate) user_attributes: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeDimension>,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>One or more custom attributes to use as criteria for the segment.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeDimension>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>One or more custom attributes to use as criteria for the segment.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeDimension>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The behavior-based criteria, such as how recently users have used your app, for the segment.</p>
        pub fn behavior(mut self, input: crate::model::SegmentBehaviors) -> Self {
            self.behavior = Some(input);
            self
        }
        /// <p>The behavior-based criteria, such as how recently users have used your app, for the segment.</p>
        pub fn set_behavior(
            mut self,
            input: std::option::Option<crate::model::SegmentBehaviors>,
        ) -> Self {
            self.behavior = input;
            self
        }
        /// <p>The demographic-based criteria, such as device platform, for the segment.</p>
        pub fn demographic(mut self, input: crate::model::SegmentDemographics) -> Self {
            self.demographic = Some(input);
            self
        }
        /// <p>The demographic-based criteria, such as device platform, for the segment.</p>
        pub fn set_demographic(
            mut self,
            input: std::option::Option<crate::model::SegmentDemographics>,
        ) -> Self {
            self.demographic = input;
            self
        }
        /// <p>The location-based criteria, such as region or GPS coordinates, for the segment.</p>
        pub fn location(mut self, input: crate::model::SegmentLocation) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The location-based criteria, such as region or GPS coordinates, for the segment.</p>
        pub fn set_location(
            mut self,
            input: std::option::Option<crate::model::SegmentLocation>,
        ) -> Self {
            self.location = input;
            self
        }
        /// Adds a key-value pair to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>One or more custom metrics to use as criteria for the segment.</p>
        pub fn metrics(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MetricDimension>,
        ) -> Self {
            let mut hash_map = self.metrics.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metrics = Some(hash_map);
            self
        }
        /// <p>One or more custom metrics to use as criteria for the segment.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::MetricDimension>,
            >,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// Adds a key-value pair to `user_attributes`.
        ///
        /// To override the contents of this collection use [`set_user_attributes`](Self::set_user_attributes).
        ///
        /// <p>One or more custom user attributes to use as criteria for the segment.</p>
        pub fn user_attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeDimension>,
        ) -> Self {
            let mut hash_map = self.user_attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.user_attributes = Some(hash_map);
            self
        }
        /// <p>One or more custom user attributes to use as criteria for the segment.</p>
        pub fn set_user_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeDimension>,
            >,
        ) -> Self {
            self.user_attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentDimensions`](crate::model::SegmentDimensions)
        pub fn build(self) -> crate::model::SegmentDimensions {
            crate::model::SegmentDimensions {
                attributes: self.attributes,
                behavior: self.behavior,
                demographic: self.demographic,
                location: self.location,
                metrics: self.metrics,
                user_attributes: self.user_attributes,
            }
        }
    }
}
impl SegmentDimensions {
    /// Creates a new builder-style object to manufacture [`SegmentDimensions`](crate::model::SegmentDimensions)
    pub fn builder() -> crate::model::segment_dimensions::Builder {
        crate::model::segment_dimensions::Builder::default()
    }
}

/// <p>Specifies attribute-based criteria for including or excluding endpoints from a segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttributeDimension {
    /// <p>The type of segment dimension to use. Valid values are: <ul><li>INCLUSIVE - endpoints that have attributes matching the values are included in the segment.</li><li>EXCLUSIVE - endpoints that have attributes matching the values are excluded in the segment.</li><li>CONTAINS - endpoints that have attributes' substrings match the values are included in the segment.</li><li>BEFORE - endpoints with attributes read as ISO_INSTANT datetimes before the value are included in the segment.</li><li>AFTER - endpoints with attributes read as ISO_INSTANT datetimes after the value are included in the segment.</li><li>ON - endpoints with attributes read as ISO_INSTANT dates on the value are included in the segment. Time is ignored in this comparison.</li><li>BETWEEN - endpoints with attributes read as ISO_INSTANT datetimes between the values are included in the segment.</li></p>
    pub attribute_type: std::option::Option<crate::model::AttributeType>,
    /// <p>The criteria values to use for the segment dimension. Depending on the value of the AttributeType property, endpoints are included or excluded from the segment if their attribute values match the criteria values.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for AttributeDimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttributeDimension");
        formatter.field("attribute_type", &self.attribute_type);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`AttributeDimension`](crate::model::AttributeDimension)
pub mod attribute_dimension {
    /// A builder for [`AttributeDimension`](crate::model::AttributeDimension)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_type: std::option::Option<crate::model::AttributeType>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The type of segment dimension to use. Valid values are: <ul><li>INCLUSIVE - endpoints that have attributes matching the values are included in the segment.</li><li>EXCLUSIVE - endpoints that have attributes matching the values are excluded in the segment.</li><li>CONTAINS - endpoints that have attributes' substrings match the values are included in the segment.</li><li>BEFORE - endpoints with attributes read as ISO_INSTANT datetimes before the value are included in the segment.</li><li>AFTER - endpoints with attributes read as ISO_INSTANT datetimes after the value are included in the segment.</li><li>ON - endpoints with attributes read as ISO_INSTANT dates on the value are included in the segment. Time is ignored in this comparison.</li><li>BETWEEN - endpoints with attributes read as ISO_INSTANT datetimes between the values are included in the segment.</li></p>
        pub fn attribute_type(mut self, input: crate::model::AttributeType) -> Self {
            self.attribute_type = Some(input);
            self
        }
        /// <p>The type of segment dimension to use. Valid values are: <ul><li>INCLUSIVE - endpoints that have attributes matching the values are included in the segment.</li><li>EXCLUSIVE - endpoints that have attributes matching the values are excluded in the segment.</li><li>CONTAINS - endpoints that have attributes' substrings match the values are included in the segment.</li><li>BEFORE - endpoints with attributes read as ISO_INSTANT datetimes before the value are included in the segment.</li><li>AFTER - endpoints with attributes read as ISO_INSTANT datetimes after the value are included in the segment.</li><li>ON - endpoints with attributes read as ISO_INSTANT dates on the value are included in the segment. Time is ignored in this comparison.</li><li>BETWEEN - endpoints with attributes read as ISO_INSTANT datetimes between the values are included in the segment.</li></p>
        pub fn set_attribute_type(
            mut self,
            input: std::option::Option<crate::model::AttributeType>,
        ) -> Self {
            self.attribute_type = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The criteria values to use for the segment dimension. Depending on the value of the AttributeType property, endpoints are included or excluded from the segment if their attribute values match the criteria values.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The criteria values to use for the segment dimension. Depending on the value of the AttributeType property, endpoints are included or excluded from the segment if their attribute values match the criteria values.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`AttributeDimension`](crate::model::AttributeDimension)
        pub fn build(self) -> crate::model::AttributeDimension {
            crate::model::AttributeDimension {
                attribute_type: self.attribute_type,
                values: self.values,
            }
        }
    }
}
impl AttributeDimension {
    /// Creates a new builder-style object to manufacture [`AttributeDimension`](crate::model::AttributeDimension)
    pub fn builder() -> crate::model::attribute_dimension::Builder {
        crate::model::attribute_dimension::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AttributeType {
    #[allow(missing_docs)] // documentation missing in model
    After,
    #[allow(missing_docs)] // documentation missing in model
    Before,
    #[allow(missing_docs)] // documentation missing in model
    Between,
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    Exclusive,
    #[allow(missing_docs)] // documentation missing in model
    Inclusive,
    #[allow(missing_docs)] // documentation missing in model
    On,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for AttributeType {
    fn from(s: &str) -> Self {
        match s {
            "AFTER" => AttributeType::After,
            "BEFORE" => AttributeType::Before,
            "BETWEEN" => AttributeType::Between,
            "CONTAINS" => AttributeType::Contains,
            "EXCLUSIVE" => AttributeType::Exclusive,
            "INCLUSIVE" => AttributeType::Inclusive,
            "ON" => AttributeType::On,
            other => AttributeType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for AttributeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AttributeType::from(s))
    }
}
impl AttributeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AttributeType::After => "AFTER",
            AttributeType::Before => "BEFORE",
            AttributeType::Between => "BETWEEN",
            AttributeType::Contains => "CONTAINS",
            AttributeType::Exclusive => "EXCLUSIVE",
            AttributeType::Inclusive => "INCLUSIVE",
            AttributeType::On => "ON",
            AttributeType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AFTER",
            "BEFORE",
            "BETWEEN",
            "CONTAINS",
            "EXCLUSIVE",
            "INCLUSIVE",
            "ON",
        ]
    }
}
impl AsRef<str> for AttributeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies metric-based criteria for including or excluding endpoints from a segment. These criteria derive from custom metrics that you define for endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MetricDimension {
    /// <p>The operator to use when comparing metric values. Valid values are: GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUAL, LESS_THAN_OR_EQUAL, and EQUAL.</p>
    pub comparison_operator: std::option::Option<std::string::String>,
    /// <p>The value to compare.</p>
    pub value: f64,
}
impl std::fmt::Debug for MetricDimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MetricDimension");
        formatter.field("comparison_operator", &self.comparison_operator);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`MetricDimension`](crate::model::MetricDimension)
pub mod metric_dimension {
    /// A builder for [`MetricDimension`](crate::model::MetricDimension)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comparison_operator: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The operator to use when comparing metric values. Valid values are: GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUAL, LESS_THAN_OR_EQUAL, and EQUAL.</p>
        pub fn comparison_operator(mut self, input: impl Into<std::string::String>) -> Self {
            self.comparison_operator = Some(input.into());
            self
        }
        /// <p>The operator to use when comparing metric values. Valid values are: GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUAL, LESS_THAN_OR_EQUAL, and EQUAL.</p>
        pub fn set_comparison_operator(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.comparison_operator = input;
            self
        }
        /// <p>The value to compare.</p>
        pub fn value(mut self, input: f64) -> Self {
            self.value = Some(input);
            self
        }
        /// <p>The value to compare.</p>
        pub fn set_value(mut self, input: std::option::Option<f64>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`MetricDimension`](crate::model::MetricDimension)
        pub fn build(self) -> crate::model::MetricDimension {
            crate::model::MetricDimension {
                comparison_operator: self.comparison_operator,
                value: self.value.unwrap_or_default(),
            }
        }
    }
}
impl MetricDimension {
    /// Creates a new builder-style object to manufacture [`MetricDimension`](crate::model::MetricDimension)
    pub fn builder() -> crate::model::metric_dimension::Builder {
        crate::model::metric_dimension::Builder::default()
    }
}

/// <p>Specifies geographical dimension settings for a segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentLocation {
    /// <p>The country or region code, in ISO 3166-1 alpha-2 format, for the segment.</p>
    pub country: std::option::Option<crate::model::SetDimension>,
    /// <p>The GPS location and range for the segment.</p>
    pub gps_point: std::option::Option<crate::model::GpsPointDimension>,
}
impl std::fmt::Debug for SegmentLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentLocation");
        formatter.field("country", &self.country);
        formatter.field("gps_point", &self.gps_point);
        formatter.finish()
    }
}
/// See [`SegmentLocation`](crate::model::SegmentLocation)
pub mod segment_location {
    /// A builder for [`SegmentLocation`](crate::model::SegmentLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) country: std::option::Option<crate::model::SetDimension>,
        pub(crate) gps_point: std::option::Option<crate::model::GpsPointDimension>,
    }
    impl Builder {
        /// <p>The country or region code, in ISO 3166-1 alpha-2 format, for the segment.</p>
        pub fn country(mut self, input: crate::model::SetDimension) -> Self {
            self.country = Some(input);
            self
        }
        /// <p>The country or region code, in ISO 3166-1 alpha-2 format, for the segment.</p>
        pub fn set_country(
            mut self,
            input: std::option::Option<crate::model::SetDimension>,
        ) -> Self {
            self.country = input;
            self
        }
        /// <p>The GPS location and range for the segment.</p>
        pub fn gps_point(mut self, input: crate::model::GpsPointDimension) -> Self {
            self.gps_point = Some(input);
            self
        }
        /// <p>The GPS location and range for the segment.</p>
        pub fn set_gps_point(
            mut self,
            input: std::option::Option<crate::model::GpsPointDimension>,
        ) -> Self {
            self.gps_point = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentLocation`](crate::model::SegmentLocation)
        pub fn build(self) -> crate::model::SegmentLocation {
            crate::model::SegmentLocation {
                country: self.country,
                gps_point: self.gps_point,
            }
        }
    }
}
impl SegmentLocation {
    /// Creates a new builder-style object to manufacture [`SegmentLocation`](crate::model::SegmentLocation)
    pub fn builder() -> crate::model::segment_location::Builder {
        crate::model::segment_location::Builder::default()
    }
}

/// <p>Specifies GPS-based criteria for including or excluding endpoints from a segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GpsPointDimension {
    /// <p>The GPS coordinates to measure distance from.</p>
    pub coordinates: std::option::Option<crate::model::GpsCoordinates>,
    /// <p>The range, in kilometers, from the GPS coordinates.</p>
    pub range_in_kilometers: f64,
}
impl std::fmt::Debug for GpsPointDimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GpsPointDimension");
        formatter.field("coordinates", &self.coordinates);
        formatter.field("range_in_kilometers", &self.range_in_kilometers);
        formatter.finish()
    }
}
/// See [`GpsPointDimension`](crate::model::GpsPointDimension)
pub mod gps_point_dimension {
    /// A builder for [`GpsPointDimension`](crate::model::GpsPointDimension)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) coordinates: std::option::Option<crate::model::GpsCoordinates>,
        pub(crate) range_in_kilometers: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The GPS coordinates to measure distance from.</p>
        pub fn coordinates(mut self, input: crate::model::GpsCoordinates) -> Self {
            self.coordinates = Some(input);
            self
        }
        /// <p>The GPS coordinates to measure distance from.</p>
        pub fn set_coordinates(
            mut self,
            input: std::option::Option<crate::model::GpsCoordinates>,
        ) -> Self {
            self.coordinates = input;
            self
        }
        /// <p>The range, in kilometers, from the GPS coordinates.</p>
        pub fn range_in_kilometers(mut self, input: f64) -> Self {
            self.range_in_kilometers = Some(input);
            self
        }
        /// <p>The range, in kilometers, from the GPS coordinates.</p>
        pub fn set_range_in_kilometers(mut self, input: std::option::Option<f64>) -> Self {
            self.range_in_kilometers = input;
            self
        }
        /// Consumes the builder and constructs a [`GpsPointDimension`](crate::model::GpsPointDimension)
        pub fn build(self) -> crate::model::GpsPointDimension {
            crate::model::GpsPointDimension {
                coordinates: self.coordinates,
                range_in_kilometers: self.range_in_kilometers.unwrap_or_default(),
            }
        }
    }
}
impl GpsPointDimension {
    /// Creates a new builder-style object to manufacture [`GpsPointDimension`](crate::model::GpsPointDimension)
    pub fn builder() -> crate::model::gps_point_dimension::Builder {
        crate::model::gps_point_dimension::Builder::default()
    }
}

/// <p>Specifies the GPS coordinates of a location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GpsCoordinates {
    /// <p>The latitude coordinate of the location.</p>
    pub latitude: f64,
    /// <p>The longitude coordinate of the location.</p>
    pub longitude: f64,
}
impl std::fmt::Debug for GpsCoordinates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GpsCoordinates");
        formatter.field("latitude", &self.latitude);
        formatter.field("longitude", &self.longitude);
        formatter.finish()
    }
}
/// See [`GpsCoordinates`](crate::model::GpsCoordinates)
pub mod gps_coordinates {
    /// A builder for [`GpsCoordinates`](crate::model::GpsCoordinates)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) latitude: std::option::Option<f64>,
        pub(crate) longitude: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The latitude coordinate of the location.</p>
        pub fn latitude(mut self, input: f64) -> Self {
            self.latitude = Some(input);
            self
        }
        /// <p>The latitude coordinate of the location.</p>
        pub fn set_latitude(mut self, input: std::option::Option<f64>) -> Self {
            self.latitude = input;
            self
        }
        /// <p>The longitude coordinate of the location.</p>
        pub fn longitude(mut self, input: f64) -> Self {
            self.longitude = Some(input);
            self
        }
        /// <p>The longitude coordinate of the location.</p>
        pub fn set_longitude(mut self, input: std::option::Option<f64>) -> Self {
            self.longitude = input;
            self
        }
        /// Consumes the builder and constructs a [`GpsCoordinates`](crate::model::GpsCoordinates)
        pub fn build(self) -> crate::model::GpsCoordinates {
            crate::model::GpsCoordinates {
                latitude: self.latitude.unwrap_or_default(),
                longitude: self.longitude.unwrap_or_default(),
            }
        }
    }
}
impl GpsCoordinates {
    /// Creates a new builder-style object to manufacture [`GpsCoordinates`](crate::model::GpsCoordinates)
    pub fn builder() -> crate::model::gps_coordinates::Builder {
        crate::model::gps_coordinates::Builder::default()
    }
}

/// <p>Specifies the dimension type and values for a segment dimension.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SetDimension {
    /// <p>The type of segment dimension to use. Valid values are: INCLUSIVE, endpoints that match the criteria are included in the segment; and, EXCLUSIVE, endpoints that match the criteria are excluded from the segment.</p>
    pub dimension_type: std::option::Option<crate::model::DimensionType>,
    /// <p>The criteria values to use for the segment dimension. Depending on the value of the DimensionType property, endpoints are included or excluded from the segment if their values match the criteria values.</p>
    pub values: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for SetDimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SetDimension");
        formatter.field("dimension_type", &self.dimension_type);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`SetDimension`](crate::model::SetDimension)
pub mod set_dimension {
    /// A builder for [`SetDimension`](crate::model::SetDimension)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimension_type: std::option::Option<crate::model::DimensionType>,
        pub(crate) values: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The type of segment dimension to use. Valid values are: INCLUSIVE, endpoints that match the criteria are included in the segment; and, EXCLUSIVE, endpoints that match the criteria are excluded from the segment.</p>
        pub fn dimension_type(mut self, input: crate::model::DimensionType) -> Self {
            self.dimension_type = Some(input);
            self
        }
        /// <p>The type of segment dimension to use. Valid values are: INCLUSIVE, endpoints that match the criteria are included in the segment; and, EXCLUSIVE, endpoints that match the criteria are excluded from the segment.</p>
        pub fn set_dimension_type(
            mut self,
            input: std::option::Option<crate::model::DimensionType>,
        ) -> Self {
            self.dimension_type = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>The criteria values to use for the segment dimension. Depending on the value of the DimensionType property, endpoints are included or excluded from the segment if their values match the criteria values.</p>
        pub fn values(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>The criteria values to use for the segment dimension. Depending on the value of the DimensionType property, endpoints are included or excluded from the segment if their values match the criteria values.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`SetDimension`](crate::model::SetDimension)
        pub fn build(self) -> crate::model::SetDimension {
            crate::model::SetDimension {
                dimension_type: self.dimension_type,
                values: self.values,
            }
        }
    }
}
impl SetDimension {
    /// Creates a new builder-style object to manufacture [`SetDimension`](crate::model::SetDimension)
    pub fn builder() -> crate::model::set_dimension::Builder {
        crate::model::set_dimension::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DimensionType {
    #[allow(missing_docs)] // documentation missing in model
    Exclusive,
    #[allow(missing_docs)] // documentation missing in model
    Inclusive,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DimensionType {
    fn from(s: &str) -> Self {
        match s {
            "EXCLUSIVE" => DimensionType::Exclusive,
            "INCLUSIVE" => DimensionType::Inclusive,
            other => DimensionType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DimensionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DimensionType::from(s))
    }
}
impl DimensionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DimensionType::Exclusive => "EXCLUSIVE",
            DimensionType::Inclusive => "INCLUSIVE",
            DimensionType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["EXCLUSIVE", "INCLUSIVE"]
    }
}
impl AsRef<str> for DimensionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies demographic-based dimension settings for including or excluding endpoints from a segment. These settings derive from characteristics of endpoint devices, such as platform, make, and model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentDemographics {
    /// <p>The app version criteria for the segment.</p>
    pub app_version: std::option::Option<crate::model::SetDimension>,
    /// <p>The channel criteria for the segment.</p>
    pub channel: std::option::Option<crate::model::SetDimension>,
    /// <p>The device type criteria for the segment.</p>
    pub device_type: std::option::Option<crate::model::SetDimension>,
    /// <p>The device make criteria for the segment.</p>
    pub make: std::option::Option<crate::model::SetDimension>,
    /// <p>The device model criteria for the segment.</p>
    pub model: std::option::Option<crate::model::SetDimension>,
    /// <p>The device platform criteria for the segment.</p>
    pub platform: std::option::Option<crate::model::SetDimension>,
}
impl std::fmt::Debug for SegmentDemographics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentDemographics");
        formatter.field("app_version", &self.app_version);
        formatter.field("channel", &self.channel);
        formatter.field("device_type", &self.device_type);
        formatter.field("make", &self.make);
        formatter.field("model", &self.model);
        formatter.field("platform", &self.platform);
        formatter.finish()
    }
}
/// See [`SegmentDemographics`](crate::model::SegmentDemographics)
pub mod segment_demographics {
    /// A builder for [`SegmentDemographics`](crate::model::SegmentDemographics)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_version: std::option::Option<crate::model::SetDimension>,
        pub(crate) channel: std::option::Option<crate::model::SetDimension>,
        pub(crate) device_type: std::option::Option<crate::model::SetDimension>,
        pub(crate) make: std::option::Option<crate::model::SetDimension>,
        pub(crate) model: std::option::Option<crate::model::SetDimension>,
        pub(crate) platform: std::option::Option<crate::model::SetDimension>,
    }
    impl Builder {
        /// <p>The app version criteria for the segment.</p>
        pub fn app_version(mut self, input: crate::model::SetDimension) -> Self {
            self.app_version = Some(input);
            self
        }
        /// <p>The app version criteria for the segment.</p>
        pub fn set_app_version(
            mut self,
            input: std::option::Option<crate::model::SetDimension>,
        ) -> Self {
            self.app_version = input;
            self
        }
        /// <p>The channel criteria for the segment.</p>
        pub fn channel(mut self, input: crate::model::SetDimension) -> Self {
            self.channel = Some(input);
            self
        }
        /// <p>The channel criteria for the segment.</p>
        pub fn set_channel(
            mut self,
            input: std::option::Option<crate::model::SetDimension>,
        ) -> Self {
            self.channel = input;
            self
        }
        /// <p>The device type criteria for the segment.</p>
        pub fn device_type(mut self, input: crate::model::SetDimension) -> Self {
            self.device_type = Some(input);
            self
        }
        /// <p>The device type criteria for the segment.</p>
        pub fn set_device_type(
            mut self,
            input: std::option::Option<crate::model::SetDimension>,
        ) -> Self {
            self.device_type = input;
            self
        }
        /// <p>The device make criteria for the segment.</p>
        pub fn make(mut self, input: crate::model::SetDimension) -> Self {
            self.make = Some(input);
            self
        }
        /// <p>The device make criteria for the segment.</p>
        pub fn set_make(mut self, input: std::option::Option<crate::model::SetDimension>) -> Self {
            self.make = input;
            self
        }
        /// <p>The device model criteria for the segment.</p>
        pub fn model(mut self, input: crate::model::SetDimension) -> Self {
            self.model = Some(input);
            self
        }
        /// <p>The device model criteria for the segment.</p>
        pub fn set_model(mut self, input: std::option::Option<crate::model::SetDimension>) -> Self {
            self.model = input;
            self
        }
        /// <p>The device platform criteria for the segment.</p>
        pub fn platform(mut self, input: crate::model::SetDimension) -> Self {
            self.platform = Some(input);
            self
        }
        /// <p>The device platform criteria for the segment.</p>
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::SetDimension>,
        ) -> Self {
            self.platform = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentDemographics`](crate::model::SegmentDemographics)
        pub fn build(self) -> crate::model::SegmentDemographics {
            crate::model::SegmentDemographics {
                app_version: self.app_version,
                channel: self.channel,
                device_type: self.device_type,
                make: self.make,
                model: self.model,
                platform: self.platform,
            }
        }
    }
}
impl SegmentDemographics {
    /// Creates a new builder-style object to manufacture [`SegmentDemographics`](crate::model::SegmentDemographics)
    pub fn builder() -> crate::model::segment_demographics::Builder {
        crate::model::segment_demographics::Builder::default()
    }
}

/// <p>Specifies dimension settings for including or excluding endpoints from a segment based on how recently an endpoint was active.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentBehaviors {
    /// <p>The dimension settings that are based on how recently an endpoint was active.</p>
    pub recency: std::option::Option<crate::model::RecencyDimension>,
}
impl std::fmt::Debug for SegmentBehaviors {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentBehaviors");
        formatter.field("recency", &self.recency);
        formatter.finish()
    }
}
/// See [`SegmentBehaviors`](crate::model::SegmentBehaviors)
pub mod segment_behaviors {
    /// A builder for [`SegmentBehaviors`](crate::model::SegmentBehaviors)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) recency: std::option::Option<crate::model::RecencyDimension>,
    }
    impl Builder {
        /// <p>The dimension settings that are based on how recently an endpoint was active.</p>
        pub fn recency(mut self, input: crate::model::RecencyDimension) -> Self {
            self.recency = Some(input);
            self
        }
        /// <p>The dimension settings that are based on how recently an endpoint was active.</p>
        pub fn set_recency(
            mut self,
            input: std::option::Option<crate::model::RecencyDimension>,
        ) -> Self {
            self.recency = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentBehaviors`](crate::model::SegmentBehaviors)
        pub fn build(self) -> crate::model::SegmentBehaviors {
            crate::model::SegmentBehaviors {
                recency: self.recency,
            }
        }
    }
}
impl SegmentBehaviors {
    /// Creates a new builder-style object to manufacture [`SegmentBehaviors`](crate::model::SegmentBehaviors)
    pub fn builder() -> crate::model::segment_behaviors::Builder {
        crate::model::segment_behaviors::Builder::default()
    }
}

/// <p>Specifies criteria for including or excluding endpoints from a segment based on how recently an endpoint was active.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecencyDimension {
    /// <p>The duration to use when determining whether an endpoint is active or inactive.</p>
    pub duration: std::option::Option<crate::model::Duration>,
    /// <p>The type of recency dimension to use for the segment. Valid values are: ACTIVE, endpoints that were active within the specified duration are included in the segment; and, INACTIVE, endpoints that weren't active within the specified duration are included in the segment.</p>
    pub recency_type: std::option::Option<crate::model::RecencyType>,
}
impl std::fmt::Debug for RecencyDimension {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecencyDimension");
        formatter.field("duration", &self.duration);
        formatter.field("recency_type", &self.recency_type);
        formatter.finish()
    }
}
/// See [`RecencyDimension`](crate::model::RecencyDimension)
pub mod recency_dimension {
    /// A builder for [`RecencyDimension`](crate::model::RecencyDimension)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) duration: std::option::Option<crate::model::Duration>,
        pub(crate) recency_type: std::option::Option<crate::model::RecencyType>,
    }
    impl Builder {
        /// <p>The duration to use when determining whether an endpoint is active or inactive.</p>
        pub fn duration(mut self, input: crate::model::Duration) -> Self {
            self.duration = Some(input);
            self
        }
        /// <p>The duration to use when determining whether an endpoint is active or inactive.</p>
        pub fn set_duration(mut self, input: std::option::Option<crate::model::Duration>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The type of recency dimension to use for the segment. Valid values are: ACTIVE, endpoints that were active within the specified duration are included in the segment; and, INACTIVE, endpoints that weren't active within the specified duration are included in the segment.</p>
        pub fn recency_type(mut self, input: crate::model::RecencyType) -> Self {
            self.recency_type = Some(input);
            self
        }
        /// <p>The type of recency dimension to use for the segment. Valid values are: ACTIVE, endpoints that were active within the specified duration are included in the segment; and, INACTIVE, endpoints that weren't active within the specified duration are included in the segment.</p>
        pub fn set_recency_type(
            mut self,
            input: std::option::Option<crate::model::RecencyType>,
        ) -> Self {
            self.recency_type = input;
            self
        }
        /// Consumes the builder and constructs a [`RecencyDimension`](crate::model::RecencyDimension)
        pub fn build(self) -> crate::model::RecencyDimension {
            crate::model::RecencyDimension {
                duration: self.duration,
                recency_type: self.recency_type,
            }
        }
    }
}
impl RecencyDimension {
    /// Creates a new builder-style object to manufacture [`RecencyDimension`](crate::model::RecencyDimension)
    pub fn builder() -> crate::model::recency_dimension::Builder {
        crate::model::recency_dimension::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RecencyType {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Inactive,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for RecencyType {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => RecencyType::Active,
            "INACTIVE" => RecencyType::Inactive,
            other => RecencyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for RecencyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RecencyType::from(s))
    }
}
impl RecencyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RecencyType::Active => "ACTIVE",
            RecencyType::Inactive => "INACTIVE",
            RecencyType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ACTIVE", "INACTIVE"]
    }
}
impl AsRef<str> for RecencyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Duration {
    #[allow(missing_docs)] // documentation missing in model
    Day14,
    #[allow(missing_docs)] // documentation missing in model
    Day30,
    #[allow(missing_docs)] // documentation missing in model
    Day7,
    #[allow(missing_docs)] // documentation missing in model
    Hr24,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Duration {
    fn from(s: &str) -> Self {
        match s {
            "DAY_14" => Duration::Day14,
            "DAY_30" => Duration::Day30,
            "DAY_7" => Duration::Day7,
            "HR_24" => Duration::Hr24,
            other => Duration::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Duration {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Duration::from(s))
    }
}
impl Duration {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Duration::Day14 => "DAY_14",
            Duration::Day30 => "DAY_30",
            Duration::Day7 => "DAY_7",
            Duration::Hr24 => "HR_24",
            Duration::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DAY_14", "DAY_30", "DAY_7", "HR_24"]
    }
}
impl AsRef<str> for Duration {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the import job that created a segment. An import job is a job that creates a user segment by importing endpoint definitions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentImportResource {
    /// <p>The number of channel types in the endpoint definitions that were imported to create the segment.</p>
    pub channel_counts: std::option::Option<std::collections::HashMap<std::string::String, i32>>,
    /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
    pub external_id: std::option::Option<std::string::String>,
    /// <p>The format of the files that were imported to create the segment. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format.</p>
    pub format: std::option::Option<crate::model::Format>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that the endpoint definitions were imported from to create the segment.</p>
    pub s3_url: std::option::Option<std::string::String>,
    /// <p>The number of endpoint definitions that were imported successfully to create the segment.</p>
    pub size: i32,
}
impl std::fmt::Debug for SegmentImportResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentImportResource");
        formatter.field("channel_counts", &self.channel_counts);
        formatter.field("external_id", &self.external_id);
        formatter.field("format", &self.format);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("s3_url", &self.s3_url);
        formatter.field("size", &self.size);
        formatter.finish()
    }
}
/// See [`SegmentImportResource`](crate::model::SegmentImportResource)
pub mod segment_import_resource {
    /// A builder for [`SegmentImportResource`](crate::model::SegmentImportResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channel_counts:
            std::option::Option<std::collections::HashMap<std::string::String, i32>>,
        pub(crate) external_id: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::Format>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) s3_url: std::option::Option<std::string::String>,
        pub(crate) size: std::option::Option<i32>,
    }
    impl Builder {
        /// Adds a key-value pair to `channel_counts`.
        ///
        /// To override the contents of this collection use [`set_channel_counts`](Self::set_channel_counts).
        ///
        /// <p>The number of channel types in the endpoint definitions that were imported to create the segment.</p>
        pub fn channel_counts(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<i32>,
        ) -> Self {
            let mut hash_map = self.channel_counts.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.channel_counts = Some(hash_map);
            self
        }
        /// <p>The number of channel types in the endpoint definitions that were imported to create the segment.</p>
        pub fn set_channel_counts(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, i32>>,
        ) -> Self {
            self.channel_counts = input;
            self
        }
        /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input;
            self
        }
        /// <p>The format of the files that were imported to create the segment. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format.</p>
        pub fn format(mut self, input: crate::model::Format) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>The format of the files that were imported to create the segment. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format.</p>
        pub fn set_format(mut self, input: std::option::Option<crate::model::Format>) -> Self {
            self.format = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that the endpoint definitions were imported from to create the segment.</p>
        pub fn s3_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_url = Some(input.into());
            self
        }
        /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that the endpoint definitions were imported from to create the segment.</p>
        pub fn set_s3_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_url = input;
            self
        }
        /// <p>The number of endpoint definitions that were imported successfully to create the segment.</p>
        pub fn size(mut self, input: i32) -> Self {
            self.size = Some(input);
            self
        }
        /// <p>The number of endpoint definitions that were imported successfully to create the segment.</p>
        pub fn set_size(mut self, input: std::option::Option<i32>) -> Self {
            self.size = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentImportResource`](crate::model::SegmentImportResource)
        pub fn build(self) -> crate::model::SegmentImportResource {
            crate::model::SegmentImportResource {
                channel_counts: self.channel_counts,
                external_id: self.external_id,
                format: self.format,
                role_arn: self.role_arn,
                s3_url: self.s3_url,
                size: self.size.unwrap_or_default(),
            }
        }
    }
}
impl SegmentImportResource {
    /// Creates a new builder-style object to manufacture [`SegmentImportResource`](crate::model::SegmentImportResource)
    pub fn builder() -> crate::model::segment_import_resource::Builder {
        crate::model::segment_import_resource::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Format {
    #[allow(missing_docs)] // documentation missing in model
    Csv,
    #[allow(missing_docs)] // documentation missing in model
    Json,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Format {
    fn from(s: &str) -> Self {
        match s {
            "CSV" => Format::Csv,
            "JSON" => Format::Json,
            other => Format::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Format {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Format::from(s))
    }
}
impl Format {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Format::Csv => "CSV",
            Format::Json => "JSON",
            Format::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CSV", "JSON"]
    }
}
impl AsRef<str> for Format {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the configuration, dimension, and other settings for a segment. A WriteSegmentRequest object can include a Dimensions object or a SegmentGroups object, but not both.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WriteSegmentRequest {
    /// <p>The criteria that define the dimensions for the segment.</p>
    pub dimensions: std::option::Option<crate::model::SegmentDimensions>,
    /// <p>The name of the segment.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The segment group to use and the dimensions to apply to the group's base segments in order to build the segment. A segment group can consist of zero or more base segments. Your request can include only one segment group.</p>
    pub segment_groups: std::option::Option<crate::model::SegmentGroupList>,
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the segment. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for WriteSegmentRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WriteSegmentRequest");
        formatter.field("dimensions", &self.dimensions);
        formatter.field("name", &self.name);
        formatter.field("segment_groups", &self.segment_groups);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`WriteSegmentRequest`](crate::model::WriteSegmentRequest)
pub mod write_segment_request {
    /// A builder for [`WriteSegmentRequest`](crate::model::WriteSegmentRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimensions: std::option::Option<crate::model::SegmentDimensions>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) segment_groups: std::option::Option<crate::model::SegmentGroupList>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The criteria that define the dimensions for the segment.</p>
        pub fn dimensions(mut self, input: crate::model::SegmentDimensions) -> Self {
            self.dimensions = Some(input);
            self
        }
        /// <p>The criteria that define the dimensions for the segment.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::SegmentDimensions>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The name of the segment.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the segment.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The segment group to use and the dimensions to apply to the group's base segments in order to build the segment. A segment group can consist of zero or more base segments. Your request can include only one segment group.</p>
        pub fn segment_groups(mut self, input: crate::model::SegmentGroupList) -> Self {
            self.segment_groups = Some(input);
            self
        }
        /// <p>The segment group to use and the dimensions to apply to the group's base segments in order to build the segment. A segment group can consist of zero or more base segments. Your request can include only one segment group.</p>
        pub fn set_segment_groups(
            mut self,
            input: std::option::Option<crate::model::SegmentGroupList>,
        ) -> Self {
            self.segment_groups = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the segment. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the segment. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`WriteSegmentRequest`](crate::model::WriteSegmentRequest)
        pub fn build(self) -> crate::model::WriteSegmentRequest {
            crate::model::WriteSegmentRequest {
                dimensions: self.dimensions,
                name: self.name,
                segment_groups: self.segment_groups,
                tags: self.tags,
            }
        }
    }
}
impl WriteSegmentRequest {
    /// Creates a new builder-style object to manufacture [`WriteSegmentRequest`](crate::model::WriteSegmentRequest)
    pub fn builder() -> crate::model::write_segment_request::Builder {
        crate::model::write_segment_request::Builder::default()
    }
}

/// <p>Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RecommenderConfigurationResponse {
    /// <p>A map that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>This value is null if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The date, in extended ISO 8601 format, when the configuration was created for the recommender model.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The custom description of the configuration for the recommender model.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the recommender model configuration.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The date, in extended ISO 8601 format, when the configuration for the recommender model was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The custom name of the configuration for the recommender model.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of Amazon Pinpoint ID that's associated with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Possible values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Each user in the model is associated with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Each user in the model is associated with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If this value is specified, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
    pub recommendation_provider_id_type: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
    pub recommendation_provider_role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the recommender model that Amazon Pinpoint retrieves the recommendation data from. This value is the ARN of an Amazon Personalize campaign.</p>
    pub recommendation_provider_uri: std::option::Option<std::string::String>,
    /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to perform additional processing of recommendation data that it retrieves from the recommender model.</p>
    pub recommendation_transformer_uri: std::option::Option<std::string::String>,
    /// <p>The custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console.</p> <p>This value is null if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
    pub recommendations_display_name: std::option::Option<std::string::String>,
    /// <p>The number of recommended items that are retrieved from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables.</p>
    pub recommendations_per_message: i32,
}
impl std::fmt::Debug for RecommenderConfigurationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RecommenderConfigurationResponse");
        formatter.field("attributes", &self.attributes);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("description", &self.description);
        formatter.field("id", &self.id);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("name", &self.name);
        formatter.field(
            "recommendation_provider_id_type",
            &self.recommendation_provider_id_type,
        );
        formatter.field(
            "recommendation_provider_role_arn",
            &self.recommendation_provider_role_arn,
        );
        formatter.field(
            "recommendation_provider_uri",
            &self.recommendation_provider_uri,
        );
        formatter.field(
            "recommendation_transformer_uri",
            &self.recommendation_transformer_uri,
        );
        formatter.field(
            "recommendations_display_name",
            &self.recommendations_display_name,
        );
        formatter.field(
            "recommendations_per_message",
            &self.recommendations_per_message,
        );
        formatter.finish()
    }
}
/// See [`RecommenderConfigurationResponse`](crate::model::RecommenderConfigurationResponse)
pub mod recommender_configuration_response {
    /// A builder for [`RecommenderConfigurationResponse`](crate::model::RecommenderConfigurationResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) recommendation_provider_id_type: std::option::Option<std::string::String>,
        pub(crate) recommendation_provider_role_arn: std::option::Option<std::string::String>,
        pub(crate) recommendation_provider_uri: std::option::Option<std::string::String>,
        pub(crate) recommendation_transformer_uri: std::option::Option<std::string::String>,
        pub(crate) recommendations_display_name: std::option::Option<std::string::String>,
        pub(crate) recommendations_per_message: std::option::Option<i32>,
    }
    impl Builder {
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>A map that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>This value is null if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>A map that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>This value is null if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The date, in extended ISO 8601 format, when the configuration was created for the recommender model.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in extended ISO 8601 format, when the configuration was created for the recommender model.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The custom description of the configuration for the recommender model.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The custom description of the configuration for the recommender model.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The unique identifier for the recommender model configuration.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the recommender model configuration.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The date, in extended ISO 8601 format, when the configuration for the recommender model was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in extended ISO 8601 format, when the configuration for the recommender model was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The custom name of the configuration for the recommender model.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The custom name of the configuration for the recommender model.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of Amazon Pinpoint ID that's associated with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Possible values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Each user in the model is associated with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Each user in the model is associated with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If this value is specified, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
        pub fn recommendation_provider_id_type(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_provider_id_type = Some(input.into());
            self
        }
        /// <p>The type of Amazon Pinpoint ID that's associated with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Possible values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Each user in the model is associated with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Each user in the model is associated with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If this value is specified, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
        pub fn set_recommendation_provider_id_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_provider_id_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
        pub fn recommendation_provider_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_provider_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
        pub fn set_recommendation_provider_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_provider_role_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the recommender model that Amazon Pinpoint retrieves the recommendation data from. This value is the ARN of an Amazon Personalize campaign.</p>
        pub fn recommendation_provider_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_provider_uri = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the recommender model that Amazon Pinpoint retrieves the recommendation data from. This value is the ARN of an Amazon Personalize campaign.</p>
        pub fn set_recommendation_provider_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_provider_uri = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to perform additional processing of recommendation data that it retrieves from the recommender model.</p>
        pub fn recommendation_transformer_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_transformer_uri = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to perform additional processing of recommendation data that it retrieves from the recommender model.</p>
        pub fn set_recommendation_transformer_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_transformer_uri = input;
            self
        }
        /// <p>The custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console.</p> <p>This value is null if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
        pub fn recommendations_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendations_display_name = Some(input.into());
            self
        }
        /// <p>The custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console.</p> <p>This value is null if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
        pub fn set_recommendations_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendations_display_name = input;
            self
        }
        /// <p>The number of recommended items that are retrieved from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables.</p>
        pub fn recommendations_per_message(mut self, input: i32) -> Self {
            self.recommendations_per_message = Some(input);
            self
        }
        /// <p>The number of recommended items that are retrieved from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables.</p>
        pub fn set_recommendations_per_message(mut self, input: std::option::Option<i32>) -> Self {
            self.recommendations_per_message = input;
            self
        }
        /// Consumes the builder and constructs a [`RecommenderConfigurationResponse`](crate::model::RecommenderConfigurationResponse)
        pub fn build(self) -> crate::model::RecommenderConfigurationResponse {
            crate::model::RecommenderConfigurationResponse {
                attributes: self.attributes,
                creation_date: self.creation_date,
                description: self.description,
                id: self.id,
                last_modified_date: self.last_modified_date,
                name: self.name,
                recommendation_provider_id_type: self.recommendation_provider_id_type,
                recommendation_provider_role_arn: self.recommendation_provider_role_arn,
                recommendation_provider_uri: self.recommendation_provider_uri,
                recommendation_transformer_uri: self.recommendation_transformer_uri,
                recommendations_display_name: self.recommendations_display_name,
                recommendations_per_message: self.recommendations_per_message.unwrap_or_default(),
            }
        }
    }
}
impl RecommenderConfigurationResponse {
    /// Creates a new builder-style object to manufacture [`RecommenderConfigurationResponse`](crate::model::RecommenderConfigurationResponse)
    pub fn builder() -> crate::model::recommender_configuration_response::Builder {
        crate::model::recommender_configuration_response::Builder::default()
    }
}

/// <p>Specifies Amazon Pinpoint configuration settings for retrieving and processing recommendation data from a recommender model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateRecommenderConfigurationShape {
    /// <p>A map of key-value pairs that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>In the map, the key is the name of a custom attribute and the value is a custom display name for that attribute. The display name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The following restrictions apply to these names:</p> <ul><li><p>An attribute name must start with a letter or number and it can contain up to 50 characters. The characters can be letters, numbers, underscores (_), or hyphens (-). Attribute names are case sensitive and must be unique.</p></li> <li><p>An attribute display name must start with a letter or number and it can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p></li></ul> <p>This object is required if the configuration invokes an AWS Lambda function (RecommendationTransformerUri) to process recommendation data. Otherwise, don't include this object in your request.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A custom description of the configuration for the recommender model. The description can contain up to 128 characters. The characters can be letters, numbers, spaces, or the following symbols: _ ; () , ‐.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A custom name of the configuration for the recommender model. The name must start with a letter or number and it can contain up to 128 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of Amazon Pinpoint ID to associate with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Valid values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Associate each user in the model with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Associate each user in the model with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If you specify this value, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
    pub recommendation_provider_id_type: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
    pub recommendation_provider_role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the recommender model to retrieve recommendation data from. This value must match the ARN of an Amazon Personalize campaign.</p>
    pub recommendation_provider_uri: std::option::Option<std::string::String>,
    /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function to invoke for additional processing of recommendation data that's retrieved from the recommender model.</p>
    pub recommendation_transformer_uri: std::option::Option<std::string::String>,
    /// <p>A custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This value is required if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p> <p>This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The name can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-). These restrictions don't apply to attribute values.</p>
    pub recommendations_display_name: std::option::Option<std::string::String>,
    /// <p>The number of recommended items to retrieve from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables. The minimum value is 1. The maximum value is 5. The default value is 5.</p> <p>To use multiple recommended items and custom attributes with message variables, you have to use an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
    pub recommendations_per_message: i32,
}
impl std::fmt::Debug for UpdateRecommenderConfigurationShape {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateRecommenderConfigurationShape");
        formatter.field("attributes", &self.attributes);
        formatter.field("description", &self.description);
        formatter.field("name", &self.name);
        formatter.field(
            "recommendation_provider_id_type",
            &self.recommendation_provider_id_type,
        );
        formatter.field(
            "recommendation_provider_role_arn",
            &self.recommendation_provider_role_arn,
        );
        formatter.field(
            "recommendation_provider_uri",
            &self.recommendation_provider_uri,
        );
        formatter.field(
            "recommendation_transformer_uri",
            &self.recommendation_transformer_uri,
        );
        formatter.field(
            "recommendations_display_name",
            &self.recommendations_display_name,
        );
        formatter.field(
            "recommendations_per_message",
            &self.recommendations_per_message,
        );
        formatter.finish()
    }
}
/// See [`UpdateRecommenderConfigurationShape`](crate::model::UpdateRecommenderConfigurationShape)
pub mod update_recommender_configuration_shape {
    /// A builder for [`UpdateRecommenderConfigurationShape`](crate::model::UpdateRecommenderConfigurationShape)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) recommendation_provider_id_type: std::option::Option<std::string::String>,
        pub(crate) recommendation_provider_role_arn: std::option::Option<std::string::String>,
        pub(crate) recommendation_provider_uri: std::option::Option<std::string::String>,
        pub(crate) recommendation_transformer_uri: std::option::Option<std::string::String>,
        pub(crate) recommendations_display_name: std::option::Option<std::string::String>,
        pub(crate) recommendations_per_message: std::option::Option<i32>,
    }
    impl Builder {
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>A map of key-value pairs that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>In the map, the key is the name of a custom attribute and the value is a custom display name for that attribute. The display name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The following restrictions apply to these names:</p> <ul><li><p>An attribute name must start with a letter or number and it can contain up to 50 characters. The characters can be letters, numbers, underscores (_), or hyphens (-). Attribute names are case sensitive and must be unique.</p></li> <li><p>An attribute display name must start with a letter or number and it can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p></li></ul> <p>This object is required if the configuration invokes an AWS Lambda function (RecommendationTransformerUri) to process recommendation data. Otherwise, don't include this object in your request.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>A map of key-value pairs that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>In the map, the key is the name of a custom attribute and the value is a custom display name for that attribute. The display name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The following restrictions apply to these names:</p> <ul><li><p>An attribute name must start with a letter or number and it can contain up to 50 characters. The characters can be letters, numbers, underscores (_), or hyphens (-). Attribute names are case sensitive and must be unique.</p></li> <li><p>An attribute display name must start with a letter or number and it can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p></li></ul> <p>This object is required if the configuration invokes an AWS Lambda function (RecommendationTransformerUri) to process recommendation data. Otherwise, don't include this object in your request.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>A custom description of the configuration for the recommender model. The description can contain up to 128 characters. The characters can be letters, numbers, spaces, or the following symbols: _ ; () , ‐.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A custom description of the configuration for the recommender model. The description can contain up to 128 characters. The characters can be letters, numbers, spaces, or the following symbols: _ ; () , ‐.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A custom name of the configuration for the recommender model. The name must start with a letter or number and it can contain up to 128 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A custom name of the configuration for the recommender model. The name must start with a letter or number and it can contain up to 128 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of Amazon Pinpoint ID to associate with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Valid values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Associate each user in the model with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Associate each user in the model with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If you specify this value, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
        pub fn recommendation_provider_id_type(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_provider_id_type = Some(input.into());
            self
        }
        /// <p>The type of Amazon Pinpoint ID to associate with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Valid values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Associate each user in the model with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Associate each user in the model with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If you specify this value, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
        pub fn set_recommendation_provider_id_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_provider_id_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
        pub fn recommendation_provider_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_provider_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
        pub fn set_recommendation_provider_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_provider_role_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the recommender model to retrieve recommendation data from. This value must match the ARN of an Amazon Personalize campaign.</p>
        pub fn recommendation_provider_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_provider_uri = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the recommender model to retrieve recommendation data from. This value must match the ARN of an Amazon Personalize campaign.</p>
        pub fn set_recommendation_provider_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_provider_uri = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function to invoke for additional processing of recommendation data that's retrieved from the recommender model.</p>
        pub fn recommendation_transformer_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_transformer_uri = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function to invoke for additional processing of recommendation data that's retrieved from the recommender model.</p>
        pub fn set_recommendation_transformer_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_transformer_uri = input;
            self
        }
        /// <p>A custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This value is required if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p> <p>This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The name can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-). These restrictions don't apply to attribute values.</p>
        pub fn recommendations_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendations_display_name = Some(input.into());
            self
        }
        /// <p>A custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This value is required if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p> <p>This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The name can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-). These restrictions don't apply to attribute values.</p>
        pub fn set_recommendations_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendations_display_name = input;
            self
        }
        /// <p>The number of recommended items to retrieve from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables. The minimum value is 1. The maximum value is 5. The default value is 5.</p> <p>To use multiple recommended items and custom attributes with message variables, you have to use an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
        pub fn recommendations_per_message(mut self, input: i32) -> Self {
            self.recommendations_per_message = Some(input);
            self
        }
        /// <p>The number of recommended items to retrieve from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables. The minimum value is 1. The maximum value is 5. The default value is 5.</p> <p>To use multiple recommended items and custom attributes with message variables, you have to use an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
        pub fn set_recommendations_per_message(mut self, input: std::option::Option<i32>) -> Self {
            self.recommendations_per_message = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateRecommenderConfigurationShape`](crate::model::UpdateRecommenderConfigurationShape)
        pub fn build(self) -> crate::model::UpdateRecommenderConfigurationShape {
            crate::model::UpdateRecommenderConfigurationShape {
                attributes: self.attributes,
                description: self.description,
                name: self.name,
                recommendation_provider_id_type: self.recommendation_provider_id_type,
                recommendation_provider_role_arn: self.recommendation_provider_role_arn,
                recommendation_provider_uri: self.recommendation_provider_uri,
                recommendation_transformer_uri: self.recommendation_transformer_uri,
                recommendations_display_name: self.recommendations_display_name,
                recommendations_per_message: self.recommendations_per_message.unwrap_or_default(),
            }
        }
    }
}
impl UpdateRecommenderConfigurationShape {
    /// Creates a new builder-style object to manufacture [`UpdateRecommenderConfigurationShape`](crate::model::UpdateRecommenderConfigurationShape)
    pub fn builder() -> crate::model::update_recommender_configuration_shape::Builder {
        crate::model::update_recommender_configuration_shape::Builder::default()
    }
}

/// <p>Specifies the content and settings for a message template that can be used in messages that are sent through a push notification channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PushNotificationTemplateRequest {
    /// <p>The message template to use for the ADM (Amazon Device Messaging) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    pub adm: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
    /// <p>The message template to use for the APNs (Apple Push Notification service) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    pub apns: std::option::Option<crate::model::ApnsPushNotificationTemplate>,
    /// <p>The message template to use for the Baidu (Baidu Cloud Push) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    pub baidu: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
    /// <p>The default message template to use for push notification channels.</p>
    pub default_value: std::option::Option<crate::model::DefaultPushNotificationTemplate>,
    /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
    pub default_substitutions: std::option::Option<std::string::String>,
    /// <p>The message template to use for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    pub gcm: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
    /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
    pub recommender_id: std::option::Option<std::string::String>,
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A custom description of the message template.</p>
    pub template_description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PushNotificationTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PushNotificationTemplateRequest");
        formatter.field("adm", &self.adm);
        formatter.field("apns", &self.apns);
        formatter.field("baidu", &self.baidu);
        formatter.field("default_value", &self.default_value);
        formatter.field("default_substitutions", &self.default_substitutions);
        formatter.field("gcm", &self.gcm);
        formatter.field("recommender_id", &self.recommender_id);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.finish()
    }
}
/// See [`PushNotificationTemplateRequest`](crate::model::PushNotificationTemplateRequest)
pub mod push_notification_template_request {
    /// A builder for [`PushNotificationTemplateRequest`](crate::model::PushNotificationTemplateRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) adm: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        pub(crate) apns: std::option::Option<crate::model::ApnsPushNotificationTemplate>,
        pub(crate) baidu: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        pub(crate) default_value:
            std::option::Option<crate::model::DefaultPushNotificationTemplate>,
        pub(crate) default_substitutions: std::option::Option<std::string::String>,
        pub(crate) gcm: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        pub(crate) recommender_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message template to use for the ADM (Amazon Device Messaging) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn adm(mut self, input: crate::model::AndroidPushNotificationTemplate) -> Self {
            self.adm = Some(input);
            self
        }
        /// <p>The message template to use for the ADM (Amazon Device Messaging) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn set_adm(
            mut self,
            input: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        ) -> Self {
            self.adm = input;
            self
        }
        /// <p>The message template to use for the APNs (Apple Push Notification service) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn apns(mut self, input: crate::model::ApnsPushNotificationTemplate) -> Self {
            self.apns = Some(input);
            self
        }
        /// <p>The message template to use for the APNs (Apple Push Notification service) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn set_apns(
            mut self,
            input: std::option::Option<crate::model::ApnsPushNotificationTemplate>,
        ) -> Self {
            self.apns = input;
            self
        }
        /// <p>The message template to use for the Baidu (Baidu Cloud Push) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn baidu(mut self, input: crate::model::AndroidPushNotificationTemplate) -> Self {
            self.baidu = Some(input);
            self
        }
        /// <p>The message template to use for the Baidu (Baidu Cloud Push) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn set_baidu(
            mut self,
            input: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        ) -> Self {
            self.baidu = input;
            self
        }
        /// <p>The default message template to use for push notification channels.</p>
        pub fn default_value(
            mut self,
            input: crate::model::DefaultPushNotificationTemplate,
        ) -> Self {
            self.default_value = Some(input);
            self
        }
        /// <p>The default message template to use for push notification channels.</p>
        pub fn set_default(
            mut self,
            input: std::option::Option<crate::model::DefaultPushNotificationTemplate>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
        pub fn default_substitutions(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_substitutions = Some(input.into());
            self
        }
        /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
        pub fn set_default_substitutions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_substitutions = input;
            self
        }
        /// <p>The message template to use for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn gcm(mut self, input: crate::model::AndroidPushNotificationTemplate) -> Self {
            self.gcm = Some(input);
            self
        }
        /// <p>The message template to use for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn set_gcm(
            mut self,
            input: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        ) -> Self {
            self.gcm = input;
            self
        }
        /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
        pub fn recommender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommender_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
        pub fn set_recommender_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommender_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>A custom description of the message template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>A custom description of the message template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// Consumes the builder and constructs a [`PushNotificationTemplateRequest`](crate::model::PushNotificationTemplateRequest)
        pub fn build(self) -> crate::model::PushNotificationTemplateRequest {
            crate::model::PushNotificationTemplateRequest {
                adm: self.adm,
                apns: self.apns,
                baidu: self.baidu,
                default_value: self.default_value,
                default_substitutions: self.default_substitutions,
                gcm: self.gcm,
                recommender_id: self.recommender_id,
                tags: self.tags,
                template_description: self.template_description,
            }
        }
    }
}
impl PushNotificationTemplateRequest {
    /// Creates a new builder-style object to manufacture [`PushNotificationTemplateRequest`](crate::model::PushNotificationTemplateRequest)
    pub fn builder() -> crate::model::push_notification_template_request::Builder {
        crate::model::push_notification_template_request::Builder::default()
    }
}

/// <p>Specifies channel-specific content and settings for a message template that can be used in push notifications that are sent through the ADM (Amazon Device Messaging), Baidu (Baidu Cloud Push), or GCM (Firebase Cloud Messaging, formerly Google Cloud Messaging) channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AndroidPushNotificationTemplate {
    /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    pub action: std::option::Option<crate::model::Action>,
    /// <p>The message body to use in a push notification that's based on the message template.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The URL of the large icon image to display in the content view of a push notification that's based on the message template.</p>
    pub image_icon_url: std::option::Option<std::string::String>,
    /// <p>The URL of an image to display in a push notification that's based on the message template.</p>
    pub image_url: std::option::Option<std::string::String>,
    /// <p>The raw, JSON-formatted string to use as the payload for a push notification that's based on the message template. If specified, this value overrides all other content for the message template.</p>
    pub raw_content: std::option::Option<std::string::String>,
    /// <p>The URL of the small icon image to display in the status bar and the content view of a push notification that's based on the message template.</p>
    pub small_image_icon_url: std::option::Option<std::string::String>,
    /// <p>The sound to play when a recipient receives a push notification that's based on the message template. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
    pub sound: std::option::Option<std::string::String>,
    /// <p>The title to use in a push notification that's based on the message template. This title appears above the notification message on a recipient's device.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AndroidPushNotificationTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AndroidPushNotificationTemplate");
        formatter.field("action", &self.action);
        formatter.field("body", &self.body);
        formatter.field("image_icon_url", &self.image_icon_url);
        formatter.field("image_url", &self.image_url);
        formatter.field("raw_content", &self.raw_content);
        formatter.field("small_image_icon_url", &self.small_image_icon_url);
        formatter.field("sound", &self.sound);
        formatter.field("title", &self.title);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`AndroidPushNotificationTemplate`](crate::model::AndroidPushNotificationTemplate)
pub mod android_push_notification_template {
    /// A builder for [`AndroidPushNotificationTemplate`](crate::model::AndroidPushNotificationTemplate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) image_icon_url: std::option::Option<std::string::String>,
        pub(crate) image_url: std::option::Option<std::string::String>,
        pub(crate) raw_content: std::option::Option<std::string::String>,
        pub(crate) small_image_icon_url: std::option::Option<std::string::String>,
        pub(crate) sound: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// <p>The message body to use in a push notification that's based on the message template.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The message body to use in a push notification that's based on the message template.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The URL of the large icon image to display in the content view of a push notification that's based on the message template.</p>
        pub fn image_icon_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_icon_url = Some(input.into());
            self
        }
        /// <p>The URL of the large icon image to display in the content view of a push notification that's based on the message template.</p>
        pub fn set_image_icon_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_icon_url = input;
            self
        }
        /// <p>The URL of an image to display in a push notification that's based on the message template.</p>
        pub fn image_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_url = Some(input.into());
            self
        }
        /// <p>The URL of an image to display in a push notification that's based on the message template.</p>
        pub fn set_image_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_url = input;
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for a push notification that's based on the message template. If specified, this value overrides all other content for the message template.</p>
        pub fn raw_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_content = Some(input.into());
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for a push notification that's based on the message template. If specified, this value overrides all other content for the message template.</p>
        pub fn set_raw_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_content = input;
            self
        }
        /// <p>The URL of the small icon image to display in the status bar and the content view of a push notification that's based on the message template.</p>
        pub fn small_image_icon_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.small_image_icon_url = Some(input.into());
            self
        }
        /// <p>The URL of the small icon image to display in the status bar and the content view of a push notification that's based on the message template.</p>
        pub fn set_small_image_icon_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.small_image_icon_url = input;
            self
        }
        /// <p>The sound to play when a recipient receives a push notification that's based on the message template. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
        pub fn sound(mut self, input: impl Into<std::string::String>) -> Self {
            self.sound = Some(input.into());
            self
        }
        /// <p>The sound to play when a recipient receives a push notification that's based on the message template. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
        pub fn set_sound(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sound = input;
            self
        }
        /// <p>The title to use in a push notification that's based on the message template. This title appears above the notification message on a recipient's device.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title to use in a push notification that's based on the message template. This title appears above the notification message on a recipient's device.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`AndroidPushNotificationTemplate`](crate::model::AndroidPushNotificationTemplate)
        pub fn build(self) -> crate::model::AndroidPushNotificationTemplate {
            crate::model::AndroidPushNotificationTemplate {
                action: self.action,
                body: self.body,
                image_icon_url: self.image_icon_url,
                image_url: self.image_url,
                raw_content: self.raw_content,
                small_image_icon_url: self.small_image_icon_url,
                sound: self.sound,
                title: self.title,
                url: self.url,
            }
        }
    }
}
impl AndroidPushNotificationTemplate {
    /// Creates a new builder-style object to manufacture [`AndroidPushNotificationTemplate`](crate::model::AndroidPushNotificationTemplate)
    pub fn builder() -> crate::model::android_push_notification_template::Builder {
        crate::model::android_push_notification_template::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Action {
    #[allow(missing_docs)] // documentation missing in model
    DeepLink,
    #[allow(missing_docs)] // documentation missing in model
    OpenApp,
    #[allow(missing_docs)] // documentation missing in model
    Url,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Action {
    fn from(s: &str) -> Self {
        match s {
            "DEEP_LINK" => Action::DeepLink,
            "OPEN_APP" => Action::OpenApp,
            "URL" => Action::Url,
            other => Action::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Action {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Action::from(s))
    }
}
impl Action {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Action::DeepLink => "DEEP_LINK",
            Action::OpenApp => "OPEN_APP",
            Action::Url => "URL",
            Action::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DEEP_LINK", "OPEN_APP", "URL"]
    }
}
impl AsRef<str> for Action {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the default settings and content for a message template that can be used in messages that are sent through a push notification channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultPushNotificationTemplate {
    /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    pub action: std::option::Option<crate::model::Action>,
    /// <p>The message body to use in push notifications that are based on the message template.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The sound to play when a recipient receives a push notification that's based on the message template. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p> <p>For an iOS platform, this value is the key for the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
    pub sound: std::option::Option<std::string::String>,
    /// <p>The title to use in push notifications that are based on the message template. This title appears above the notification message on a recipient's device.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DefaultPushNotificationTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultPushNotificationTemplate");
        formatter.field("action", &self.action);
        formatter.field("body", &self.body);
        formatter.field("sound", &self.sound);
        formatter.field("title", &self.title);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`DefaultPushNotificationTemplate`](crate::model::DefaultPushNotificationTemplate)
pub mod default_push_notification_template {
    /// A builder for [`DefaultPushNotificationTemplate`](crate::model::DefaultPushNotificationTemplate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) sound: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// <p>The message body to use in push notifications that are based on the message template.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The message body to use in push notifications that are based on the message template.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The sound to play when a recipient receives a push notification that's based on the message template. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p> <p>For an iOS platform, this value is the key for the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
        pub fn sound(mut self, input: impl Into<std::string::String>) -> Self {
            self.sound = Some(input.into());
            self
        }
        /// <p>The sound to play when a recipient receives a push notification that's based on the message template. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p> <p>For an iOS platform, this value is the key for the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
        pub fn set_sound(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sound = input;
            self
        }
        /// <p>The title to use in push notifications that are based on the message template. This title appears above the notification message on a recipient's device.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title to use in push notifications that are based on the message template. This title appears above the notification message on a recipient's device.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultPushNotificationTemplate`](crate::model::DefaultPushNotificationTemplate)
        pub fn build(self) -> crate::model::DefaultPushNotificationTemplate {
            crate::model::DefaultPushNotificationTemplate {
                action: self.action,
                body: self.body,
                sound: self.sound,
                title: self.title,
                url: self.url,
            }
        }
    }
}
impl DefaultPushNotificationTemplate {
    /// Creates a new builder-style object to manufacture [`DefaultPushNotificationTemplate`](crate::model::DefaultPushNotificationTemplate)
    pub fn builder() -> crate::model::default_push_notification_template::Builder {
        crate::model::default_push_notification_template::Builder::default()
    }
}

/// <p>Specifies channel-specific content and settings for a message template that can be used in push notifications that are sent through the APNs (Apple Push Notification service) channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApnsPushNotificationTemplate {
    /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    pub action: std::option::Option<crate::model::Action>,
    /// <p>The message body to use in push notifications that are based on the message template.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The URL of an image or video to display in push notifications that are based on the message template.</p>
    pub media_url: std::option::Option<std::string::String>,
    /// <p>The raw, JSON-formatted string to use as the payload for push notifications that are based on the message template. If specified, this value overrides all other content for the message template.</p>
    pub raw_content: std::option::Option<std::string::String>,
    /// <p>The key for the sound to play when the recipient receives a push notification that's based on the message template. The value for this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
    pub sound: std::option::Option<std::string::String>,
    /// <p>The title to use in push notifications that are based on the message template. This title appears above the notification message on a recipient's device.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApnsPushNotificationTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApnsPushNotificationTemplate");
        formatter.field("action", &self.action);
        formatter.field("body", &self.body);
        formatter.field("media_url", &self.media_url);
        formatter.field("raw_content", &self.raw_content);
        formatter.field("sound", &self.sound);
        formatter.field("title", &self.title);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`ApnsPushNotificationTemplate`](crate::model::ApnsPushNotificationTemplate)
pub mod apns_push_notification_template {
    /// A builder for [`ApnsPushNotificationTemplate`](crate::model::ApnsPushNotificationTemplate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) media_url: std::option::Option<std::string::String>,
        pub(crate) raw_content: std::option::Option<std::string::String>,
        pub(crate) sound: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// <p>The message body to use in push notifications that are based on the message template.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The message body to use in push notifications that are based on the message template.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The URL of an image or video to display in push notifications that are based on the message template.</p>
        pub fn media_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_url = Some(input.into());
            self
        }
        /// <p>The URL of an image or video to display in push notifications that are based on the message template.</p>
        pub fn set_media_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.media_url = input;
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for push notifications that are based on the message template. If specified, this value overrides all other content for the message template.</p>
        pub fn raw_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_content = Some(input.into());
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for push notifications that are based on the message template. If specified, this value overrides all other content for the message template.</p>
        pub fn set_raw_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_content = input;
            self
        }
        /// <p>The key for the sound to play when the recipient receives a push notification that's based on the message template. The value for this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
        pub fn sound(mut self, input: impl Into<std::string::String>) -> Self {
            self.sound = Some(input.into());
            self
        }
        /// <p>The key for the sound to play when the recipient receives a push notification that's based on the message template. The value for this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
        pub fn set_sound(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sound = input;
            self
        }
        /// <p>The title to use in push notifications that are based on the message template. This title appears above the notification message on a recipient's device.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title to use in push notifications that are based on the message template. This title appears above the notification message on a recipient's device.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`ApnsPushNotificationTemplate`](crate::model::ApnsPushNotificationTemplate)
        pub fn build(self) -> crate::model::ApnsPushNotificationTemplate {
            crate::model::ApnsPushNotificationTemplate {
                action: self.action,
                body: self.body,
                media_url: self.media_url,
                raw_content: self.raw_content,
                sound: self.sound,
                title: self.title,
                url: self.url,
            }
        }
    }
}
impl ApnsPushNotificationTemplate {
    /// Creates a new builder-style object to manufacture [`ApnsPushNotificationTemplate`](crate::model::ApnsPushNotificationTemplate)
    pub fn builder() -> crate::model::apns_push_notification_template::Builder {
        crate::model::apns_push_notification_template::Builder::default()
    }
}

/// <p>Provides information about the status, configuration, and other settings for a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneyResponse {
    /// <p>A map that contains a set of Activity objects, one object for each activity in the journey. For each Activity object, the key is the unique identifier (string) for an activity and the value is the settings for the activity.</p>
    pub activities:
        std::option::Option<std::collections::HashMap<std::string::String, crate::model::Activity>>,
    /// <p>The unique identifier for the application that the journey applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the journey was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the journey.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the journey was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The messaging and entry limits for the journey.</p>
    pub limits: std::option::Option<crate::model::JourneyLimits>,
    /// <p>Specifies whether the journey's scheduled start and end times use each participant's local time. If this value is true, the schedule uses each participant's local time.</p>
    pub local_time: bool,
    /// <p>The name of the journey.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The quiet time settings for the journey. Quiet time is a specific time range when a journey doesn't send messages to participants, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint for the participant is set to a valid value.</p></li> <li><p>The current time in the participant's time zone is later than or equal to the time specified by the QuietTime.Start property for the journey.</p></li> <li><p>The current time in the participant's time zone is earlier than or equal to the time specified by the QuietTime.End property for the journey.</p></li></ul> <p>If any of the preceding conditions isn't met, the participant will receive messages from the journey, even if quiet time is enabled.</p>
    pub quiet_time: std::option::Option<crate::model::QuietTime>,
    /// <p>The frequency with which Amazon Pinpoint evaluates segment and event data for the journey, as a duration in ISO 8601 format.</p>
    pub refresh_frequency: std::option::Option<std::string::String>,
    /// <p>The schedule settings for the journey.</p>
    pub schedule: std::option::Option<crate::model::JourneySchedule>,
    /// <p>The unique identifier for the first activity in the journey.</p>
    pub start_activity: std::option::Option<std::string::String>,
    /// <p>The segment that defines which users are participants in the journey.</p>
    pub start_condition: std::option::Option<crate::model::StartCondition>,
    /// <p>The current status of the journey. Possible values are:</p> <ul><li><p>DRAFT - The journey is being developed and hasn't been published yet.</p></li> <li><p>ACTIVE - The journey has been developed and published. Depending on the journey's schedule, the journey may currently be running or scheduled to start running at a later time. If a journey's status is ACTIVE, you can't add, change, or remove activities from it.</p></li> <li><p>COMPLETED - The journey has been published and has finished running. All participants have entered the journey and no participants are waiting to complete the journey or any activities in the journey.</p></li> <li><p>CANCELLED - The journey has been stopped. If a journey's status is CANCELLED, you can't add, change, or remove activities or segment settings from the journey.</p></li> <li><p>CLOSED - The journey has been published and has started running. It may have also passed its scheduled end time, or passed its scheduled start time and a refresh frequency hasn't been specified for it. If a journey's status is CLOSED, you can't add participants to it, and no existing participants can enter the journey for the first time. However, any existing participants who are currently waiting to start an activity may continue the journey.</p></li></ul>
    pub state: std::option::Option<crate::model::State>,
    /// <p>This object is not used or supported.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies whether endpoints in quiet hours should enter a wait till the end of their quiet hours.</p>
    pub wait_for_quiet_time: bool,
    /// <p>Specifies whether a journey should be refreshed on segment update.</p>
    pub refresh_on_segment_update: bool,
    /// <p>The channel-specific configurations for the journey.</p>
    pub journey_channel_settings: std::option::Option<crate::model::JourneyChannelSettings>,
}
impl std::fmt::Debug for JourneyResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneyResponse");
        formatter.field("activities", &self.activities);
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("id", &self.id);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("limits", &self.limits);
        formatter.field("local_time", &self.local_time);
        formatter.field("name", &self.name);
        formatter.field("quiet_time", &self.quiet_time);
        formatter.field("refresh_frequency", &self.refresh_frequency);
        formatter.field("schedule", &self.schedule);
        formatter.field("start_activity", &self.start_activity);
        formatter.field("start_condition", &self.start_condition);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("wait_for_quiet_time", &self.wait_for_quiet_time);
        formatter.field("refresh_on_segment_update", &self.refresh_on_segment_update);
        formatter.field("journey_channel_settings", &self.journey_channel_settings);
        formatter.finish()
    }
}
/// See [`JourneyResponse`](crate::model::JourneyResponse)
pub mod journey_response {
    /// A builder for [`JourneyResponse`](crate::model::JourneyResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) activities: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::Activity>,
        >,
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) limits: std::option::Option<crate::model::JourneyLimits>,
        pub(crate) local_time: std::option::Option<bool>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) quiet_time: std::option::Option<crate::model::QuietTime>,
        pub(crate) refresh_frequency: std::option::Option<std::string::String>,
        pub(crate) schedule: std::option::Option<crate::model::JourneySchedule>,
        pub(crate) start_activity: std::option::Option<std::string::String>,
        pub(crate) start_condition: std::option::Option<crate::model::StartCondition>,
        pub(crate) state: std::option::Option<crate::model::State>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) wait_for_quiet_time: std::option::Option<bool>,
        pub(crate) refresh_on_segment_update: std::option::Option<bool>,
        pub(crate) journey_channel_settings:
            std::option::Option<crate::model::JourneyChannelSettings>,
    }
    impl Builder {
        /// Adds a key-value pair to `activities`.
        ///
        /// To override the contents of this collection use [`set_activities`](Self::set_activities).
        ///
        /// <p>A map that contains a set of Activity objects, one object for each activity in the journey. For each Activity object, the key is the unique identifier (string) for an activity and the value is the settings for the activity.</p>
        pub fn activities(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::Activity>,
        ) -> Self {
            let mut hash_map = self.activities.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.activities = Some(hash_map);
            self
        }
        /// <p>A map that contains a set of Activity objects, one object for each activity in the journey. For each Activity object, the key is the unique identifier (string) for an activity and the value is the settings for the activity.</p>
        pub fn set_activities(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::Activity>,
            >,
        ) -> Self {
            self.activities = input;
            self
        }
        /// <p>The unique identifier for the application that the journey applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the journey applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the journey was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the journey was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The unique identifier for the journey.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the journey.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the journey was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the journey was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The messaging and entry limits for the journey.</p>
        pub fn limits(mut self, input: crate::model::JourneyLimits) -> Self {
            self.limits = Some(input);
            self
        }
        /// <p>The messaging and entry limits for the journey.</p>
        pub fn set_limits(
            mut self,
            input: std::option::Option<crate::model::JourneyLimits>,
        ) -> Self {
            self.limits = input;
            self
        }
        /// <p>Specifies whether the journey's scheduled start and end times use each participant's local time. If this value is true, the schedule uses each participant's local time.</p>
        pub fn local_time(mut self, input: bool) -> Self {
            self.local_time = Some(input);
            self
        }
        /// <p>Specifies whether the journey's scheduled start and end times use each participant's local time. If this value is true, the schedule uses each participant's local time.</p>
        pub fn set_local_time(mut self, input: std::option::Option<bool>) -> Self {
            self.local_time = input;
            self
        }
        /// <p>The name of the journey.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the journey.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The quiet time settings for the journey. Quiet time is a specific time range when a journey doesn't send messages to participants, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint for the participant is set to a valid value.</p></li> <li><p>The current time in the participant's time zone is later than or equal to the time specified by the QuietTime.Start property for the journey.</p></li> <li><p>The current time in the participant's time zone is earlier than or equal to the time specified by the QuietTime.End property for the journey.</p></li></ul> <p>If any of the preceding conditions isn't met, the participant will receive messages from the journey, even if quiet time is enabled.</p>
        pub fn quiet_time(mut self, input: crate::model::QuietTime) -> Self {
            self.quiet_time = Some(input);
            self
        }
        /// <p>The quiet time settings for the journey. Quiet time is a specific time range when a journey doesn't send messages to participants, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint for the participant is set to a valid value.</p></li> <li><p>The current time in the participant's time zone is later than or equal to the time specified by the QuietTime.Start property for the journey.</p></li> <li><p>The current time in the participant's time zone is earlier than or equal to the time specified by the QuietTime.End property for the journey.</p></li></ul> <p>If any of the preceding conditions isn't met, the participant will receive messages from the journey, even if quiet time is enabled.</p>
        pub fn set_quiet_time(
            mut self,
            input: std::option::Option<crate::model::QuietTime>,
        ) -> Self {
            self.quiet_time = input;
            self
        }
        /// <p>The frequency with which Amazon Pinpoint evaluates segment and event data for the journey, as a duration in ISO 8601 format.</p>
        pub fn refresh_frequency(mut self, input: impl Into<std::string::String>) -> Self {
            self.refresh_frequency = Some(input.into());
            self
        }
        /// <p>The frequency with which Amazon Pinpoint evaluates segment and event data for the journey, as a duration in ISO 8601 format.</p>
        pub fn set_refresh_frequency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.refresh_frequency = input;
            self
        }
        /// <p>The schedule settings for the journey.</p>
        pub fn schedule(mut self, input: crate::model::JourneySchedule) -> Self {
            self.schedule = Some(input);
            self
        }
        /// <p>The schedule settings for the journey.</p>
        pub fn set_schedule(
            mut self,
            input: std::option::Option<crate::model::JourneySchedule>,
        ) -> Self {
            self.schedule = input;
            self
        }
        /// <p>The unique identifier for the first activity in the journey.</p>
        pub fn start_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the first activity in the journey.</p>
        pub fn set_start_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.start_activity = input;
            self
        }
        /// <p>The segment that defines which users are participants in the journey.</p>
        pub fn start_condition(mut self, input: crate::model::StartCondition) -> Self {
            self.start_condition = Some(input);
            self
        }
        /// <p>The segment that defines which users are participants in the journey.</p>
        pub fn set_start_condition(
            mut self,
            input: std::option::Option<crate::model::StartCondition>,
        ) -> Self {
            self.start_condition = input;
            self
        }
        /// <p>The current status of the journey. Possible values are:</p> <ul><li><p>DRAFT - The journey is being developed and hasn't been published yet.</p></li> <li><p>ACTIVE - The journey has been developed and published. Depending on the journey's schedule, the journey may currently be running or scheduled to start running at a later time. If a journey's status is ACTIVE, you can't add, change, or remove activities from it.</p></li> <li><p>COMPLETED - The journey has been published and has finished running. All participants have entered the journey and no participants are waiting to complete the journey or any activities in the journey.</p></li> <li><p>CANCELLED - The journey has been stopped. If a journey's status is CANCELLED, you can't add, change, or remove activities or segment settings from the journey.</p></li> <li><p>CLOSED - The journey has been published and has started running. It may have also passed its scheduled end time, or passed its scheduled start time and a refresh frequency hasn't been specified for it. If a journey's status is CLOSED, you can't add participants to it, and no existing participants can enter the journey for the first time. However, any existing participants who are currently waiting to start an activity may continue the journey.</p></li></ul>
        pub fn state(mut self, input: crate::model::State) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current status of the journey. Possible values are:</p> <ul><li><p>DRAFT - The journey is being developed and hasn't been published yet.</p></li> <li><p>ACTIVE - The journey has been developed and published. Depending on the journey's schedule, the journey may currently be running or scheduled to start running at a later time. If a journey's status is ACTIVE, you can't add, change, or remove activities from it.</p></li> <li><p>COMPLETED - The journey has been published and has finished running. All participants have entered the journey and no participants are waiting to complete the journey or any activities in the journey.</p></li> <li><p>CANCELLED - The journey has been stopped. If a journey's status is CANCELLED, you can't add, change, or remove activities or segment settings from the journey.</p></li> <li><p>CLOSED - The journey has been published and has started running. It may have also passed its scheduled end time, or passed its scheduled start time and a refresh frequency hasn't been specified for it. If a journey's status is CLOSED, you can't add participants to it, and no existing participants can enter the journey for the first time. However, any existing participants who are currently waiting to start an activity may continue the journey.</p></li></ul>
        pub fn set_state(mut self, input: std::option::Option<crate::model::State>) -> Self {
            self.state = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>This object is not used or supported.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>This object is not used or supported.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>Specifies whether endpoints in quiet hours should enter a wait till the end of their quiet hours.</p>
        pub fn wait_for_quiet_time(mut self, input: bool) -> Self {
            self.wait_for_quiet_time = Some(input);
            self
        }
        /// <p>Specifies whether endpoints in quiet hours should enter a wait till the end of their quiet hours.</p>
        pub fn set_wait_for_quiet_time(mut self, input: std::option::Option<bool>) -> Self {
            self.wait_for_quiet_time = input;
            self
        }
        /// <p>Specifies whether a journey should be refreshed on segment update.</p>
        pub fn refresh_on_segment_update(mut self, input: bool) -> Self {
            self.refresh_on_segment_update = Some(input);
            self
        }
        /// <p>Specifies whether a journey should be refreshed on segment update.</p>
        pub fn set_refresh_on_segment_update(mut self, input: std::option::Option<bool>) -> Self {
            self.refresh_on_segment_update = input;
            self
        }
        /// <p>The channel-specific configurations for the journey.</p>
        pub fn journey_channel_settings(
            mut self,
            input: crate::model::JourneyChannelSettings,
        ) -> Self {
            self.journey_channel_settings = Some(input);
            self
        }
        /// <p>The channel-specific configurations for the journey.</p>
        pub fn set_journey_channel_settings(
            mut self,
            input: std::option::Option<crate::model::JourneyChannelSettings>,
        ) -> Self {
            self.journey_channel_settings = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneyResponse`](crate::model::JourneyResponse)
        pub fn build(self) -> crate::model::JourneyResponse {
            crate::model::JourneyResponse {
                activities: self.activities,
                application_id: self.application_id,
                creation_date: self.creation_date,
                id: self.id,
                last_modified_date: self.last_modified_date,
                limits: self.limits,
                local_time: self.local_time.unwrap_or_default(),
                name: self.name,
                quiet_time: self.quiet_time,
                refresh_frequency: self.refresh_frequency,
                schedule: self.schedule,
                start_activity: self.start_activity,
                start_condition: self.start_condition,
                state: self.state,
                tags: self.tags,
                wait_for_quiet_time: self.wait_for_quiet_time.unwrap_or_default(),
                refresh_on_segment_update: self.refresh_on_segment_update.unwrap_or_default(),
                journey_channel_settings: self.journey_channel_settings,
            }
        }
    }
}
impl JourneyResponse {
    /// Creates a new builder-style object to manufacture [`JourneyResponse`](crate::model::JourneyResponse)
    pub fn builder() -> crate::model::journey_response::Builder {
        crate::model::journey_response::Builder::default()
    }
}

/// <p>The channel-specific configurations for the journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneyChannelSettings {
    /// <p>Amazon Resource Name (ARN) of the Connect Campaign.</p>
    pub connect_campaign_arn: std::option::Option<std::string::String>,
    /// <p>IAM role ARN to be assumed when invoking Connect campaign execution APIs for dialing.</p>
    pub connect_campaign_execution_role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JourneyChannelSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneyChannelSettings");
        formatter.field("connect_campaign_arn", &self.connect_campaign_arn);
        formatter.field(
            "connect_campaign_execution_role_arn",
            &self.connect_campaign_execution_role_arn,
        );
        formatter.finish()
    }
}
/// See [`JourneyChannelSettings`](crate::model::JourneyChannelSettings)
pub mod journey_channel_settings {
    /// A builder for [`JourneyChannelSettings`](crate::model::JourneyChannelSettings)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connect_campaign_arn: std::option::Option<std::string::String>,
        pub(crate) connect_campaign_execution_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Amazon Resource Name (ARN) of the Connect Campaign.</p>
        pub fn connect_campaign_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.connect_campaign_arn = Some(input.into());
            self
        }
        /// <p>Amazon Resource Name (ARN) of the Connect Campaign.</p>
        pub fn set_connect_campaign_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_campaign_arn = input;
            self
        }
        /// <p>IAM role ARN to be assumed when invoking Connect campaign execution APIs for dialing.</p>
        pub fn connect_campaign_execution_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.connect_campaign_execution_role_arn = Some(input.into());
            self
        }
        /// <p>IAM role ARN to be assumed when invoking Connect campaign execution APIs for dialing.</p>
        pub fn set_connect_campaign_execution_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connect_campaign_execution_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneyChannelSettings`](crate::model::JourneyChannelSettings)
        pub fn build(self) -> crate::model::JourneyChannelSettings {
            crate::model::JourneyChannelSettings {
                connect_campaign_arn: self.connect_campaign_arn,
                connect_campaign_execution_role_arn: self.connect_campaign_execution_role_arn,
            }
        }
    }
}
impl JourneyChannelSettings {
    /// Creates a new builder-style object to manufacture [`JourneyChannelSettings`](crate::model::JourneyChannelSettings)
    pub fn builder() -> crate::model::journey_channel_settings::Builder {
        crate::model::journey_channel_settings::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum State {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Closed,
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Draft,
    #[allow(missing_docs)] // documentation missing in model
    Paused,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for State {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => State::Active,
            "CANCELLED" => State::Cancelled,
            "CLOSED" => State::Closed,
            "COMPLETED" => State::Completed,
            "DRAFT" => State::Draft,
            "PAUSED" => State::Paused,
            other => State::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for State {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(State::from(s))
    }
}
impl State {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            State::Active => "ACTIVE",
            State::Cancelled => "CANCELLED",
            State::Closed => "CLOSED",
            State::Completed => "COMPLETED",
            State::Draft => "DRAFT",
            State::Paused => "PAUSED",
            State::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE",
            "CANCELLED",
            "CLOSED",
            "COMPLETED",
            "DRAFT",
            "PAUSED",
        ]
    }
}
impl AsRef<str> for State {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the conditions for the first activity in a journey. This activity and its conditions determine which users are participants in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartCondition {
    /// <p>The custom description of the condition.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Specifies the settings for an event that causes a journey activity to start.</p>
    pub event_start_condition: std::option::Option<crate::model::EventStartCondition>,
    /// <p>The segment that's associated with the first activity in the journey. This segment determines which users are participants in the journey.</p>
    pub segment_start_condition: std::option::Option<crate::model::SegmentCondition>,
}
impl std::fmt::Debug for StartCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartCondition");
        formatter.field("description", &self.description);
        formatter.field("event_start_condition", &self.event_start_condition);
        formatter.field("segment_start_condition", &self.segment_start_condition);
        formatter.finish()
    }
}
/// See [`StartCondition`](crate::model::StartCondition)
pub mod start_condition {
    /// A builder for [`StartCondition`](crate::model::StartCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) event_start_condition: std::option::Option<crate::model::EventStartCondition>,
        pub(crate) segment_start_condition: std::option::Option<crate::model::SegmentCondition>,
    }
    impl Builder {
        /// <p>The custom description of the condition.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The custom description of the condition.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>Specifies the settings for an event that causes a journey activity to start.</p>
        pub fn event_start_condition(mut self, input: crate::model::EventStartCondition) -> Self {
            self.event_start_condition = Some(input);
            self
        }
        /// <p>Specifies the settings for an event that causes a journey activity to start.</p>
        pub fn set_event_start_condition(
            mut self,
            input: std::option::Option<crate::model::EventStartCondition>,
        ) -> Self {
            self.event_start_condition = input;
            self
        }
        /// <p>The segment that's associated with the first activity in the journey. This segment determines which users are participants in the journey.</p>
        pub fn segment_start_condition(mut self, input: crate::model::SegmentCondition) -> Self {
            self.segment_start_condition = Some(input);
            self
        }
        /// <p>The segment that's associated with the first activity in the journey. This segment determines which users are participants in the journey.</p>
        pub fn set_segment_start_condition(
            mut self,
            input: std::option::Option<crate::model::SegmentCondition>,
        ) -> Self {
            self.segment_start_condition = input;
            self
        }
        /// Consumes the builder and constructs a [`StartCondition`](crate::model::StartCondition)
        pub fn build(self) -> crate::model::StartCondition {
            crate::model::StartCondition {
                description: self.description,
                event_start_condition: self.event_start_condition,
                segment_start_condition: self.segment_start_condition,
            }
        }
    }
}
impl StartCondition {
    /// Creates a new builder-style object to manufacture [`StartCondition`](crate::model::StartCondition)
    pub fn builder() -> crate::model::start_condition::Builder {
        crate::model::start_condition::Builder::default()
    }
}

/// <p>Specifies a segment to associate with an activity in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentCondition {
    /// <p>The unique identifier for the segment to associate with the activity.</p>
    pub segment_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SegmentCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentCondition");
        formatter.field("segment_id", &self.segment_id);
        formatter.finish()
    }
}
/// See [`SegmentCondition`](crate::model::SegmentCondition)
pub mod segment_condition {
    /// A builder for [`SegmentCondition`](crate::model::SegmentCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) segment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the segment to associate with the activity.</p>
        pub fn segment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the segment to associate with the activity.</p>
        pub fn set_segment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentCondition`](crate::model::SegmentCondition)
        pub fn build(self) -> crate::model::SegmentCondition {
            crate::model::SegmentCondition {
                segment_id: self.segment_id,
            }
        }
    }
}
impl SegmentCondition {
    /// Creates a new builder-style object to manufacture [`SegmentCondition`](crate::model::SegmentCondition)
    pub fn builder() -> crate::model::segment_condition::Builder {
        crate::model::segment_condition::Builder::default()
    }
}

/// <p>Specifies the settings for an event that causes a journey activity to start.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventStartCondition {
    /// <p>Specifies the settings for an event that causes a campaign to be sent or a journey activity to be performed.</p>
    pub event_filter: std::option::Option<crate::model::EventFilter>,
    #[allow(missing_docs)] // documentation missing in model
    pub segment_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EventStartCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventStartCondition");
        formatter.field("event_filter", &self.event_filter);
        formatter.field("segment_id", &self.segment_id);
        formatter.finish()
    }
}
/// See [`EventStartCondition`](crate::model::EventStartCondition)
pub mod event_start_condition {
    /// A builder for [`EventStartCondition`](crate::model::EventStartCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_filter: std::option::Option<crate::model::EventFilter>,
        pub(crate) segment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the settings for an event that causes a campaign to be sent or a journey activity to be performed.</p>
        pub fn event_filter(mut self, input: crate::model::EventFilter) -> Self {
            self.event_filter = Some(input);
            self
        }
        /// <p>Specifies the settings for an event that causes a campaign to be sent or a journey activity to be performed.</p>
        pub fn set_event_filter(
            mut self,
            input: std::option::Option<crate::model::EventFilter>,
        ) -> Self {
            self.event_filter = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn segment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_id = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_segment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EventStartCondition`](crate::model::EventStartCondition)
        pub fn build(self) -> crate::model::EventStartCondition {
            crate::model::EventStartCondition {
                event_filter: self.event_filter,
                segment_id: self.segment_id,
            }
        }
    }
}
impl EventStartCondition {
    /// Creates a new builder-style object to manufacture [`EventStartCondition`](crate::model::EventStartCondition)
    pub fn builder() -> crate::model::event_start_condition::Builder {
        crate::model::event_start_condition::Builder::default()
    }
}

/// <p>Specifies the settings for an event that causes a campaign to be sent or a journey activity to be performed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventFilter {
    /// <p>The dimensions for the event filter to use for the campaign or the journey activity.</p>
    pub dimensions: std::option::Option<crate::model::EventDimensions>,
    /// <p>The type of event that causes the campaign to be sent or the journey activity to be performed. Valid values are: SYSTEM, sends the campaign or performs the activity when a system event occurs; and, ENDPOINT, sends the campaign or performs the activity when an endpoint event (<link  linkend="apps-application-id-events">Events resource</link>) occurs.</p>
    pub filter_type: std::option::Option<crate::model::FilterType>,
}
impl std::fmt::Debug for EventFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventFilter");
        formatter.field("dimensions", &self.dimensions);
        formatter.field("filter_type", &self.filter_type);
        formatter.finish()
    }
}
/// See [`EventFilter`](crate::model::EventFilter)
pub mod event_filter {
    /// A builder for [`EventFilter`](crate::model::EventFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimensions: std::option::Option<crate::model::EventDimensions>,
        pub(crate) filter_type: std::option::Option<crate::model::FilterType>,
    }
    impl Builder {
        /// <p>The dimensions for the event filter to use for the campaign or the journey activity.</p>
        pub fn dimensions(mut self, input: crate::model::EventDimensions) -> Self {
            self.dimensions = Some(input);
            self
        }
        /// <p>The dimensions for the event filter to use for the campaign or the journey activity.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::EventDimensions>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The type of event that causes the campaign to be sent or the journey activity to be performed. Valid values are: SYSTEM, sends the campaign or performs the activity when a system event occurs; and, ENDPOINT, sends the campaign or performs the activity when an endpoint event (<link  linkend="apps-application-id-events">Events resource</link>) occurs.</p>
        pub fn filter_type(mut self, input: crate::model::FilterType) -> Self {
            self.filter_type = Some(input);
            self
        }
        /// <p>The type of event that causes the campaign to be sent or the journey activity to be performed. Valid values are: SYSTEM, sends the campaign or performs the activity when a system event occurs; and, ENDPOINT, sends the campaign or performs the activity when an endpoint event (<link  linkend="apps-application-id-events">Events resource</link>) occurs.</p>
        pub fn set_filter_type(
            mut self,
            input: std::option::Option<crate::model::FilterType>,
        ) -> Self {
            self.filter_type = input;
            self
        }
        /// Consumes the builder and constructs a [`EventFilter`](crate::model::EventFilter)
        pub fn build(self) -> crate::model::EventFilter {
            crate::model::EventFilter {
                dimensions: self.dimensions,
                filter_type: self.filter_type,
            }
        }
    }
}
impl EventFilter {
    /// Creates a new builder-style object to manufacture [`EventFilter`](crate::model::EventFilter)
    pub fn builder() -> crate::model::event_filter::Builder {
        crate::model::event_filter::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FilterType {
    #[allow(missing_docs)] // documentation missing in model
    Endpoint,
    #[allow(missing_docs)] // documentation missing in model
    System,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for FilterType {
    fn from(s: &str) -> Self {
        match s {
            "ENDPOINT" => FilterType::Endpoint,
            "SYSTEM" => FilterType::System,
            other => FilterType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for FilterType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FilterType::from(s))
    }
}
impl FilterType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FilterType::Endpoint => "ENDPOINT",
            FilterType::System => "SYSTEM",
            FilterType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ENDPOINT", "SYSTEM"]
    }
}
impl AsRef<str> for FilterType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the dimensions for an event filter that determines when a campaign is sent or a journey activity is performed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventDimensions {
    /// <p>One or more custom attributes that your application reports to Amazon Pinpoint. You can use these attributes as selection criteria when you create an event filter.</p>
    pub attributes: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AttributeDimension>,
    >,
    /// <p>The name of the event that causes the campaign to be sent or the journey activity to be performed. This can be a standard event that Amazon Pinpoint generates, such as _email.delivered. For campaigns, this can also be a custom event that's specific to your application. For information about standard events, see <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/event-streams.html">Streaming Amazon Pinpoint Events</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p>
    pub event_type: std::option::Option<crate::model::SetDimension>,
    /// <p>One or more custom metrics that your application reports to Amazon Pinpoint. You can use these metrics as selection criteria when you create an event filter.</p>
    pub metrics: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::MetricDimension>,
    >,
}
impl std::fmt::Debug for EventDimensions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventDimensions");
        formatter.field("attributes", &self.attributes);
        formatter.field("event_type", &self.event_type);
        formatter.field("metrics", &self.metrics);
        formatter.finish()
    }
}
/// See [`EventDimensions`](crate::model::EventDimensions)
pub mod event_dimensions {
    /// A builder for [`EventDimensions`](crate::model::EventDimensions)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AttributeDimension>,
        >,
        pub(crate) event_type: std::option::Option<crate::model::SetDimension>,
        pub(crate) metrics: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::MetricDimension>,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>One or more custom attributes that your application reports to Amazon Pinpoint. You can use these attributes as selection criteria when you create an event filter.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AttributeDimension>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>One or more custom attributes that your application reports to Amazon Pinpoint. You can use these attributes as selection criteria when you create an event filter.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AttributeDimension>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The name of the event that causes the campaign to be sent or the journey activity to be performed. This can be a standard event that Amazon Pinpoint generates, such as _email.delivered. For campaigns, this can also be a custom event that's specific to your application. For information about standard events, see <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/event-streams.html">Streaming Amazon Pinpoint Events</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p>
        pub fn event_type(mut self, input: crate::model::SetDimension) -> Self {
            self.event_type = Some(input);
            self
        }
        /// <p>The name of the event that causes the campaign to be sent or the journey activity to be performed. This can be a standard event that Amazon Pinpoint generates, such as _email.delivered. For campaigns, this can also be a custom event that's specific to your application. For information about standard events, see <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/event-streams.html">Streaming Amazon Pinpoint Events</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p>
        pub fn set_event_type(
            mut self,
            input: std::option::Option<crate::model::SetDimension>,
        ) -> Self {
            self.event_type = input;
            self
        }
        /// Adds a key-value pair to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>One or more custom metrics that your application reports to Amazon Pinpoint. You can use these metrics as selection criteria when you create an event filter.</p>
        pub fn metrics(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MetricDimension>,
        ) -> Self {
            let mut hash_map = self.metrics.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metrics = Some(hash_map);
            self
        }
        /// <p>One or more custom metrics that your application reports to Amazon Pinpoint. You can use these metrics as selection criteria when you create an event filter.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::MetricDimension>,
            >,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`EventDimensions`](crate::model::EventDimensions)
        pub fn build(self) -> crate::model::EventDimensions {
            crate::model::EventDimensions {
                attributes: self.attributes,
                event_type: self.event_type,
                metrics: self.metrics,
            }
        }
    }
}
impl EventDimensions {
    /// Creates a new builder-style object to manufacture [`EventDimensions`](crate::model::EventDimensions)
    pub fn builder() -> crate::model::event_dimensions::Builder {
        crate::model::event_dimensions::Builder::default()
    }
}

/// <p>Specifies the schedule settings for a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneySchedule {
    /// <p>The scheduled time, in ISO 8601 format, when the journey ended or will end.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The scheduled time, in ISO 8601 format, when the journey began or will begin.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The starting UTC offset for the journey schedule, if the value of the journey's LocalTime property is true. Valid values are: UTC,
    /// UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05, UTC+05:30,
    /// UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+08:45, UTC+09, UTC+09:30,
    /// UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+12:45, UTC+13, UTC+13:45, UTC-02,
    /// UTC-02:30, UTC-03, UTC-03:30, UTC-04, UTC-05, UTC-06, UTC-07, UTC-08, UTC-09,
    /// UTC-09:30, UTC-10, and UTC-11.</p>
    pub timezone: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JourneySchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneySchedule");
        formatter.field("end_time", &self.end_time);
        formatter.field("start_time", &self.start_time);
        formatter.field("timezone", &self.timezone);
        formatter.finish()
    }
}
/// See [`JourneySchedule`](crate::model::JourneySchedule)
pub mod journey_schedule {
    /// A builder for [`JourneySchedule`](crate::model::JourneySchedule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) timezone: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The scheduled time, in ISO 8601 format, when the journey ended or will end.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The scheduled time, in ISO 8601 format, when the journey ended or will end.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The scheduled time, in ISO 8601 format, when the journey began or will begin.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The scheduled time, in ISO 8601 format, when the journey began or will begin.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The starting UTC offset for the journey schedule, if the value of the journey's LocalTime property is true. Valid values are: UTC,
        /// UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05, UTC+05:30,
        /// UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+08:45, UTC+09, UTC+09:30,
        /// UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+12:45, UTC+13, UTC+13:45, UTC-02,
        /// UTC-02:30, UTC-03, UTC-03:30, UTC-04, UTC-05, UTC-06, UTC-07, UTC-08, UTC-09,
        /// UTC-09:30, UTC-10, and UTC-11.</p>
        pub fn timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.timezone = Some(input.into());
            self
        }
        /// <p>The starting UTC offset for the journey schedule, if the value of the journey's LocalTime property is true. Valid values are: UTC,
        /// UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05, UTC+05:30,
        /// UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+08:45, UTC+09, UTC+09:30,
        /// UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+12:45, UTC+13, UTC+13:45, UTC-02,
        /// UTC-02:30, UTC-03, UTC-03:30, UTC-04, UTC-05, UTC-06, UTC-07, UTC-08, UTC-09,
        /// UTC-09:30, UTC-10, and UTC-11.</p>
        pub fn set_timezone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timezone = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneySchedule`](crate::model::JourneySchedule)
        pub fn build(self) -> crate::model::JourneySchedule {
            crate::model::JourneySchedule {
                end_time: self.end_time,
                start_time: self.start_time,
                timezone: self.timezone,
            }
        }
    }
}
impl JourneySchedule {
    /// Creates a new builder-style object to manufacture [`JourneySchedule`](crate::model::JourneySchedule)
    pub fn builder() -> crate::model::journey_schedule::Builder {
        crate::model::journey_schedule::Builder::default()
    }
}

/// <p>Specifies the start and end times that define a time range when messages aren't sent to endpoints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct QuietTime {
    /// <p>The specific time when quiet time ends. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.</p>
    pub end: std::option::Option<std::string::String>,
    /// <p>The specific time when quiet time begins. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.</p>
    pub start: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for QuietTime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("QuietTime");
        formatter.field("end", &self.end);
        formatter.field("start", &self.start);
        formatter.finish()
    }
}
/// See [`QuietTime`](crate::model::QuietTime)
pub mod quiet_time {
    /// A builder for [`QuietTime`](crate::model::QuietTime)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) end: std::option::Option<std::string::String>,
        pub(crate) start: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The specific time when quiet time ends. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.</p>
        pub fn end(mut self, input: impl Into<std::string::String>) -> Self {
            self.end = Some(input.into());
            self
        }
        /// <p>The specific time when quiet time ends. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.</p>
        pub fn set_end(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end = input;
            self
        }
        /// <p>The specific time when quiet time begins. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.</p>
        pub fn start(mut self, input: impl Into<std::string::String>) -> Self {
            self.start = Some(input.into());
            self
        }
        /// <p>The specific time when quiet time begins. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.</p>
        pub fn set_start(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start = input;
            self
        }
        /// Consumes the builder and constructs a [`QuietTime`](crate::model::QuietTime)
        pub fn build(self) -> crate::model::QuietTime {
            crate::model::QuietTime {
                end: self.end,
                start: self.start,
            }
        }
    }
}
impl QuietTime {
    /// Creates a new builder-style object to manufacture [`QuietTime`](crate::model::QuietTime)
    pub fn builder() -> crate::model::quiet_time::Builder {
        crate::model::quiet_time::Builder::default()
    }
}

/// <p>Specifies limits on the messages that a journey can send and the number of times participants can enter a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneyLimits {
    /// <p>The maximum number of messages that the journey can send to a single participant during a 24-hour period. The maximum value is 100.</p>
    pub daily_cap: i32,
    /// <p>The maximum number of times that a participant can enter the journey. The maximum value is 100. To allow participants to enter the journey an unlimited number of times, set this value to 0.</p>
    pub endpoint_reentry_cap: i32,
    /// <p>The maximum number of messages that the journey can send each second.</p>
    pub messages_per_second: i32,
    /// <p>Minimum time that must pass before an endpoint can re-enter a given journey. The duration should use an ISO 8601 format, such as PT1H. </p>
    pub endpoint_reentry_interval: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JourneyLimits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneyLimits");
        formatter.field("daily_cap", &self.daily_cap);
        formatter.field("endpoint_reentry_cap", &self.endpoint_reentry_cap);
        formatter.field("messages_per_second", &self.messages_per_second);
        formatter.field("endpoint_reentry_interval", &self.endpoint_reentry_interval);
        formatter.finish()
    }
}
/// See [`JourneyLimits`](crate::model::JourneyLimits)
pub mod journey_limits {
    /// A builder for [`JourneyLimits`](crate::model::JourneyLimits)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) daily_cap: std::option::Option<i32>,
        pub(crate) endpoint_reentry_cap: std::option::Option<i32>,
        pub(crate) messages_per_second: std::option::Option<i32>,
        pub(crate) endpoint_reentry_interval: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum number of messages that the journey can send to a single participant during a 24-hour period. The maximum value is 100.</p>
        pub fn daily_cap(mut self, input: i32) -> Self {
            self.daily_cap = Some(input);
            self
        }
        /// <p>The maximum number of messages that the journey can send to a single participant during a 24-hour period. The maximum value is 100.</p>
        pub fn set_daily_cap(mut self, input: std::option::Option<i32>) -> Self {
            self.daily_cap = input;
            self
        }
        /// <p>The maximum number of times that a participant can enter the journey. The maximum value is 100. To allow participants to enter the journey an unlimited number of times, set this value to 0.</p>
        pub fn endpoint_reentry_cap(mut self, input: i32) -> Self {
            self.endpoint_reentry_cap = Some(input);
            self
        }
        /// <p>The maximum number of times that a participant can enter the journey. The maximum value is 100. To allow participants to enter the journey an unlimited number of times, set this value to 0.</p>
        pub fn set_endpoint_reentry_cap(mut self, input: std::option::Option<i32>) -> Self {
            self.endpoint_reentry_cap = input;
            self
        }
        /// <p>The maximum number of messages that the journey can send each second.</p>
        pub fn messages_per_second(mut self, input: i32) -> Self {
            self.messages_per_second = Some(input);
            self
        }
        /// <p>The maximum number of messages that the journey can send each second.</p>
        pub fn set_messages_per_second(mut self, input: std::option::Option<i32>) -> Self {
            self.messages_per_second = input;
            self
        }
        /// <p>Minimum time that must pass before an endpoint can re-enter a given journey. The duration should use an ISO 8601 format, such as PT1H. </p>
        pub fn endpoint_reentry_interval(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_reentry_interval = Some(input.into());
            self
        }
        /// <p>Minimum time that must pass before an endpoint can re-enter a given journey. The duration should use an ISO 8601 format, such as PT1H. </p>
        pub fn set_endpoint_reentry_interval(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_reentry_interval = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneyLimits`](crate::model::JourneyLimits)
        pub fn build(self) -> crate::model::JourneyLimits {
            crate::model::JourneyLimits {
                daily_cap: self.daily_cap.unwrap_or_default(),
                endpoint_reentry_cap: self.endpoint_reentry_cap.unwrap_or_default(),
                messages_per_second: self.messages_per_second.unwrap_or_default(),
                endpoint_reentry_interval: self.endpoint_reentry_interval,
            }
        }
    }
}
impl JourneyLimits {
    /// Creates a new builder-style object to manufacture [`JourneyLimits`](crate::model::JourneyLimits)
    pub fn builder() -> crate::model::journey_limits::Builder {
        crate::model::journey_limits::Builder::default()
    }
}

/// <p>Specifies the configuration and other settings for an activity in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Activity {
    /// <p>The settings for a custom message activity. This type of activity calls an AWS Lambda function or web hook that sends messages to participants.</p>
    pub custom: std::option::Option<crate::model::CustomMessageActivity>,
    /// <p>The settings for a yes/no split activity. This type of activity sends participants down one of two paths in a journey, based on conditions that you specify.</p>
    pub conditional_split: std::option::Option<crate::model::ConditionalSplitActivity>,
    /// <p>The custom description of the activity.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The settings for an email activity. This type of activity sends an email message to participants.</p>
    pub email: std::option::Option<crate::model::EmailMessageActivity>,
    /// <p>The settings for a holdout activity. This type of activity stops a journey for a specified percentage of participants.</p>
    pub holdout: std::option::Option<crate::model::HoldoutActivity>,
    /// <p>The settings for a multivariate split activity. This type of activity sends participants down one of as many as five paths (including a default <i>Else</i> path) in a journey, based on conditions that you specify.</p>
    pub multi_condition: std::option::Option<crate::model::MultiConditionalSplitActivity>,
    /// <p>The settings for a push notification activity. This type of activity sends a push notification to participants.</p>
    pub push: std::option::Option<crate::model::PushMessageActivity>,
    /// <p>The settings for a random split activity. This type of activity randomly sends specified percentages of participants down one of as many as five paths in a journey, based on conditions that you specify.</p>
    pub random_split: std::option::Option<crate::model::RandomSplitActivity>,
    /// <p>The settings for an SMS activity. This type of activity sends a text message to participants.</p>
    pub sms: std::option::Option<crate::model::SmsMessageActivity>,
    /// <p>The settings for a wait activity. This type of activity waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.</p>
    pub wait: std::option::Option<crate::model::WaitActivity>,
    /// <p>The settings for a connect activity. This type of activity initiates a contact center call to participants.</p>
    pub contact_center: std::option::Option<crate::model::ContactCenterActivity>,
}
impl std::fmt::Debug for Activity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Activity");
        formatter.field("custom", &self.custom);
        formatter.field("conditional_split", &self.conditional_split);
        formatter.field("description", &self.description);
        formatter.field("email", &self.email);
        formatter.field("holdout", &self.holdout);
        formatter.field("multi_condition", &self.multi_condition);
        formatter.field("push", &self.push);
        formatter.field("random_split", &self.random_split);
        formatter.field("sms", &self.sms);
        formatter.field("wait", &self.wait);
        formatter.field("contact_center", &self.contact_center);
        formatter.finish()
    }
}
/// See [`Activity`](crate::model::Activity)
pub mod activity {
    /// A builder for [`Activity`](crate::model::Activity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom: std::option::Option<crate::model::CustomMessageActivity>,
        pub(crate) conditional_split: std::option::Option<crate::model::ConditionalSplitActivity>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<crate::model::EmailMessageActivity>,
        pub(crate) holdout: std::option::Option<crate::model::HoldoutActivity>,
        pub(crate) multi_condition:
            std::option::Option<crate::model::MultiConditionalSplitActivity>,
        pub(crate) push: std::option::Option<crate::model::PushMessageActivity>,
        pub(crate) random_split: std::option::Option<crate::model::RandomSplitActivity>,
        pub(crate) sms: std::option::Option<crate::model::SmsMessageActivity>,
        pub(crate) wait: std::option::Option<crate::model::WaitActivity>,
        pub(crate) contact_center: std::option::Option<crate::model::ContactCenterActivity>,
    }
    impl Builder {
        /// <p>The settings for a custom message activity. This type of activity calls an AWS Lambda function or web hook that sends messages to participants.</p>
        pub fn custom(mut self, input: crate::model::CustomMessageActivity) -> Self {
            self.custom = Some(input);
            self
        }
        /// <p>The settings for a custom message activity. This type of activity calls an AWS Lambda function or web hook that sends messages to participants.</p>
        pub fn set_custom(
            mut self,
            input: std::option::Option<crate::model::CustomMessageActivity>,
        ) -> Self {
            self.custom = input;
            self
        }
        /// <p>The settings for a yes/no split activity. This type of activity sends participants down one of two paths in a journey, based on conditions that you specify.</p>
        pub fn conditional_split(mut self, input: crate::model::ConditionalSplitActivity) -> Self {
            self.conditional_split = Some(input);
            self
        }
        /// <p>The settings for a yes/no split activity. This type of activity sends participants down one of two paths in a journey, based on conditions that you specify.</p>
        pub fn set_conditional_split(
            mut self,
            input: std::option::Option<crate::model::ConditionalSplitActivity>,
        ) -> Self {
            self.conditional_split = input;
            self
        }
        /// <p>The custom description of the activity.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The custom description of the activity.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The settings for an email activity. This type of activity sends an email message to participants.</p>
        pub fn email(mut self, input: crate::model::EmailMessageActivity) -> Self {
            self.email = Some(input);
            self
        }
        /// <p>The settings for an email activity. This type of activity sends an email message to participants.</p>
        pub fn set_email(
            mut self,
            input: std::option::Option<crate::model::EmailMessageActivity>,
        ) -> Self {
            self.email = input;
            self
        }
        /// <p>The settings for a holdout activity. This type of activity stops a journey for a specified percentage of participants.</p>
        pub fn holdout(mut self, input: crate::model::HoldoutActivity) -> Self {
            self.holdout = Some(input);
            self
        }
        /// <p>The settings for a holdout activity. This type of activity stops a journey for a specified percentage of participants.</p>
        pub fn set_holdout(
            mut self,
            input: std::option::Option<crate::model::HoldoutActivity>,
        ) -> Self {
            self.holdout = input;
            self
        }
        /// <p>The settings for a multivariate split activity. This type of activity sends participants down one of as many as five paths (including a default <i>Else</i> path) in a journey, based on conditions that you specify.</p>
        pub fn multi_condition(
            mut self,
            input: crate::model::MultiConditionalSplitActivity,
        ) -> Self {
            self.multi_condition = Some(input);
            self
        }
        /// <p>The settings for a multivariate split activity. This type of activity sends participants down one of as many as five paths (including a default <i>Else</i> path) in a journey, based on conditions that you specify.</p>
        pub fn set_multi_condition(
            mut self,
            input: std::option::Option<crate::model::MultiConditionalSplitActivity>,
        ) -> Self {
            self.multi_condition = input;
            self
        }
        /// <p>The settings for a push notification activity. This type of activity sends a push notification to participants.</p>
        pub fn push(mut self, input: crate::model::PushMessageActivity) -> Self {
            self.push = Some(input);
            self
        }
        /// <p>The settings for a push notification activity. This type of activity sends a push notification to participants.</p>
        pub fn set_push(
            mut self,
            input: std::option::Option<crate::model::PushMessageActivity>,
        ) -> Self {
            self.push = input;
            self
        }
        /// <p>The settings for a random split activity. This type of activity randomly sends specified percentages of participants down one of as many as five paths in a journey, based on conditions that you specify.</p>
        pub fn random_split(mut self, input: crate::model::RandomSplitActivity) -> Self {
            self.random_split = Some(input);
            self
        }
        /// <p>The settings for a random split activity. This type of activity randomly sends specified percentages of participants down one of as many as five paths in a journey, based on conditions that you specify.</p>
        pub fn set_random_split(
            mut self,
            input: std::option::Option<crate::model::RandomSplitActivity>,
        ) -> Self {
            self.random_split = input;
            self
        }
        /// <p>The settings for an SMS activity. This type of activity sends a text message to participants.</p>
        pub fn sms(mut self, input: crate::model::SmsMessageActivity) -> Self {
            self.sms = Some(input);
            self
        }
        /// <p>The settings for an SMS activity. This type of activity sends a text message to participants.</p>
        pub fn set_sms(
            mut self,
            input: std::option::Option<crate::model::SmsMessageActivity>,
        ) -> Self {
            self.sms = input;
            self
        }
        /// <p>The settings for a wait activity. This type of activity waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.</p>
        pub fn wait(mut self, input: crate::model::WaitActivity) -> Self {
            self.wait = Some(input);
            self
        }
        /// <p>The settings for a wait activity. This type of activity waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.</p>
        pub fn set_wait(mut self, input: std::option::Option<crate::model::WaitActivity>) -> Self {
            self.wait = input;
            self
        }
        /// <p>The settings for a connect activity. This type of activity initiates a contact center call to participants.</p>
        pub fn contact_center(mut self, input: crate::model::ContactCenterActivity) -> Self {
            self.contact_center = Some(input);
            self
        }
        /// <p>The settings for a connect activity. This type of activity initiates a contact center call to participants.</p>
        pub fn set_contact_center(
            mut self,
            input: std::option::Option<crate::model::ContactCenterActivity>,
        ) -> Self {
            self.contact_center = input;
            self
        }
        /// Consumes the builder and constructs a [`Activity`](crate::model::Activity)
        pub fn build(self) -> crate::model::Activity {
            crate::model::Activity {
                custom: self.custom,
                conditional_split: self.conditional_split,
                description: self.description,
                email: self.email,
                holdout: self.holdout,
                multi_condition: self.multi_condition,
                push: self.push,
                random_split: self.random_split,
                sms: self.sms,
                wait: self.wait,
                contact_center: self.contact_center,
            }
        }
    }
}
impl Activity {
    /// Creates a new builder-style object to manufacture [`Activity`](crate::model::Activity)
    pub fn builder() -> crate::model::activity::Builder {
        crate::model::activity::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ContactCenterActivity {
    /// <p>The unique identifier for the next activity to perform after the this activity.</p>
    pub next_activity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ContactCenterActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ContactCenterActivity");
        formatter.field("next_activity", &self.next_activity);
        formatter.finish()
    }
}
/// See [`ContactCenterActivity`](crate::model::ContactCenterActivity)
pub mod contact_center_activity {
    /// A builder for [`ContactCenterActivity`](crate::model::ContactCenterActivity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_activity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the next activity to perform after the this activity.</p>
        pub fn next_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the next activity to perform after the this activity.</p>
        pub fn set_next_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_activity = input;
            self
        }
        /// Consumes the builder and constructs a [`ContactCenterActivity`](crate::model::ContactCenterActivity)
        pub fn build(self) -> crate::model::ContactCenterActivity {
            crate::model::ContactCenterActivity {
                next_activity: self.next_activity,
            }
        }
    }
}
impl ContactCenterActivity {
    /// Creates a new builder-style object to manufacture [`ContactCenterActivity`](crate::model::ContactCenterActivity)
    pub fn builder() -> crate::model::contact_center_activity::Builder {
        crate::model::contact_center_activity::Builder::default()
    }
}

/// <p>Specifies the settings for a wait activity in a journey. This type of activity waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WaitActivity {
    /// <p>The unique identifier for the next activity to perform, after performing the wait activity.</p>
    pub next_activity: std::option::Option<std::string::String>,
    /// <p>The amount of time to wait or the date and time when the activity moves participants to the next activity in the journey.</p>
    pub wait_time: std::option::Option<crate::model::WaitTime>,
}
impl std::fmt::Debug for WaitActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WaitActivity");
        formatter.field("next_activity", &self.next_activity);
        formatter.field("wait_time", &self.wait_time);
        formatter.finish()
    }
}
/// See [`WaitActivity`](crate::model::WaitActivity)
pub mod wait_activity {
    /// A builder for [`WaitActivity`](crate::model::WaitActivity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_activity: std::option::Option<std::string::String>,
        pub(crate) wait_time: std::option::Option<crate::model::WaitTime>,
    }
    impl Builder {
        /// <p>The unique identifier for the next activity to perform, after performing the wait activity.</p>
        pub fn next_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the next activity to perform, after performing the wait activity.</p>
        pub fn set_next_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_activity = input;
            self
        }
        /// <p>The amount of time to wait or the date and time when the activity moves participants to the next activity in the journey.</p>
        pub fn wait_time(mut self, input: crate::model::WaitTime) -> Self {
            self.wait_time = Some(input);
            self
        }
        /// <p>The amount of time to wait or the date and time when the activity moves participants to the next activity in the journey.</p>
        pub fn set_wait_time(mut self, input: std::option::Option<crate::model::WaitTime>) -> Self {
            self.wait_time = input;
            self
        }
        /// Consumes the builder and constructs a [`WaitActivity`](crate::model::WaitActivity)
        pub fn build(self) -> crate::model::WaitActivity {
            crate::model::WaitActivity {
                next_activity: self.next_activity,
                wait_time: self.wait_time,
            }
        }
    }
}
impl WaitActivity {
    /// Creates a new builder-style object to manufacture [`WaitActivity`](crate::model::WaitActivity)
    pub fn builder() -> crate::model::wait_activity::Builder {
        crate::model::wait_activity::Builder::default()
    }
}

/// <p>Specifies a duration or a date and time that indicates when Amazon Pinpoint determines whether an activity's conditions have been met or an activity moves participants to the next activity in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WaitTime {
    /// <p>The amount of time to wait, as a duration in ISO 8601 format, before determining whether the activity's conditions have been met or moving participants to the next activity in the journey.</p>
    pub wait_for: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint determines whether the activity's conditions have been met or the activity moves participants to the next activity in the journey.</p>
    pub wait_until: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for WaitTime {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WaitTime");
        formatter.field("wait_for", &self.wait_for);
        formatter.field("wait_until", &self.wait_until);
        formatter.finish()
    }
}
/// See [`WaitTime`](crate::model::WaitTime)
pub mod wait_time {
    /// A builder for [`WaitTime`](crate::model::WaitTime)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) wait_for: std::option::Option<std::string::String>,
        pub(crate) wait_until: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The amount of time to wait, as a duration in ISO 8601 format, before determining whether the activity's conditions have been met or moving participants to the next activity in the journey.</p>
        pub fn wait_for(mut self, input: impl Into<std::string::String>) -> Self {
            self.wait_for = Some(input.into());
            self
        }
        /// <p>The amount of time to wait, as a duration in ISO 8601 format, before determining whether the activity's conditions have been met or moving participants to the next activity in the journey.</p>
        pub fn set_wait_for(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.wait_for = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint determines whether the activity's conditions have been met or the activity moves participants to the next activity in the journey.</p>
        pub fn wait_until(mut self, input: impl Into<std::string::String>) -> Self {
            self.wait_until = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint determines whether the activity's conditions have been met or the activity moves participants to the next activity in the journey.</p>
        pub fn set_wait_until(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.wait_until = input;
            self
        }
        /// Consumes the builder and constructs a [`WaitTime`](crate::model::WaitTime)
        pub fn build(self) -> crate::model::WaitTime {
            crate::model::WaitTime {
                wait_for: self.wait_for,
                wait_until: self.wait_until,
            }
        }
    }
}
impl WaitTime {
    /// Creates a new builder-style object to manufacture [`WaitTime`](crate::model::WaitTime)
    pub fn builder() -> crate::model::wait_time::Builder {
        crate::model::wait_time::Builder::default()
    }
}

/// <p>Specifies the settings for an SMS activity in a journey. This type of activity sends a text message to participants.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SmsMessageActivity {
    /// <p>Specifies the sender ID and message type for an SMS message that's sent to participants in a journey.</p>
    pub message_config: std::option::Option<crate::model::JourneySmsMessage>,
    /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
    pub next_activity: std::option::Option<std::string::String>,
    /// <p>The name of the SMS message template to use for the message. If specified, this value must match the name of an existing message template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the version of the SMS template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
    pub template_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SmsMessageActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SmsMessageActivity");
        formatter.field("message_config", &self.message_config);
        formatter.field("next_activity", &self.next_activity);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_version", &self.template_version);
        formatter.finish()
    }
}
/// See [`SmsMessageActivity`](crate::model::SmsMessageActivity)
pub mod sms_message_activity {
    /// A builder for [`SmsMessageActivity`](crate::model::SmsMessageActivity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_config: std::option::Option<crate::model::JourneySmsMessage>,
        pub(crate) next_activity: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the sender ID and message type for an SMS message that's sent to participants in a journey.</p>
        pub fn message_config(mut self, input: crate::model::JourneySmsMessage) -> Self {
            self.message_config = Some(input);
            self
        }
        /// <p>Specifies the sender ID and message type for an SMS message that's sent to participants in a journey.</p>
        pub fn set_message_config(
            mut self,
            input: std::option::Option<crate::model::JourneySmsMessage>,
        ) -> Self {
            self.message_config = input;
            self
        }
        /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
        pub fn next_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
        pub fn set_next_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_activity = input;
            self
        }
        /// <p>The name of the SMS message template to use for the message. If specified, this value must match the name of an existing message template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the SMS message template to use for the message. If specified, this value must match the name of an existing message template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The unique identifier for the version of the SMS template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
        pub fn template_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_version = Some(input.into());
            self
        }
        /// <p>The unique identifier for the version of the SMS template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
        pub fn set_template_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_version = input;
            self
        }
        /// Consumes the builder and constructs a [`SmsMessageActivity`](crate::model::SmsMessageActivity)
        pub fn build(self) -> crate::model::SmsMessageActivity {
            crate::model::SmsMessageActivity {
                message_config: self.message_config,
                next_activity: self.next_activity,
                template_name: self.template_name,
                template_version: self.template_version,
            }
        }
    }
}
impl SmsMessageActivity {
    /// Creates a new builder-style object to manufacture [`SmsMessageActivity`](crate::model::SmsMessageActivity)
    pub fn builder() -> crate::model::sms_message_activity::Builder {
        crate::model::sms_message_activity::Builder::default()
    }
}

/// <p>Specifies the sender ID and message type for an SMS message that's sent to participants in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneySmsMessage {
    /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
    pub message_type: std::option::Option<crate::model::MessageType>,
    /// <p>The long code to send the SMS message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code using an E.164 format to ensure prompt and accurate delivery of the message. For example, +12065550100.</p>
    pub origination_number: std::option::Option<std::string::String>,
    /// <p>The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-countries.html">Supported Countries and Regions</a> in the Amazon Pinpoint User Guide.</p>
    pub sender_id: std::option::Option<std::string::String>,
    /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
    pub template_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JourneySmsMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneySmsMessage");
        formatter.field("message_type", &self.message_type);
        formatter.field("origination_number", &self.origination_number);
        formatter.field("sender_id", &self.sender_id);
        formatter.field("entity_id", &self.entity_id);
        formatter.field("template_id", &self.template_id);
        formatter.finish()
    }
}
/// See [`JourneySmsMessage`](crate::model::JourneySmsMessage)
pub mod journey_sms_message {
    /// A builder for [`JourneySmsMessage`](crate::model::JourneySmsMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_type: std::option::Option<crate::model::MessageType>,
        pub(crate) origination_number: std::option::Option<std::string::String>,
        pub(crate) sender_id: std::option::Option<std::string::String>,
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
        pub fn message_type(mut self, input: crate::model::MessageType) -> Self {
            self.message_type = Some(input);
            self
        }
        /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
        pub fn set_message_type(
            mut self,
            input: std::option::Option<crate::model::MessageType>,
        ) -> Self {
            self.message_type = input;
            self
        }
        /// <p>The long code to send the SMS message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code using an E.164 format to ensure prompt and accurate delivery of the message. For example, +12065550100.</p>
        pub fn origination_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.origination_number = Some(input.into());
            self
        }
        /// <p>The long code to send the SMS message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code using an E.164 format to ensure prompt and accurate delivery of the message. For example, +12065550100.</p>
        pub fn set_origination_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.origination_number = input;
            self
        }
        /// <p>The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-countries.html">Supported Countries and Regions</a> in the Amazon Pinpoint User Guide.</p>
        pub fn sender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sender_id = Some(input.into());
            self
        }
        /// <p>The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-countries.html">Supported Countries and Regions</a> in the Amazon Pinpoint User Guide.</p>
        pub fn set_sender_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sender_id = input;
            self
        }
        /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneySmsMessage`](crate::model::JourneySmsMessage)
        pub fn build(self) -> crate::model::JourneySmsMessage {
            crate::model::JourneySmsMessage {
                message_type: self.message_type,
                origination_number: self.origination_number,
                sender_id: self.sender_id,
                entity_id: self.entity_id,
                template_id: self.template_id,
            }
        }
    }
}
impl JourneySmsMessage {
    /// Creates a new builder-style object to manufacture [`JourneySmsMessage`](crate::model::JourneySmsMessage)
    pub fn builder() -> crate::model::journey_sms_message::Builder {
        crate::model::journey_sms_message::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MessageType {
    #[allow(missing_docs)] // documentation missing in model
    Promotional,
    #[allow(missing_docs)] // documentation missing in model
    Transactional,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for MessageType {
    fn from(s: &str) -> Self {
        match s {
            "PROMOTIONAL" => MessageType::Promotional,
            "TRANSACTIONAL" => MessageType::Transactional,
            other => MessageType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for MessageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MessageType::from(s))
    }
}
impl MessageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MessageType::Promotional => "PROMOTIONAL",
            MessageType::Transactional => "TRANSACTIONAL",
            MessageType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["PROMOTIONAL", "TRANSACTIONAL"]
    }
}
impl AsRef<str> for MessageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the settings for a random split activity in a journey. This type of activity randomly sends specified percentages of participants down one of as many as five paths in a journey, based on conditions that you specify.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RandomSplitActivity {
    /// <p>The paths for the activity, including the percentage of participants to enter each path and the activity to perform for each path.</p>
    pub branches: std::option::Option<std::vec::Vec<crate::model::RandomSplitEntry>>,
}
impl std::fmt::Debug for RandomSplitActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RandomSplitActivity");
        formatter.field("branches", &self.branches);
        formatter.finish()
    }
}
/// See [`RandomSplitActivity`](crate::model::RandomSplitActivity)
pub mod random_split_activity {
    /// A builder for [`RandomSplitActivity`](crate::model::RandomSplitActivity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) branches: std::option::Option<std::vec::Vec<crate::model::RandomSplitEntry>>,
    }
    impl Builder {
        /// Appends an item to `branches`.
        ///
        /// To override the contents of this collection use [`set_branches`](Self::set_branches).
        ///
        /// <p>The paths for the activity, including the percentage of participants to enter each path and the activity to perform for each path.</p>
        pub fn branches(mut self, input: impl Into<crate::model::RandomSplitEntry>) -> Self {
            let mut v = self.branches.unwrap_or_default();
            v.push(input.into());
            self.branches = Some(v);
            self
        }
        /// <p>The paths for the activity, including the percentage of participants to enter each path and the activity to perform for each path.</p>
        pub fn set_branches(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RandomSplitEntry>>,
        ) -> Self {
            self.branches = input;
            self
        }
        /// Consumes the builder and constructs a [`RandomSplitActivity`](crate::model::RandomSplitActivity)
        pub fn build(self) -> crate::model::RandomSplitActivity {
            crate::model::RandomSplitActivity {
                branches: self.branches,
            }
        }
    }
}
impl RandomSplitActivity {
    /// Creates a new builder-style object to manufacture [`RandomSplitActivity`](crate::model::RandomSplitActivity)
    pub fn builder() -> crate::model::random_split_activity::Builder {
        crate::model::random_split_activity::Builder::default()
    }
}

/// <p>Specifies the settings for a path in a random split activity in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RandomSplitEntry {
    /// <p>The unique identifier for the next activity to perform, after completing the activity for the path.</p>
    pub next_activity: std::option::Option<std::string::String>,
    /// <p>The percentage of participants to send down the activity path.</p> <p>To determine which participants are sent down each path, Amazon Pinpoint applies a probability-based algorithm to the percentages that you specify for the paths. Therefore, the actual percentage of participants who are sent down a path may not be equal to the percentage that you specify.</p>
    pub percentage: i32,
}
impl std::fmt::Debug for RandomSplitEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RandomSplitEntry");
        formatter.field("next_activity", &self.next_activity);
        formatter.field("percentage", &self.percentage);
        formatter.finish()
    }
}
/// See [`RandomSplitEntry`](crate::model::RandomSplitEntry)
pub mod random_split_entry {
    /// A builder for [`RandomSplitEntry`](crate::model::RandomSplitEntry)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_activity: std::option::Option<std::string::String>,
        pub(crate) percentage: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the next activity to perform, after completing the activity for the path.</p>
        pub fn next_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the next activity to perform, after completing the activity for the path.</p>
        pub fn set_next_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_activity = input;
            self
        }
        /// <p>The percentage of participants to send down the activity path.</p> <p>To determine which participants are sent down each path, Amazon Pinpoint applies a probability-based algorithm to the percentages that you specify for the paths. Therefore, the actual percentage of participants who are sent down a path may not be equal to the percentage that you specify.</p>
        pub fn percentage(mut self, input: i32) -> Self {
            self.percentage = Some(input);
            self
        }
        /// <p>The percentage of participants to send down the activity path.</p> <p>To determine which participants are sent down each path, Amazon Pinpoint applies a probability-based algorithm to the percentages that you specify for the paths. Therefore, the actual percentage of participants who are sent down a path may not be equal to the percentage that you specify.</p>
        pub fn set_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`RandomSplitEntry`](crate::model::RandomSplitEntry)
        pub fn build(self) -> crate::model::RandomSplitEntry {
            crate::model::RandomSplitEntry {
                next_activity: self.next_activity,
                percentage: self.percentage.unwrap_or_default(),
            }
        }
    }
}
impl RandomSplitEntry {
    /// Creates a new builder-style object to manufacture [`RandomSplitEntry`](crate::model::RandomSplitEntry)
    pub fn builder() -> crate::model::random_split_entry::Builder {
        crate::model::random_split_entry::Builder::default()
    }
}

/// <p>Specifies the settings for a push notification activity in a journey. This type of activity sends a push notification to participants.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PushMessageActivity {
    /// <p>Specifies the time to live (TTL) value for push notifications that are sent to participants in a journey.</p>
    pub message_config: std::option::Option<crate::model::JourneyPushMessage>,
    /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
    pub next_activity: std::option::Option<std::string::String>,
    /// <p>The name of the push notification template to use for the message. If specified, this value must match the name of an existing message template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the version of the push notification template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
    pub template_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PushMessageActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PushMessageActivity");
        formatter.field("message_config", &self.message_config);
        formatter.field("next_activity", &self.next_activity);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_version", &self.template_version);
        formatter.finish()
    }
}
/// See [`PushMessageActivity`](crate::model::PushMessageActivity)
pub mod push_message_activity {
    /// A builder for [`PushMessageActivity`](crate::model::PushMessageActivity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_config: std::option::Option<crate::model::JourneyPushMessage>,
        pub(crate) next_activity: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the time to live (TTL) value for push notifications that are sent to participants in a journey.</p>
        pub fn message_config(mut self, input: crate::model::JourneyPushMessage) -> Self {
            self.message_config = Some(input);
            self
        }
        /// <p>Specifies the time to live (TTL) value for push notifications that are sent to participants in a journey.</p>
        pub fn set_message_config(
            mut self,
            input: std::option::Option<crate::model::JourneyPushMessage>,
        ) -> Self {
            self.message_config = input;
            self
        }
        /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
        pub fn next_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
        pub fn set_next_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_activity = input;
            self
        }
        /// <p>The name of the push notification template to use for the message. If specified, this value must match the name of an existing message template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the push notification template to use for the message. If specified, this value must match the name of an existing message template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The unique identifier for the version of the push notification template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
        pub fn template_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_version = Some(input.into());
            self
        }
        /// <p>The unique identifier for the version of the push notification template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
        pub fn set_template_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_version = input;
            self
        }
        /// Consumes the builder and constructs a [`PushMessageActivity`](crate::model::PushMessageActivity)
        pub fn build(self) -> crate::model::PushMessageActivity {
            crate::model::PushMessageActivity {
                message_config: self.message_config,
                next_activity: self.next_activity,
                template_name: self.template_name,
                template_version: self.template_version,
            }
        }
    }
}
impl PushMessageActivity {
    /// Creates a new builder-style object to manufacture [`PushMessageActivity`](crate::model::PushMessageActivity)
    pub fn builder() -> crate::model::push_message_activity::Builder {
        crate::model::push_message_activity::Builder::default()
    }
}

/// <p>Specifies the message configuration for a push notification that's sent to participants in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneyPushMessage {
    /// <p>The number of seconds that the push notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.</p>
    pub time_to_live: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JourneyPushMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneyPushMessage");
        formatter.field("time_to_live", &self.time_to_live);
        formatter.finish()
    }
}
/// See [`JourneyPushMessage`](crate::model::JourneyPushMessage)
pub mod journey_push_message {
    /// A builder for [`JourneyPushMessage`](crate::model::JourneyPushMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) time_to_live: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The number of seconds that the push notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.</p>
        pub fn time_to_live(mut self, input: impl Into<std::string::String>) -> Self {
            self.time_to_live = Some(input.into());
            self
        }
        /// <p>The number of seconds that the push notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.</p>
        pub fn set_time_to_live(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.time_to_live = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneyPushMessage`](crate::model::JourneyPushMessage)
        pub fn build(self) -> crate::model::JourneyPushMessage {
            crate::model::JourneyPushMessage {
                time_to_live: self.time_to_live,
            }
        }
    }
}
impl JourneyPushMessage {
    /// Creates a new builder-style object to manufacture [`JourneyPushMessage`](crate::model::JourneyPushMessage)
    pub fn builder() -> crate::model::journey_push_message::Builder {
        crate::model::journey_push_message::Builder::default()
    }
}

/// <p>Specifies the settings for a multivariate split activity in a journey. This type of activity sends participants down one of as many as five paths (including a default <i>Else</i> path) in a journey, based on conditions that you specify.</p> <note><p>To create multivariate split activities that send participants down different paths based on push notification events (such as Open or Received events), your mobile app has to specify the User ID and Endpoint ID values. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/integrate.html">Integrating Amazon Pinpoint with your application</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p></note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MultiConditionalSplitActivity {
    /// <p>The paths for the activity, including the conditions for entering each path and the activity to perform for each path.</p>
    pub branches: std::option::Option<std::vec::Vec<crate::model::MultiConditionalBranch>>,
    /// <p>The unique identifier for the activity to perform for participants who don't meet any of the conditions specified for other paths in the activity.</p>
    pub default_activity: std::option::Option<std::string::String>,
    /// <p>The amount of time to wait or the date and time when Amazon Pinpoint determines whether the conditions are met.</p>
    pub evaluation_wait_time: std::option::Option<crate::model::WaitTime>,
}
impl std::fmt::Debug for MultiConditionalSplitActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MultiConditionalSplitActivity");
        formatter.field("branches", &self.branches);
        formatter.field("default_activity", &self.default_activity);
        formatter.field("evaluation_wait_time", &self.evaluation_wait_time);
        formatter.finish()
    }
}
/// See [`MultiConditionalSplitActivity`](crate::model::MultiConditionalSplitActivity)
pub mod multi_conditional_split_activity {
    /// A builder for [`MultiConditionalSplitActivity`](crate::model::MultiConditionalSplitActivity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) branches:
            std::option::Option<std::vec::Vec<crate::model::MultiConditionalBranch>>,
        pub(crate) default_activity: std::option::Option<std::string::String>,
        pub(crate) evaluation_wait_time: std::option::Option<crate::model::WaitTime>,
    }
    impl Builder {
        /// Appends an item to `branches`.
        ///
        /// To override the contents of this collection use [`set_branches`](Self::set_branches).
        ///
        /// <p>The paths for the activity, including the conditions for entering each path and the activity to perform for each path.</p>
        pub fn branches(mut self, input: impl Into<crate::model::MultiConditionalBranch>) -> Self {
            let mut v = self.branches.unwrap_or_default();
            v.push(input.into());
            self.branches = Some(v);
            self
        }
        /// <p>The paths for the activity, including the conditions for entering each path and the activity to perform for each path.</p>
        pub fn set_branches(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::MultiConditionalBranch>>,
        ) -> Self {
            self.branches = input;
            self
        }
        /// <p>The unique identifier for the activity to perform for participants who don't meet any of the conditions specified for other paths in the activity.</p>
        pub fn default_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the activity to perform for participants who don't meet any of the conditions specified for other paths in the activity.</p>
        pub fn set_default_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_activity = input;
            self
        }
        /// <p>The amount of time to wait or the date and time when Amazon Pinpoint determines whether the conditions are met.</p>
        pub fn evaluation_wait_time(mut self, input: crate::model::WaitTime) -> Self {
            self.evaluation_wait_time = Some(input);
            self
        }
        /// <p>The amount of time to wait or the date and time when Amazon Pinpoint determines whether the conditions are met.</p>
        pub fn set_evaluation_wait_time(
            mut self,
            input: std::option::Option<crate::model::WaitTime>,
        ) -> Self {
            self.evaluation_wait_time = input;
            self
        }
        /// Consumes the builder and constructs a [`MultiConditionalSplitActivity`](crate::model::MultiConditionalSplitActivity)
        pub fn build(self) -> crate::model::MultiConditionalSplitActivity {
            crate::model::MultiConditionalSplitActivity {
                branches: self.branches,
                default_activity: self.default_activity,
                evaluation_wait_time: self.evaluation_wait_time,
            }
        }
    }
}
impl MultiConditionalSplitActivity {
    /// Creates a new builder-style object to manufacture [`MultiConditionalSplitActivity`](crate::model::MultiConditionalSplitActivity)
    pub fn builder() -> crate::model::multi_conditional_split_activity::Builder {
        crate::model::multi_conditional_split_activity::Builder::default()
    }
}

/// <p>Specifies a condition to evaluate for an activity path in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MultiConditionalBranch {
    /// <p>The condition to evaluate for the activity path.</p>
    pub condition: std::option::Option<crate::model::SimpleCondition>,
    /// <p>The unique identifier for the next activity to perform, after completing the activity for the path.</p>
    pub next_activity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MultiConditionalBranch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MultiConditionalBranch");
        formatter.field("condition", &self.condition);
        formatter.field("next_activity", &self.next_activity);
        formatter.finish()
    }
}
/// See [`MultiConditionalBranch`](crate::model::MultiConditionalBranch)
pub mod multi_conditional_branch {
    /// A builder for [`MultiConditionalBranch`](crate::model::MultiConditionalBranch)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) condition: std::option::Option<crate::model::SimpleCondition>,
        pub(crate) next_activity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The condition to evaluate for the activity path.</p>
        pub fn condition(mut self, input: crate::model::SimpleCondition) -> Self {
            self.condition = Some(input);
            self
        }
        /// <p>The condition to evaluate for the activity path.</p>
        pub fn set_condition(
            mut self,
            input: std::option::Option<crate::model::SimpleCondition>,
        ) -> Self {
            self.condition = input;
            self
        }
        /// <p>The unique identifier for the next activity to perform, after completing the activity for the path.</p>
        pub fn next_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the next activity to perform, after completing the activity for the path.</p>
        pub fn set_next_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_activity = input;
            self
        }
        /// Consumes the builder and constructs a [`MultiConditionalBranch`](crate::model::MultiConditionalBranch)
        pub fn build(self) -> crate::model::MultiConditionalBranch {
            crate::model::MultiConditionalBranch {
                condition: self.condition,
                next_activity: self.next_activity,
            }
        }
    }
}
impl MultiConditionalBranch {
    /// Creates a new builder-style object to manufacture [`MultiConditionalBranch`](crate::model::MultiConditionalBranch)
    pub fn builder() -> crate::model::multi_conditional_branch::Builder {
        crate::model::multi_conditional_branch::Builder::default()
    }
}

/// <p>Specifies a condition to evaluate for an activity in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimpleCondition {
    /// <p>The dimension settings for the event that's associated with the activity.</p>
    pub event_condition: std::option::Option<crate::model::EventCondition>,
    /// <p>The segment that's associated with the activity.</p>
    pub segment_condition: std::option::Option<crate::model::SegmentCondition>,
    /// <p>The dimension settings for the segment that's associated with the activity.</p>
    pub segment_dimensions: std::option::Option<crate::model::SegmentDimensions>,
}
impl std::fmt::Debug for SimpleCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimpleCondition");
        formatter.field("event_condition", &self.event_condition);
        formatter.field("segment_condition", &self.segment_condition);
        formatter.field("segment_dimensions", &self.segment_dimensions);
        formatter.finish()
    }
}
/// See [`SimpleCondition`](crate::model::SimpleCondition)
pub mod simple_condition {
    /// A builder for [`SimpleCondition`](crate::model::SimpleCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event_condition: std::option::Option<crate::model::EventCondition>,
        pub(crate) segment_condition: std::option::Option<crate::model::SegmentCondition>,
        pub(crate) segment_dimensions: std::option::Option<crate::model::SegmentDimensions>,
    }
    impl Builder {
        /// <p>The dimension settings for the event that's associated with the activity.</p>
        pub fn event_condition(mut self, input: crate::model::EventCondition) -> Self {
            self.event_condition = Some(input);
            self
        }
        /// <p>The dimension settings for the event that's associated with the activity.</p>
        pub fn set_event_condition(
            mut self,
            input: std::option::Option<crate::model::EventCondition>,
        ) -> Self {
            self.event_condition = input;
            self
        }
        /// <p>The segment that's associated with the activity.</p>
        pub fn segment_condition(mut self, input: crate::model::SegmentCondition) -> Self {
            self.segment_condition = Some(input);
            self
        }
        /// <p>The segment that's associated with the activity.</p>
        pub fn set_segment_condition(
            mut self,
            input: std::option::Option<crate::model::SegmentCondition>,
        ) -> Self {
            self.segment_condition = input;
            self
        }
        /// <p>The dimension settings for the segment that's associated with the activity.</p>
        pub fn segment_dimensions(mut self, input: crate::model::SegmentDimensions) -> Self {
            self.segment_dimensions = Some(input);
            self
        }
        /// <p>The dimension settings for the segment that's associated with the activity.</p>
        pub fn set_segment_dimensions(
            mut self,
            input: std::option::Option<crate::model::SegmentDimensions>,
        ) -> Self {
            self.segment_dimensions = input;
            self
        }
        /// Consumes the builder and constructs a [`SimpleCondition`](crate::model::SimpleCondition)
        pub fn build(self) -> crate::model::SimpleCondition {
            crate::model::SimpleCondition {
                event_condition: self.event_condition,
                segment_condition: self.segment_condition,
                segment_dimensions: self.segment_dimensions,
            }
        }
    }
}
impl SimpleCondition {
    /// Creates a new builder-style object to manufacture [`SimpleCondition`](crate::model::SimpleCondition)
    pub fn builder() -> crate::model::simple_condition::Builder {
        crate::model::simple_condition::Builder::default()
    }
}

/// <p>Specifies the conditions to evaluate for an event that applies to an activity in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventCondition {
    /// <p>The dimensions for the event filter to use for the activity.</p>
    pub dimensions: std::option::Option<crate::model::EventDimensions>,
    /// <p>The message identifier (message_id) for the message to use when determining whether message events meet the condition.</p>
    pub message_activity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EventCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventCondition");
        formatter.field("dimensions", &self.dimensions);
        formatter.field("message_activity", &self.message_activity);
        formatter.finish()
    }
}
/// See [`EventCondition`](crate::model::EventCondition)
pub mod event_condition {
    /// A builder for [`EventCondition`](crate::model::EventCondition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimensions: std::option::Option<crate::model::EventDimensions>,
        pub(crate) message_activity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The dimensions for the event filter to use for the activity.</p>
        pub fn dimensions(mut self, input: crate::model::EventDimensions) -> Self {
            self.dimensions = Some(input);
            self
        }
        /// <p>The dimensions for the event filter to use for the activity.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::EventDimensions>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The message identifier (message_id) for the message to use when determining whether message events meet the condition.</p>
        pub fn message_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_activity = Some(input.into());
            self
        }
        /// <p>The message identifier (message_id) for the message to use when determining whether message events meet the condition.</p>
        pub fn set_message_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.message_activity = input;
            self
        }
        /// Consumes the builder and constructs a [`EventCondition`](crate::model::EventCondition)
        pub fn build(self) -> crate::model::EventCondition {
            crate::model::EventCondition {
                dimensions: self.dimensions,
                message_activity: self.message_activity,
            }
        }
    }
}
impl EventCondition {
    /// Creates a new builder-style object to manufacture [`EventCondition`](crate::model::EventCondition)
    pub fn builder() -> crate::model::event_condition::Builder {
        crate::model::event_condition::Builder::default()
    }
}

/// <p>Specifies the settings for a holdout activity in a journey. This type of activity stops a journey for a specified percentage of participants.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct HoldoutActivity {
    /// <p>The unique identifier for the next activity to perform, after performing the holdout activity.</p>
    pub next_activity: std::option::Option<std::string::String>,
    /// <p>The percentage of participants who shouldn't continue the journey.</p> <p>To determine which participants are held out, Amazon Pinpoint applies a probability-based algorithm to the percentage that you specify. Therefore, the actual percentage of participants who are held out may not be equal to the percentage that you specify.</p>
    pub percentage: i32,
}
impl std::fmt::Debug for HoldoutActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("HoldoutActivity");
        formatter.field("next_activity", &self.next_activity);
        formatter.field("percentage", &self.percentage);
        formatter.finish()
    }
}
/// See [`HoldoutActivity`](crate::model::HoldoutActivity)
pub mod holdout_activity {
    /// A builder for [`HoldoutActivity`](crate::model::HoldoutActivity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) next_activity: std::option::Option<std::string::String>,
        pub(crate) percentage: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the next activity to perform, after performing the holdout activity.</p>
        pub fn next_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the next activity to perform, after performing the holdout activity.</p>
        pub fn set_next_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_activity = input;
            self
        }
        /// <p>The percentage of participants who shouldn't continue the journey.</p> <p>To determine which participants are held out, Amazon Pinpoint applies a probability-based algorithm to the percentage that you specify. Therefore, the actual percentage of participants who are held out may not be equal to the percentage that you specify.</p>
        pub fn percentage(mut self, input: i32) -> Self {
            self.percentage = Some(input);
            self
        }
        /// <p>The percentage of participants who shouldn't continue the journey.</p> <p>To determine which participants are held out, Amazon Pinpoint applies a probability-based algorithm to the percentage that you specify. Therefore, the actual percentage of participants who are held out may not be equal to the percentage that you specify.</p>
        pub fn set_percentage(mut self, input: std::option::Option<i32>) -> Self {
            self.percentage = input;
            self
        }
        /// Consumes the builder and constructs a [`HoldoutActivity`](crate::model::HoldoutActivity)
        pub fn build(self) -> crate::model::HoldoutActivity {
            crate::model::HoldoutActivity {
                next_activity: self.next_activity,
                percentage: self.percentage.unwrap_or_default(),
            }
        }
    }
}
impl HoldoutActivity {
    /// Creates a new builder-style object to manufacture [`HoldoutActivity`](crate::model::HoldoutActivity)
    pub fn builder() -> crate::model::holdout_activity::Builder {
        crate::model::holdout_activity::Builder::default()
    }
}

/// <p>Specifies the settings for an email activity in a journey. This type of activity sends an email message to participants.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EmailMessageActivity {
    /// <p>Specifies the sender address for an email message that's sent to participants in the journey.</p>
    pub message_config: std::option::Option<crate::model::JourneyEmailMessage>,
    /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
    pub next_activity: std::option::Option<std::string::String>,
    /// <p>The name of the email message template to use for the message. If specified, this value must match the name of an existing message template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the version of the email template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
    pub template_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EmailMessageActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EmailMessageActivity");
        formatter.field("message_config", &self.message_config);
        formatter.field("next_activity", &self.next_activity);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_version", &self.template_version);
        formatter.finish()
    }
}
/// See [`EmailMessageActivity`](crate::model::EmailMessageActivity)
pub mod email_message_activity {
    /// A builder for [`EmailMessageActivity`](crate::model::EmailMessageActivity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_config: std::option::Option<crate::model::JourneyEmailMessage>,
        pub(crate) next_activity: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the sender address for an email message that's sent to participants in the journey.</p>
        pub fn message_config(mut self, input: crate::model::JourneyEmailMessage) -> Self {
            self.message_config = Some(input);
            self
        }
        /// <p>Specifies the sender address for an email message that's sent to participants in the journey.</p>
        pub fn set_message_config(
            mut self,
            input: std::option::Option<crate::model::JourneyEmailMessage>,
        ) -> Self {
            self.message_config = input;
            self
        }
        /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
        pub fn next_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
        pub fn set_next_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_activity = input;
            self
        }
        /// <p>The name of the email message template to use for the message. If specified, this value must match the name of an existing message template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the email message template to use for the message. If specified, this value must match the name of an existing message template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The unique identifier for the version of the email template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
        pub fn template_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_version = Some(input.into());
            self
        }
        /// <p>The unique identifier for the version of the email template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
        pub fn set_template_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_version = input;
            self
        }
        /// Consumes the builder and constructs a [`EmailMessageActivity`](crate::model::EmailMessageActivity)
        pub fn build(self) -> crate::model::EmailMessageActivity {
            crate::model::EmailMessageActivity {
                message_config: self.message_config,
                next_activity: self.next_activity,
                template_name: self.template_name,
                template_version: self.template_version,
            }
        }
    }
}
impl EmailMessageActivity {
    /// Creates a new builder-style object to manufacture [`EmailMessageActivity`](crate::model::EmailMessageActivity)
    pub fn builder() -> crate::model::email_message_activity::Builder {
        crate::model::email_message_activity::Builder::default()
    }
}

/// <p>Specifies the "From" address for an email message that's sent to participants in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneyEmailMessage {
    /// <p>The verified email address to send the email message from. The default address is the FromAddress specified for the email channel for the application.</p>
    pub from_address: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JourneyEmailMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneyEmailMessage");
        formatter.field("from_address", &self.from_address);
        formatter.finish()
    }
}
/// See [`JourneyEmailMessage`](crate::model::JourneyEmailMessage)
pub mod journey_email_message {
    /// A builder for [`JourneyEmailMessage`](crate::model::JourneyEmailMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) from_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The verified email address to send the email message from. The default address is the FromAddress specified for the email channel for the application.</p>
        pub fn from_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_address = Some(input.into());
            self
        }
        /// <p>The verified email address to send the email message from. The default address is the FromAddress specified for the email channel for the application.</p>
        pub fn set_from_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from_address = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneyEmailMessage`](crate::model::JourneyEmailMessage)
        pub fn build(self) -> crate::model::JourneyEmailMessage {
            crate::model::JourneyEmailMessage {
                from_address: self.from_address,
            }
        }
    }
}
impl JourneyEmailMessage {
    /// Creates a new builder-style object to manufacture [`JourneyEmailMessage`](crate::model::JourneyEmailMessage)
    pub fn builder() -> crate::model::journey_email_message::Builder {
        crate::model::journey_email_message::Builder::default()
    }
}

/// <p>Specifies the settings for a yes/no split activity in a journey. This type of activity sends participants down one of two paths in a journey, based on conditions that you specify.</p> <note><p>To create yes/no split activities that send participants down different paths based on push notification events (such as Open or Received events), your mobile app has to specify the User ID and Endpoint ID values. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/integrate.html">Integrating Amazon Pinpoint with your application</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p></note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConditionalSplitActivity {
    /// <p>The conditions that define the paths for the activity, and the relationship between the conditions.</p>
    pub condition: std::option::Option<crate::model::Condition>,
    /// <p>The amount of time to wait before determining whether the conditions are met, or the date and time when Amazon Pinpoint determines whether the conditions are met.</p>
    pub evaluation_wait_time: std::option::Option<crate::model::WaitTime>,
    /// <p>The unique identifier for the activity to perform if the conditions aren't met.</p>
    pub false_activity: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the activity to perform if the conditions are met.</p>
    pub true_activity: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConditionalSplitActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConditionalSplitActivity");
        formatter.field("condition", &self.condition);
        formatter.field("evaluation_wait_time", &self.evaluation_wait_time);
        formatter.field("false_activity", &self.false_activity);
        formatter.field("true_activity", &self.true_activity);
        formatter.finish()
    }
}
/// See [`ConditionalSplitActivity`](crate::model::ConditionalSplitActivity)
pub mod conditional_split_activity {
    /// A builder for [`ConditionalSplitActivity`](crate::model::ConditionalSplitActivity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) condition: std::option::Option<crate::model::Condition>,
        pub(crate) evaluation_wait_time: std::option::Option<crate::model::WaitTime>,
        pub(crate) false_activity: std::option::Option<std::string::String>,
        pub(crate) true_activity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The conditions that define the paths for the activity, and the relationship between the conditions.</p>
        pub fn condition(mut self, input: crate::model::Condition) -> Self {
            self.condition = Some(input);
            self
        }
        /// <p>The conditions that define the paths for the activity, and the relationship between the conditions.</p>
        pub fn set_condition(
            mut self,
            input: std::option::Option<crate::model::Condition>,
        ) -> Self {
            self.condition = input;
            self
        }
        /// <p>The amount of time to wait before determining whether the conditions are met, or the date and time when Amazon Pinpoint determines whether the conditions are met.</p>
        pub fn evaluation_wait_time(mut self, input: crate::model::WaitTime) -> Self {
            self.evaluation_wait_time = Some(input);
            self
        }
        /// <p>The amount of time to wait before determining whether the conditions are met, or the date and time when Amazon Pinpoint determines whether the conditions are met.</p>
        pub fn set_evaluation_wait_time(
            mut self,
            input: std::option::Option<crate::model::WaitTime>,
        ) -> Self {
            self.evaluation_wait_time = input;
            self
        }
        /// <p>The unique identifier for the activity to perform if the conditions aren't met.</p>
        pub fn false_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.false_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the activity to perform if the conditions aren't met.</p>
        pub fn set_false_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.false_activity = input;
            self
        }
        /// <p>The unique identifier for the activity to perform if the conditions are met.</p>
        pub fn true_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.true_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the activity to perform if the conditions are met.</p>
        pub fn set_true_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.true_activity = input;
            self
        }
        /// Consumes the builder and constructs a [`ConditionalSplitActivity`](crate::model::ConditionalSplitActivity)
        pub fn build(self) -> crate::model::ConditionalSplitActivity {
            crate::model::ConditionalSplitActivity {
                condition: self.condition,
                evaluation_wait_time: self.evaluation_wait_time,
                false_activity: self.false_activity,
                true_activity: self.true_activity,
            }
        }
    }
}
impl ConditionalSplitActivity {
    /// Creates a new builder-style object to manufacture [`ConditionalSplitActivity`](crate::model::ConditionalSplitActivity)
    pub fn builder() -> crate::model::conditional_split_activity::Builder {
        crate::model::conditional_split_activity::Builder::default()
    }
}

/// <p>Specifies the conditions to evaluate for an activity in a journey, and how to evaluate those conditions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Condition {
    /// <p>The conditions to evaluate for the activity.</p>
    pub conditions: std::option::Option<std::vec::Vec<crate::model::SimpleCondition>>,
    /// <p>Specifies how to handle multiple conditions for the activity. For example, if you specify two conditions for an activity, whether both or only one of the conditions must be met for the activity to be performed.</p>
    pub operator: std::option::Option<crate::model::Operator>,
}
impl std::fmt::Debug for Condition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Condition");
        formatter.field("conditions", &self.conditions);
        formatter.field("operator", &self.operator);
        formatter.finish()
    }
}
/// See [`Condition`](crate::model::Condition)
pub mod condition {
    /// A builder for [`Condition`](crate::model::Condition)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) conditions: std::option::Option<std::vec::Vec<crate::model::SimpleCondition>>,
        pub(crate) operator: std::option::Option<crate::model::Operator>,
    }
    impl Builder {
        /// Appends an item to `conditions`.
        ///
        /// To override the contents of this collection use [`set_conditions`](Self::set_conditions).
        ///
        /// <p>The conditions to evaluate for the activity.</p>
        pub fn conditions(mut self, input: impl Into<crate::model::SimpleCondition>) -> Self {
            let mut v = self.conditions.unwrap_or_default();
            v.push(input.into());
            self.conditions = Some(v);
            self
        }
        /// <p>The conditions to evaluate for the activity.</p>
        pub fn set_conditions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SimpleCondition>>,
        ) -> Self {
            self.conditions = input;
            self
        }
        /// <p>Specifies how to handle multiple conditions for the activity. For example, if you specify two conditions for an activity, whether both or only one of the conditions must be met for the activity to be performed.</p>
        pub fn operator(mut self, input: crate::model::Operator) -> Self {
            self.operator = Some(input);
            self
        }
        /// <p>Specifies how to handle multiple conditions for the activity. For example, if you specify two conditions for an activity, whether both or only one of the conditions must be met for the activity to be performed.</p>
        pub fn set_operator(mut self, input: std::option::Option<crate::model::Operator>) -> Self {
            self.operator = input;
            self
        }
        /// Consumes the builder and constructs a [`Condition`](crate::model::Condition)
        pub fn build(self) -> crate::model::Condition {
            crate::model::Condition {
                conditions: self.conditions,
                operator: self.operator,
            }
        }
    }
}
impl Condition {
    /// Creates a new builder-style object to manufacture [`Condition`](crate::model::Condition)
    pub fn builder() -> crate::model::condition::Builder {
        crate::model::condition::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Operator {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Any,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Operator {
    fn from(s: &str) -> Self {
        match s {
            "ALL" => Operator::All,
            "ANY" => Operator::Any,
            other => Operator::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Operator {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Operator::from(s))
    }
}
impl Operator {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Operator::All => "ALL",
            Operator::Any => "ANY",
            Operator::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ALL", "ANY"]
    }
}
impl AsRef<str> for Operator {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The settings for a custom message activity. This type of activity calls an AWS Lambda function or web hook that sends messages to participants.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomMessageActivity {
    /// <p>The destination to send the campaign or treatment to. This value can be one of the following:</p> <ul><li><p>The name or Amazon Resource Name (ARN) of an AWS Lambda function to invoke to handle delivery of the campaign or treatment.</p></li> <li><p>The URL for a web application or service that supports HTTPS and can receive the message. The URL has to be a full URL, including the HTTPS protocol.</p></li></ul>
    pub delivery_uri: std::option::Option<std::string::String>,
    /// <p>The types of endpoints to send the custom message to. Each valid value maps to a type of channel that you can associate with an endpoint by using the ChannelType property of an endpoint.</p>
    pub endpoint_types: std::option::Option<std::vec::Vec<crate::model::EndpointTypesElement>>,
    /// <p>Specifies the message data included in a custom channel message that's sent to participants in a journey.</p>
    pub message_config: std::option::Option<crate::model::JourneyCustomMessage>,
    /// <p>The unique identifier for the next activity to perform, after Amazon Pinpoint calls the AWS Lambda function or web hook.</p>
    pub next_activity: std::option::Option<std::string::String>,
    /// <p>The name of the custom message template to use for the message. If specified, this value must match the name of an existing message template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the version of the message template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
    pub template_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CustomMessageActivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomMessageActivity");
        formatter.field("delivery_uri", &self.delivery_uri);
        formatter.field("endpoint_types", &self.endpoint_types);
        formatter.field("message_config", &self.message_config);
        formatter.field("next_activity", &self.next_activity);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_version", &self.template_version);
        formatter.finish()
    }
}
/// See [`CustomMessageActivity`](crate::model::CustomMessageActivity)
pub mod custom_message_activity {
    /// A builder for [`CustomMessageActivity`](crate::model::CustomMessageActivity)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delivery_uri: std::option::Option<std::string::String>,
        pub(crate) endpoint_types:
            std::option::Option<std::vec::Vec<crate::model::EndpointTypesElement>>,
        pub(crate) message_config: std::option::Option<crate::model::JourneyCustomMessage>,
        pub(crate) next_activity: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The destination to send the campaign or treatment to. This value can be one of the following:</p> <ul><li><p>The name or Amazon Resource Name (ARN) of an AWS Lambda function to invoke to handle delivery of the campaign or treatment.</p></li> <li><p>The URL for a web application or service that supports HTTPS and can receive the message. The URL has to be a full URL, including the HTTPS protocol.</p></li></ul>
        pub fn delivery_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.delivery_uri = Some(input.into());
            self
        }
        /// <p>The destination to send the campaign or treatment to. This value can be one of the following:</p> <ul><li><p>The name or Amazon Resource Name (ARN) of an AWS Lambda function to invoke to handle delivery of the campaign or treatment.</p></li> <li><p>The URL for a web application or service that supports HTTPS and can receive the message. The URL has to be a full URL, including the HTTPS protocol.</p></li></ul>
        pub fn set_delivery_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delivery_uri = input;
            self
        }
        /// Appends an item to `endpoint_types`.
        ///
        /// To override the contents of this collection use [`set_endpoint_types`](Self::set_endpoint_types).
        ///
        /// <p>The types of endpoints to send the custom message to. Each valid value maps to a type of channel that you can associate with an endpoint by using the ChannelType property of an endpoint.</p>
        pub fn endpoint_types(
            mut self,
            input: impl Into<crate::model::EndpointTypesElement>,
        ) -> Self {
            let mut v = self.endpoint_types.unwrap_or_default();
            v.push(input.into());
            self.endpoint_types = Some(v);
            self
        }
        /// <p>The types of endpoints to send the custom message to. Each valid value maps to a type of channel that you can associate with an endpoint by using the ChannelType property of an endpoint.</p>
        pub fn set_endpoint_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndpointTypesElement>>,
        ) -> Self {
            self.endpoint_types = input;
            self
        }
        /// <p>Specifies the message data included in a custom channel message that's sent to participants in a journey.</p>
        pub fn message_config(mut self, input: crate::model::JourneyCustomMessage) -> Self {
            self.message_config = Some(input);
            self
        }
        /// <p>Specifies the message data included in a custom channel message that's sent to participants in a journey.</p>
        pub fn set_message_config(
            mut self,
            input: std::option::Option<crate::model::JourneyCustomMessage>,
        ) -> Self {
            self.message_config = input;
            self
        }
        /// <p>The unique identifier for the next activity to perform, after Amazon Pinpoint calls the AWS Lambda function or web hook.</p>
        pub fn next_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the next activity to perform, after Amazon Pinpoint calls the AWS Lambda function or web hook.</p>
        pub fn set_next_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.next_activity = input;
            self
        }
        /// <p>The name of the custom message template to use for the message. If specified, this value must match the name of an existing message template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the custom message template to use for the message. If specified, this value must match the name of an existing message template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The unique identifier for the version of the message template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
        pub fn template_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_version = Some(input.into());
            self
        }
        /// <p>The unique identifier for the version of the message template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
        pub fn set_template_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_version = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomMessageActivity`](crate::model::CustomMessageActivity)
        pub fn build(self) -> crate::model::CustomMessageActivity {
            crate::model::CustomMessageActivity {
                delivery_uri: self.delivery_uri,
                endpoint_types: self.endpoint_types,
                message_config: self.message_config,
                next_activity: self.next_activity,
                template_name: self.template_name,
                template_version: self.template_version,
            }
        }
    }
}
impl CustomMessageActivity {
    /// Creates a new builder-style object to manufacture [`CustomMessageActivity`](crate::model::CustomMessageActivity)
    pub fn builder() -> crate::model::custom_message_activity::Builder {
        crate::model::custom_message_activity::Builder::default()
    }
}

/// <p>Specifies the message content for a custom channel message that's sent to participants in a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneyCustomMessage {
    /// <p>The message content that's passed to an AWS Lambda function or to a web hook.</p>
    pub data: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JourneyCustomMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneyCustomMessage");
        formatter.field("data", &self.data);
        formatter.finish()
    }
}
/// See [`JourneyCustomMessage`](crate::model::JourneyCustomMessage)
pub mod journey_custom_message {
    /// A builder for [`JourneyCustomMessage`](crate::model::JourneyCustomMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message content that's passed to an AWS Lambda function or to a web hook.</p>
        pub fn data(mut self, input: impl Into<std::string::String>) -> Self {
            self.data = Some(input.into());
            self
        }
        /// <p>The message content that's passed to an AWS Lambda function or to a web hook.</p>
        pub fn set_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneyCustomMessage`](crate::model::JourneyCustomMessage)
        pub fn build(self) -> crate::model::JourneyCustomMessage {
            crate::model::JourneyCustomMessage { data: self.data }
        }
    }
}
impl JourneyCustomMessage {
    /// Creates a new builder-style object to manufacture [`JourneyCustomMessage`](crate::model::JourneyCustomMessage)
    pub fn builder() -> crate::model::journey_custom_message::Builder {
        crate::model::journey_custom_message::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EndpointTypesElement {
    #[allow(missing_docs)] // documentation missing in model
    Adm,
    #[allow(missing_docs)] // documentation missing in model
    Apns,
    #[allow(missing_docs)] // documentation missing in model
    ApnsSandbox,
    #[allow(missing_docs)] // documentation missing in model
    ApnsVoip,
    #[allow(missing_docs)] // documentation missing in model
    ApnsVoipSandbox,
    #[allow(missing_docs)] // documentation missing in model
    Baidu,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Email,
    #[allow(missing_docs)] // documentation missing in model
    Gcm,
    #[allow(missing_docs)] // documentation missing in model
    InApp,
    #[allow(missing_docs)] // documentation missing in model
    Push,
    #[allow(missing_docs)] // documentation missing in model
    Sms,
    #[allow(missing_docs)] // documentation missing in model
    Voice,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for EndpointTypesElement {
    fn from(s: &str) -> Self {
        match s {
            "ADM" => EndpointTypesElement::Adm,
            "APNS" => EndpointTypesElement::Apns,
            "APNS_SANDBOX" => EndpointTypesElement::ApnsSandbox,
            "APNS_VOIP" => EndpointTypesElement::ApnsVoip,
            "APNS_VOIP_SANDBOX" => EndpointTypesElement::ApnsVoipSandbox,
            "BAIDU" => EndpointTypesElement::Baidu,
            "CUSTOM" => EndpointTypesElement::Custom,
            "EMAIL" => EndpointTypesElement::Email,
            "GCM" => EndpointTypesElement::Gcm,
            "IN_APP" => EndpointTypesElement::InApp,
            "PUSH" => EndpointTypesElement::Push,
            "SMS" => EndpointTypesElement::Sms,
            "VOICE" => EndpointTypesElement::Voice,
            other => EndpointTypesElement::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for EndpointTypesElement {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EndpointTypesElement::from(s))
    }
}
impl EndpointTypesElement {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EndpointTypesElement::Adm => "ADM",
            EndpointTypesElement::Apns => "APNS",
            EndpointTypesElement::ApnsSandbox => "APNS_SANDBOX",
            EndpointTypesElement::ApnsVoip => "APNS_VOIP",
            EndpointTypesElement::ApnsVoipSandbox => "APNS_VOIP_SANDBOX",
            EndpointTypesElement::Baidu => "BAIDU",
            EndpointTypesElement::Custom => "CUSTOM",
            EndpointTypesElement::Email => "EMAIL",
            EndpointTypesElement::Gcm => "GCM",
            EndpointTypesElement::InApp => "IN_APP",
            EndpointTypesElement::Push => "PUSH",
            EndpointTypesElement::Sms => "SMS",
            EndpointTypesElement::Voice => "VOICE",
            EndpointTypesElement::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ADM",
            "APNS",
            "APNS_SANDBOX",
            "APNS_VOIP",
            "APNS_VOIP_SANDBOX",
            "BAIDU",
            "CUSTOM",
            "EMAIL",
            "GCM",
            "IN_APP",
            "PUSH",
            "SMS",
            "VOICE",
        ]
    }
}
impl AsRef<str> for EndpointTypesElement {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Changes the status of a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneyStateRequest {
    /// <p>The status of the journey. Currently, Supported values are ACTIVE, PAUSED, and CANCELLED</p> <p>If you cancel a journey, Amazon Pinpoint continues to perform activities that are currently in progress, until those activities are complete. Amazon Pinpoint also continues to collect and aggregate analytics data for those activities, until they are complete, and any activities that were complete when you cancelled the journey.</p> <p>After you cancel a journey, you can't add, change, or remove any activities from the journey. In addition, Amazon Pinpoint stops evaluating the journey and doesn't perform any activities that haven't started.</p> <p>When the journey is paused, Amazon Pinpoint continues to perform activities that are currently in progress, until those activities are complete. Endpoints will stop entering journeys when the journey is paused and will resume entering the journey after the journey is resumed. For wait activities, wait time is paused when the journey is paused. Currently, PAUSED only supports journeys with a segment refresh interval.</p>
    pub state: std::option::Option<crate::model::State>,
}
impl std::fmt::Debug for JourneyStateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneyStateRequest");
        formatter.field("state", &self.state);
        formatter.finish()
    }
}
/// See [`JourneyStateRequest`](crate::model::JourneyStateRequest)
pub mod journey_state_request {
    /// A builder for [`JourneyStateRequest`](crate::model::JourneyStateRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) state: std::option::Option<crate::model::State>,
    }
    impl Builder {
        /// <p>The status of the journey. Currently, Supported values are ACTIVE, PAUSED, and CANCELLED</p> <p>If you cancel a journey, Amazon Pinpoint continues to perform activities that are currently in progress, until those activities are complete. Amazon Pinpoint also continues to collect and aggregate analytics data for those activities, until they are complete, and any activities that were complete when you cancelled the journey.</p> <p>After you cancel a journey, you can't add, change, or remove any activities from the journey. In addition, Amazon Pinpoint stops evaluating the journey and doesn't perform any activities that haven't started.</p> <p>When the journey is paused, Amazon Pinpoint continues to perform activities that are currently in progress, until those activities are complete. Endpoints will stop entering journeys when the journey is paused and will resume entering the journey after the journey is resumed. For wait activities, wait time is paused when the journey is paused. Currently, PAUSED only supports journeys with a segment refresh interval.</p>
        pub fn state(mut self, input: crate::model::State) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The status of the journey. Currently, Supported values are ACTIVE, PAUSED, and CANCELLED</p> <p>If you cancel a journey, Amazon Pinpoint continues to perform activities that are currently in progress, until those activities are complete. Amazon Pinpoint also continues to collect and aggregate analytics data for those activities, until they are complete, and any activities that were complete when you cancelled the journey.</p> <p>After you cancel a journey, you can't add, change, or remove any activities from the journey. In addition, Amazon Pinpoint stops evaluating the journey and doesn't perform any activities that haven't started.</p> <p>When the journey is paused, Amazon Pinpoint continues to perform activities that are currently in progress, until those activities are complete. Endpoints will stop entering journeys when the journey is paused and will resume entering the journey after the journey is resumed. For wait activities, wait time is paused when the journey is paused. Currently, PAUSED only supports journeys with a segment refresh interval.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::State>) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneyStateRequest`](crate::model::JourneyStateRequest)
        pub fn build(self) -> crate::model::JourneyStateRequest {
            crate::model::JourneyStateRequest { state: self.state }
        }
    }
}
impl JourneyStateRequest {
    /// Creates a new builder-style object to manufacture [`JourneyStateRequest`](crate::model::JourneyStateRequest)
    pub fn builder() -> crate::model::journey_state_request::Builder {
        crate::model::journey_state_request::Builder::default()
    }
}

/// <p>Specifies the configuration and other settings for a journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WriteJourneyRequest {
    /// <p>A map that contains a set of Activity objects, one object for each activity in the journey. For each Activity object, the key is the unique identifier (string) for an activity and the value is the settings for the activity. An activity identifier can contain a maximum of 100 characters. The characters must be alphanumeric characters.</p>
    pub activities:
        std::option::Option<std::collections::HashMap<std::string::String, crate::model::Activity>>,
    /// <p>The date, in ISO 8601 format, when the journey was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the journey was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The messaging and entry limits for the journey.</p>
    pub limits: std::option::Option<crate::model::JourneyLimits>,
    /// <p>Specifies whether the journey's scheduled start and end times use each participant's local time. To base the schedule on each participant's local time, set this value to true.</p>
    pub local_time: bool,
    /// <p>The name of the journey. A journey name can contain a maximum of 150 characters. The characters can be alphanumeric characters or symbols, such as underscores (_) or hyphens (-). A journey name can't contain any spaces.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The quiet time settings for the journey. Quiet time is a specific time range when a journey doesn't send messages to participants, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint for the participant is set to a valid value.</p></li> <li><p>The current time in the participant's time zone is later than or equal to the time specified by the QuietTime.Start property for the journey.</p></li> <li><p>The current time in the participant's time zone is earlier than or equal to the time specified by the QuietTime.End property for the journey.</p></li></ul> <p>If any of the preceding conditions isn't met, the participant will receive messages from the journey, even if quiet time is enabled.</p>
    pub quiet_time: std::option::Option<crate::model::QuietTime>,
    /// <p>The frequency with which Amazon Pinpoint evaluates segment and event data for the journey, as a duration in ISO 8601 format.</p>
    pub refresh_frequency: std::option::Option<std::string::String>,
    /// <p>The schedule settings for the journey.</p>
    pub schedule: std::option::Option<crate::model::JourneySchedule>,
    /// <p>The unique identifier for the first activity in the journey. The identifier for this activity can contain a maximum of 128 characters. The characters must be alphanumeric characters.</p>
    pub start_activity: std::option::Option<std::string::String>,
    /// <p>The segment that defines which users are participants in the journey.</p>
    pub start_condition: std::option::Option<crate::model::StartCondition>,
    /// <p>The status of the journey. Valid values are:</p> <ul><li><p>DRAFT - Saves the journey and doesn't publish it.</p></li> <li><p>ACTIVE - Saves and publishes the journey. Depending on the journey's schedule, the journey starts running immediately or at the scheduled start time. If a journey's status is ACTIVE, you can't add, change, or remove activities from it.</p></li></ul> <p>PAUSED, CANCELLED, COMPLETED, and CLOSED states are not supported in requests to create or update a journey. To cancel, pause, or resume a journey, use the <link  linkend="apps-application-id-journeys-journey-id-state">Journey State</link> resource.</p>
    pub state: std::option::Option<crate::model::State>,
    /// <p>Specifies whether endpoints in quiet hours should enter a wait till the end of their quiet hours.</p>
    pub wait_for_quiet_time: bool,
    /// <p>Specifies whether a journey should be refreshed on segment update.</p>
    pub refresh_on_segment_update: bool,
}
impl std::fmt::Debug for WriteJourneyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WriteJourneyRequest");
        formatter.field("activities", &self.activities);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("limits", &self.limits);
        formatter.field("local_time", &self.local_time);
        formatter.field("name", &self.name);
        formatter.field("quiet_time", &self.quiet_time);
        formatter.field("refresh_frequency", &self.refresh_frequency);
        formatter.field("schedule", &self.schedule);
        formatter.field("start_activity", &self.start_activity);
        formatter.field("start_condition", &self.start_condition);
        formatter.field("state", &self.state);
        formatter.field("wait_for_quiet_time", &self.wait_for_quiet_time);
        formatter.field("refresh_on_segment_update", &self.refresh_on_segment_update);
        formatter.finish()
    }
}
/// See [`WriteJourneyRequest`](crate::model::WriteJourneyRequest)
pub mod write_journey_request {
    /// A builder for [`WriteJourneyRequest`](crate::model::WriteJourneyRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) activities: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::Activity>,
        >,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) limits: std::option::Option<crate::model::JourneyLimits>,
        pub(crate) local_time: std::option::Option<bool>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) quiet_time: std::option::Option<crate::model::QuietTime>,
        pub(crate) refresh_frequency: std::option::Option<std::string::String>,
        pub(crate) schedule: std::option::Option<crate::model::JourneySchedule>,
        pub(crate) start_activity: std::option::Option<std::string::String>,
        pub(crate) start_condition: std::option::Option<crate::model::StartCondition>,
        pub(crate) state: std::option::Option<crate::model::State>,
        pub(crate) wait_for_quiet_time: std::option::Option<bool>,
        pub(crate) refresh_on_segment_update: std::option::Option<bool>,
    }
    impl Builder {
        /// Adds a key-value pair to `activities`.
        ///
        /// To override the contents of this collection use [`set_activities`](Self::set_activities).
        ///
        /// <p>A map that contains a set of Activity objects, one object for each activity in the journey. For each Activity object, the key is the unique identifier (string) for an activity and the value is the settings for the activity. An activity identifier can contain a maximum of 100 characters. The characters must be alphanumeric characters.</p>
        pub fn activities(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::Activity>,
        ) -> Self {
            let mut hash_map = self.activities.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.activities = Some(hash_map);
            self
        }
        /// <p>A map that contains a set of Activity objects, one object for each activity in the journey. For each Activity object, the key is the unique identifier (string) for an activity and the value is the settings for the activity. An activity identifier can contain a maximum of 100 characters. The characters must be alphanumeric characters.</p>
        pub fn set_activities(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::Activity>,
            >,
        ) -> Self {
            self.activities = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the journey was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the journey was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the journey was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the journey was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The messaging and entry limits for the journey.</p>
        pub fn limits(mut self, input: crate::model::JourneyLimits) -> Self {
            self.limits = Some(input);
            self
        }
        /// <p>The messaging and entry limits for the journey.</p>
        pub fn set_limits(
            mut self,
            input: std::option::Option<crate::model::JourneyLimits>,
        ) -> Self {
            self.limits = input;
            self
        }
        /// <p>Specifies whether the journey's scheduled start and end times use each participant's local time. To base the schedule on each participant's local time, set this value to true.</p>
        pub fn local_time(mut self, input: bool) -> Self {
            self.local_time = Some(input);
            self
        }
        /// <p>Specifies whether the journey's scheduled start and end times use each participant's local time. To base the schedule on each participant's local time, set this value to true.</p>
        pub fn set_local_time(mut self, input: std::option::Option<bool>) -> Self {
            self.local_time = input;
            self
        }
        /// <p>The name of the journey. A journey name can contain a maximum of 150 characters. The characters can be alphanumeric characters or symbols, such as underscores (_) or hyphens (-). A journey name can't contain any spaces.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the journey. A journey name can contain a maximum of 150 characters. The characters can be alphanumeric characters or symbols, such as underscores (_) or hyphens (-). A journey name can't contain any spaces.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The quiet time settings for the journey. Quiet time is a specific time range when a journey doesn't send messages to participants, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint for the participant is set to a valid value.</p></li> <li><p>The current time in the participant's time zone is later than or equal to the time specified by the QuietTime.Start property for the journey.</p></li> <li><p>The current time in the participant's time zone is earlier than or equal to the time specified by the QuietTime.End property for the journey.</p></li></ul> <p>If any of the preceding conditions isn't met, the participant will receive messages from the journey, even if quiet time is enabled.</p>
        pub fn quiet_time(mut self, input: crate::model::QuietTime) -> Self {
            self.quiet_time = Some(input);
            self
        }
        /// <p>The quiet time settings for the journey. Quiet time is a specific time range when a journey doesn't send messages to participants, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint for the participant is set to a valid value.</p></li> <li><p>The current time in the participant's time zone is later than or equal to the time specified by the QuietTime.Start property for the journey.</p></li> <li><p>The current time in the participant's time zone is earlier than or equal to the time specified by the QuietTime.End property for the journey.</p></li></ul> <p>If any of the preceding conditions isn't met, the participant will receive messages from the journey, even if quiet time is enabled.</p>
        pub fn set_quiet_time(
            mut self,
            input: std::option::Option<crate::model::QuietTime>,
        ) -> Self {
            self.quiet_time = input;
            self
        }
        /// <p>The frequency with which Amazon Pinpoint evaluates segment and event data for the journey, as a duration in ISO 8601 format.</p>
        pub fn refresh_frequency(mut self, input: impl Into<std::string::String>) -> Self {
            self.refresh_frequency = Some(input.into());
            self
        }
        /// <p>The frequency with which Amazon Pinpoint evaluates segment and event data for the journey, as a duration in ISO 8601 format.</p>
        pub fn set_refresh_frequency(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.refresh_frequency = input;
            self
        }
        /// <p>The schedule settings for the journey.</p>
        pub fn schedule(mut self, input: crate::model::JourneySchedule) -> Self {
            self.schedule = Some(input);
            self
        }
        /// <p>The schedule settings for the journey.</p>
        pub fn set_schedule(
            mut self,
            input: std::option::Option<crate::model::JourneySchedule>,
        ) -> Self {
            self.schedule = input;
            self
        }
        /// <p>The unique identifier for the first activity in the journey. The identifier for this activity can contain a maximum of 128 characters. The characters must be alphanumeric characters.</p>
        pub fn start_activity(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_activity = Some(input.into());
            self
        }
        /// <p>The unique identifier for the first activity in the journey. The identifier for this activity can contain a maximum of 128 characters. The characters must be alphanumeric characters.</p>
        pub fn set_start_activity(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.start_activity = input;
            self
        }
        /// <p>The segment that defines which users are participants in the journey.</p>
        pub fn start_condition(mut self, input: crate::model::StartCondition) -> Self {
            self.start_condition = Some(input);
            self
        }
        /// <p>The segment that defines which users are participants in the journey.</p>
        pub fn set_start_condition(
            mut self,
            input: std::option::Option<crate::model::StartCondition>,
        ) -> Self {
            self.start_condition = input;
            self
        }
        /// <p>The status of the journey. Valid values are:</p> <ul><li><p>DRAFT - Saves the journey and doesn't publish it.</p></li> <li><p>ACTIVE - Saves and publishes the journey. Depending on the journey's schedule, the journey starts running immediately or at the scheduled start time. If a journey's status is ACTIVE, you can't add, change, or remove activities from it.</p></li></ul> <p>PAUSED, CANCELLED, COMPLETED, and CLOSED states are not supported in requests to create or update a journey. To cancel, pause, or resume a journey, use the <link  linkend="apps-application-id-journeys-journey-id-state">Journey State</link> resource.</p>
        pub fn state(mut self, input: crate::model::State) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The status of the journey. Valid values are:</p> <ul><li><p>DRAFT - Saves the journey and doesn't publish it.</p></li> <li><p>ACTIVE - Saves and publishes the journey. Depending on the journey's schedule, the journey starts running immediately or at the scheduled start time. If a journey's status is ACTIVE, you can't add, change, or remove activities from it.</p></li></ul> <p>PAUSED, CANCELLED, COMPLETED, and CLOSED states are not supported in requests to create or update a journey. To cancel, pause, or resume a journey, use the <link  linkend="apps-application-id-journeys-journey-id-state">Journey State</link> resource.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::State>) -> Self {
            self.state = input;
            self
        }
        /// <p>Specifies whether endpoints in quiet hours should enter a wait till the end of their quiet hours.</p>
        pub fn wait_for_quiet_time(mut self, input: bool) -> Self {
            self.wait_for_quiet_time = Some(input);
            self
        }
        /// <p>Specifies whether endpoints in quiet hours should enter a wait till the end of their quiet hours.</p>
        pub fn set_wait_for_quiet_time(mut self, input: std::option::Option<bool>) -> Self {
            self.wait_for_quiet_time = input;
            self
        }
        /// <p>Specifies whether a journey should be refreshed on segment update.</p>
        pub fn refresh_on_segment_update(mut self, input: bool) -> Self {
            self.refresh_on_segment_update = Some(input);
            self
        }
        /// <p>Specifies whether a journey should be refreshed on segment update.</p>
        pub fn set_refresh_on_segment_update(mut self, input: std::option::Option<bool>) -> Self {
            self.refresh_on_segment_update = input;
            self
        }
        /// Consumes the builder and constructs a [`WriteJourneyRequest`](crate::model::WriteJourneyRequest)
        pub fn build(self) -> crate::model::WriteJourneyRequest {
            crate::model::WriteJourneyRequest {
                activities: self.activities,
                creation_date: self.creation_date,
                last_modified_date: self.last_modified_date,
                limits: self.limits,
                local_time: self.local_time.unwrap_or_default(),
                name: self.name,
                quiet_time: self.quiet_time,
                refresh_frequency: self.refresh_frequency,
                schedule: self.schedule,
                start_activity: self.start_activity,
                start_condition: self.start_condition,
                state: self.state,
                wait_for_quiet_time: self.wait_for_quiet_time.unwrap_or_default(),
                refresh_on_segment_update: self.refresh_on_segment_update.unwrap_or_default(),
            }
        }
    }
}
impl WriteJourneyRequest {
    /// Creates a new builder-style object to manufacture [`WriteJourneyRequest`](crate::model::WriteJourneyRequest)
    pub fn builder() -> crate::model::write_journey_request::Builder {
        crate::model::write_journey_request::Builder::default()
    }
}

/// <p>InApp Template Request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InAppTemplateRequest {
    /// <p>The content of the message, can include up to 5 modals. Each modal must contain a message, a header, and background color. ImageUrl and buttons are optional.</p>
    pub content: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
    /// <p>Custom config to be sent to client.</p>
    pub custom_config:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The layout of the message.</p>
    pub layout: std::option::Option<crate::model::Layout>,
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The description of the template.</p>
    pub template_description: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InAppTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InAppTemplateRequest");
        formatter.field("content", &self.content);
        formatter.field("custom_config", &self.custom_config);
        formatter.field("layout", &self.layout);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.finish()
    }
}
/// See [`InAppTemplateRequest`](crate::model::InAppTemplateRequest)
pub mod in_app_template_request {
    /// A builder for [`InAppTemplateRequest`](crate::model::InAppTemplateRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
        pub(crate) custom_config: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) layout: std::option::Option<crate::model::Layout>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `content`.
        ///
        /// To override the contents of this collection use [`set_content`](Self::set_content).
        ///
        /// <p>The content of the message, can include up to 5 modals. Each modal must contain a message, a header, and background color. ImageUrl and buttons are optional.</p>
        pub fn content(mut self, input: impl Into<crate::model::InAppMessageContent>) -> Self {
            let mut v = self.content.unwrap_or_default();
            v.push(input.into());
            self.content = Some(v);
            self
        }
        /// <p>The content of the message, can include up to 5 modals. Each modal must contain a message, a header, and background color. ImageUrl and buttons are optional.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
        ) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `custom_config`.
        ///
        /// To override the contents of this collection use [`set_custom_config`](Self::set_custom_config).
        ///
        /// <p>Custom config to be sent to client.</p>
        pub fn custom_config(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.custom_config.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.custom_config = Some(hash_map);
            self
        }
        /// <p>Custom config to be sent to client.</p>
        pub fn set_custom_config(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.custom_config = input;
            self
        }
        /// <p>The layout of the message.</p>
        pub fn layout(mut self, input: crate::model::Layout) -> Self {
            self.layout = Some(input);
            self
        }
        /// <p>The layout of the message.</p>
        pub fn set_layout(mut self, input: std::option::Option<crate::model::Layout>) -> Self {
            self.layout = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The description of the template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>The description of the template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// Consumes the builder and constructs a [`InAppTemplateRequest`](crate::model::InAppTemplateRequest)
        pub fn build(self) -> crate::model::InAppTemplateRequest {
            crate::model::InAppTemplateRequest {
                content: self.content,
                custom_config: self.custom_config,
                layout: self.layout,
                tags: self.tags,
                template_description: self.template_description,
            }
        }
    }
}
impl InAppTemplateRequest {
    /// Creates a new builder-style object to manufacture [`InAppTemplateRequest`](crate::model::InAppTemplateRequest)
    pub fn builder() -> crate::model::in_app_template_request::Builder {
        crate::model::in_app_template_request::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Layout {
    #[allow(missing_docs)] // documentation missing in model
    BottomBanner,
    #[allow(missing_docs)] // documentation missing in model
    Carousel,
    #[allow(missing_docs)] // documentation missing in model
    MiddleBanner,
    #[allow(missing_docs)] // documentation missing in model
    MobileFeed,
    #[allow(missing_docs)] // documentation missing in model
    Overlays,
    #[allow(missing_docs)] // documentation missing in model
    TopBanner,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Layout {
    fn from(s: &str) -> Self {
        match s {
            "BOTTOM_BANNER" => Layout::BottomBanner,
            "CAROUSEL" => Layout::Carousel,
            "MIDDLE_BANNER" => Layout::MiddleBanner,
            "MOBILE_FEED" => Layout::MobileFeed,
            "OVERLAYS" => Layout::Overlays,
            "TOP_BANNER" => Layout::TopBanner,
            other => Layout::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Layout {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Layout::from(s))
    }
}
impl Layout {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Layout::BottomBanner => "BOTTOM_BANNER",
            Layout::Carousel => "CAROUSEL",
            Layout::MiddleBanner => "MIDDLE_BANNER",
            Layout::MobileFeed => "MOBILE_FEED",
            Layout::Overlays => "OVERLAYS",
            Layout::TopBanner => "TOP_BANNER",
            Layout::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "BOTTOM_BANNER",
            "CAROUSEL",
            "MIDDLE_BANNER",
            "MOBILE_FEED",
            "OVERLAYS",
            "TOP_BANNER",
        ]
    }
}
impl AsRef<str> for Layout {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration for the message content.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InAppMessageContent {
    /// <p>The background color for the message.</p>
    pub background_color: std::option::Option<std::string::String>,
    /// <p>The configuration for the message body.</p>
    pub body_config: std::option::Option<crate::model::InAppMessageBodyConfig>,
    /// <p>The configuration for the message header.</p>
    pub header_config: std::option::Option<crate::model::InAppMessageHeaderConfig>,
    /// <p>The image url for the background of message.</p>
    pub image_url: std::option::Option<std::string::String>,
    /// <p>The first button inside the message.</p>
    pub primary_btn: std::option::Option<crate::model::InAppMessageButton>,
    /// <p>The second button inside message.</p>
    pub secondary_btn: std::option::Option<crate::model::InAppMessageButton>,
}
impl std::fmt::Debug for InAppMessageContent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InAppMessageContent");
        formatter.field("background_color", &self.background_color);
        formatter.field("body_config", &self.body_config);
        formatter.field("header_config", &self.header_config);
        formatter.field("image_url", &self.image_url);
        formatter.field("primary_btn", &self.primary_btn);
        formatter.field("secondary_btn", &self.secondary_btn);
        formatter.finish()
    }
}
/// See [`InAppMessageContent`](crate::model::InAppMessageContent)
pub mod in_app_message_content {
    /// A builder for [`InAppMessageContent`](crate::model::InAppMessageContent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) background_color: std::option::Option<std::string::String>,
        pub(crate) body_config: std::option::Option<crate::model::InAppMessageBodyConfig>,
        pub(crate) header_config: std::option::Option<crate::model::InAppMessageHeaderConfig>,
        pub(crate) image_url: std::option::Option<std::string::String>,
        pub(crate) primary_btn: std::option::Option<crate::model::InAppMessageButton>,
        pub(crate) secondary_btn: std::option::Option<crate::model::InAppMessageButton>,
    }
    impl Builder {
        /// <p>The background color for the message.</p>
        pub fn background_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.background_color = Some(input.into());
            self
        }
        /// <p>The background color for the message.</p>
        pub fn set_background_color(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.background_color = input;
            self
        }
        /// <p>The configuration for the message body.</p>
        pub fn body_config(mut self, input: crate::model::InAppMessageBodyConfig) -> Self {
            self.body_config = Some(input);
            self
        }
        /// <p>The configuration for the message body.</p>
        pub fn set_body_config(
            mut self,
            input: std::option::Option<crate::model::InAppMessageBodyConfig>,
        ) -> Self {
            self.body_config = input;
            self
        }
        /// <p>The configuration for the message header.</p>
        pub fn header_config(mut self, input: crate::model::InAppMessageHeaderConfig) -> Self {
            self.header_config = Some(input);
            self
        }
        /// <p>The configuration for the message header.</p>
        pub fn set_header_config(
            mut self,
            input: std::option::Option<crate::model::InAppMessageHeaderConfig>,
        ) -> Self {
            self.header_config = input;
            self
        }
        /// <p>The image url for the background of message.</p>
        pub fn image_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_url = Some(input.into());
            self
        }
        /// <p>The image url for the background of message.</p>
        pub fn set_image_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_url = input;
            self
        }
        /// <p>The first button inside the message.</p>
        pub fn primary_btn(mut self, input: crate::model::InAppMessageButton) -> Self {
            self.primary_btn = Some(input);
            self
        }
        /// <p>The first button inside the message.</p>
        pub fn set_primary_btn(
            mut self,
            input: std::option::Option<crate::model::InAppMessageButton>,
        ) -> Self {
            self.primary_btn = input;
            self
        }
        /// <p>The second button inside message.</p>
        pub fn secondary_btn(mut self, input: crate::model::InAppMessageButton) -> Self {
            self.secondary_btn = Some(input);
            self
        }
        /// <p>The second button inside message.</p>
        pub fn set_secondary_btn(
            mut self,
            input: std::option::Option<crate::model::InAppMessageButton>,
        ) -> Self {
            self.secondary_btn = input;
            self
        }
        /// Consumes the builder and constructs a [`InAppMessageContent`](crate::model::InAppMessageContent)
        pub fn build(self) -> crate::model::InAppMessageContent {
            crate::model::InAppMessageContent {
                background_color: self.background_color,
                body_config: self.body_config,
                header_config: self.header_config,
                image_url: self.image_url,
                primary_btn: self.primary_btn,
                secondary_btn: self.secondary_btn,
            }
        }
    }
}
impl InAppMessageContent {
    /// Creates a new builder-style object to manufacture [`InAppMessageContent`](crate::model::InAppMessageContent)
    pub fn builder() -> crate::model::in_app_message_content::Builder {
        crate::model::in_app_message_content::Builder::default()
    }
}

/// <p>Button Config for an in-app message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InAppMessageButton {
    /// <p>Default button content.</p>
    pub android: std::option::Option<crate::model::OverrideButtonConfiguration>,
    /// <p>Default button content.</p>
    pub default_config: std::option::Option<crate::model::DefaultButtonConfiguration>,
    /// <p>Default button content.</p>
    pub ios: std::option::Option<crate::model::OverrideButtonConfiguration>,
    /// <p>Default button content.</p>
    pub web: std::option::Option<crate::model::OverrideButtonConfiguration>,
}
impl std::fmt::Debug for InAppMessageButton {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InAppMessageButton");
        formatter.field("android", &self.android);
        formatter.field("default_config", &self.default_config);
        formatter.field("ios", &self.ios);
        formatter.field("web", &self.web);
        formatter.finish()
    }
}
/// See [`InAppMessageButton`](crate::model::InAppMessageButton)
pub mod in_app_message_button {
    /// A builder for [`InAppMessageButton`](crate::model::InAppMessageButton)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) android: std::option::Option<crate::model::OverrideButtonConfiguration>,
        pub(crate) default_config: std::option::Option<crate::model::DefaultButtonConfiguration>,
        pub(crate) ios: std::option::Option<crate::model::OverrideButtonConfiguration>,
        pub(crate) web: std::option::Option<crate::model::OverrideButtonConfiguration>,
    }
    impl Builder {
        /// <p>Default button content.</p>
        pub fn android(mut self, input: crate::model::OverrideButtonConfiguration) -> Self {
            self.android = Some(input);
            self
        }
        /// <p>Default button content.</p>
        pub fn set_android(
            mut self,
            input: std::option::Option<crate::model::OverrideButtonConfiguration>,
        ) -> Self {
            self.android = input;
            self
        }
        /// <p>Default button content.</p>
        pub fn default_config(mut self, input: crate::model::DefaultButtonConfiguration) -> Self {
            self.default_config = Some(input);
            self
        }
        /// <p>Default button content.</p>
        pub fn set_default_config(
            mut self,
            input: std::option::Option<crate::model::DefaultButtonConfiguration>,
        ) -> Self {
            self.default_config = input;
            self
        }
        /// <p>Default button content.</p>
        pub fn ios(mut self, input: crate::model::OverrideButtonConfiguration) -> Self {
            self.ios = Some(input);
            self
        }
        /// <p>Default button content.</p>
        pub fn set_ios(
            mut self,
            input: std::option::Option<crate::model::OverrideButtonConfiguration>,
        ) -> Self {
            self.ios = input;
            self
        }
        /// <p>Default button content.</p>
        pub fn web(mut self, input: crate::model::OverrideButtonConfiguration) -> Self {
            self.web = Some(input);
            self
        }
        /// <p>Default button content.</p>
        pub fn set_web(
            mut self,
            input: std::option::Option<crate::model::OverrideButtonConfiguration>,
        ) -> Self {
            self.web = input;
            self
        }
        /// Consumes the builder and constructs a [`InAppMessageButton`](crate::model::InAppMessageButton)
        pub fn build(self) -> crate::model::InAppMessageButton {
            crate::model::InAppMessageButton {
                android: self.android,
                default_config: self.default_config,
                ios: self.ios,
                web: self.web,
            }
        }
    }
}
impl InAppMessageButton {
    /// Creates a new builder-style object to manufacture [`InAppMessageButton`](crate::model::InAppMessageButton)
    pub fn builder() -> crate::model::in_app_message_button::Builder {
        crate::model::in_app_message_button::Builder::default()
    }
}

/// <p>Override button configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OverrideButtonConfiguration {
    /// <p>Action triggered by the button.</p>
    pub button_action: std::option::Option<crate::model::ButtonAction>,
    /// <p>Button destination.</p>
    pub link: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OverrideButtonConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OverrideButtonConfiguration");
        formatter.field("button_action", &self.button_action);
        formatter.field("link", &self.link);
        formatter.finish()
    }
}
/// See [`OverrideButtonConfiguration`](crate::model::OverrideButtonConfiguration)
pub mod override_button_configuration {
    /// A builder for [`OverrideButtonConfiguration`](crate::model::OverrideButtonConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) button_action: std::option::Option<crate::model::ButtonAction>,
        pub(crate) link: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Action triggered by the button.</p>
        pub fn button_action(mut self, input: crate::model::ButtonAction) -> Self {
            self.button_action = Some(input);
            self
        }
        /// <p>Action triggered by the button.</p>
        pub fn set_button_action(
            mut self,
            input: std::option::Option<crate::model::ButtonAction>,
        ) -> Self {
            self.button_action = input;
            self
        }
        /// <p>Button destination.</p>
        pub fn link(mut self, input: impl Into<std::string::String>) -> Self {
            self.link = Some(input.into());
            self
        }
        /// <p>Button destination.</p>
        pub fn set_link(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link = input;
            self
        }
        /// Consumes the builder and constructs a [`OverrideButtonConfiguration`](crate::model::OverrideButtonConfiguration)
        pub fn build(self) -> crate::model::OverrideButtonConfiguration {
            crate::model::OverrideButtonConfiguration {
                button_action: self.button_action,
                link: self.link,
            }
        }
    }
}
impl OverrideButtonConfiguration {
    /// Creates a new builder-style object to manufacture [`OverrideButtonConfiguration`](crate::model::OverrideButtonConfiguration)
    pub fn builder() -> crate::model::override_button_configuration::Builder {
        crate::model::override_button_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ButtonAction {
    #[allow(missing_docs)] // documentation missing in model
    Close,
    #[allow(missing_docs)] // documentation missing in model
    DeepLink,
    #[allow(missing_docs)] // documentation missing in model
    Link,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ButtonAction {
    fn from(s: &str) -> Self {
        match s {
            "CLOSE" => ButtonAction::Close,
            "DEEP_LINK" => ButtonAction::DeepLink,
            "LINK" => ButtonAction::Link,
            other => ButtonAction::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ButtonAction {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ButtonAction::from(s))
    }
}
impl ButtonAction {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ButtonAction::Close => "CLOSE",
            ButtonAction::DeepLink => "DEEP_LINK",
            ButtonAction::Link => "LINK",
            ButtonAction::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CLOSE", "DEEP_LINK", "LINK"]
    }
}
impl AsRef<str> for ButtonAction {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Default button configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultButtonConfiguration {
    /// <p>The background color of the button.</p>
    pub background_color: std::option::Option<std::string::String>,
    /// <p>The border radius of the button.</p>
    pub border_radius: i32,
    /// <p>Action triggered by the button.</p>
    pub button_action: std::option::Option<crate::model::ButtonAction>,
    /// <p>Button destination.</p>
    pub link: std::option::Option<std::string::String>,
    /// <p>Button text.</p>
    pub text: std::option::Option<std::string::String>,
    /// <p>The text color of the button.</p>
    pub text_color: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DefaultButtonConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultButtonConfiguration");
        formatter.field("background_color", &self.background_color);
        formatter.field("border_radius", &self.border_radius);
        formatter.field("button_action", &self.button_action);
        formatter.field("link", &self.link);
        formatter.field("text", &self.text);
        formatter.field("text_color", &self.text_color);
        formatter.finish()
    }
}
/// See [`DefaultButtonConfiguration`](crate::model::DefaultButtonConfiguration)
pub mod default_button_configuration {
    /// A builder for [`DefaultButtonConfiguration`](crate::model::DefaultButtonConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) background_color: std::option::Option<std::string::String>,
        pub(crate) border_radius: std::option::Option<i32>,
        pub(crate) button_action: std::option::Option<crate::model::ButtonAction>,
        pub(crate) link: std::option::Option<std::string::String>,
        pub(crate) text: std::option::Option<std::string::String>,
        pub(crate) text_color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The background color of the button.</p>
        pub fn background_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.background_color = Some(input.into());
            self
        }
        /// <p>The background color of the button.</p>
        pub fn set_background_color(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.background_color = input;
            self
        }
        /// <p>The border radius of the button.</p>
        pub fn border_radius(mut self, input: i32) -> Self {
            self.border_radius = Some(input);
            self
        }
        /// <p>The border radius of the button.</p>
        pub fn set_border_radius(mut self, input: std::option::Option<i32>) -> Self {
            self.border_radius = input;
            self
        }
        /// <p>Action triggered by the button.</p>
        pub fn button_action(mut self, input: crate::model::ButtonAction) -> Self {
            self.button_action = Some(input);
            self
        }
        /// <p>Action triggered by the button.</p>
        pub fn set_button_action(
            mut self,
            input: std::option::Option<crate::model::ButtonAction>,
        ) -> Self {
            self.button_action = input;
            self
        }
        /// <p>Button destination.</p>
        pub fn link(mut self, input: impl Into<std::string::String>) -> Self {
            self.link = Some(input.into());
            self
        }
        /// <p>Button destination.</p>
        pub fn set_link(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.link = input;
            self
        }
        /// <p>Button text.</p>
        pub fn text(mut self, input: impl Into<std::string::String>) -> Self {
            self.text = Some(input.into());
            self
        }
        /// <p>Button text.</p>
        pub fn set_text(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text = input;
            self
        }
        /// <p>The text color of the button.</p>
        pub fn text_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.text_color = Some(input.into());
            self
        }
        /// <p>The text color of the button.</p>
        pub fn set_text_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text_color = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultButtonConfiguration`](crate::model::DefaultButtonConfiguration)
        pub fn build(self) -> crate::model::DefaultButtonConfiguration {
            crate::model::DefaultButtonConfiguration {
                background_color: self.background_color,
                border_radius: self.border_radius.unwrap_or_default(),
                button_action: self.button_action,
                link: self.link,
                text: self.text,
                text_color: self.text_color,
            }
        }
    }
}
impl DefaultButtonConfiguration {
    /// Creates a new builder-style object to manufacture [`DefaultButtonConfiguration`](crate::model::DefaultButtonConfiguration)
    pub fn builder() -> crate::model::default_button_configuration::Builder {
        crate::model::default_button_configuration::Builder::default()
    }
}

/// <p>Text config for Message Header.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InAppMessageHeaderConfig {
    /// <p>The alignment of the text. Valid values: LEFT, CENTER, RIGHT.</p>
    pub alignment: std::option::Option<crate::model::Alignment>,
    /// <p>Message Header.</p>
    pub header: std::option::Option<std::string::String>,
    /// <p>The text color.</p>
    pub text_color: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InAppMessageHeaderConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InAppMessageHeaderConfig");
        formatter.field("alignment", &self.alignment);
        formatter.field("header", &self.header);
        formatter.field("text_color", &self.text_color);
        formatter.finish()
    }
}
/// See [`InAppMessageHeaderConfig`](crate::model::InAppMessageHeaderConfig)
pub mod in_app_message_header_config {
    /// A builder for [`InAppMessageHeaderConfig`](crate::model::InAppMessageHeaderConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alignment: std::option::Option<crate::model::Alignment>,
        pub(crate) header: std::option::Option<std::string::String>,
        pub(crate) text_color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alignment of the text. Valid values: LEFT, CENTER, RIGHT.</p>
        pub fn alignment(mut self, input: crate::model::Alignment) -> Self {
            self.alignment = Some(input);
            self
        }
        /// <p>The alignment of the text. Valid values: LEFT, CENTER, RIGHT.</p>
        pub fn set_alignment(
            mut self,
            input: std::option::Option<crate::model::Alignment>,
        ) -> Self {
            self.alignment = input;
            self
        }
        /// <p>Message Header.</p>
        pub fn header(mut self, input: impl Into<std::string::String>) -> Self {
            self.header = Some(input.into());
            self
        }
        /// <p>Message Header.</p>
        pub fn set_header(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.header = input;
            self
        }
        /// <p>The text color.</p>
        pub fn text_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.text_color = Some(input.into());
            self
        }
        /// <p>The text color.</p>
        pub fn set_text_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text_color = input;
            self
        }
        /// Consumes the builder and constructs a [`InAppMessageHeaderConfig`](crate::model::InAppMessageHeaderConfig)
        pub fn build(self) -> crate::model::InAppMessageHeaderConfig {
            crate::model::InAppMessageHeaderConfig {
                alignment: self.alignment,
                header: self.header,
                text_color: self.text_color,
            }
        }
    }
}
impl InAppMessageHeaderConfig {
    /// Creates a new builder-style object to manufacture [`InAppMessageHeaderConfig`](crate::model::InAppMessageHeaderConfig)
    pub fn builder() -> crate::model::in_app_message_header_config::Builder {
        crate::model::in_app_message_header_config::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Alignment {
    #[allow(missing_docs)] // documentation missing in model
    Center,
    #[allow(missing_docs)] // documentation missing in model
    Left,
    #[allow(missing_docs)] // documentation missing in model
    Right,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Alignment {
    fn from(s: &str) -> Self {
        match s {
            "CENTER" => Alignment::Center,
            "LEFT" => Alignment::Left,
            "RIGHT" => Alignment::Right,
            other => Alignment::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Alignment {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Alignment::from(s))
    }
}
impl Alignment {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Alignment::Center => "CENTER",
            Alignment::Left => "LEFT",
            Alignment::Right => "RIGHT",
            Alignment::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CENTER", "LEFT", "RIGHT"]
    }
}
impl AsRef<str> for Alignment {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Text config for Message Body.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InAppMessageBodyConfig {
    /// <p>The alignment of the text. Valid values: LEFT, CENTER, RIGHT.</p>
    pub alignment: std::option::Option<crate::model::Alignment>,
    /// <p>Message Body.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The text color.</p>
    pub text_color: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InAppMessageBodyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InAppMessageBodyConfig");
        formatter.field("alignment", &self.alignment);
        formatter.field("body", &self.body);
        formatter.field("text_color", &self.text_color);
        formatter.finish()
    }
}
/// See [`InAppMessageBodyConfig`](crate::model::InAppMessageBodyConfig)
pub mod in_app_message_body_config {
    /// A builder for [`InAppMessageBodyConfig`](crate::model::InAppMessageBodyConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) alignment: std::option::Option<crate::model::Alignment>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) text_color: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The alignment of the text. Valid values: LEFT, CENTER, RIGHT.</p>
        pub fn alignment(mut self, input: crate::model::Alignment) -> Self {
            self.alignment = Some(input);
            self
        }
        /// <p>The alignment of the text. Valid values: LEFT, CENTER, RIGHT.</p>
        pub fn set_alignment(
            mut self,
            input: std::option::Option<crate::model::Alignment>,
        ) -> Self {
            self.alignment = input;
            self
        }
        /// <p>Message Body.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>Message Body.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The text color.</p>
        pub fn text_color(mut self, input: impl Into<std::string::String>) -> Self {
            self.text_color = Some(input.into());
            self
        }
        /// <p>The text color.</p>
        pub fn set_text_color(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text_color = input;
            self
        }
        /// Consumes the builder and constructs a [`InAppMessageBodyConfig`](crate::model::InAppMessageBodyConfig)
        pub fn build(self) -> crate::model::InAppMessageBodyConfig {
            crate::model::InAppMessageBodyConfig {
                alignment: self.alignment,
                body: self.body,
                text_color: self.text_color,
            }
        }
    }
}
impl InAppMessageBodyConfig {
    /// Creates a new builder-style object to manufacture [`InAppMessageBodyConfig`](crate::model::InAppMessageBodyConfig)
    pub fn builder() -> crate::model::in_app_message_body_config::Builder {
        crate::model::in_app_message_body_config::Builder::default()
    }
}

/// <p>Provides information about the status and settings of the GCM channel for an application. The GCM channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GcmChannelResponse {
    /// <p>The unique identifier for the application that the GCM channel applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date and time when the GCM channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The Web API Key, also referred to as an <i>API_KEY</i> or <i>server key</i>, that you received from Google to communicate with Google services.</p>
    pub credential: std::option::Option<std::string::String>,
    /// <p>Specifies whether the GCM channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>(Deprecated) An identifier for the GCM channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the GCM channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the GCM channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the GCM channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The type of messaging or notification platform for the channel. For the GCM channel, this value is GCM.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current version of the GCM channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for GcmChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GcmChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("credential", &self.credential);
        formatter.field("enabled", &self.enabled);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("id", &self.id);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("platform", &self.platform);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`GcmChannelResponse`](crate::model::GcmChannelResponse)
pub mod gcm_channel_response {
    /// A builder for [`GcmChannelResponse`](crate::model::GcmChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) credential: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the GCM channel applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the GCM channel applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date and time when the GCM channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time when the GCM channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The Web API Key, also referred to as an <i>API_KEY</i> or <i>server key</i>, that you received from Google to communicate with Google services.</p>
        pub fn credential(mut self, input: impl Into<std::string::String>) -> Self {
            self.credential = Some(input.into());
            self
        }
        /// <p>The Web API Key, also referred to as an <i>API_KEY</i> or <i>server key</i>, that you received from Google to communicate with Google services.</p>
        pub fn set_credential(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.credential = input;
            self
        }
        /// <p>Specifies whether the GCM channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the GCM channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>(Deprecated) An identifier for the GCM channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the GCM channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the GCM channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the GCM channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the GCM channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the GCM channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time when the GCM channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time when the GCM channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the GCM channel, this value is GCM.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the GCM channel, this value is GCM.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current version of the GCM channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the GCM channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`GcmChannelResponse`](crate::model::GcmChannelResponse)
        pub fn build(self) -> crate::model::GcmChannelResponse {
            crate::model::GcmChannelResponse {
                application_id: self.application_id,
                creation_date: self.creation_date,
                credential: self.credential,
                enabled: self.enabled.unwrap_or_default(),
                has_credential: self.has_credential.unwrap_or_default(),
                id: self.id,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                platform: self.platform,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl GcmChannelResponse {
    /// Creates a new builder-style object to manufacture [`GcmChannelResponse`](crate::model::GcmChannelResponse)
    pub fn builder() -> crate::model::gcm_channel_response::Builder {
        crate::model::gcm_channel_response::Builder::default()
    }
}

/// <p>Specifies the status and settings of the GCM channel for an application. This channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GcmChannelRequest {
    /// <p>The Web API Key, also referred to as an <i>API_KEY</i> or <i>server key</i>, that you received from Google to communicate with Google services.</p>
    pub api_key: std::option::Option<std::string::String>,
    /// <p>Specifies whether to enable the GCM channel for the application.</p>
    pub enabled: bool,
}
impl std::fmt::Debug for GcmChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GcmChannelRequest");
        formatter.field("api_key", &self.api_key);
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`GcmChannelRequest`](crate::model::GcmChannelRequest)
pub mod gcm_channel_request {
    /// A builder for [`GcmChannelRequest`](crate::model::GcmChannelRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) api_key: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Web API Key, also referred to as an <i>API_KEY</i> or <i>server key</i>, that you received from Google to communicate with Google services.</p>
        pub fn api_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.api_key = Some(input.into());
            self
        }
        /// <p>The Web API Key, also referred to as an <i>API_KEY</i> or <i>server key</i>, that you received from Google to communicate with Google services.</p>
        pub fn set_api_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.api_key = input;
            self
        }
        /// <p>Specifies whether to enable the GCM channel for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether to enable the GCM channel for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`GcmChannelRequest`](crate::model::GcmChannelRequest)
        pub fn build(self) -> crate::model::GcmChannelRequest {
            crate::model::GcmChannelRequest {
                api_key: self.api_key,
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl GcmChannelRequest {
    /// Creates a new builder-style object to manufacture [`GcmChannelRequest`](crate::model::GcmChannelRequest)
    pub fn builder() -> crate::model::gcm_channel_request::Builder {
        crate::model::gcm_channel_request::Builder::default()
    }
}

/// <p>Specifies a batch of endpoints to create or update and the settings and attributes to set or change for each endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointBatchRequest {
    /// <p>An array that defines the endpoints to create or update and, for each endpoint, the property values to set or change. An array can contain a maximum of 100 items.</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::EndpointBatchItem>>,
}
impl std::fmt::Debug for EndpointBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointBatchRequest");
        formatter.field("item", &self.item);
        formatter.finish()
    }
}
/// See [`EndpointBatchRequest`](crate::model::EndpointBatchRequest)
pub mod endpoint_batch_request {
    /// A builder for [`EndpointBatchRequest`](crate::model::EndpointBatchRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::EndpointBatchItem>>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array that defines the endpoints to create or update and, for each endpoint, the property values to set or change. An array can contain a maximum of 100 items.</p>
        pub fn item(mut self, input: impl Into<crate::model::EndpointBatchItem>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array that defines the endpoints to create or update and, for each endpoint, the property values to set or change. An array can contain a maximum of 100 items.</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndpointBatchItem>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointBatchRequest`](crate::model::EndpointBatchRequest)
        pub fn build(self) -> crate::model::EndpointBatchRequest {
            crate::model::EndpointBatchRequest { item: self.item }
        }
    }
}
impl EndpointBatchRequest {
    /// Creates a new builder-style object to manufacture [`EndpointBatchRequest`](crate::model::EndpointBatchRequest)
    pub fn builder() -> crate::model::endpoint_batch_request::Builder {
        crate::model::endpoint_batch_request::Builder::default()
    }
}

/// <p>Specifies an endpoint to create or update and the settings and attributes to set or change for the endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointBatchItem {
    /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
    pub attributes: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The channel to use when sending messages or push notifications to the endpoint.</p>
    pub channel_type: std::option::Option<crate::model::ChannelType>,
    /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
    pub demographic: std::option::Option<crate::model::EndpointDemographic>,
    /// <p>The date and time, in ISO 8601 format, when the endpoint was created or updated.</p>
    pub effective_date: std::option::Option<std::string::String>,
    /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
    pub endpoint_status: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the endpoint in the context of the batch.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The geographic information for the endpoint.</p>
    pub location: std::option::Option<crate::model::EndpointLocation>,
    /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
    pub metrics: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
    /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
    pub opt_out: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request to create or update the endpoint.</p>
    pub request_id: std::option::Option<std::string::String>,
    /// <p>One or more custom attributes that describe the user who's associated with the endpoint.</p>
    pub user: std::option::Option<crate::model::EndpointUser>,
}
impl std::fmt::Debug for EndpointBatchItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointBatchItem");
        formatter.field("address", &self.address);
        formatter.field("attributes", &self.attributes);
        formatter.field("channel_type", &self.channel_type);
        formatter.field("demographic", &self.demographic);
        formatter.field("effective_date", &self.effective_date);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.field("id", &self.id);
        formatter.field("location", &self.location);
        formatter.field("metrics", &self.metrics);
        formatter.field("opt_out", &self.opt_out);
        formatter.field("request_id", &self.request_id);
        formatter.field("user", &self.user);
        formatter.finish()
    }
}
/// See [`EndpointBatchItem`](crate::model::EndpointBatchItem)
pub mod endpoint_batch_item {
    /// A builder for [`EndpointBatchItem`](crate::model::EndpointBatchItem)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) channel_type: std::option::Option<crate::model::ChannelType>,
        pub(crate) demographic: std::option::Option<crate::model::EndpointDemographic>,
        pub(crate) effective_date: std::option::Option<std::string::String>,
        pub(crate) endpoint_status: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::EndpointLocation>,
        pub(crate) metrics:
            std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        pub(crate) opt_out: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        pub(crate) user: std::option::Option<crate::model::EndpointUser>,
    }
    impl Builder {
        /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The channel to use when sending messages or push notifications to the endpoint.</p>
        pub fn channel_type(mut self, input: crate::model::ChannelType) -> Self {
            self.channel_type = Some(input);
            self
        }
        /// <p>The channel to use when sending messages or push notifications to the endpoint.</p>
        pub fn set_channel_type(
            mut self,
            input: std::option::Option<crate::model::ChannelType>,
        ) -> Self {
            self.channel_type = input;
            self
        }
        /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
        pub fn demographic(mut self, input: crate::model::EndpointDemographic) -> Self {
            self.demographic = Some(input);
            self
        }
        /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
        pub fn set_demographic(
            mut self,
            input: std::option::Option<crate::model::EndpointDemographic>,
        ) -> Self {
            self.demographic = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the endpoint was created or updated.</p>
        pub fn effective_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the endpoint was created or updated.</p>
        pub fn set_effective_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_date = input;
            self
        }
        /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
        pub fn endpoint_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_status = Some(input.into());
            self
        }
        /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// <p>The unique identifier for the endpoint in the context of the batch.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the endpoint in the context of the batch.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The geographic information for the endpoint.</p>
        pub fn location(mut self, input: crate::model::EndpointLocation) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The geographic information for the endpoint.</p>
        pub fn set_location(
            mut self,
            input: std::option::Option<crate::model::EndpointLocation>,
        ) -> Self {
            self.location = input;
            self
        }
        /// Adds a key-value pair to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
        pub fn metrics(mut self, k: impl Into<std::string::String>, v: impl Into<f64>) -> Self {
            let mut hash_map = self.metrics.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metrics = Some(hash_map);
            self
        }
        /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
        pub fn opt_out(mut self, input: impl Into<std::string::String>) -> Self {
            self.opt_out = Some(input.into());
            self
        }
        /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
        pub fn set_opt_out(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.opt_out = input;
            self
        }
        /// <p>The unique identifier for the request to create or update the endpoint.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the request to create or update the endpoint.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// <p>One or more custom attributes that describe the user who's associated with the endpoint.</p>
        pub fn user(mut self, input: crate::model::EndpointUser) -> Self {
            self.user = Some(input);
            self
        }
        /// <p>One or more custom attributes that describe the user who's associated with the endpoint.</p>
        pub fn set_user(mut self, input: std::option::Option<crate::model::EndpointUser>) -> Self {
            self.user = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointBatchItem`](crate::model::EndpointBatchItem)
        pub fn build(self) -> crate::model::EndpointBatchItem {
            crate::model::EndpointBatchItem {
                address: self.address,
                attributes: self.attributes,
                channel_type: self.channel_type,
                demographic: self.demographic,
                effective_date: self.effective_date,
                endpoint_status: self.endpoint_status,
                id: self.id,
                location: self.location,
                metrics: self.metrics,
                opt_out: self.opt_out,
                request_id: self.request_id,
                user: self.user,
            }
        }
    }
}
impl EndpointBatchItem {
    /// Creates a new builder-style object to manufacture [`EndpointBatchItem`](crate::model::EndpointBatchItem)
    pub fn builder() -> crate::model::endpoint_batch_item::Builder {
        crate::model::endpoint_batch_item::Builder::default()
    }
}

/// <p>Specifies data for one or more attributes that describe the user who's associated with an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointUser {
    /// <p>One or more custom attributes that describe the user by associating a name with an array of values. For example, the value of an attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
    pub user_attributes: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The unique identifier for the user.</p>
    pub user_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EndpointUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointUser");
        formatter.field("user_attributes", &self.user_attributes);
        formatter.field("user_id", &self.user_id);
        formatter.finish()
    }
}
/// See [`EndpointUser`](crate::model::EndpointUser)
pub mod endpoint_user {
    /// A builder for [`EndpointUser`](crate::model::EndpointUser)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) user_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Adds a key-value pair to `user_attributes`.
        ///
        /// To override the contents of this collection use [`set_user_attributes`](Self::set_user_attributes).
        ///
        /// <p>One or more custom attributes that describe the user by associating a name with an array of values. For example, the value of an attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
        pub fn user_attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.user_attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.user_attributes = Some(hash_map);
            self
        }
        /// <p>One or more custom attributes that describe the user by associating a name with an array of values. For example, the value of an attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
        pub fn set_user_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.user_attributes = input;
            self
        }
        /// <p>The unique identifier for the user.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the user.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointUser`](crate::model::EndpointUser)
        pub fn build(self) -> crate::model::EndpointUser {
            crate::model::EndpointUser {
                user_attributes: self.user_attributes,
                user_id: self.user_id,
            }
        }
    }
}
impl EndpointUser {
    /// Creates a new builder-style object to manufacture [`EndpointUser`](crate::model::EndpointUser)
    pub fn builder() -> crate::model::endpoint_user::Builder {
        crate::model::endpoint_user::Builder::default()
    }
}

/// <p>Specifies geographic information about an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointLocation {
    /// <p>The name of the city where the endpoint is located.</p>
    pub city: std::option::Option<std::string::String>,
    /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the endpoint is located. For example, US for the United States.</p>
    pub country: std::option::Option<std::string::String>,
    /// <p>The latitude coordinate of the endpoint location, rounded to one decimal place.</p>
    pub latitude: f64,
    /// <p>The longitude coordinate of the endpoint location, rounded to one decimal place.</p>
    pub longitude: f64,
    /// <p>The postal or ZIP code for the area where the endpoint is located.</p>
    pub postal_code: std::option::Option<std::string::String>,
    /// <p>The name of the region where the endpoint is located. For locations in the United States, this value is the name of a state.</p>
    pub region: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EndpointLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointLocation");
        formatter.field("city", &self.city);
        formatter.field("country", &self.country);
        formatter.field("latitude", &self.latitude);
        formatter.field("longitude", &self.longitude);
        formatter.field("postal_code", &self.postal_code);
        formatter.field("region", &self.region);
        formatter.finish()
    }
}
/// See [`EndpointLocation`](crate::model::EndpointLocation)
pub mod endpoint_location {
    /// A builder for [`EndpointLocation`](crate::model::EndpointLocation)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) city: std::option::Option<std::string::String>,
        pub(crate) country: std::option::Option<std::string::String>,
        pub(crate) latitude: std::option::Option<f64>,
        pub(crate) longitude: std::option::Option<f64>,
        pub(crate) postal_code: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the city where the endpoint is located.</p>
        pub fn city(mut self, input: impl Into<std::string::String>) -> Self {
            self.city = Some(input.into());
            self
        }
        /// <p>The name of the city where the endpoint is located.</p>
        pub fn set_city(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.city = input;
            self
        }
        /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the endpoint is located. For example, US for the United States.</p>
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the endpoint is located. For example, US for the United States.</p>
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        /// <p>The latitude coordinate of the endpoint location, rounded to one decimal place.</p>
        pub fn latitude(mut self, input: f64) -> Self {
            self.latitude = Some(input);
            self
        }
        /// <p>The latitude coordinate of the endpoint location, rounded to one decimal place.</p>
        pub fn set_latitude(mut self, input: std::option::Option<f64>) -> Self {
            self.latitude = input;
            self
        }
        /// <p>The longitude coordinate of the endpoint location, rounded to one decimal place.</p>
        pub fn longitude(mut self, input: f64) -> Self {
            self.longitude = Some(input);
            self
        }
        /// <p>The longitude coordinate of the endpoint location, rounded to one decimal place.</p>
        pub fn set_longitude(mut self, input: std::option::Option<f64>) -> Self {
            self.longitude = input;
            self
        }
        /// <p>The postal or ZIP code for the area where the endpoint is located.</p>
        pub fn postal_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.postal_code = Some(input.into());
            self
        }
        /// <p>The postal or ZIP code for the area where the endpoint is located.</p>
        pub fn set_postal_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.postal_code = input;
            self
        }
        /// <p>The name of the region where the endpoint is located. For locations in the United States, this value is the name of a state.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The name of the region where the endpoint is located. For locations in the United States, this value is the name of a state.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointLocation`](crate::model::EndpointLocation)
        pub fn build(self) -> crate::model::EndpointLocation {
            crate::model::EndpointLocation {
                city: self.city,
                country: self.country,
                latitude: self.latitude.unwrap_or_default(),
                longitude: self.longitude.unwrap_or_default(),
                postal_code: self.postal_code,
                region: self.region,
            }
        }
    }
}
impl EndpointLocation {
    /// Creates a new builder-style object to manufacture [`EndpointLocation`](crate::model::EndpointLocation)
    pub fn builder() -> crate::model::endpoint_location::Builder {
        crate::model::endpoint_location::Builder::default()
    }
}

/// <p>Specifies demographic information about an endpoint, such as the applicable time zone and platform.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointDemographic {
    /// <p>The version of the app that's associated with the endpoint.</p>
    pub app_version: std::option::Option<std::string::String>,
    /// <p>The locale of the endpoint, in the following format: the ISO 639-1 alpha-2 code, followed by an underscore (_), followed by an ISO 3166-1 alpha-2 value.</p>
    pub locale: std::option::Option<std::string::String>,
    /// <p>The manufacturer of the endpoint device, such as apple or samsung.</p>
    pub make: std::option::Option<std::string::String>,
    /// <p>The model name or number of the endpoint device, such as iPhone or SM-G900F.</p>
    pub model: std::option::Option<std::string::String>,
    /// <p>The model version of the endpoint device.</p>
    pub model_version: std::option::Option<std::string::String>,
    /// <p>The platform of the endpoint device, such as ios.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The platform version of the endpoint device.</p>
    pub platform_version: std::option::Option<std::string::String>,
    /// <p>The time zone of the endpoint, specified as a tz database name value, such as America/Los_Angeles.</p>
    pub timezone: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EndpointDemographic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointDemographic");
        formatter.field("app_version", &self.app_version);
        formatter.field("locale", &self.locale);
        formatter.field("make", &self.make);
        formatter.field("model", &self.model);
        formatter.field("model_version", &self.model_version);
        formatter.field("platform", &self.platform);
        formatter.field("platform_version", &self.platform_version);
        formatter.field("timezone", &self.timezone);
        formatter.finish()
    }
}
/// See [`EndpointDemographic`](crate::model::EndpointDemographic)
pub mod endpoint_demographic {
    /// A builder for [`EndpointDemographic`](crate::model::EndpointDemographic)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_version: std::option::Option<std::string::String>,
        pub(crate) locale: std::option::Option<std::string::String>,
        pub(crate) make: std::option::Option<std::string::String>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) platform_version: std::option::Option<std::string::String>,
        pub(crate) timezone: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version of the app that's associated with the endpoint.</p>
        pub fn app_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_version = Some(input.into());
            self
        }
        /// <p>The version of the app that's associated with the endpoint.</p>
        pub fn set_app_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_version = input;
            self
        }
        /// <p>The locale of the endpoint, in the following format: the ISO 639-1 alpha-2 code, followed by an underscore (_), followed by an ISO 3166-1 alpha-2 value.</p>
        pub fn locale(mut self, input: impl Into<std::string::String>) -> Self {
            self.locale = Some(input.into());
            self
        }
        /// <p>The locale of the endpoint, in the following format: the ISO 639-1 alpha-2 code, followed by an underscore (_), followed by an ISO 3166-1 alpha-2 value.</p>
        pub fn set_locale(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.locale = input;
            self
        }
        /// <p>The manufacturer of the endpoint device, such as apple or samsung.</p>
        pub fn make(mut self, input: impl Into<std::string::String>) -> Self {
            self.make = Some(input.into());
            self
        }
        /// <p>The manufacturer of the endpoint device, such as apple or samsung.</p>
        pub fn set_make(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.make = input;
            self
        }
        /// <p>The model name or number of the endpoint device, such as iPhone or SM-G900F.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The model name or number of the endpoint device, such as iPhone or SM-G900F.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// <p>The model version of the endpoint device.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The model version of the endpoint device.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p>The platform of the endpoint device, such as ios.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The platform of the endpoint device, such as ios.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The platform version of the endpoint device.</p>
        pub fn platform_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform_version = Some(input.into());
            self
        }
        /// <p>The platform version of the endpoint device.</p>
        pub fn set_platform_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.platform_version = input;
            self
        }
        /// <p>The time zone of the endpoint, specified as a tz database name value, such as America/Los_Angeles.</p>
        pub fn timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.timezone = Some(input.into());
            self
        }
        /// <p>The time zone of the endpoint, specified as a tz database name value, such as America/Los_Angeles.</p>
        pub fn set_timezone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timezone = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointDemographic`](crate::model::EndpointDemographic)
        pub fn build(self) -> crate::model::EndpointDemographic {
            crate::model::EndpointDemographic {
                app_version: self.app_version,
                locale: self.locale,
                make: self.make,
                model: self.model,
                model_version: self.model_version,
                platform: self.platform,
                platform_version: self.platform_version,
                timezone: self.timezone,
            }
        }
    }
}
impl EndpointDemographic {
    /// Creates a new builder-style object to manufacture [`EndpointDemographic`](crate::model::EndpointDemographic)
    pub fn builder() -> crate::model::endpoint_demographic::Builder {
        crate::model::endpoint_demographic::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChannelType {
    #[allow(missing_docs)] // documentation missing in model
    Adm,
    #[allow(missing_docs)] // documentation missing in model
    Apns,
    #[allow(missing_docs)] // documentation missing in model
    ApnsSandbox,
    #[allow(missing_docs)] // documentation missing in model
    ApnsVoip,
    #[allow(missing_docs)] // documentation missing in model
    ApnsVoipSandbox,
    #[allow(missing_docs)] // documentation missing in model
    Baidu,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    Email,
    #[allow(missing_docs)] // documentation missing in model
    Gcm,
    #[allow(missing_docs)] // documentation missing in model
    InApp,
    #[allow(missing_docs)] // documentation missing in model
    Push,
    #[allow(missing_docs)] // documentation missing in model
    Sms,
    #[allow(missing_docs)] // documentation missing in model
    Voice,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ChannelType {
    fn from(s: &str) -> Self {
        match s {
            "ADM" => ChannelType::Adm,
            "APNS" => ChannelType::Apns,
            "APNS_SANDBOX" => ChannelType::ApnsSandbox,
            "APNS_VOIP" => ChannelType::ApnsVoip,
            "APNS_VOIP_SANDBOX" => ChannelType::ApnsVoipSandbox,
            "BAIDU" => ChannelType::Baidu,
            "CUSTOM" => ChannelType::Custom,
            "EMAIL" => ChannelType::Email,
            "GCM" => ChannelType::Gcm,
            "IN_APP" => ChannelType::InApp,
            "PUSH" => ChannelType::Push,
            "SMS" => ChannelType::Sms,
            "VOICE" => ChannelType::Voice,
            other => ChannelType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ChannelType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChannelType::from(s))
    }
}
impl ChannelType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChannelType::Adm => "ADM",
            ChannelType::Apns => "APNS",
            ChannelType::ApnsSandbox => "APNS_SANDBOX",
            ChannelType::ApnsVoip => "APNS_VOIP",
            ChannelType::ApnsVoipSandbox => "APNS_VOIP_SANDBOX",
            ChannelType::Baidu => "BAIDU",
            ChannelType::Custom => "CUSTOM",
            ChannelType::Email => "EMAIL",
            ChannelType::Gcm => "GCM",
            ChannelType::InApp => "IN_APP",
            ChannelType::Push => "PUSH",
            ChannelType::Sms => "SMS",
            ChannelType::Voice => "VOICE",
            ChannelType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ADM",
            "APNS",
            "APNS_SANDBOX",
            "APNS_VOIP",
            "APNS_VOIP_SANDBOX",
            "BAIDU",
            "CUSTOM",
            "EMAIL",
            "GCM",
            "IN_APP",
            "PUSH",
            "SMS",
            "VOICE",
        ]
    }
}
impl AsRef<str> for ChannelType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the channel type and other settings for an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointRequest {
    /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
    pub attributes: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The channel to use when sending messages or push notifications to the endpoint.</p>
    pub channel_type: std::option::Option<crate::model::ChannelType>,
    /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
    pub demographic: std::option::Option<crate::model::EndpointDemographic>,
    /// <p>The date and time, in ISO 8601 format, when the endpoint is updated.</p>
    pub effective_date: std::option::Option<std::string::String>,
    /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
    pub endpoint_status: std::option::Option<std::string::String>,
    /// <p>The geographic information for the endpoint.</p>
    pub location: std::option::Option<crate::model::EndpointLocation>,
    /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
    pub metrics: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
    /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
    pub opt_out: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the most recent request to update the endpoint.</p>
    pub request_id: std::option::Option<std::string::String>,
    /// <p>One or more custom attributes that describe the user who's associated with the endpoint.</p>
    pub user: std::option::Option<crate::model::EndpointUser>,
}
impl std::fmt::Debug for EndpointRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointRequest");
        formatter.field("address", &self.address);
        formatter.field("attributes", &self.attributes);
        formatter.field("channel_type", &self.channel_type);
        formatter.field("demographic", &self.demographic);
        formatter.field("effective_date", &self.effective_date);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.field("location", &self.location);
        formatter.field("metrics", &self.metrics);
        formatter.field("opt_out", &self.opt_out);
        formatter.field("request_id", &self.request_id);
        formatter.field("user", &self.user);
        formatter.finish()
    }
}
/// See [`EndpointRequest`](crate::model::EndpointRequest)
pub mod endpoint_request {
    /// A builder for [`EndpointRequest`](crate::model::EndpointRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) channel_type: std::option::Option<crate::model::ChannelType>,
        pub(crate) demographic: std::option::Option<crate::model::EndpointDemographic>,
        pub(crate) effective_date: std::option::Option<std::string::String>,
        pub(crate) endpoint_status: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::EndpointLocation>,
        pub(crate) metrics:
            std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        pub(crate) opt_out: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        pub(crate) user: std::option::Option<crate::model::EndpointUser>,
    }
    impl Builder {
        /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The channel to use when sending messages or push notifications to the endpoint.</p>
        pub fn channel_type(mut self, input: crate::model::ChannelType) -> Self {
            self.channel_type = Some(input);
            self
        }
        /// <p>The channel to use when sending messages or push notifications to the endpoint.</p>
        pub fn set_channel_type(
            mut self,
            input: std::option::Option<crate::model::ChannelType>,
        ) -> Self {
            self.channel_type = input;
            self
        }
        /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
        pub fn demographic(mut self, input: crate::model::EndpointDemographic) -> Self {
            self.demographic = Some(input);
            self
        }
        /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
        pub fn set_demographic(
            mut self,
            input: std::option::Option<crate::model::EndpointDemographic>,
        ) -> Self {
            self.demographic = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the endpoint is updated.</p>
        pub fn effective_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the endpoint is updated.</p>
        pub fn set_effective_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_date = input;
            self
        }
        /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
        pub fn endpoint_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_status = Some(input.into());
            self
        }
        /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// <p>The geographic information for the endpoint.</p>
        pub fn location(mut self, input: crate::model::EndpointLocation) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The geographic information for the endpoint.</p>
        pub fn set_location(
            mut self,
            input: std::option::Option<crate::model::EndpointLocation>,
        ) -> Self {
            self.location = input;
            self
        }
        /// Adds a key-value pair to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
        pub fn metrics(mut self, k: impl Into<std::string::String>, v: impl Into<f64>) -> Self {
            let mut hash_map = self.metrics.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metrics = Some(hash_map);
            self
        }
        /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
        pub fn opt_out(mut self, input: impl Into<std::string::String>) -> Self {
            self.opt_out = Some(input.into());
            self
        }
        /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
        pub fn set_opt_out(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.opt_out = input;
            self
        }
        /// <p>The unique identifier for the most recent request to update the endpoint.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the most recent request to update the endpoint.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// <p>One or more custom attributes that describe the user who's associated with the endpoint.</p>
        pub fn user(mut self, input: crate::model::EndpointUser) -> Self {
            self.user = Some(input);
            self
        }
        /// <p>One or more custom attributes that describe the user who's associated with the endpoint.</p>
        pub fn set_user(mut self, input: std::option::Option<crate::model::EndpointUser>) -> Self {
            self.user = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointRequest`](crate::model::EndpointRequest)
        pub fn build(self) -> crate::model::EndpointRequest {
            crate::model::EndpointRequest {
                address: self.address,
                attributes: self.attributes,
                channel_type: self.channel_type,
                demographic: self.demographic,
                effective_date: self.effective_date,
                endpoint_status: self.endpoint_status,
                location: self.location,
                metrics: self.metrics,
                opt_out: self.opt_out,
                request_id: self.request_id,
                user: self.user,
            }
        }
    }
}
impl EndpointRequest {
    /// Creates a new builder-style object to manufacture [`EndpointRequest`](crate::model::EndpointRequest)
    pub fn builder() -> crate::model::endpoint_request::Builder {
        crate::model::endpoint_request::Builder::default()
    }
}

/// <p>Specifies the content and settings for a message template that can be used in messages that are sent through the email channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EmailTemplateRequest {
    /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
    pub default_substitutions: std::option::Option<std::string::String>,
    /// <p>The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.</p>
    pub html_part: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
    pub recommender_id: std::option::Option<std::string::String>,
    /// <p>The subject line, or title, to use in email messages that are based on the message template.</p>
    pub subject: std::option::Option<std::string::String>,
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A custom description of the message template.</p>
    pub template_description: std::option::Option<std::string::String>,
    /// <p>The message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.</p>
    pub text_part: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EmailTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EmailTemplateRequest");
        formatter.field("default_substitutions", &self.default_substitutions);
        formatter.field("html_part", &self.html_part);
        formatter.field("recommender_id", &self.recommender_id);
        formatter.field("subject", &self.subject);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.field("text_part", &self.text_part);
        formatter.finish()
    }
}
/// See [`EmailTemplateRequest`](crate::model::EmailTemplateRequest)
pub mod email_template_request {
    /// A builder for [`EmailTemplateRequest`](crate::model::EmailTemplateRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) default_substitutions: std::option::Option<std::string::String>,
        pub(crate) html_part: std::option::Option<std::string::String>,
        pub(crate) recommender_id: std::option::Option<std::string::String>,
        pub(crate) subject: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
        pub(crate) text_part: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
        pub fn default_substitutions(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_substitutions = Some(input.into());
            self
        }
        /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
        pub fn set_default_substitutions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_substitutions = input;
            self
        }
        /// <p>The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.</p>
        pub fn html_part(mut self, input: impl Into<std::string::String>) -> Self {
            self.html_part = Some(input.into());
            self
        }
        /// <p>The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.</p>
        pub fn set_html_part(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.html_part = input;
            self
        }
        /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
        pub fn recommender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommender_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
        pub fn set_recommender_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommender_id = input;
            self
        }
        /// <p>The subject line, or title, to use in email messages that are based on the message template.</p>
        pub fn subject(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject = Some(input.into());
            self
        }
        /// <p>The subject line, or title, to use in email messages that are based on the message template.</p>
        pub fn set_subject(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>A custom description of the message template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>A custom description of the message template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// <p>The message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.</p>
        pub fn text_part(mut self, input: impl Into<std::string::String>) -> Self {
            self.text_part = Some(input.into());
            self
        }
        /// <p>The message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.</p>
        pub fn set_text_part(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text_part = input;
            self
        }
        /// Consumes the builder and constructs a [`EmailTemplateRequest`](crate::model::EmailTemplateRequest)
        pub fn build(self) -> crate::model::EmailTemplateRequest {
            crate::model::EmailTemplateRequest {
                default_substitutions: self.default_substitutions,
                html_part: self.html_part,
                recommender_id: self.recommender_id,
                subject: self.subject,
                tags: self.tags,
                template_description: self.template_description,
                text_part: self.text_part,
            }
        }
    }
}
impl EmailTemplateRequest {
    /// Creates a new builder-style object to manufacture [`EmailTemplateRequest`](crate::model::EmailTemplateRequest)
    pub fn builder() -> crate::model::email_template_request::Builder {
        crate::model::email_template_request::Builder::default()
    }
}

/// <p>Provides information about the status and settings of the email channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EmailChannelResponse {
    /// <p>The unique identifier for the application that the email channel applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The <a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_ConfigurationSet.html">Amazon SES configuration set</a> that's applied to messages that are sent through the channel.</p>
    pub configuration_set: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when the email channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>Specifies whether the email channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>The verified email address that email is sent from when you send email through the channel.</p>
    pub from_address: std::option::Option<std::string::String>,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>(Deprecated) An identifier for the email channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that's used when you send email through the channel.</p>
    pub identity: std::option::Option<std::string::String>,
    /// <p>Specifies whether the email channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the email channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when the email channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The maximum number of emails that can be sent through the channel each second.</p>
    pub messages_per_second: i32,
    /// <p>The type of messaging or notification platform for the channel. For the email channel, this value is EMAIL.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that Amazon Pinpoint uses to submit email-related event data for the channel.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The current version of the email channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for EmailChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EmailChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("configuration_set", &self.configuration_set);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("enabled", &self.enabled);
        formatter.field("from_address", &self.from_address);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("id", &self.id);
        formatter.field("identity", &self.identity);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("messages_per_second", &self.messages_per_second);
        formatter.field("platform", &self.platform);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`EmailChannelResponse`](crate::model::EmailChannelResponse)
pub mod email_channel_response {
    /// A builder for [`EmailChannelResponse`](crate::model::EmailChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) configuration_set: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) from_address: std::option::Option<std::string::String>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) identity: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) messages_per_second: std::option::Option<i32>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the email channel applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the email channel applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_ConfigurationSet.html">Amazon SES configuration set</a> that's applied to messages that are sent through the channel.</p>
        pub fn configuration_set(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_set = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_ConfigurationSet.html">Amazon SES configuration set</a> that's applied to messages that are sent through the channel.</p>
        pub fn set_configuration_set(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_set = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the email channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the email channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>Specifies whether the email channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the email channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The verified email address that email is sent from when you send email through the channel.</p>
        pub fn from_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_address = Some(input.into());
            self
        }
        /// <p>The verified email address that email is sent from when you send email through the channel.</p>
        pub fn set_from_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from_address = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>(Deprecated) An identifier for the email channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the email channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that's used when you send email through the channel.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that's used when you send email through the channel.</p>
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identity = input;
            self
        }
        /// <p>Specifies whether the email channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the email channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the email channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the email channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the email channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the email channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The maximum number of emails that can be sent through the channel each second.</p>
        pub fn messages_per_second(mut self, input: i32) -> Self {
            self.messages_per_second = Some(input);
            self
        }
        /// <p>The maximum number of emails that can be sent through the channel each second.</p>
        pub fn set_messages_per_second(mut self, input: std::option::Option<i32>) -> Self {
            self.messages_per_second = input;
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the email channel, this value is EMAIL.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the email channel, this value is EMAIL.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The ARN of the AWS Identity and Access Management (IAM) role that Amazon Pinpoint uses to submit email-related event data for the channel.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the AWS Identity and Access Management (IAM) role that Amazon Pinpoint uses to submit email-related event data for the channel.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The current version of the email channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the email channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`EmailChannelResponse`](crate::model::EmailChannelResponse)
        pub fn build(self) -> crate::model::EmailChannelResponse {
            crate::model::EmailChannelResponse {
                application_id: self.application_id,
                configuration_set: self.configuration_set,
                creation_date: self.creation_date,
                enabled: self.enabled.unwrap_or_default(),
                from_address: self.from_address,
                has_credential: self.has_credential.unwrap_or_default(),
                id: self.id,
                identity: self.identity,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                messages_per_second: self.messages_per_second.unwrap_or_default(),
                platform: self.platform,
                role_arn: self.role_arn,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl EmailChannelResponse {
    /// Creates a new builder-style object to manufacture [`EmailChannelResponse`](crate::model::EmailChannelResponse)
    pub fn builder() -> crate::model::email_channel_response::Builder {
        crate::model::email_channel_response::Builder::default()
    }
}

/// <p>Specifies the status and settings of the email channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EmailChannelRequest {
    /// <p>The <a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_ConfigurationSet.html">Amazon SES configuration set</a> that you want to apply to messages that you send through the channel.</p>
    pub configuration_set: std::option::Option<std::string::String>,
    /// <p>Specifies whether to enable the email channel for the application.</p>
    pub enabled: bool,
    /// <p>The verified email address that you want to send email from when you send email through the channel.</p>
    pub from_address: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that you want to use when you send email through the channel.</p>
    pub identity: std::option::Option<std::string::String>,
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that you want Amazon Pinpoint to use when it submits email-related event data for the channel.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EmailChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EmailChannelRequest");
        formatter.field("configuration_set", &self.configuration_set);
        formatter.field("enabled", &self.enabled);
        formatter.field("from_address", &self.from_address);
        formatter.field("identity", &self.identity);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`EmailChannelRequest`](crate::model::EmailChannelRequest)
pub mod email_channel_request {
    /// A builder for [`EmailChannelRequest`](crate::model::EmailChannelRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) configuration_set: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) from_address: std::option::Option<std::string::String>,
        pub(crate) identity: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The <a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_ConfigurationSet.html">Amazon SES configuration set</a> that you want to apply to messages that you send through the channel.</p>
        pub fn configuration_set(mut self, input: impl Into<std::string::String>) -> Self {
            self.configuration_set = Some(input.into());
            self
        }
        /// <p>The <a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_ConfigurationSet.html">Amazon SES configuration set</a> that you want to apply to messages that you send through the channel.</p>
        pub fn set_configuration_set(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.configuration_set = input;
            self
        }
        /// <p>Specifies whether to enable the email channel for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether to enable the email channel for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The verified email address that you want to send email from when you send email through the channel.</p>
        pub fn from_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_address = Some(input.into());
            self
        }
        /// <p>The verified email address that you want to send email from when you send email through the channel.</p>
        pub fn set_from_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from_address = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that you want to use when you send email through the channel.</p>
        pub fn identity(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that you want to use when you send email through the channel.</p>
        pub fn set_identity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identity = input;
            self
        }
        /// <p>The ARN of the AWS Identity and Access Management (IAM) role that you want Amazon Pinpoint to use when it submits email-related event data for the channel.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the AWS Identity and Access Management (IAM) role that you want Amazon Pinpoint to use when it submits email-related event data for the channel.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`EmailChannelRequest`](crate::model::EmailChannelRequest)
        pub fn build(self) -> crate::model::EmailChannelRequest {
            crate::model::EmailChannelRequest {
                configuration_set: self.configuration_set,
                enabled: self.enabled.unwrap_or_default(),
                from_address: self.from_address,
                identity: self.identity,
                role_arn: self.role_arn,
            }
        }
    }
}
impl EmailChannelRequest {
    /// Creates a new builder-style object to manufacture [`EmailChannelRequest`](crate::model::EmailChannelRequest)
    pub fn builder() -> crate::model::email_channel_request::Builder {
        crate::model::email_channel_request::Builder::default()
    }
}

/// <p>Provides information about the status, configuration, and other settings for a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignResponse {
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    pub additional_treatments: std::option::Option<std::vec::Vec<crate::model::TreatmentResource>>,
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    pub custom_delivery_configuration:
        std::option::Option<crate::model::CustomDeliveryConfiguration>,
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    pub default_state: std::option::Option<crate::model::CampaignState>,
    /// <p>The custom description of the campaign.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub holdout_percent: i32,
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub hook: std::option::Option<crate::model::CampaignHook>,
    /// <p>The unique identifier for the campaign.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub is_paused: bool,
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The messaging limits for the campaign.</p>
    pub limits: std::option::Option<crate::model::CampaignLimits>,
    /// <p>The message configuration settings for the campaign.</p>
    pub message_configuration: std::option::Option<crate::model::MessageConfiguration>,
    /// <p>The name of the campaign.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The schedule settings for the campaign.</p>
    pub schedule: std::option::Option<crate::model::Schedule>,
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    pub segment_id: std::option::Option<std::string::String>,
    /// <p>The version number of the segment that's associated with the campaign.</p>
    pub segment_version: i32,
    /// <p>The current status of the campaign.</p>
    pub state: std::option::Option<crate::model::CampaignState>,
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The message template that’s used for the campaign.</p>
    pub template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
    /// <p>The custom description of the default treatment for the campaign.</p>
    pub treatment_description: std::option::Option<std::string::String>,
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub treatment_name: std::option::Option<std::string::String>,
    /// <p>The version number of the campaign.</p>
    pub version: i32,
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub priority: i32,
}
impl std::fmt::Debug for CampaignResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignResponse");
        formatter.field("additional_treatments", &self.additional_treatments);
        formatter.field("application_id", &self.application_id);
        formatter.field("arn", &self.arn);
        formatter.field("creation_date", &self.creation_date);
        formatter.field(
            "custom_delivery_configuration",
            &self.custom_delivery_configuration,
        );
        formatter.field("default_state", &self.default_state);
        formatter.field("description", &self.description);
        formatter.field("holdout_percent", &self.holdout_percent);
        formatter.field("hook", &self.hook);
        formatter.field("id", &self.id);
        formatter.field("is_paused", &self.is_paused);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("limits", &self.limits);
        formatter.field("message_configuration", &self.message_configuration);
        formatter.field("name", &self.name);
        formatter.field("schedule", &self.schedule);
        formatter.field("segment_id", &self.segment_id);
        formatter.field("segment_version", &self.segment_version);
        formatter.field("state", &self.state);
        formatter.field("tags", &self.tags);
        formatter.field("template_configuration", &self.template_configuration);
        formatter.field("treatment_description", &self.treatment_description);
        formatter.field("treatment_name", &self.treatment_name);
        formatter.field("version", &self.version);
        formatter.field("priority", &self.priority);
        formatter.finish()
    }
}
/// See [`CampaignResponse`](crate::model::CampaignResponse)
pub mod campaign_response {
    /// A builder for [`CampaignResponse`](crate::model::CampaignResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) additional_treatments:
            std::option::Option<std::vec::Vec<crate::model::TreatmentResource>>,
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) custom_delivery_configuration:
            std::option::Option<crate::model::CustomDeliveryConfiguration>,
        pub(crate) default_state: std::option::Option<crate::model::CampaignState>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) holdout_percent: std::option::Option<i32>,
        pub(crate) hook: std::option::Option<crate::model::CampaignHook>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_paused: std::option::Option<bool>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) limits: std::option::Option<crate::model::CampaignLimits>,
        pub(crate) message_configuration: std::option::Option<crate::model::MessageConfiguration>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) schedule: std::option::Option<crate::model::Schedule>,
        pub(crate) segment_id: std::option::Option<std::string::String>,
        pub(crate) segment_version: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::CampaignState>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
        pub(crate) treatment_description: std::option::Option<std::string::String>,
        pub(crate) treatment_name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
        pub(crate) priority: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `additional_treatments`.
        ///
        /// To override the contents of this collection use [`set_additional_treatments`](Self::set_additional_treatments).
        ///
        /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
        pub fn additional_treatments(
            mut self,
            input: impl Into<crate::model::TreatmentResource>,
        ) -> Self {
            let mut v = self.additional_treatments.unwrap_or_default();
            v.push(input.into());
            self.additional_treatments = Some(v);
            self
        }
        /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
        pub fn set_additional_treatments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TreatmentResource>>,
        ) -> Self {
            self.additional_treatments = input;
            self
        }
        /// <p>The unique identifier for the application that the campaign applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the campaign applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
        pub fn custom_delivery_configuration(
            mut self,
            input: crate::model::CustomDeliveryConfiguration,
        ) -> Self {
            self.custom_delivery_configuration = Some(input);
            self
        }
        /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
        pub fn set_custom_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::CustomDeliveryConfiguration>,
        ) -> Self {
            self.custom_delivery_configuration = input;
            self
        }
        /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
        pub fn default_state(mut self, input: crate::model::CampaignState) -> Self {
            self.default_state = Some(input);
            self
        }
        /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
        pub fn set_default_state(
            mut self,
            input: std::option::Option<crate::model::CampaignState>,
        ) -> Self {
            self.default_state = input;
            self
        }
        /// <p>The custom description of the campaign.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The custom description of the campaign.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
        pub fn holdout_percent(mut self, input: i32) -> Self {
            self.holdout_percent = Some(input);
            self
        }
        /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
        pub fn set_holdout_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.holdout_percent = input;
            self
        }
        /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
        pub fn hook(mut self, input: crate::model::CampaignHook) -> Self {
            self.hook = Some(input);
            self
        }
        /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
        pub fn set_hook(mut self, input: std::option::Option<crate::model::CampaignHook>) -> Self {
            self.hook = input;
            self
        }
        /// <p>The unique identifier for the campaign.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the campaign.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
        pub fn is_paused(mut self, input: bool) -> Self {
            self.is_paused = Some(input);
            self
        }
        /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
        pub fn set_is_paused(mut self, input: std::option::Option<bool>) -> Self {
            self.is_paused = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The messaging limits for the campaign.</p>
        pub fn limits(mut self, input: crate::model::CampaignLimits) -> Self {
            self.limits = Some(input);
            self
        }
        /// <p>The messaging limits for the campaign.</p>
        pub fn set_limits(
            mut self,
            input: std::option::Option<crate::model::CampaignLimits>,
        ) -> Self {
            self.limits = input;
            self
        }
        /// <p>The message configuration settings for the campaign.</p>
        pub fn message_configuration(mut self, input: crate::model::MessageConfiguration) -> Self {
            self.message_configuration = Some(input);
            self
        }
        /// <p>The message configuration settings for the campaign.</p>
        pub fn set_message_configuration(
            mut self,
            input: std::option::Option<crate::model::MessageConfiguration>,
        ) -> Self {
            self.message_configuration = input;
            self
        }
        /// <p>The name of the campaign.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the campaign.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The schedule settings for the campaign.</p>
        pub fn schedule(mut self, input: crate::model::Schedule) -> Self {
            self.schedule = Some(input);
            self
        }
        /// <p>The schedule settings for the campaign.</p>
        pub fn set_schedule(mut self, input: std::option::Option<crate::model::Schedule>) -> Self {
            self.schedule = input;
            self
        }
        /// <p>The unique identifier for the segment that's associated with the campaign.</p>
        pub fn segment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the segment that's associated with the campaign.</p>
        pub fn set_segment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_id = input;
            self
        }
        /// <p>The version number of the segment that's associated with the campaign.</p>
        pub fn segment_version(mut self, input: i32) -> Self {
            self.segment_version = Some(input);
            self
        }
        /// <p>The version number of the segment that's associated with the campaign.</p>
        pub fn set_segment_version(mut self, input: std::option::Option<i32>) -> Self {
            self.segment_version = input;
            self
        }
        /// <p>The current status of the campaign.</p>
        pub fn state(mut self, input: crate::model::CampaignState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current status of the campaign.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::CampaignState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The message template that’s used for the campaign.</p>
        pub fn template_configuration(
            mut self,
            input: crate::model::TemplateConfiguration,
        ) -> Self {
            self.template_configuration = Some(input);
            self
        }
        /// <p>The message template that’s used for the campaign.</p>
        pub fn set_template_configuration(
            mut self,
            input: std::option::Option<crate::model::TemplateConfiguration>,
        ) -> Self {
            self.template_configuration = input;
            self
        }
        /// <p>The custom description of the default treatment for the campaign.</p>
        pub fn treatment_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.treatment_description = Some(input.into());
            self
        }
        /// <p>The custom description of the default treatment for the campaign.</p>
        pub fn set_treatment_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.treatment_description = input;
            self
        }
        /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
        pub fn treatment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.treatment_name = Some(input.into());
            self
        }
        /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
        pub fn set_treatment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.treatment_name = input;
            self
        }
        /// <p>The version number of the campaign.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The version number of the campaign.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignResponse`](crate::model::CampaignResponse)
        pub fn build(self) -> crate::model::CampaignResponse {
            crate::model::CampaignResponse {
                additional_treatments: self.additional_treatments,
                application_id: self.application_id,
                arn: self.arn,
                creation_date: self.creation_date,
                custom_delivery_configuration: self.custom_delivery_configuration,
                default_state: self.default_state,
                description: self.description,
                holdout_percent: self.holdout_percent.unwrap_or_default(),
                hook: self.hook,
                id: self.id,
                is_paused: self.is_paused.unwrap_or_default(),
                last_modified_date: self.last_modified_date,
                limits: self.limits,
                message_configuration: self.message_configuration,
                name: self.name,
                schedule: self.schedule,
                segment_id: self.segment_id,
                segment_version: self.segment_version.unwrap_or_default(),
                state: self.state,
                tags: self.tags,
                template_configuration: self.template_configuration,
                treatment_description: self.treatment_description,
                treatment_name: self.treatment_name,
                version: self.version.unwrap_or_default(),
                priority: self.priority.unwrap_or_default(),
            }
        }
    }
}
impl CampaignResponse {
    /// Creates a new builder-style object to manufacture [`CampaignResponse`](crate::model::CampaignResponse)
    pub fn builder() -> crate::model::campaign_response::Builder {
        crate::model::campaign_response::Builder::default()
    }
}

/// <p>Specifies the message template to use for the message, for each type of channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TemplateConfiguration {
    /// <p>The email template to use for the message.</p>
    pub email_template: std::option::Option<crate::model::Template>,
    /// <p>The push notification template to use for the message.</p>
    pub push_template: std::option::Option<crate::model::Template>,
    /// <p>The SMS template to use for the message.</p>
    pub sms_template: std::option::Option<crate::model::Template>,
    /// <p>The voice template to use for the message. This object isn't supported for campaigns.</p>
    pub voice_template: std::option::Option<crate::model::Template>,
}
impl std::fmt::Debug for TemplateConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TemplateConfiguration");
        formatter.field("email_template", &self.email_template);
        formatter.field("push_template", &self.push_template);
        formatter.field("sms_template", &self.sms_template);
        formatter.field("voice_template", &self.voice_template);
        formatter.finish()
    }
}
/// See [`TemplateConfiguration`](crate::model::TemplateConfiguration)
pub mod template_configuration {
    /// A builder for [`TemplateConfiguration`](crate::model::TemplateConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) email_template: std::option::Option<crate::model::Template>,
        pub(crate) push_template: std::option::Option<crate::model::Template>,
        pub(crate) sms_template: std::option::Option<crate::model::Template>,
        pub(crate) voice_template: std::option::Option<crate::model::Template>,
    }
    impl Builder {
        /// <p>The email template to use for the message.</p>
        pub fn email_template(mut self, input: crate::model::Template) -> Self {
            self.email_template = Some(input);
            self
        }
        /// <p>The email template to use for the message.</p>
        pub fn set_email_template(
            mut self,
            input: std::option::Option<crate::model::Template>,
        ) -> Self {
            self.email_template = input;
            self
        }
        /// <p>The push notification template to use for the message.</p>
        pub fn push_template(mut self, input: crate::model::Template) -> Self {
            self.push_template = Some(input);
            self
        }
        /// <p>The push notification template to use for the message.</p>
        pub fn set_push_template(
            mut self,
            input: std::option::Option<crate::model::Template>,
        ) -> Self {
            self.push_template = input;
            self
        }
        /// <p>The SMS template to use for the message.</p>
        pub fn sms_template(mut self, input: crate::model::Template) -> Self {
            self.sms_template = Some(input);
            self
        }
        /// <p>The SMS template to use for the message.</p>
        pub fn set_sms_template(
            mut self,
            input: std::option::Option<crate::model::Template>,
        ) -> Self {
            self.sms_template = input;
            self
        }
        /// <p>The voice template to use for the message. This object isn't supported for campaigns.</p>
        pub fn voice_template(mut self, input: crate::model::Template) -> Self {
            self.voice_template = Some(input);
            self
        }
        /// <p>The voice template to use for the message. This object isn't supported for campaigns.</p>
        pub fn set_voice_template(
            mut self,
            input: std::option::Option<crate::model::Template>,
        ) -> Self {
            self.voice_template = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateConfiguration`](crate::model::TemplateConfiguration)
        pub fn build(self) -> crate::model::TemplateConfiguration {
            crate::model::TemplateConfiguration {
                email_template: self.email_template,
                push_template: self.push_template,
                sms_template: self.sms_template,
                voice_template: self.voice_template,
            }
        }
    }
}
impl TemplateConfiguration {
    /// Creates a new builder-style object to manufacture [`TemplateConfiguration`](crate::model::TemplateConfiguration)
    pub fn builder() -> crate::model::template_configuration::Builder {
        crate::model::template_configuration::Builder::default()
    }
}

/// <p>Specifies the name and version of the message template to use for the message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Template {
    /// <p>The name of the message template to use for the message. If specified, this value must match the name of an existing message template.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the version of the message template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Template {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Template");
        formatter.field("name", &self.name);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`Template`](crate::model::Template)
pub mod template {
    /// A builder for [`Template`](crate::model::Template)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the message template to use for the message. If specified, this value must match the name of an existing message template.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the message template to use for the message. If specified, this value must match the name of an existing message template.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique identifier for the version of the message template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The unique identifier for the version of the message template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`Template`](crate::model::Template)
        pub fn build(self) -> crate::model::Template {
            crate::model::Template {
                name: self.name,
                version: self.version,
            }
        }
    }
}
impl Template {
    /// Creates a new builder-style object to manufacture [`Template`](crate::model::Template)
    pub fn builder() -> crate::model::template::Builder {
        crate::model::template::Builder::default()
    }
}

/// <p>Provides information about the status of a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignState {
    /// <p>The current status of the campaign, or the current status of a treatment that belongs to an A/B test campaign.</p> <p>If a campaign uses A/B testing, the campaign has a status of COMPLETED only if all campaign treatments have a status of COMPLETED. If you delete the segment that's associated with a campaign, the campaign fails and has a status of DELETED.</p>
    pub campaign_status: std::option::Option<crate::model::CampaignStatus>,
}
impl std::fmt::Debug for CampaignState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignState");
        formatter.field("campaign_status", &self.campaign_status);
        formatter.finish()
    }
}
/// See [`CampaignState`](crate::model::CampaignState)
pub mod campaign_state {
    /// A builder for [`CampaignState`](crate::model::CampaignState)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) campaign_status: std::option::Option<crate::model::CampaignStatus>,
    }
    impl Builder {
        /// <p>The current status of the campaign, or the current status of a treatment that belongs to an A/B test campaign.</p> <p>If a campaign uses A/B testing, the campaign has a status of COMPLETED only if all campaign treatments have a status of COMPLETED. If you delete the segment that's associated with a campaign, the campaign fails and has a status of DELETED.</p>
        pub fn campaign_status(mut self, input: crate::model::CampaignStatus) -> Self {
            self.campaign_status = Some(input);
            self
        }
        /// <p>The current status of the campaign, or the current status of a treatment that belongs to an A/B test campaign.</p> <p>If a campaign uses A/B testing, the campaign has a status of COMPLETED only if all campaign treatments have a status of COMPLETED. If you delete the segment that's associated with a campaign, the campaign fails and has a status of DELETED.</p>
        pub fn set_campaign_status(
            mut self,
            input: std::option::Option<crate::model::CampaignStatus>,
        ) -> Self {
            self.campaign_status = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignState`](crate::model::CampaignState)
        pub fn build(self) -> crate::model::CampaignState {
            crate::model::CampaignState {
                campaign_status: self.campaign_status,
            }
        }
    }
}
impl CampaignState {
    /// Creates a new builder-style object to manufacture [`CampaignState`](crate::model::CampaignState)
    pub fn builder() -> crate::model::campaign_state::Builder {
        crate::model::campaign_state::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CampaignStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    Executing,
    #[allow(missing_docs)] // documentation missing in model
    Invalid,
    #[allow(missing_docs)] // documentation missing in model
    Paused,
    #[allow(missing_docs)] // documentation missing in model
    PendingNextRun,
    #[allow(missing_docs)] // documentation missing in model
    Scheduled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for CampaignStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => CampaignStatus::Completed,
            "DELETED" => CampaignStatus::Deleted,
            "EXECUTING" => CampaignStatus::Executing,
            "INVALID" => CampaignStatus::Invalid,
            "PAUSED" => CampaignStatus::Paused,
            "PENDING_NEXT_RUN" => CampaignStatus::PendingNextRun,
            "SCHEDULED" => CampaignStatus::Scheduled,
            other => CampaignStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for CampaignStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CampaignStatus::from(s))
    }
}
impl CampaignStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CampaignStatus::Completed => "COMPLETED",
            CampaignStatus::Deleted => "DELETED",
            CampaignStatus::Executing => "EXECUTING",
            CampaignStatus::Invalid => "INVALID",
            CampaignStatus::Paused => "PAUSED",
            CampaignStatus::PendingNextRun => "PENDING_NEXT_RUN",
            CampaignStatus::Scheduled => "SCHEDULED",
            CampaignStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "DELETED",
            "EXECUTING",
            "INVALID",
            "PAUSED",
            "PENDING_NEXT_RUN",
            "SCHEDULED",
        ]
    }
}
impl AsRef<str> for CampaignStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the schedule settings for a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Schedule {
    /// <p>The scheduled time, in ISO 8601 format, when the campaign ended or will end.</p>
    pub end_time: std::option::Option<std::string::String>,
    /// <p>The type of event that causes the campaign to be sent, if the value of the Frequency property is EVENT.</p>
    pub event_filter: std::option::Option<crate::model::CampaignEventFilter>,
    /// <p>Specifies how often the campaign is sent or whether the campaign is sent in response to a specific event.</p>
    pub frequency: std::option::Option<crate::model::Frequency>,
    /// <p>Specifies whether the start and end times for the campaign schedule use each recipient's local time. To base the schedule on each recipient's local time, set this value to true.</p>
    pub is_local_time: bool,
    /// <p>The default quiet time for the campaign. Quiet time is a specific time range when a campaign doesn't send messages to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the campaign.</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the campaign.</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from the campaign, even if quiet time is enabled.</p>
    pub quiet_time: std::option::Option<crate::model::QuietTime>,
    /// <p>The scheduled time when the campaign began or will begin. Valid values are: IMMEDIATE, to start the campaign immediately; or, a specific time in ISO 8601 format.</p>
    pub start_time: std::option::Option<std::string::String>,
    /// <p>The starting UTC offset for the campaign schedule, if the value of the IsLocalTime property is true. Valid values are: UTC, UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05,
    /// UTC+05:30, UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+09, UTC+09:30,
    /// UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+13, UTC-02, UTC-03, UTC-04, UTC-05, UTC-06,
    /// UTC-07, UTC-08, UTC-09, UTC-10, and UTC-11.</p>
    pub timezone: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Schedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Schedule");
        formatter.field("end_time", &self.end_time);
        formatter.field("event_filter", &self.event_filter);
        formatter.field("frequency", &self.frequency);
        formatter.field("is_local_time", &self.is_local_time);
        formatter.field("quiet_time", &self.quiet_time);
        formatter.field("start_time", &self.start_time);
        formatter.field("timezone", &self.timezone);
        formatter.finish()
    }
}
/// See [`Schedule`](crate::model::Schedule)
pub mod schedule {
    /// A builder for [`Schedule`](crate::model::Schedule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) end_time: std::option::Option<std::string::String>,
        pub(crate) event_filter: std::option::Option<crate::model::CampaignEventFilter>,
        pub(crate) frequency: std::option::Option<crate::model::Frequency>,
        pub(crate) is_local_time: std::option::Option<bool>,
        pub(crate) quiet_time: std::option::Option<crate::model::QuietTime>,
        pub(crate) start_time: std::option::Option<std::string::String>,
        pub(crate) timezone: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The scheduled time, in ISO 8601 format, when the campaign ended or will end.</p>
        pub fn end_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_time = Some(input.into());
            self
        }
        /// <p>The scheduled time, in ISO 8601 format, when the campaign ended or will end.</p>
        pub fn set_end_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The type of event that causes the campaign to be sent, if the value of the Frequency property is EVENT.</p>
        pub fn event_filter(mut self, input: crate::model::CampaignEventFilter) -> Self {
            self.event_filter = Some(input);
            self
        }
        /// <p>The type of event that causes the campaign to be sent, if the value of the Frequency property is EVENT.</p>
        pub fn set_event_filter(
            mut self,
            input: std::option::Option<crate::model::CampaignEventFilter>,
        ) -> Self {
            self.event_filter = input;
            self
        }
        /// <p>Specifies how often the campaign is sent or whether the campaign is sent in response to a specific event.</p>
        pub fn frequency(mut self, input: crate::model::Frequency) -> Self {
            self.frequency = Some(input);
            self
        }
        /// <p>Specifies how often the campaign is sent or whether the campaign is sent in response to a specific event.</p>
        pub fn set_frequency(
            mut self,
            input: std::option::Option<crate::model::Frequency>,
        ) -> Self {
            self.frequency = input;
            self
        }
        /// <p>Specifies whether the start and end times for the campaign schedule use each recipient's local time. To base the schedule on each recipient's local time, set this value to true.</p>
        pub fn is_local_time(mut self, input: bool) -> Self {
            self.is_local_time = Some(input);
            self
        }
        /// <p>Specifies whether the start and end times for the campaign schedule use each recipient's local time. To base the schedule on each recipient's local time, set this value to true.</p>
        pub fn set_is_local_time(mut self, input: std::option::Option<bool>) -> Self {
            self.is_local_time = input;
            self
        }
        /// <p>The default quiet time for the campaign. Quiet time is a specific time range when a campaign doesn't send messages to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the campaign.</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the campaign.</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from the campaign, even if quiet time is enabled.</p>
        pub fn quiet_time(mut self, input: crate::model::QuietTime) -> Self {
            self.quiet_time = Some(input);
            self
        }
        /// <p>The default quiet time for the campaign. Quiet time is a specific time range when a campaign doesn't send messages to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the campaign.</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the campaign.</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from the campaign, even if quiet time is enabled.</p>
        pub fn set_quiet_time(
            mut self,
            input: std::option::Option<crate::model::QuietTime>,
        ) -> Self {
            self.quiet_time = input;
            self
        }
        /// <p>The scheduled time when the campaign began or will begin. Valid values are: IMMEDIATE, to start the campaign immediately; or, a specific time in ISO 8601 format.</p>
        pub fn start_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_time = Some(input.into());
            self
        }
        /// <p>The scheduled time when the campaign began or will begin. Valid values are: IMMEDIATE, to start the campaign immediately; or, a specific time in ISO 8601 format.</p>
        pub fn set_start_time(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The starting UTC offset for the campaign schedule, if the value of the IsLocalTime property is true. Valid values are: UTC, UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05,
        /// UTC+05:30, UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+09, UTC+09:30,
        /// UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+13, UTC-02, UTC-03, UTC-04, UTC-05, UTC-06,
        /// UTC-07, UTC-08, UTC-09, UTC-10, and UTC-11.</p>
        pub fn timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.timezone = Some(input.into());
            self
        }
        /// <p>The starting UTC offset for the campaign schedule, if the value of the IsLocalTime property is true. Valid values are: UTC, UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05,
        /// UTC+05:30, UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+09, UTC+09:30,
        /// UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+13, UTC-02, UTC-03, UTC-04, UTC-05, UTC-06,
        /// UTC-07, UTC-08, UTC-09, UTC-10, and UTC-11.</p>
        pub fn set_timezone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timezone = input;
            self
        }
        /// Consumes the builder and constructs a [`Schedule`](crate::model::Schedule)
        pub fn build(self) -> crate::model::Schedule {
            crate::model::Schedule {
                end_time: self.end_time,
                event_filter: self.event_filter,
                frequency: self.frequency,
                is_local_time: self.is_local_time.unwrap_or_default(),
                quiet_time: self.quiet_time,
                start_time: self.start_time,
                timezone: self.timezone,
            }
        }
    }
}
impl Schedule {
    /// Creates a new builder-style object to manufacture [`Schedule`](crate::model::Schedule)
    pub fn builder() -> crate::model::schedule::Builder {
        crate::model::schedule::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Frequency {
    #[allow(missing_docs)] // documentation missing in model
    Daily,
    #[allow(missing_docs)] // documentation missing in model
    Event,
    #[allow(missing_docs)] // documentation missing in model
    Hourly,
    #[allow(missing_docs)] // documentation missing in model
    InAppEvent,
    #[allow(missing_docs)] // documentation missing in model
    Monthly,
    #[allow(missing_docs)] // documentation missing in model
    Once,
    #[allow(missing_docs)] // documentation missing in model
    Weekly,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Frequency {
    fn from(s: &str) -> Self {
        match s {
            "DAILY" => Frequency::Daily,
            "EVENT" => Frequency::Event,
            "HOURLY" => Frequency::Hourly,
            "IN_APP_EVENT" => Frequency::InAppEvent,
            "MONTHLY" => Frequency::Monthly,
            "ONCE" => Frequency::Once,
            "WEEKLY" => Frequency::Weekly,
            other => Frequency::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Frequency {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Frequency::from(s))
    }
}
impl Frequency {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Frequency::Daily => "DAILY",
            Frequency::Event => "EVENT",
            Frequency::Hourly => "HOURLY",
            Frequency::InAppEvent => "IN_APP_EVENT",
            Frequency::Monthly => "MONTHLY",
            Frequency::Once => "ONCE",
            Frequency::Weekly => "WEEKLY",
            Frequency::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "DAILY",
            "EVENT",
            "HOURLY",
            "IN_APP_EVENT",
            "MONTHLY",
            "ONCE",
            "WEEKLY",
        ]
    }
}
impl AsRef<str> for Frequency {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the settings for events that cause a campaign to be sent.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignEventFilter {
    /// <p>The dimension settings of the event filter for the campaign.</p>
    pub dimensions: std::option::Option<crate::model::EventDimensions>,
    /// <p>The type of event that causes the campaign to be sent. Valid values are: SYSTEM, sends the campaign when a system event occurs; and, ENDPOINT, sends the campaign when an endpoint event (<link  linkend="apps-application-id-events">Events</link> resource) occurs.</p>
    pub filter_type: std::option::Option<crate::model::FilterType>,
}
impl std::fmt::Debug for CampaignEventFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignEventFilter");
        formatter.field("dimensions", &self.dimensions);
        formatter.field("filter_type", &self.filter_type);
        formatter.finish()
    }
}
/// See [`CampaignEventFilter`](crate::model::CampaignEventFilter)
pub mod campaign_event_filter {
    /// A builder for [`CampaignEventFilter`](crate::model::CampaignEventFilter)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dimensions: std::option::Option<crate::model::EventDimensions>,
        pub(crate) filter_type: std::option::Option<crate::model::FilterType>,
    }
    impl Builder {
        /// <p>The dimension settings of the event filter for the campaign.</p>
        pub fn dimensions(mut self, input: crate::model::EventDimensions) -> Self {
            self.dimensions = Some(input);
            self
        }
        /// <p>The dimension settings of the event filter for the campaign.</p>
        pub fn set_dimensions(
            mut self,
            input: std::option::Option<crate::model::EventDimensions>,
        ) -> Self {
            self.dimensions = input;
            self
        }
        /// <p>The type of event that causes the campaign to be sent. Valid values are: SYSTEM, sends the campaign when a system event occurs; and, ENDPOINT, sends the campaign when an endpoint event (<link  linkend="apps-application-id-events">Events</link> resource) occurs.</p>
        pub fn filter_type(mut self, input: crate::model::FilterType) -> Self {
            self.filter_type = Some(input);
            self
        }
        /// <p>The type of event that causes the campaign to be sent. Valid values are: SYSTEM, sends the campaign when a system event occurs; and, ENDPOINT, sends the campaign when an endpoint event (<link  linkend="apps-application-id-events">Events</link> resource) occurs.</p>
        pub fn set_filter_type(
            mut self,
            input: std::option::Option<crate::model::FilterType>,
        ) -> Self {
            self.filter_type = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignEventFilter`](crate::model::CampaignEventFilter)
        pub fn build(self) -> crate::model::CampaignEventFilter {
            crate::model::CampaignEventFilter {
                dimensions: self.dimensions,
                filter_type: self.filter_type,
            }
        }
    }
}
impl CampaignEventFilter {
    /// Creates a new builder-style object to manufacture [`CampaignEventFilter`](crate::model::CampaignEventFilter)
    pub fn builder() -> crate::model::campaign_event_filter::Builder {
        crate::model::campaign_event_filter::Builder::default()
    }
}

/// <p>Specifies the message configuration settings for a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MessageConfiguration {
    /// <p>The message that the campaign sends through the ADM (Amazon Device Messaging) channel. If specified, this message overrides the default message.</p>
    pub adm_message: std::option::Option<crate::model::Message>,
    /// <p>The message that the campaign sends through the APNs (Apple Push Notification service) channel. If specified, this message overrides the default message.</p>
    pub apns_message: std::option::Option<crate::model::Message>,
    /// <p>The message that the campaign sends through the Baidu (Baidu Cloud Push) channel. If specified, this message overrides the default message.</p>
    pub baidu_message: std::option::Option<crate::model::Message>,
    /// <p>The message that the campaign sends through a custom channel, as specified by the delivery configuration (CustomDeliveryConfiguration) settings for the campaign. If specified, this message overrides the default message.</p>
    pub custom_message: std::option::Option<crate::model::CampaignCustomMessage>,
    /// <p>The default message that the campaign sends through all the channels that are configured for the campaign.</p>
    pub default_message: std::option::Option<crate::model::Message>,
    /// <p>The message that the campaign sends through the email channel. If specified, this message overrides the default message.</p>
    pub email_message: std::option::Option<crate::model::CampaignEmailMessage>,
    /// <p>The message that the campaign sends through the GCM channel, which enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. If specified, this message overrides the default message.</p>
    pub gcm_message: std::option::Option<crate::model::Message>,
    /// <p>The message that the campaign sends through the SMS channel. If specified, this message overrides the default message.</p>
    pub sms_message: std::option::Option<crate::model::CampaignSmsMessage>,
    /// <p>The in-app message configuration.</p>
    pub in_app_message: std::option::Option<crate::model::CampaignInAppMessage>,
}
impl std::fmt::Debug for MessageConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MessageConfiguration");
        formatter.field("adm_message", &self.adm_message);
        formatter.field("apns_message", &self.apns_message);
        formatter.field("baidu_message", &self.baidu_message);
        formatter.field("custom_message", &self.custom_message);
        formatter.field("default_message", &self.default_message);
        formatter.field("email_message", &self.email_message);
        formatter.field("gcm_message", &self.gcm_message);
        formatter.field("sms_message", &self.sms_message);
        formatter.field("in_app_message", &self.in_app_message);
        formatter.finish()
    }
}
/// See [`MessageConfiguration`](crate::model::MessageConfiguration)
pub mod message_configuration {
    /// A builder for [`MessageConfiguration`](crate::model::MessageConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) adm_message: std::option::Option<crate::model::Message>,
        pub(crate) apns_message: std::option::Option<crate::model::Message>,
        pub(crate) baidu_message: std::option::Option<crate::model::Message>,
        pub(crate) custom_message: std::option::Option<crate::model::CampaignCustomMessage>,
        pub(crate) default_message: std::option::Option<crate::model::Message>,
        pub(crate) email_message: std::option::Option<crate::model::CampaignEmailMessage>,
        pub(crate) gcm_message: std::option::Option<crate::model::Message>,
        pub(crate) sms_message: std::option::Option<crate::model::CampaignSmsMessage>,
        pub(crate) in_app_message: std::option::Option<crate::model::CampaignInAppMessage>,
    }
    impl Builder {
        /// <p>The message that the campaign sends through the ADM (Amazon Device Messaging) channel. If specified, this message overrides the default message.</p>
        pub fn adm_message(mut self, input: crate::model::Message) -> Self {
            self.adm_message = Some(input);
            self
        }
        /// <p>The message that the campaign sends through the ADM (Amazon Device Messaging) channel. If specified, this message overrides the default message.</p>
        pub fn set_adm_message(
            mut self,
            input: std::option::Option<crate::model::Message>,
        ) -> Self {
            self.adm_message = input;
            self
        }
        /// <p>The message that the campaign sends through the APNs (Apple Push Notification service) channel. If specified, this message overrides the default message.</p>
        pub fn apns_message(mut self, input: crate::model::Message) -> Self {
            self.apns_message = Some(input);
            self
        }
        /// <p>The message that the campaign sends through the APNs (Apple Push Notification service) channel. If specified, this message overrides the default message.</p>
        pub fn set_apns_message(
            mut self,
            input: std::option::Option<crate::model::Message>,
        ) -> Self {
            self.apns_message = input;
            self
        }
        /// <p>The message that the campaign sends through the Baidu (Baidu Cloud Push) channel. If specified, this message overrides the default message.</p>
        pub fn baidu_message(mut self, input: crate::model::Message) -> Self {
            self.baidu_message = Some(input);
            self
        }
        /// <p>The message that the campaign sends through the Baidu (Baidu Cloud Push) channel. If specified, this message overrides the default message.</p>
        pub fn set_baidu_message(
            mut self,
            input: std::option::Option<crate::model::Message>,
        ) -> Self {
            self.baidu_message = input;
            self
        }
        /// <p>The message that the campaign sends through a custom channel, as specified by the delivery configuration (CustomDeliveryConfiguration) settings for the campaign. If specified, this message overrides the default message.</p>
        pub fn custom_message(mut self, input: crate::model::CampaignCustomMessage) -> Self {
            self.custom_message = Some(input);
            self
        }
        /// <p>The message that the campaign sends through a custom channel, as specified by the delivery configuration (CustomDeliveryConfiguration) settings for the campaign. If specified, this message overrides the default message.</p>
        pub fn set_custom_message(
            mut self,
            input: std::option::Option<crate::model::CampaignCustomMessage>,
        ) -> Self {
            self.custom_message = input;
            self
        }
        /// <p>The default message that the campaign sends through all the channels that are configured for the campaign.</p>
        pub fn default_message(mut self, input: crate::model::Message) -> Self {
            self.default_message = Some(input);
            self
        }
        /// <p>The default message that the campaign sends through all the channels that are configured for the campaign.</p>
        pub fn set_default_message(
            mut self,
            input: std::option::Option<crate::model::Message>,
        ) -> Self {
            self.default_message = input;
            self
        }
        /// <p>The message that the campaign sends through the email channel. If specified, this message overrides the default message.</p>
        pub fn email_message(mut self, input: crate::model::CampaignEmailMessage) -> Self {
            self.email_message = Some(input);
            self
        }
        /// <p>The message that the campaign sends through the email channel. If specified, this message overrides the default message.</p>
        pub fn set_email_message(
            mut self,
            input: std::option::Option<crate::model::CampaignEmailMessage>,
        ) -> Self {
            self.email_message = input;
            self
        }
        /// <p>The message that the campaign sends through the GCM channel, which enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. If specified, this message overrides the default message.</p>
        pub fn gcm_message(mut self, input: crate::model::Message) -> Self {
            self.gcm_message = Some(input);
            self
        }
        /// <p>The message that the campaign sends through the GCM channel, which enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. If specified, this message overrides the default message.</p>
        pub fn set_gcm_message(
            mut self,
            input: std::option::Option<crate::model::Message>,
        ) -> Self {
            self.gcm_message = input;
            self
        }
        /// <p>The message that the campaign sends through the SMS channel. If specified, this message overrides the default message.</p>
        pub fn sms_message(mut self, input: crate::model::CampaignSmsMessage) -> Self {
            self.sms_message = Some(input);
            self
        }
        /// <p>The message that the campaign sends through the SMS channel. If specified, this message overrides the default message.</p>
        pub fn set_sms_message(
            mut self,
            input: std::option::Option<crate::model::CampaignSmsMessage>,
        ) -> Self {
            self.sms_message = input;
            self
        }
        /// <p>The in-app message configuration.</p>
        pub fn in_app_message(mut self, input: crate::model::CampaignInAppMessage) -> Self {
            self.in_app_message = Some(input);
            self
        }
        /// <p>The in-app message configuration.</p>
        pub fn set_in_app_message(
            mut self,
            input: std::option::Option<crate::model::CampaignInAppMessage>,
        ) -> Self {
            self.in_app_message = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageConfiguration`](crate::model::MessageConfiguration)
        pub fn build(self) -> crate::model::MessageConfiguration {
            crate::model::MessageConfiguration {
                adm_message: self.adm_message,
                apns_message: self.apns_message,
                baidu_message: self.baidu_message,
                custom_message: self.custom_message,
                default_message: self.default_message,
                email_message: self.email_message,
                gcm_message: self.gcm_message,
                sms_message: self.sms_message,
                in_app_message: self.in_app_message,
            }
        }
    }
}
impl MessageConfiguration {
    /// Creates a new builder-style object to manufacture [`MessageConfiguration`](crate::model::MessageConfiguration)
    pub fn builder() -> crate::model::message_configuration::Builder {
        crate::model::message_configuration::Builder::default()
    }
}

/// <p>In-app message configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignInAppMessage {
    /// <p>The message body of the notification, the email body or the text message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>In-app message content.</p>
    pub content: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
    /// <p>Custom config to be sent to client.</p>
    pub custom_config:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>In-app message layout.</p>
    pub layout: std::option::Option<crate::model::Layout>,
}
impl std::fmt::Debug for CampaignInAppMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignInAppMessage");
        formatter.field("body", &self.body);
        formatter.field("content", &self.content);
        formatter.field("custom_config", &self.custom_config);
        formatter.field("layout", &self.layout);
        formatter.finish()
    }
}
/// See [`CampaignInAppMessage`](crate::model::CampaignInAppMessage)
pub mod campaign_in_app_message {
    /// A builder for [`CampaignInAppMessage`](crate::model::CampaignInAppMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
        pub(crate) custom_config: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) layout: std::option::Option<crate::model::Layout>,
    }
    impl Builder {
        /// <p>The message body of the notification, the email body or the text message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The message body of the notification, the email body or the text message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// Appends an item to `content`.
        ///
        /// To override the contents of this collection use [`set_content`](Self::set_content).
        ///
        /// <p>In-app message content.</p>
        pub fn content(mut self, input: impl Into<crate::model::InAppMessageContent>) -> Self {
            let mut v = self.content.unwrap_or_default();
            v.push(input.into());
            self.content = Some(v);
            self
        }
        /// <p>In-app message content.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
        ) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `custom_config`.
        ///
        /// To override the contents of this collection use [`set_custom_config`](Self::set_custom_config).
        ///
        /// <p>Custom config to be sent to client.</p>
        pub fn custom_config(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.custom_config.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.custom_config = Some(hash_map);
            self
        }
        /// <p>Custom config to be sent to client.</p>
        pub fn set_custom_config(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.custom_config = input;
            self
        }
        /// <p>In-app message layout.</p>
        pub fn layout(mut self, input: crate::model::Layout) -> Self {
            self.layout = Some(input);
            self
        }
        /// <p>In-app message layout.</p>
        pub fn set_layout(mut self, input: std::option::Option<crate::model::Layout>) -> Self {
            self.layout = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignInAppMessage`](crate::model::CampaignInAppMessage)
        pub fn build(self) -> crate::model::CampaignInAppMessage {
            crate::model::CampaignInAppMessage {
                body: self.body,
                content: self.content,
                custom_config: self.custom_config,
                layout: self.layout,
            }
        }
    }
}
impl CampaignInAppMessage {
    /// Creates a new builder-style object to manufacture [`CampaignInAppMessage`](crate::model::CampaignInAppMessage)
    pub fn builder() -> crate::model::campaign_in_app_message::Builder {
        crate::model::campaign_in_app_message::Builder::default()
    }
}

/// <p>Specifies the content and settings for an SMS message that's sent to recipients of a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignSmsMessage {
    /// <p>The body of the SMS message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
    pub message_type: std::option::Option<crate::model::MessageType>,
    /// <p>The long code to send the SMS message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code using an E.164 format to ensure prompt and accurate delivery of the message. For example, +12065550100.</p>
    pub origination_number: std::option::Option<std::string::String>,
    /// <p>The sender ID to display on recipients' devices when they receive the SMS message.</p>
    pub sender_id: std::option::Option<std::string::String>,
    /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
    pub template_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CampaignSmsMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignSmsMessage");
        formatter.field("body", &self.body);
        formatter.field("message_type", &self.message_type);
        formatter.field("origination_number", &self.origination_number);
        formatter.field("sender_id", &self.sender_id);
        formatter.field("entity_id", &self.entity_id);
        formatter.field("template_id", &self.template_id);
        formatter.finish()
    }
}
/// See [`CampaignSmsMessage`](crate::model::CampaignSmsMessage)
pub mod campaign_sms_message {
    /// A builder for [`CampaignSmsMessage`](crate::model::CampaignSmsMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) message_type: std::option::Option<crate::model::MessageType>,
        pub(crate) origination_number: std::option::Option<std::string::String>,
        pub(crate) sender_id: std::option::Option<std::string::String>,
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The body of the SMS message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The body of the SMS message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
        pub fn message_type(mut self, input: crate::model::MessageType) -> Self {
            self.message_type = Some(input);
            self
        }
        /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
        pub fn set_message_type(
            mut self,
            input: std::option::Option<crate::model::MessageType>,
        ) -> Self {
            self.message_type = input;
            self
        }
        /// <p>The long code to send the SMS message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code using an E.164 format to ensure prompt and accurate delivery of the message. For example, +12065550100.</p>
        pub fn origination_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.origination_number = Some(input.into());
            self
        }
        /// <p>The long code to send the SMS message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code using an E.164 format to ensure prompt and accurate delivery of the message. For example, +12065550100.</p>
        pub fn set_origination_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.origination_number = input;
            self
        }
        /// <p>The sender ID to display on recipients' devices when they receive the SMS message.</p>
        pub fn sender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sender_id = Some(input.into());
            self
        }
        /// <p>The sender ID to display on recipients' devices when they receive the SMS message.</p>
        pub fn set_sender_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sender_id = input;
            self
        }
        /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignSmsMessage`](crate::model::CampaignSmsMessage)
        pub fn build(self) -> crate::model::CampaignSmsMessage {
            crate::model::CampaignSmsMessage {
                body: self.body,
                message_type: self.message_type,
                origination_number: self.origination_number,
                sender_id: self.sender_id,
                entity_id: self.entity_id,
                template_id: self.template_id,
            }
        }
    }
}
impl CampaignSmsMessage {
    /// Creates a new builder-style object to manufacture [`CampaignSmsMessage`](crate::model::CampaignSmsMessage)
    pub fn builder() -> crate::model::campaign_sms_message::Builder {
        crate::model::campaign_sms_message::Builder::default()
    }
}

/// <p>Specifies the content and settings for a push notification that's sent to recipients of a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Message {
    /// <p>The action to occur if a recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of iOS and Android.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    pub action: std::option::Option<crate::model::Action>,
    /// <p>The body of the notification message. The maximum number of characters is 200.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The URL of the image to display as the push-notification icon, such as the icon for the app.</p>
    pub image_icon_url: std::option::Option<std::string::String>,
    /// <p>The URL of the image to display as the small, push-notification icon, such as a small version of the icon for the app.</p>
    pub image_small_icon_url: std::option::Option<std::string::String>,
    /// <p>The URL of an image to display in the push notification.</p>
    pub image_url: std::option::Option<std::string::String>,
    /// <p>The JSON payload to use for a silent push notification.</p>
    pub json_body: std::option::Option<std::string::String>,
    /// <p>The URL of the image or video to display in the push notification.</p>
    pub media_url: std::option::Option<std::string::String>,
    /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
    pub raw_content: std::option::Option<std::string::String>,
    /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration, displaying messages in an in-app message center, or supporting phone home functionality.</p>
    pub silent_push: bool,
    /// <p>The number of seconds that the push-notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.</p>
    pub time_to_live: i32,
    /// <p>The title to display above the notification message on a recipient's device.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Message {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Message");
        formatter.field("action", &self.action);
        formatter.field("body", &self.body);
        formatter.field("image_icon_url", &self.image_icon_url);
        formatter.field("image_small_icon_url", &self.image_small_icon_url);
        formatter.field("image_url", &self.image_url);
        formatter.field("json_body", &self.json_body);
        formatter.field("media_url", &self.media_url);
        formatter.field("raw_content", &self.raw_content);
        formatter.field("silent_push", &self.silent_push);
        formatter.field("time_to_live", &self.time_to_live);
        formatter.field("title", &self.title);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`Message`](crate::model::Message)
pub mod message {
    /// A builder for [`Message`](crate::model::Message)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) image_icon_url: std::option::Option<std::string::String>,
        pub(crate) image_small_icon_url: std::option::Option<std::string::String>,
        pub(crate) image_url: std::option::Option<std::string::String>,
        pub(crate) json_body: std::option::Option<std::string::String>,
        pub(crate) media_url: std::option::Option<std::string::String>,
        pub(crate) raw_content: std::option::Option<std::string::String>,
        pub(crate) silent_push: std::option::Option<bool>,
        pub(crate) time_to_live: std::option::Option<i32>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action to occur if a recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of iOS and Android.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action to occur if a recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of iOS and Android.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// <p>The body of the notification message. The maximum number of characters is 200.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The body of the notification message. The maximum number of characters is 200.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The URL of the image to display as the push-notification icon, such as the icon for the app.</p>
        pub fn image_icon_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_icon_url = Some(input.into());
            self
        }
        /// <p>The URL of the image to display as the push-notification icon, such as the icon for the app.</p>
        pub fn set_image_icon_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_icon_url = input;
            self
        }
        /// <p>The URL of the image to display as the small, push-notification icon, such as a small version of the icon for the app.</p>
        pub fn image_small_icon_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_small_icon_url = Some(input.into());
            self
        }
        /// <p>The URL of the image to display as the small, push-notification icon, such as a small version of the icon for the app.</p>
        pub fn set_image_small_icon_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_small_icon_url = input;
            self
        }
        /// <p>The URL of an image to display in the push notification.</p>
        pub fn image_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_url = Some(input.into());
            self
        }
        /// <p>The URL of an image to display in the push notification.</p>
        pub fn set_image_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_url = input;
            self
        }
        /// <p>The JSON payload to use for a silent push notification.</p>
        pub fn json_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.json_body = Some(input.into());
            self
        }
        /// <p>The JSON payload to use for a silent push notification.</p>
        pub fn set_json_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.json_body = input;
            self
        }
        /// <p>The URL of the image or video to display in the push notification.</p>
        pub fn media_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_url = Some(input.into());
            self
        }
        /// <p>The URL of the image or video to display in the push notification.</p>
        pub fn set_media_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.media_url = input;
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
        pub fn raw_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_content = Some(input.into());
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
        pub fn set_raw_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_content = input;
            self
        }
        /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration, displaying messages in an in-app message center, or supporting phone home functionality.</p>
        pub fn silent_push(mut self, input: bool) -> Self {
            self.silent_push = Some(input);
            self
        }
        /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration, displaying messages in an in-app message center, or supporting phone home functionality.</p>
        pub fn set_silent_push(mut self, input: std::option::Option<bool>) -> Self {
            self.silent_push = input;
            self
        }
        /// <p>The number of seconds that the push-notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.</p>
        pub fn time_to_live(mut self, input: i32) -> Self {
            self.time_to_live = Some(input);
            self
        }
        /// <p>The number of seconds that the push-notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.</p>
        pub fn set_time_to_live(mut self, input: std::option::Option<i32>) -> Self {
            self.time_to_live = input;
            self
        }
        /// <p>The title to display above the notification message on a recipient's device.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title to display above the notification message on a recipient's device.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`Message`](crate::model::Message)
        pub fn build(self) -> crate::model::Message {
            crate::model::Message {
                action: self.action,
                body: self.body,
                image_icon_url: self.image_icon_url,
                image_small_icon_url: self.image_small_icon_url,
                image_url: self.image_url,
                json_body: self.json_body,
                media_url: self.media_url,
                raw_content: self.raw_content,
                silent_push: self.silent_push.unwrap_or_default(),
                time_to_live: self.time_to_live.unwrap_or_default(),
                title: self.title,
                url: self.url,
            }
        }
    }
}
impl Message {
    /// Creates a new builder-style object to manufacture [`Message`](crate::model::Message)
    pub fn builder() -> crate::model::message::Builder {
        crate::model::message::Builder::default()
    }
}

/// <p>Specifies the content and "From" address for an email message that's sent to recipients of a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignEmailMessage {
    /// <p>The body of the email for recipients whose email clients don't render HTML content.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The verified email address to send the email from. The default address is the FromAddress specified for the email channel for the application.</p>
    pub from_address: std::option::Option<std::string::String>,
    /// <p>The body of the email, in HTML format, for recipients whose email clients render HTML content.</p>
    pub html_body: std::option::Option<std::string::String>,
    /// <p>The subject line, or title, of the email.</p>
    pub title: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CampaignEmailMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignEmailMessage");
        formatter.field("body", &self.body);
        formatter.field("from_address", &self.from_address);
        formatter.field("html_body", &self.html_body);
        formatter.field("title", &self.title);
        formatter.finish()
    }
}
/// See [`CampaignEmailMessage`](crate::model::CampaignEmailMessage)
pub mod campaign_email_message {
    /// A builder for [`CampaignEmailMessage`](crate::model::CampaignEmailMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) from_address: std::option::Option<std::string::String>,
        pub(crate) html_body: std::option::Option<std::string::String>,
        pub(crate) title: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The body of the email for recipients whose email clients don't render HTML content.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The body of the email for recipients whose email clients don't render HTML content.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The verified email address to send the email from. The default address is the FromAddress specified for the email channel for the application.</p>
        pub fn from_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_address = Some(input.into());
            self
        }
        /// <p>The verified email address to send the email from. The default address is the FromAddress specified for the email channel for the application.</p>
        pub fn set_from_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from_address = input;
            self
        }
        /// <p>The body of the email, in HTML format, for recipients whose email clients render HTML content.</p>
        pub fn html_body(mut self, input: impl Into<std::string::String>) -> Self {
            self.html_body = Some(input.into());
            self
        }
        /// <p>The body of the email, in HTML format, for recipients whose email clients render HTML content.</p>
        pub fn set_html_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.html_body = input;
            self
        }
        /// <p>The subject line, or title, of the email.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The subject line, or title, of the email.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignEmailMessage`](crate::model::CampaignEmailMessage)
        pub fn build(self) -> crate::model::CampaignEmailMessage {
            crate::model::CampaignEmailMessage {
                body: self.body,
                from_address: self.from_address,
                html_body: self.html_body,
                title: self.title,
            }
        }
    }
}
impl CampaignEmailMessage {
    /// Creates a new builder-style object to manufacture [`CampaignEmailMessage`](crate::model::CampaignEmailMessage)
    pub fn builder() -> crate::model::campaign_email_message::Builder {
        crate::model::campaign_email_message::Builder::default()
    }
}

/// <p>Specifies the contents of a message that's sent through a custom channel to recipients of a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignCustomMessage {
    /// <p>The raw, JSON-formatted string to use as the payload for the message. The maximum size is 5 KB.</p>
    pub data: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CampaignCustomMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignCustomMessage");
        formatter.field("data", &self.data);
        formatter.finish()
    }
}
/// See [`CampaignCustomMessage`](crate::model::CampaignCustomMessage)
pub mod campaign_custom_message {
    /// A builder for [`CampaignCustomMessage`](crate::model::CampaignCustomMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The raw, JSON-formatted string to use as the payload for the message. The maximum size is 5 KB.</p>
        pub fn data(mut self, input: impl Into<std::string::String>) -> Self {
            self.data = Some(input.into());
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the message. The maximum size is 5 KB.</p>
        pub fn set_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignCustomMessage`](crate::model::CampaignCustomMessage)
        pub fn build(self) -> crate::model::CampaignCustomMessage {
            crate::model::CampaignCustomMessage { data: self.data }
        }
    }
}
impl CampaignCustomMessage {
    /// Creates a new builder-style object to manufacture [`CampaignCustomMessage`](crate::model::CampaignCustomMessage)
    pub fn builder() -> crate::model::campaign_custom_message::Builder {
        crate::model::campaign_custom_message::Builder::default()
    }
}

/// <p>For a campaign, specifies limits on the messages that the campaign can send. For an application, specifies the default limits for messages that campaigns in the application can send.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignLimits {
    /// <p>The maximum number of messages that a campaign can send to a single endpoint during a 24-hour period. For an application, this value specifies the default limit for the number of messages that campaigns and journeys can send to a single endpoint during a 24-hour period. The maximum value is 100.</p>
    pub daily: i32,
    /// <p>The maximum amount of time, in seconds, that a campaign can attempt to deliver a message after the scheduled start time for the campaign. The minimum value is 60 seconds.</p>
    pub maximum_duration: i32,
    /// <p>The maximum number of messages that a campaign can send each second. For an application, this value specifies the default limit for the number of messages that campaigns can send each second. The minimum value is 50. The maximum value is 20,000.</p>
    pub messages_per_second: i32,
    /// <p>The maximum number of messages that a campaign can send to a single endpoint during the course of the campaign. If a campaign recurs, this setting applies to all runs of the campaign. The maximum value is 100.</p>
    pub total: i32,
    /// <p>The maximum total number of messages that the campaign can send per user session.</p>
    pub session: i32,
}
impl std::fmt::Debug for CampaignLimits {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignLimits");
        formatter.field("daily", &self.daily);
        formatter.field("maximum_duration", &self.maximum_duration);
        formatter.field("messages_per_second", &self.messages_per_second);
        formatter.field("total", &self.total);
        formatter.field("session", &self.session);
        formatter.finish()
    }
}
/// See [`CampaignLimits`](crate::model::CampaignLimits)
pub mod campaign_limits {
    /// A builder for [`CampaignLimits`](crate::model::CampaignLimits)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) daily: std::option::Option<i32>,
        pub(crate) maximum_duration: std::option::Option<i32>,
        pub(crate) messages_per_second: std::option::Option<i32>,
        pub(crate) total: std::option::Option<i32>,
        pub(crate) session: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum number of messages that a campaign can send to a single endpoint during a 24-hour period. For an application, this value specifies the default limit for the number of messages that campaigns and journeys can send to a single endpoint during a 24-hour period. The maximum value is 100.</p>
        pub fn daily(mut self, input: i32) -> Self {
            self.daily = Some(input);
            self
        }
        /// <p>The maximum number of messages that a campaign can send to a single endpoint during a 24-hour period. For an application, this value specifies the default limit for the number of messages that campaigns and journeys can send to a single endpoint during a 24-hour period. The maximum value is 100.</p>
        pub fn set_daily(mut self, input: std::option::Option<i32>) -> Self {
            self.daily = input;
            self
        }
        /// <p>The maximum amount of time, in seconds, that a campaign can attempt to deliver a message after the scheduled start time for the campaign. The minimum value is 60 seconds.</p>
        pub fn maximum_duration(mut self, input: i32) -> Self {
            self.maximum_duration = Some(input);
            self
        }
        /// <p>The maximum amount of time, in seconds, that a campaign can attempt to deliver a message after the scheduled start time for the campaign. The minimum value is 60 seconds.</p>
        pub fn set_maximum_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_duration = input;
            self
        }
        /// <p>The maximum number of messages that a campaign can send each second. For an application, this value specifies the default limit for the number of messages that campaigns can send each second. The minimum value is 50. The maximum value is 20,000.</p>
        pub fn messages_per_second(mut self, input: i32) -> Self {
            self.messages_per_second = Some(input);
            self
        }
        /// <p>The maximum number of messages that a campaign can send each second. For an application, this value specifies the default limit for the number of messages that campaigns can send each second. The minimum value is 50. The maximum value is 20,000.</p>
        pub fn set_messages_per_second(mut self, input: std::option::Option<i32>) -> Self {
            self.messages_per_second = input;
            self
        }
        /// <p>The maximum number of messages that a campaign can send to a single endpoint during the course of the campaign. If a campaign recurs, this setting applies to all runs of the campaign. The maximum value is 100.</p>
        pub fn total(mut self, input: i32) -> Self {
            self.total = Some(input);
            self
        }
        /// <p>The maximum number of messages that a campaign can send to a single endpoint during the course of the campaign. If a campaign recurs, this setting applies to all runs of the campaign. The maximum value is 100.</p>
        pub fn set_total(mut self, input: std::option::Option<i32>) -> Self {
            self.total = input;
            self
        }
        /// <p>The maximum total number of messages that the campaign can send per user session.</p>
        pub fn session(mut self, input: i32) -> Self {
            self.session = Some(input);
            self
        }
        /// <p>The maximum total number of messages that the campaign can send per user session.</p>
        pub fn set_session(mut self, input: std::option::Option<i32>) -> Self {
            self.session = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignLimits`](crate::model::CampaignLimits)
        pub fn build(self) -> crate::model::CampaignLimits {
            crate::model::CampaignLimits {
                daily: self.daily.unwrap_or_default(),
                maximum_duration: self.maximum_duration.unwrap_or_default(),
                messages_per_second: self.messages_per_second.unwrap_or_default(),
                total: self.total.unwrap_or_default(),
                session: self.session.unwrap_or_default(),
            }
        }
    }
}
impl CampaignLimits {
    /// Creates a new builder-style object to manufacture [`CampaignLimits`](crate::model::CampaignLimits)
    pub fn builder() -> crate::model::campaign_limits::Builder {
        crate::model::campaign_limits::Builder::default()
    }
}

/// <p>Specifies settings for invoking an AWS Lambda function that customizes a segment for a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignHook {
    /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to customize a segment for a campaign.</p>
    pub lambda_function_name: std::option::Option<std::string::String>,
    /// <p>The mode that Amazon Pinpoint uses to invoke the AWS Lambda function. Possible values are:</p> <ul><li><p>FILTER - Invoke the function to customize the segment that's used by a campaign.</p></li> <li><p>DELIVERY - (Deprecated) Previously, invoked the function to send a campaign through a custom channel. This functionality is not supported anymore. To send a campaign through a custom channel, use the CustomDeliveryConfiguration and CampaignCustomMessage objects of the campaign.</p></li></ul>
    pub mode: std::option::Option<crate::model::Mode>,
    /// <p>The web URL that Amazon Pinpoint calls to invoke the AWS Lambda function over HTTPS.</p>
    pub web_url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CampaignHook {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignHook");
        formatter.field("lambda_function_name", &self.lambda_function_name);
        formatter.field("mode", &self.mode);
        formatter.field("web_url", &self.web_url);
        formatter.finish()
    }
}
/// See [`CampaignHook`](crate::model::CampaignHook)
pub mod campaign_hook {
    /// A builder for [`CampaignHook`](crate::model::CampaignHook)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lambda_function_name: std::option::Option<std::string::String>,
        pub(crate) mode: std::option::Option<crate::model::Mode>,
        pub(crate) web_url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to customize a segment for a campaign.</p>
        pub fn lambda_function_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.lambda_function_name = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to customize a segment for a campaign.</p>
        pub fn set_lambda_function_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.lambda_function_name = input;
            self
        }
        /// <p>The mode that Amazon Pinpoint uses to invoke the AWS Lambda function. Possible values are:</p> <ul><li><p>FILTER - Invoke the function to customize the segment that's used by a campaign.</p></li> <li><p>DELIVERY - (Deprecated) Previously, invoked the function to send a campaign through a custom channel. This functionality is not supported anymore. To send a campaign through a custom channel, use the CustomDeliveryConfiguration and CampaignCustomMessage objects of the campaign.</p></li></ul>
        pub fn mode(mut self, input: crate::model::Mode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>The mode that Amazon Pinpoint uses to invoke the AWS Lambda function. Possible values are:</p> <ul><li><p>FILTER - Invoke the function to customize the segment that's used by a campaign.</p></li> <li><p>DELIVERY - (Deprecated) Previously, invoked the function to send a campaign through a custom channel. This functionality is not supported anymore. To send a campaign through a custom channel, use the CustomDeliveryConfiguration and CampaignCustomMessage objects of the campaign.</p></li></ul>
        pub fn set_mode(mut self, input: std::option::Option<crate::model::Mode>) -> Self {
            self.mode = input;
            self
        }
        /// <p>The web URL that Amazon Pinpoint calls to invoke the AWS Lambda function over HTTPS.</p>
        pub fn web_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.web_url = Some(input.into());
            self
        }
        /// <p>The web URL that Amazon Pinpoint calls to invoke the AWS Lambda function over HTTPS.</p>
        pub fn set_web_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.web_url = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignHook`](crate::model::CampaignHook)
        pub fn build(self) -> crate::model::CampaignHook {
            crate::model::CampaignHook {
                lambda_function_name: self.lambda_function_name,
                mode: self.mode,
                web_url: self.web_url,
            }
        }
    }
}
impl CampaignHook {
    /// Creates a new builder-style object to manufacture [`CampaignHook`](crate::model::CampaignHook)
    pub fn builder() -> crate::model::campaign_hook::Builder {
        crate::model::campaign_hook::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Mode {
    #[allow(missing_docs)] // documentation missing in model
    Delivery,
    #[allow(missing_docs)] // documentation missing in model
    Filter,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for Mode {
    fn from(s: &str) -> Self {
        match s {
            "DELIVERY" => Mode::Delivery,
            "FILTER" => Mode::Filter,
            other => Mode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for Mode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Mode::from(s))
    }
}
impl Mode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Mode::Delivery => "DELIVERY",
            Mode::Filter => "FILTER",
            Mode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DELIVERY", "FILTER"]
    }
}
impl AsRef<str> for Mode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the delivery configuration settings for sending a campaign or campaign treatment through a custom channel. This object is required if you use the CampaignCustomMessage object to define the message to send for the campaign or campaign treatment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CustomDeliveryConfiguration {
    /// <p>The destination to send the campaign or treatment to. This value can be one of the following:</p> <ul><li><p>The name or Amazon Resource Name (ARN) of an AWS Lambda function to invoke to handle delivery of the campaign or treatment.</p></li> <li><p>The URL for a web application or service that supports HTTPS and can receive the message. The URL has to be a full URL, including the HTTPS protocol.</p></li></ul>
    pub delivery_uri: std::option::Option<std::string::String>,
    /// <p>The types of endpoints to send the campaign or treatment to. Each valid value maps to a type of channel that you can associate with an endpoint by using the ChannelType property of an endpoint.</p>
    pub endpoint_types: std::option::Option<std::vec::Vec<crate::model::EndpointTypesElement>>,
}
impl std::fmt::Debug for CustomDeliveryConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CustomDeliveryConfiguration");
        formatter.field("delivery_uri", &self.delivery_uri);
        formatter.field("endpoint_types", &self.endpoint_types);
        formatter.finish()
    }
}
/// See [`CustomDeliveryConfiguration`](crate::model::CustomDeliveryConfiguration)
pub mod custom_delivery_configuration {
    /// A builder for [`CustomDeliveryConfiguration`](crate::model::CustomDeliveryConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delivery_uri: std::option::Option<std::string::String>,
        pub(crate) endpoint_types:
            std::option::Option<std::vec::Vec<crate::model::EndpointTypesElement>>,
    }
    impl Builder {
        /// <p>The destination to send the campaign or treatment to. This value can be one of the following:</p> <ul><li><p>The name or Amazon Resource Name (ARN) of an AWS Lambda function to invoke to handle delivery of the campaign or treatment.</p></li> <li><p>The URL for a web application or service that supports HTTPS and can receive the message. The URL has to be a full URL, including the HTTPS protocol.</p></li></ul>
        pub fn delivery_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.delivery_uri = Some(input.into());
            self
        }
        /// <p>The destination to send the campaign or treatment to. This value can be one of the following:</p> <ul><li><p>The name or Amazon Resource Name (ARN) of an AWS Lambda function to invoke to handle delivery of the campaign or treatment.</p></li> <li><p>The URL for a web application or service that supports HTTPS and can receive the message. The URL has to be a full URL, including the HTTPS protocol.</p></li></ul>
        pub fn set_delivery_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.delivery_uri = input;
            self
        }
        /// Appends an item to `endpoint_types`.
        ///
        /// To override the contents of this collection use [`set_endpoint_types`](Self::set_endpoint_types).
        ///
        /// <p>The types of endpoints to send the campaign or treatment to. Each valid value maps to a type of channel that you can associate with an endpoint by using the ChannelType property of an endpoint.</p>
        pub fn endpoint_types(
            mut self,
            input: impl Into<crate::model::EndpointTypesElement>,
        ) -> Self {
            let mut v = self.endpoint_types.unwrap_or_default();
            v.push(input.into());
            self.endpoint_types = Some(v);
            self
        }
        /// <p>The types of endpoints to send the campaign or treatment to. Each valid value maps to a type of channel that you can associate with an endpoint by using the ChannelType property of an endpoint.</p>
        pub fn set_endpoint_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndpointTypesElement>>,
        ) -> Self {
            self.endpoint_types = input;
            self
        }
        /// Consumes the builder and constructs a [`CustomDeliveryConfiguration`](crate::model::CustomDeliveryConfiguration)
        pub fn build(self) -> crate::model::CustomDeliveryConfiguration {
            crate::model::CustomDeliveryConfiguration {
                delivery_uri: self.delivery_uri,
                endpoint_types: self.endpoint_types,
            }
        }
    }
}
impl CustomDeliveryConfiguration {
    /// Creates a new builder-style object to manufacture [`CustomDeliveryConfiguration`](crate::model::CustomDeliveryConfiguration)
    pub fn builder() -> crate::model::custom_delivery_configuration::Builder {
        crate::model::custom_delivery_configuration::Builder::default()
    }
}

/// <p>Specifies the settings for a campaign treatment. A <i>treatment</i> is a variation of a campaign that's used for A/B testing of a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TreatmentResource {
    /// <p>The delivery configuration settings for sending the treatment through a custom channel. This object is required if the MessageConfiguration object for the treatment specifies a CustomMessage object.</p>
    pub custom_delivery_configuration:
        std::option::Option<crate::model::CustomDeliveryConfiguration>,
    /// <p>The unique identifier for the treatment.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The message configuration settings for the treatment.</p>
    pub message_configuration: std::option::Option<crate::model::MessageConfiguration>,
    /// <p>The schedule settings for the treatment.</p>
    pub schedule: std::option::Option<crate::model::Schedule>,
    /// <p>The allocated percentage of users (segment members) that the treatment is sent to.</p>
    pub size_percent: i32,
    /// <p>The current status of the treatment.</p>
    pub state: std::option::Option<crate::model::CampaignState>,
    /// <p>The message template to use for the treatment.</p>
    pub template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
    /// <p>The custom description of the treatment.</p>
    pub treatment_description: std::option::Option<std::string::String>,
    /// <p>The custom name of the treatment.</p>
    pub treatment_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TreatmentResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TreatmentResource");
        formatter.field(
            "custom_delivery_configuration",
            &self.custom_delivery_configuration,
        );
        formatter.field("id", &self.id);
        formatter.field("message_configuration", &self.message_configuration);
        formatter.field("schedule", &self.schedule);
        formatter.field("size_percent", &self.size_percent);
        formatter.field("state", &self.state);
        formatter.field("template_configuration", &self.template_configuration);
        formatter.field("treatment_description", &self.treatment_description);
        formatter.field("treatment_name", &self.treatment_name);
        formatter.finish()
    }
}
/// See [`TreatmentResource`](crate::model::TreatmentResource)
pub mod treatment_resource {
    /// A builder for [`TreatmentResource`](crate::model::TreatmentResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_delivery_configuration:
            std::option::Option<crate::model::CustomDeliveryConfiguration>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) message_configuration: std::option::Option<crate::model::MessageConfiguration>,
        pub(crate) schedule: std::option::Option<crate::model::Schedule>,
        pub(crate) size_percent: std::option::Option<i32>,
        pub(crate) state: std::option::Option<crate::model::CampaignState>,
        pub(crate) template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
        pub(crate) treatment_description: std::option::Option<std::string::String>,
        pub(crate) treatment_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The delivery configuration settings for sending the treatment through a custom channel. This object is required if the MessageConfiguration object for the treatment specifies a CustomMessage object.</p>
        pub fn custom_delivery_configuration(
            mut self,
            input: crate::model::CustomDeliveryConfiguration,
        ) -> Self {
            self.custom_delivery_configuration = Some(input);
            self
        }
        /// <p>The delivery configuration settings for sending the treatment through a custom channel. This object is required if the MessageConfiguration object for the treatment specifies a CustomMessage object.</p>
        pub fn set_custom_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::CustomDeliveryConfiguration>,
        ) -> Self {
            self.custom_delivery_configuration = input;
            self
        }
        /// <p>The unique identifier for the treatment.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the treatment.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The message configuration settings for the treatment.</p>
        pub fn message_configuration(mut self, input: crate::model::MessageConfiguration) -> Self {
            self.message_configuration = Some(input);
            self
        }
        /// <p>The message configuration settings for the treatment.</p>
        pub fn set_message_configuration(
            mut self,
            input: std::option::Option<crate::model::MessageConfiguration>,
        ) -> Self {
            self.message_configuration = input;
            self
        }
        /// <p>The schedule settings for the treatment.</p>
        pub fn schedule(mut self, input: crate::model::Schedule) -> Self {
            self.schedule = Some(input);
            self
        }
        /// <p>The schedule settings for the treatment.</p>
        pub fn set_schedule(mut self, input: std::option::Option<crate::model::Schedule>) -> Self {
            self.schedule = input;
            self
        }
        /// <p>The allocated percentage of users (segment members) that the treatment is sent to.</p>
        pub fn size_percent(mut self, input: i32) -> Self {
            self.size_percent = Some(input);
            self
        }
        /// <p>The allocated percentage of users (segment members) that the treatment is sent to.</p>
        pub fn set_size_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.size_percent = input;
            self
        }
        /// <p>The current status of the treatment.</p>
        pub fn state(mut self, input: crate::model::CampaignState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current status of the treatment.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::CampaignState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The message template to use for the treatment.</p>
        pub fn template_configuration(
            mut self,
            input: crate::model::TemplateConfiguration,
        ) -> Self {
            self.template_configuration = Some(input);
            self
        }
        /// <p>The message template to use for the treatment.</p>
        pub fn set_template_configuration(
            mut self,
            input: std::option::Option<crate::model::TemplateConfiguration>,
        ) -> Self {
            self.template_configuration = input;
            self
        }
        /// <p>The custom description of the treatment.</p>
        pub fn treatment_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.treatment_description = Some(input.into());
            self
        }
        /// <p>The custom description of the treatment.</p>
        pub fn set_treatment_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.treatment_description = input;
            self
        }
        /// <p>The custom name of the treatment.</p>
        pub fn treatment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.treatment_name = Some(input.into());
            self
        }
        /// <p>The custom name of the treatment.</p>
        pub fn set_treatment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.treatment_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TreatmentResource`](crate::model::TreatmentResource)
        pub fn build(self) -> crate::model::TreatmentResource {
            crate::model::TreatmentResource {
                custom_delivery_configuration: self.custom_delivery_configuration,
                id: self.id,
                message_configuration: self.message_configuration,
                schedule: self.schedule,
                size_percent: self.size_percent.unwrap_or_default(),
                state: self.state,
                template_configuration: self.template_configuration,
                treatment_description: self.treatment_description,
                treatment_name: self.treatment_name,
            }
        }
    }
}
impl TreatmentResource {
    /// Creates a new builder-style object to manufacture [`TreatmentResource`](crate::model::TreatmentResource)
    pub fn builder() -> crate::model::treatment_resource::Builder {
        crate::model::treatment_resource::Builder::default()
    }
}

/// <p>Specifies the configuration and other settings for a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WriteCampaignRequest {
    /// <p>An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.</p>
    pub additional_treatments:
        std::option::Option<std::vec::Vec<crate::model::WriteTreatmentResource>>,
    /// <p>The delivery configuration settings for sending the campaign through a custom channel. This object is required if the MessageConfiguration object for the campaign specifies a CustomMessage object.</p>
    pub custom_delivery_configuration:
        std::option::Option<crate::model::CustomDeliveryConfiguration>,
    /// <p>A custom description of the campaign.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub holdout_percent: i32,
    /// <p>The settings for the AWS Lambda function to invoke as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub hook: std::option::Option<crate::model::CampaignHook>,
    /// <p>Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub is_paused: bool,
    /// <p>The messaging limits for the campaign.</p>
    pub limits: std::option::Option<crate::model::CampaignLimits>,
    /// <p>The message configuration settings for the campaign.</p>
    pub message_configuration: std::option::Option<crate::model::MessageConfiguration>,
    /// <p>A custom name for the campaign.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The schedule settings for the campaign.</p>
    pub schedule: std::option::Option<crate::model::Schedule>,
    /// <p>The unique identifier for the segment to associate with the campaign.</p>
    pub segment_id: std::option::Option<std::string::String>,
    /// <p>The version of the segment to associate with the campaign.</p>
    pub segment_version: i32,
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The message template to use for the campaign.</p>
    pub template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
    /// <p>A custom description of the default treatment for the campaign.</p>
    pub treatment_description: std::option::Option<std::string::String>,
    /// <p>A custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub treatment_name: std::option::Option<std::string::String>,
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub priority: i32,
}
impl std::fmt::Debug for WriteCampaignRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WriteCampaignRequest");
        formatter.field("additional_treatments", &self.additional_treatments);
        formatter.field(
            "custom_delivery_configuration",
            &self.custom_delivery_configuration,
        );
        formatter.field("description", &self.description);
        formatter.field("holdout_percent", &self.holdout_percent);
        formatter.field("hook", &self.hook);
        formatter.field("is_paused", &self.is_paused);
        formatter.field("limits", &self.limits);
        formatter.field("message_configuration", &self.message_configuration);
        formatter.field("name", &self.name);
        formatter.field("schedule", &self.schedule);
        formatter.field("segment_id", &self.segment_id);
        formatter.field("segment_version", &self.segment_version);
        formatter.field("tags", &self.tags);
        formatter.field("template_configuration", &self.template_configuration);
        formatter.field("treatment_description", &self.treatment_description);
        formatter.field("treatment_name", &self.treatment_name);
        formatter.field("priority", &self.priority);
        formatter.finish()
    }
}
/// See [`WriteCampaignRequest`](crate::model::WriteCampaignRequest)
pub mod write_campaign_request {
    /// A builder for [`WriteCampaignRequest`](crate::model::WriteCampaignRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) additional_treatments:
            std::option::Option<std::vec::Vec<crate::model::WriteTreatmentResource>>,
        pub(crate) custom_delivery_configuration:
            std::option::Option<crate::model::CustomDeliveryConfiguration>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) holdout_percent: std::option::Option<i32>,
        pub(crate) hook: std::option::Option<crate::model::CampaignHook>,
        pub(crate) is_paused: std::option::Option<bool>,
        pub(crate) limits: std::option::Option<crate::model::CampaignLimits>,
        pub(crate) message_configuration: std::option::Option<crate::model::MessageConfiguration>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) schedule: std::option::Option<crate::model::Schedule>,
        pub(crate) segment_id: std::option::Option<std::string::String>,
        pub(crate) segment_version: std::option::Option<i32>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
        pub(crate) treatment_description: std::option::Option<std::string::String>,
        pub(crate) treatment_name: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<i32>,
    }
    impl Builder {
        /// Appends an item to `additional_treatments`.
        ///
        /// To override the contents of this collection use [`set_additional_treatments`](Self::set_additional_treatments).
        ///
        /// <p>An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.</p>
        pub fn additional_treatments(
            mut self,
            input: impl Into<crate::model::WriteTreatmentResource>,
        ) -> Self {
            let mut v = self.additional_treatments.unwrap_or_default();
            v.push(input.into());
            self.additional_treatments = Some(v);
            self
        }
        /// <p>An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.</p>
        pub fn set_additional_treatments(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WriteTreatmentResource>>,
        ) -> Self {
            self.additional_treatments = input;
            self
        }
        /// <p>The delivery configuration settings for sending the campaign through a custom channel. This object is required if the MessageConfiguration object for the campaign specifies a CustomMessage object.</p>
        pub fn custom_delivery_configuration(
            mut self,
            input: crate::model::CustomDeliveryConfiguration,
        ) -> Self {
            self.custom_delivery_configuration = Some(input);
            self
        }
        /// <p>The delivery configuration settings for sending the campaign through a custom channel. This object is required if the MessageConfiguration object for the campaign specifies a CustomMessage object.</p>
        pub fn set_custom_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::CustomDeliveryConfiguration>,
        ) -> Self {
            self.custom_delivery_configuration = input;
            self
        }
        /// <p>A custom description of the campaign.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A custom description of the campaign.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
        pub fn holdout_percent(mut self, input: i32) -> Self {
            self.holdout_percent = Some(input);
            self
        }
        /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
        pub fn set_holdout_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.holdout_percent = input;
            self
        }
        /// <p>The settings for the AWS Lambda function to invoke as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
        pub fn hook(mut self, input: crate::model::CampaignHook) -> Self {
            self.hook = Some(input);
            self
        }
        /// <p>The settings for the AWS Lambda function to invoke as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
        pub fn set_hook(mut self, input: std::option::Option<crate::model::CampaignHook>) -> Self {
            self.hook = input;
            self
        }
        /// <p>Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
        pub fn is_paused(mut self, input: bool) -> Self {
            self.is_paused = Some(input);
            self
        }
        /// <p>Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
        pub fn set_is_paused(mut self, input: std::option::Option<bool>) -> Self {
            self.is_paused = input;
            self
        }
        /// <p>The messaging limits for the campaign.</p>
        pub fn limits(mut self, input: crate::model::CampaignLimits) -> Self {
            self.limits = Some(input);
            self
        }
        /// <p>The messaging limits for the campaign.</p>
        pub fn set_limits(
            mut self,
            input: std::option::Option<crate::model::CampaignLimits>,
        ) -> Self {
            self.limits = input;
            self
        }
        /// <p>The message configuration settings for the campaign.</p>
        pub fn message_configuration(mut self, input: crate::model::MessageConfiguration) -> Self {
            self.message_configuration = Some(input);
            self
        }
        /// <p>The message configuration settings for the campaign.</p>
        pub fn set_message_configuration(
            mut self,
            input: std::option::Option<crate::model::MessageConfiguration>,
        ) -> Self {
            self.message_configuration = input;
            self
        }
        /// <p>A custom name for the campaign.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A custom name for the campaign.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The schedule settings for the campaign.</p>
        pub fn schedule(mut self, input: crate::model::Schedule) -> Self {
            self.schedule = Some(input);
            self
        }
        /// <p>The schedule settings for the campaign.</p>
        pub fn set_schedule(mut self, input: std::option::Option<crate::model::Schedule>) -> Self {
            self.schedule = input;
            self
        }
        /// <p>The unique identifier for the segment to associate with the campaign.</p>
        pub fn segment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the segment to associate with the campaign.</p>
        pub fn set_segment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_id = input;
            self
        }
        /// <p>The version of the segment to associate with the campaign.</p>
        pub fn segment_version(mut self, input: i32) -> Self {
            self.segment_version = Some(input);
            self
        }
        /// <p>The version of the segment to associate with the campaign.</p>
        pub fn set_segment_version(mut self, input: std::option::Option<i32>) -> Self {
            self.segment_version = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The message template to use for the campaign.</p>
        pub fn template_configuration(
            mut self,
            input: crate::model::TemplateConfiguration,
        ) -> Self {
            self.template_configuration = Some(input);
            self
        }
        /// <p>The message template to use for the campaign.</p>
        pub fn set_template_configuration(
            mut self,
            input: std::option::Option<crate::model::TemplateConfiguration>,
        ) -> Self {
            self.template_configuration = input;
            self
        }
        /// <p>A custom description of the default treatment for the campaign.</p>
        pub fn treatment_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.treatment_description = Some(input.into());
            self
        }
        /// <p>A custom description of the default treatment for the campaign.</p>
        pub fn set_treatment_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.treatment_description = input;
            self
        }
        /// <p>A custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
        pub fn treatment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.treatment_name = Some(input.into());
            self
        }
        /// <p>A custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
        pub fn set_treatment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.treatment_name = input;
            self
        }
        /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// Consumes the builder and constructs a [`WriteCampaignRequest`](crate::model::WriteCampaignRequest)
        pub fn build(self) -> crate::model::WriteCampaignRequest {
            crate::model::WriteCampaignRequest {
                additional_treatments: self.additional_treatments,
                custom_delivery_configuration: self.custom_delivery_configuration,
                description: self.description,
                holdout_percent: self.holdout_percent.unwrap_or_default(),
                hook: self.hook,
                is_paused: self.is_paused.unwrap_or_default(),
                limits: self.limits,
                message_configuration: self.message_configuration,
                name: self.name,
                schedule: self.schedule,
                segment_id: self.segment_id,
                segment_version: self.segment_version.unwrap_or_default(),
                tags: self.tags,
                template_configuration: self.template_configuration,
                treatment_description: self.treatment_description,
                treatment_name: self.treatment_name,
                priority: self.priority.unwrap_or_default(),
            }
        }
    }
}
impl WriteCampaignRequest {
    /// Creates a new builder-style object to manufacture [`WriteCampaignRequest`](crate::model::WriteCampaignRequest)
    pub fn builder() -> crate::model::write_campaign_request::Builder {
        crate::model::write_campaign_request::Builder::default()
    }
}

/// <p>Specifies the settings for a campaign treatment. A <i>treatment</i> is a variation of a campaign that's used for A/B testing of a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WriteTreatmentResource {
    /// <p>The delivery configuration settings for sending the treatment through a custom channel. This object is required if the MessageConfiguration object for the treatment specifies a CustomMessage object.</p>
    pub custom_delivery_configuration:
        std::option::Option<crate::model::CustomDeliveryConfiguration>,
    /// <p>The message configuration settings for the treatment.</p>
    pub message_configuration: std::option::Option<crate::model::MessageConfiguration>,
    /// <p>The schedule settings for the treatment.</p>
    pub schedule: std::option::Option<crate::model::Schedule>,
    /// <p>The allocated percentage of users (segment members) to send the treatment to.</p>
    pub size_percent: i32,
    /// <p>The message template to use for the treatment.</p>
    pub template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
    /// <p>A custom description of the treatment.</p>
    pub treatment_description: std::option::Option<std::string::String>,
    /// <p>A custom name for the treatment.</p>
    pub treatment_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for WriteTreatmentResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WriteTreatmentResource");
        formatter.field(
            "custom_delivery_configuration",
            &self.custom_delivery_configuration,
        );
        formatter.field("message_configuration", &self.message_configuration);
        formatter.field("schedule", &self.schedule);
        formatter.field("size_percent", &self.size_percent);
        formatter.field("template_configuration", &self.template_configuration);
        formatter.field("treatment_description", &self.treatment_description);
        formatter.field("treatment_name", &self.treatment_name);
        formatter.finish()
    }
}
/// See [`WriteTreatmentResource`](crate::model::WriteTreatmentResource)
pub mod write_treatment_resource {
    /// A builder for [`WriteTreatmentResource`](crate::model::WriteTreatmentResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) custom_delivery_configuration:
            std::option::Option<crate::model::CustomDeliveryConfiguration>,
        pub(crate) message_configuration: std::option::Option<crate::model::MessageConfiguration>,
        pub(crate) schedule: std::option::Option<crate::model::Schedule>,
        pub(crate) size_percent: std::option::Option<i32>,
        pub(crate) template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
        pub(crate) treatment_description: std::option::Option<std::string::String>,
        pub(crate) treatment_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The delivery configuration settings for sending the treatment through a custom channel. This object is required if the MessageConfiguration object for the treatment specifies a CustomMessage object.</p>
        pub fn custom_delivery_configuration(
            mut self,
            input: crate::model::CustomDeliveryConfiguration,
        ) -> Self {
            self.custom_delivery_configuration = Some(input);
            self
        }
        /// <p>The delivery configuration settings for sending the treatment through a custom channel. This object is required if the MessageConfiguration object for the treatment specifies a CustomMessage object.</p>
        pub fn set_custom_delivery_configuration(
            mut self,
            input: std::option::Option<crate::model::CustomDeliveryConfiguration>,
        ) -> Self {
            self.custom_delivery_configuration = input;
            self
        }
        /// <p>The message configuration settings for the treatment.</p>
        pub fn message_configuration(mut self, input: crate::model::MessageConfiguration) -> Self {
            self.message_configuration = Some(input);
            self
        }
        /// <p>The message configuration settings for the treatment.</p>
        pub fn set_message_configuration(
            mut self,
            input: std::option::Option<crate::model::MessageConfiguration>,
        ) -> Self {
            self.message_configuration = input;
            self
        }
        /// <p>The schedule settings for the treatment.</p>
        pub fn schedule(mut self, input: crate::model::Schedule) -> Self {
            self.schedule = Some(input);
            self
        }
        /// <p>The schedule settings for the treatment.</p>
        pub fn set_schedule(mut self, input: std::option::Option<crate::model::Schedule>) -> Self {
            self.schedule = input;
            self
        }
        /// <p>The allocated percentage of users (segment members) to send the treatment to.</p>
        pub fn size_percent(mut self, input: i32) -> Self {
            self.size_percent = Some(input);
            self
        }
        /// <p>The allocated percentage of users (segment members) to send the treatment to.</p>
        pub fn set_size_percent(mut self, input: std::option::Option<i32>) -> Self {
            self.size_percent = input;
            self
        }
        /// <p>The message template to use for the treatment.</p>
        pub fn template_configuration(
            mut self,
            input: crate::model::TemplateConfiguration,
        ) -> Self {
            self.template_configuration = Some(input);
            self
        }
        /// <p>The message template to use for the treatment.</p>
        pub fn set_template_configuration(
            mut self,
            input: std::option::Option<crate::model::TemplateConfiguration>,
        ) -> Self {
            self.template_configuration = input;
            self
        }
        /// <p>A custom description of the treatment.</p>
        pub fn treatment_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.treatment_description = Some(input.into());
            self
        }
        /// <p>A custom description of the treatment.</p>
        pub fn set_treatment_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.treatment_description = input;
            self
        }
        /// <p>A custom name for the treatment.</p>
        pub fn treatment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.treatment_name = Some(input.into());
            self
        }
        /// <p>A custom name for the treatment.</p>
        pub fn set_treatment_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.treatment_name = input;
            self
        }
        /// Consumes the builder and constructs a [`WriteTreatmentResource`](crate::model::WriteTreatmentResource)
        pub fn build(self) -> crate::model::WriteTreatmentResource {
            crate::model::WriteTreatmentResource {
                custom_delivery_configuration: self.custom_delivery_configuration,
                message_configuration: self.message_configuration,
                schedule: self.schedule,
                size_percent: self.size_percent.unwrap_or_default(),
                template_configuration: self.template_configuration,
                treatment_description: self.treatment_description,
                treatment_name: self.treatment_name,
            }
        }
    }
}
impl WriteTreatmentResource {
    /// Creates a new builder-style object to manufacture [`WriteTreatmentResource`](crate::model::WriteTreatmentResource)
    pub fn builder() -> crate::model::write_treatment_resource::Builder {
        crate::model::write_treatment_resource::Builder::default()
    }
}

/// <p>Provides information about the status and settings of the Baidu (Baidu Cloud Push) channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BaiduChannelResponse {
    /// <p>The unique identifier for the application that the Baidu channel applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date and time when the Baidu channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The API key that you received from the Baidu Cloud Push service to communicate with the service.</p>
    pub credential: std::option::Option<std::string::String>,
    /// <p>Specifies whether the Baidu channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>(Deprecated) An identifier for the Baidu channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the Baidu channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the Baidu channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the Baidu channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The type of messaging or notification platform for the channel. For the Baidu channel, this value is BAIDU.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current version of the Baidu channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for BaiduChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BaiduChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("credential", &self.credential);
        formatter.field("enabled", &self.enabled);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("id", &self.id);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("platform", &self.platform);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`BaiduChannelResponse`](crate::model::BaiduChannelResponse)
pub mod baidu_channel_response {
    /// A builder for [`BaiduChannelResponse`](crate::model::BaiduChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) credential: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the Baidu channel applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the Baidu channel applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date and time when the Baidu channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time when the Baidu channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The API key that you received from the Baidu Cloud Push service to communicate with the service.</p>
        pub fn credential(mut self, input: impl Into<std::string::String>) -> Self {
            self.credential = Some(input.into());
            self
        }
        /// <p>The API key that you received from the Baidu Cloud Push service to communicate with the service.</p>
        pub fn set_credential(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.credential = input;
            self
        }
        /// <p>Specifies whether the Baidu channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the Baidu channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>(Deprecated) An identifier for the Baidu channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the Baidu channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the Baidu channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the Baidu channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the Baidu channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the Baidu channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time when the Baidu channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time when the Baidu channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the Baidu channel, this value is BAIDU.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the Baidu channel, this value is BAIDU.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current version of the Baidu channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the Baidu channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`BaiduChannelResponse`](crate::model::BaiduChannelResponse)
        pub fn build(self) -> crate::model::BaiduChannelResponse {
            crate::model::BaiduChannelResponse {
                application_id: self.application_id,
                creation_date: self.creation_date,
                credential: self.credential,
                enabled: self.enabled.unwrap_or_default(),
                has_credential: self.has_credential.unwrap_or_default(),
                id: self.id,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                platform: self.platform,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl BaiduChannelResponse {
    /// Creates a new builder-style object to manufacture [`BaiduChannelResponse`](crate::model::BaiduChannelResponse)
    pub fn builder() -> crate::model::baidu_channel_response::Builder {
        crate::model::baidu_channel_response::Builder::default()
    }
}

/// <p>Specifies the status and settings of the Baidu (Baidu Cloud Push) channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BaiduChannelRequest {
    /// <p>The API key that you received from the Baidu Cloud Push service to communicate with the service.</p>
    pub api_key: std::option::Option<std::string::String>,
    /// <p>Specifies whether to enable the Baidu channel for the application.</p>
    pub enabled: bool,
    /// <p>The secret key that you received from the Baidu Cloud Push service to communicate with the service.</p>
    pub secret_key: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BaiduChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BaiduChannelRequest");
        formatter.field("api_key", &self.api_key);
        formatter.field("enabled", &self.enabled);
        formatter.field("secret_key", &self.secret_key);
        formatter.finish()
    }
}
/// See [`BaiduChannelRequest`](crate::model::BaiduChannelRequest)
pub mod baidu_channel_request {
    /// A builder for [`BaiduChannelRequest`](crate::model::BaiduChannelRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) api_key: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) secret_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The API key that you received from the Baidu Cloud Push service to communicate with the service.</p>
        pub fn api_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.api_key = Some(input.into());
            self
        }
        /// <p>The API key that you received from the Baidu Cloud Push service to communicate with the service.</p>
        pub fn set_api_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.api_key = input;
            self
        }
        /// <p>Specifies whether to enable the Baidu channel for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether to enable the Baidu channel for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The secret key that you received from the Baidu Cloud Push service to communicate with the service.</p>
        pub fn secret_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_key = Some(input.into());
            self
        }
        /// <p>The secret key that you received from the Baidu Cloud Push service to communicate with the service.</p>
        pub fn set_secret_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.secret_key = input;
            self
        }
        /// Consumes the builder and constructs a [`BaiduChannelRequest`](crate::model::BaiduChannelRequest)
        pub fn build(self) -> crate::model::BaiduChannelRequest {
            crate::model::BaiduChannelRequest {
                api_key: self.api_key,
                enabled: self.enabled.unwrap_or_default(),
                secret_key: self.secret_key,
            }
        }
    }
}
impl BaiduChannelRequest {
    /// Creates a new builder-style object to manufacture [`BaiduChannelRequest`](crate::model::BaiduChannelRequest)
    pub fn builder() -> crate::model::baidu_channel_request::Builder {
        crate::model::baidu_channel_request::Builder::default()
    }
}

/// <p>Provides information about an application, including the default settings for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationSettingsResource {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application. You can use this hook to customize segments that are used by campaigns in the application.</p>
    pub campaign_hook: std::option::Option<crate::model::CampaignHook>,
    /// <p>The date and time, in ISO 8601 format, when the application's settings were last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The default sending limits for campaigns in the application.</p>
    pub limits: std::option::Option<crate::model::CampaignLimits>,
    /// <p>The default quiet time for campaigns in the application. Quiet time is a specific time range when messages aren't sent to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign or journey that has custom quiet time settings).</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign or journey that has custom quiet time settings).</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign or journey, even if quiet time is enabled.</p>
    pub quiet_time: std::option::Option<crate::model::QuietTime>,
}
impl std::fmt::Debug for ApplicationSettingsResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationSettingsResource");
        formatter.field("application_id", &self.application_id);
        formatter.field("campaign_hook", &self.campaign_hook);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("limits", &self.limits);
        formatter.field("quiet_time", &self.quiet_time);
        formatter.finish()
    }
}
/// See [`ApplicationSettingsResource`](crate::model::ApplicationSettingsResource)
pub mod application_settings_resource {
    /// A builder for [`ApplicationSettingsResource`](crate::model::ApplicationSettingsResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) campaign_hook: std::option::Option<crate::model::CampaignHook>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) limits: std::option::Option<crate::model::CampaignLimits>,
        pub(crate) quiet_time: std::option::Option<crate::model::QuietTime>,
    }
    impl Builder {
        /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application. You can use this hook to customize segments that are used by campaigns in the application.</p>
        pub fn campaign_hook(mut self, input: crate::model::CampaignHook) -> Self {
            self.campaign_hook = Some(input);
            self
        }
        /// <p>The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application. You can use this hook to customize segments that are used by campaigns in the application.</p>
        pub fn set_campaign_hook(
            mut self,
            input: std::option::Option<crate::model::CampaignHook>,
        ) -> Self {
            self.campaign_hook = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the application's settings were last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the application's settings were last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The default sending limits for campaigns in the application.</p>
        pub fn limits(mut self, input: crate::model::CampaignLimits) -> Self {
            self.limits = Some(input);
            self
        }
        /// <p>The default sending limits for campaigns in the application.</p>
        pub fn set_limits(
            mut self,
            input: std::option::Option<crate::model::CampaignLimits>,
        ) -> Self {
            self.limits = input;
            self
        }
        /// <p>The default quiet time for campaigns in the application. Quiet time is a specific time range when messages aren't sent to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign or journey that has custom quiet time settings).</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign or journey that has custom quiet time settings).</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign or journey, even if quiet time is enabled.</p>
        pub fn quiet_time(mut self, input: crate::model::QuietTime) -> Self {
            self.quiet_time = Some(input);
            self
        }
        /// <p>The default quiet time for campaigns in the application. Quiet time is a specific time range when messages aren't sent to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign or journey that has custom quiet time settings).</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign or journey that has custom quiet time settings).</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign or journey, even if quiet time is enabled.</p>
        pub fn set_quiet_time(
            mut self,
            input: std::option::Option<crate::model::QuietTime>,
        ) -> Self {
            self.quiet_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationSettingsResource`](crate::model::ApplicationSettingsResource)
        pub fn build(self) -> crate::model::ApplicationSettingsResource {
            crate::model::ApplicationSettingsResource {
                application_id: self.application_id,
                campaign_hook: self.campaign_hook,
                last_modified_date: self.last_modified_date,
                limits: self.limits,
                quiet_time: self.quiet_time,
            }
        }
    }
}
impl ApplicationSettingsResource {
    /// Creates a new builder-style object to manufacture [`ApplicationSettingsResource`](crate::model::ApplicationSettingsResource)
    pub fn builder() -> crate::model::application_settings_resource::Builder {
        crate::model::application_settings_resource::Builder::default()
    }
}

/// <p>Specifies the default settings for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WriteApplicationSettingsRequest {
    /// <p>The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application. You can use this hook to customize segments that are used by campaigns in the application.</p> <p>To override these settings and define custom settings for a specific campaign, use the CampaignHook object of the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource.</p>
    pub campaign_hook: std::option::Option<crate::model::CampaignHook>,
    /// <p>Specifies whether to enable application-related alarms in Amazon CloudWatch.</p>
    pub cloud_watch_metrics_enabled: bool,
    #[allow(missing_docs)] // documentation missing in model
    pub event_tagging_enabled: bool,
    /// <p>The default sending limits for campaigns in the application. To override these limits and define custom limits for a specific campaign or journey, use the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource or the <link  linkend="apps-application-id-journeys-journey-id">Journey</link> resource, respectively.</p>
    pub limits: std::option::Option<crate::model::CampaignLimits>,
    /// <p>The default quiet time for campaigns in the application. Quiet time is a specific time range when messages aren't sent to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign or journey that has custom quiet time settings).</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign or journey that has custom quiet time settings).</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign or journey, even if quiet time is enabled.</p> <p>To override the default quiet time settings for a specific campaign or journey, use the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource or the <link  linkend="apps-application-id-journeys-journey-id">Journey</link> resource to define a custom quiet time for the campaign or journey.</p>
    pub quiet_time: std::option::Option<crate::model::QuietTime>,
}
impl std::fmt::Debug for WriteApplicationSettingsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WriteApplicationSettingsRequest");
        formatter.field("campaign_hook", &self.campaign_hook);
        formatter.field(
            "cloud_watch_metrics_enabled",
            &self.cloud_watch_metrics_enabled,
        );
        formatter.field("event_tagging_enabled", &self.event_tagging_enabled);
        formatter.field("limits", &self.limits);
        formatter.field("quiet_time", &self.quiet_time);
        formatter.finish()
    }
}
/// See [`WriteApplicationSettingsRequest`](crate::model::WriteApplicationSettingsRequest)
pub mod write_application_settings_request {
    /// A builder for [`WriteApplicationSettingsRequest`](crate::model::WriteApplicationSettingsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) campaign_hook: std::option::Option<crate::model::CampaignHook>,
        pub(crate) cloud_watch_metrics_enabled: std::option::Option<bool>,
        pub(crate) event_tagging_enabled: std::option::Option<bool>,
        pub(crate) limits: std::option::Option<crate::model::CampaignLimits>,
        pub(crate) quiet_time: std::option::Option<crate::model::QuietTime>,
    }
    impl Builder {
        /// <p>The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application. You can use this hook to customize segments that are used by campaigns in the application.</p> <p>To override these settings and define custom settings for a specific campaign, use the CampaignHook object of the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource.</p>
        pub fn campaign_hook(mut self, input: crate::model::CampaignHook) -> Self {
            self.campaign_hook = Some(input);
            self
        }
        /// <p>The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application. You can use this hook to customize segments that are used by campaigns in the application.</p> <p>To override these settings and define custom settings for a specific campaign, use the CampaignHook object of the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource.</p>
        pub fn set_campaign_hook(
            mut self,
            input: std::option::Option<crate::model::CampaignHook>,
        ) -> Self {
            self.campaign_hook = input;
            self
        }
        /// <p>Specifies whether to enable application-related alarms in Amazon CloudWatch.</p>
        pub fn cloud_watch_metrics_enabled(mut self, input: bool) -> Self {
            self.cloud_watch_metrics_enabled = Some(input);
            self
        }
        /// <p>Specifies whether to enable application-related alarms in Amazon CloudWatch.</p>
        pub fn set_cloud_watch_metrics_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.cloud_watch_metrics_enabled = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn event_tagging_enabled(mut self, input: bool) -> Self {
            self.event_tagging_enabled = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn set_event_tagging_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.event_tagging_enabled = input;
            self
        }
        /// <p>The default sending limits for campaigns in the application. To override these limits and define custom limits for a specific campaign or journey, use the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource or the <link  linkend="apps-application-id-journeys-journey-id">Journey</link> resource, respectively.</p>
        pub fn limits(mut self, input: crate::model::CampaignLimits) -> Self {
            self.limits = Some(input);
            self
        }
        /// <p>The default sending limits for campaigns in the application. To override these limits and define custom limits for a specific campaign or journey, use the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource or the <link  linkend="apps-application-id-journeys-journey-id">Journey</link> resource, respectively.</p>
        pub fn set_limits(
            mut self,
            input: std::option::Option<crate::model::CampaignLimits>,
        ) -> Self {
            self.limits = input;
            self
        }
        /// <p>The default quiet time for campaigns in the application. Quiet time is a specific time range when messages aren't sent to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign or journey that has custom quiet time settings).</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign or journey that has custom quiet time settings).</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign or journey, even if quiet time is enabled.</p> <p>To override the default quiet time settings for a specific campaign or journey, use the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource or the <link  linkend="apps-application-id-journeys-journey-id">Journey</link> resource to define a custom quiet time for the campaign or journey.</p>
        pub fn quiet_time(mut self, input: crate::model::QuietTime) -> Self {
            self.quiet_time = Some(input);
            self
        }
        /// <p>The default quiet time for campaigns in the application. Quiet time is a specific time range when messages aren't sent to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign or journey that has custom quiet time settings).</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign or journey that has custom quiet time settings).</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign or journey, even if quiet time is enabled.</p> <p>To override the default quiet time settings for a specific campaign or journey, use the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource or the <link  linkend="apps-application-id-journeys-journey-id">Journey</link> resource to define a custom quiet time for the campaign or journey.</p>
        pub fn set_quiet_time(
            mut self,
            input: std::option::Option<crate::model::QuietTime>,
        ) -> Self {
            self.quiet_time = input;
            self
        }
        /// Consumes the builder and constructs a [`WriteApplicationSettingsRequest`](crate::model::WriteApplicationSettingsRequest)
        pub fn build(self) -> crate::model::WriteApplicationSettingsRequest {
            crate::model::WriteApplicationSettingsRequest {
                campaign_hook: self.campaign_hook,
                cloud_watch_metrics_enabled: self.cloud_watch_metrics_enabled.unwrap_or_default(),
                event_tagging_enabled: self.event_tagging_enabled.unwrap_or_default(),
                limits: self.limits,
                quiet_time: self.quiet_time,
            }
        }
    }
}
impl WriteApplicationSettingsRequest {
    /// Creates a new builder-style object to manufacture [`WriteApplicationSettingsRequest`](crate::model::WriteApplicationSettingsRequest)
    pub fn builder() -> crate::model::write_application_settings_request::Builder {
        crate::model::write_application_settings_request::Builder::default()
    }
}

/// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApnsVoipSandboxChannelResponse {
    /// <p>The unique identifier for the application that the APNs VoIP sandbox channel applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date and time when the APNs VoIP sandbox channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.</p>
    pub default_authentication_method: std::option::Option<std::string::String>,
    /// <p>Specifies whether the APNs VoIP sandbox channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>Specifies whether the APNs VoIP sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
    pub has_token_key: bool,
    /// <p>(Deprecated) An identifier for the APNs VoIP sandbox channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the APNs VoIP sandbox channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the APNs VoIP sandbox channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the APNs VoIP sandbox channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The type of messaging or notification platform for the channel. For the APNs VoIP sandbox channel, this value is APNS_VOIP_SANDBOX.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current version of the APNs VoIP sandbox channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for ApnsVoipSandboxChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApnsVoipSandboxChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field(
            "default_authentication_method",
            &self.default_authentication_method,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("has_token_key", &self.has_token_key);
        formatter.field("id", &self.id);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("platform", &self.platform);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`ApnsVoipSandboxChannelResponse`](crate::model::ApnsVoipSandboxChannelResponse)
pub mod apns_voip_sandbox_channel_response {
    /// A builder for [`ApnsVoipSandboxChannelResponse`](crate::model::ApnsVoipSandboxChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) default_authentication_method: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) has_token_key: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the APNs VoIP sandbox channel applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the APNs VoIP sandbox channel applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date and time when the APNs VoIP sandbox channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time when the APNs VoIP sandbox channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.</p>
        pub fn default_authentication_method(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_authentication_method = Some(input.into());
            self
        }
        /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.</p>
        pub fn set_default_authentication_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_authentication_method = input;
            self
        }
        /// <p>Specifies whether the APNs VoIP sandbox channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the APNs VoIP sandbox channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>Specifies whether the APNs VoIP sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
        pub fn has_token_key(mut self, input: bool) -> Self {
            self.has_token_key = Some(input);
            self
        }
        /// <p>Specifies whether the APNs VoIP sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
        pub fn set_has_token_key(mut self, input: std::option::Option<bool>) -> Self {
            self.has_token_key = input;
            self
        }
        /// <p>(Deprecated) An identifier for the APNs VoIP sandbox channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the APNs VoIP sandbox channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the APNs VoIP sandbox channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the APNs VoIP sandbox channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the APNs VoIP sandbox channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the APNs VoIP sandbox channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time when the APNs VoIP sandbox channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time when the APNs VoIP sandbox channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the APNs VoIP sandbox channel, this value is APNS_VOIP_SANDBOX.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the APNs VoIP sandbox channel, this value is APNS_VOIP_SANDBOX.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current version of the APNs VoIP sandbox channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the APNs VoIP sandbox channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`ApnsVoipSandboxChannelResponse`](crate::model::ApnsVoipSandboxChannelResponse)
        pub fn build(self) -> crate::model::ApnsVoipSandboxChannelResponse {
            crate::model::ApnsVoipSandboxChannelResponse {
                application_id: self.application_id,
                creation_date: self.creation_date,
                default_authentication_method: self.default_authentication_method,
                enabled: self.enabled.unwrap_or_default(),
                has_credential: self.has_credential.unwrap_or_default(),
                has_token_key: self.has_token_key.unwrap_or_default(),
                id: self.id,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                platform: self.platform,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl ApnsVoipSandboxChannelResponse {
    /// Creates a new builder-style object to manufacture [`ApnsVoipSandboxChannelResponse`](crate::model::ApnsVoipSandboxChannelResponse)
    pub fn builder() -> crate::model::apns_voip_sandbox_channel_response::Builder {
        crate::model::apns_voip_sandbox_channel_response::Builder::default()
    }
}

/// <p>Specifies the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApnsVoipSandboxChannelRequest {
    /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.</p>
    pub certificate: std::option::Option<std::string::String>,
    /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment for this channel, key or certificate.</p>
    pub default_authentication_method: std::option::Option<std::string::String>,
    /// <p>Specifies whether the APNs VoIP sandbox channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.</p>
    pub private_key: std::option::Option<std::string::String>,
    /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
    pub team_id: std::option::Option<std::string::String>,
    /// <p>The authentication key to use for APNs tokens.</p>
    pub token_key: std::option::Option<std::string::String>,
    /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.</p>
    pub token_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApnsVoipSandboxChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApnsVoipSandboxChannelRequest");
        formatter.field("bundle_id", &self.bundle_id);
        formatter.field("certificate", &self.certificate);
        formatter.field(
            "default_authentication_method",
            &self.default_authentication_method,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field("private_key", &self.private_key);
        formatter.field("team_id", &self.team_id);
        formatter.field("token_key", &self.token_key);
        formatter.field("token_key_id", &self.token_key_id);
        formatter.finish()
    }
}
/// See [`ApnsVoipSandboxChannelRequest`](crate::model::ApnsVoipSandboxChannelRequest)
pub mod apns_voip_sandbox_channel_request {
    /// A builder for [`ApnsVoipSandboxChannelRequest`](crate::model::ApnsVoipSandboxChannelRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) certificate: std::option::Option<std::string::String>,
        pub(crate) default_authentication_method: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) private_key: std::option::Option<std::string::String>,
        pub(crate) team_id: std::option::Option<std::string::String>,
        pub(crate) token_key: std::option::Option<std::string::String>,
        pub(crate) token_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.</p>
        pub fn certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate = Some(input.into());
            self
        }
        /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.</p>
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.certificate = input;
            self
        }
        /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment for this channel, key or certificate.</p>
        pub fn default_authentication_method(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_authentication_method = Some(input.into());
            self
        }
        /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment for this channel, key or certificate.</p>
        pub fn set_default_authentication_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_authentication_method = input;
            self
        }
        /// <p>Specifies whether the APNs VoIP sandbox channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the APNs VoIP sandbox channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.</p>
        pub fn private_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_key = Some(input.into());
            self
        }
        /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.</p>
        pub fn set_private_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.private_key = input;
            self
        }
        /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
        pub fn team_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.team_id = Some(input.into());
            self
        }
        /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
        pub fn set_team_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.team_id = input;
            self
        }
        /// <p>The authentication key to use for APNs tokens.</p>
        pub fn token_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_key = Some(input.into());
            self
        }
        /// <p>The authentication key to use for APNs tokens.</p>
        pub fn set_token_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token_key = input;
            self
        }
        /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.</p>
        pub fn token_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_key_id = Some(input.into());
            self
        }
        /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.</p>
        pub fn set_token_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ApnsVoipSandboxChannelRequest`](crate::model::ApnsVoipSandboxChannelRequest)
        pub fn build(self) -> crate::model::ApnsVoipSandboxChannelRequest {
            crate::model::ApnsVoipSandboxChannelRequest {
                bundle_id: self.bundle_id,
                certificate: self.certificate,
                default_authentication_method: self.default_authentication_method,
                enabled: self.enabled.unwrap_or_default(),
                private_key: self.private_key,
                team_id: self.team_id,
                token_key: self.token_key,
                token_key_id: self.token_key_id,
            }
        }
    }
}
impl ApnsVoipSandboxChannelRequest {
    /// Creates a new builder-style object to manufacture [`ApnsVoipSandboxChannelRequest`](crate::model::ApnsVoipSandboxChannelRequest)
    pub fn builder() -> crate::model::apns_voip_sandbox_channel_request::Builder {
        crate::model::apns_voip_sandbox_channel_request::Builder::default()
    }
}

/// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApnsVoipChannelResponse {
    /// <p>The unique identifier for the application that the APNs VoIP channel applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date and time when the APNs VoIP channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.</p>
    pub default_authentication_method: std::option::Option<std::string::String>,
    /// <p>Specifies whether the APNs VoIP channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>Specifies whether the APNs VoIP channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
    pub has_token_key: bool,
    /// <p>(Deprecated) An identifier for the APNs VoIP channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the APNs VoIP channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the APNs VoIP channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the APNs VoIP channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The type of messaging or notification platform for the channel. For the APNs VoIP channel, this value is APNS_VOIP.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current version of the APNs VoIP channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for ApnsVoipChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApnsVoipChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field(
            "default_authentication_method",
            &self.default_authentication_method,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("has_token_key", &self.has_token_key);
        formatter.field("id", &self.id);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("platform", &self.platform);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`ApnsVoipChannelResponse`](crate::model::ApnsVoipChannelResponse)
pub mod apns_voip_channel_response {
    /// A builder for [`ApnsVoipChannelResponse`](crate::model::ApnsVoipChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) default_authentication_method: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) has_token_key: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the APNs VoIP channel applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the APNs VoIP channel applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date and time when the APNs VoIP channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time when the APNs VoIP channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.</p>
        pub fn default_authentication_method(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_authentication_method = Some(input.into());
            self
        }
        /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.</p>
        pub fn set_default_authentication_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_authentication_method = input;
            self
        }
        /// <p>Specifies whether the APNs VoIP channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the APNs VoIP channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>Specifies whether the APNs VoIP channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
        pub fn has_token_key(mut self, input: bool) -> Self {
            self.has_token_key = Some(input);
            self
        }
        /// <p>Specifies whether the APNs VoIP channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
        pub fn set_has_token_key(mut self, input: std::option::Option<bool>) -> Self {
            self.has_token_key = input;
            self
        }
        /// <p>(Deprecated) An identifier for the APNs VoIP channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the APNs VoIP channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the APNs VoIP channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the APNs VoIP channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the APNs VoIP channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the APNs VoIP channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time when the APNs VoIP channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time when the APNs VoIP channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the APNs VoIP channel, this value is APNS_VOIP.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the APNs VoIP channel, this value is APNS_VOIP.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current version of the APNs VoIP channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the APNs VoIP channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`ApnsVoipChannelResponse`](crate::model::ApnsVoipChannelResponse)
        pub fn build(self) -> crate::model::ApnsVoipChannelResponse {
            crate::model::ApnsVoipChannelResponse {
                application_id: self.application_id,
                creation_date: self.creation_date,
                default_authentication_method: self.default_authentication_method,
                enabled: self.enabled.unwrap_or_default(),
                has_credential: self.has_credential.unwrap_or_default(),
                has_token_key: self.has_token_key.unwrap_or_default(),
                id: self.id,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                platform: self.platform,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl ApnsVoipChannelResponse {
    /// Creates a new builder-style object to manufacture [`ApnsVoipChannelResponse`](crate::model::ApnsVoipChannelResponse)
    pub fn builder() -> crate::model::apns_voip_channel_response::Builder {
        crate::model::apns_voip_channel_response::Builder::default()
    }
}

/// <p>Specifies the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApnsVoipChannelRequest {
    /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.</p>
    pub certificate: std::option::Option<std::string::String>,
    /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.</p>
    pub default_authentication_method: std::option::Option<std::string::String>,
    /// <p>Specifies whether to enable the APNs VoIP channel for the application.</p>
    pub enabled: bool,
    /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.</p>
    pub private_key: std::option::Option<std::string::String>,
    /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
    pub team_id: std::option::Option<std::string::String>,
    /// <p>The authentication key to use for APNs tokens.</p>
    pub token_key: std::option::Option<std::string::String>,
    /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.</p>
    pub token_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApnsVoipChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApnsVoipChannelRequest");
        formatter.field("bundle_id", &self.bundle_id);
        formatter.field("certificate", &self.certificate);
        formatter.field(
            "default_authentication_method",
            &self.default_authentication_method,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field("private_key", &self.private_key);
        formatter.field("team_id", &self.team_id);
        formatter.field("token_key", &self.token_key);
        formatter.field("token_key_id", &self.token_key_id);
        formatter.finish()
    }
}
/// See [`ApnsVoipChannelRequest`](crate::model::ApnsVoipChannelRequest)
pub mod apns_voip_channel_request {
    /// A builder for [`ApnsVoipChannelRequest`](crate::model::ApnsVoipChannelRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) certificate: std::option::Option<std::string::String>,
        pub(crate) default_authentication_method: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) private_key: std::option::Option<std::string::String>,
        pub(crate) team_id: std::option::Option<std::string::String>,
        pub(crate) token_key: std::option::Option<std::string::String>,
        pub(crate) token_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.</p>
        pub fn certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate = Some(input.into());
            self
        }
        /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.</p>
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.certificate = input;
            self
        }
        /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.</p>
        pub fn default_authentication_method(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_authentication_method = Some(input.into());
            self
        }
        /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.</p>
        pub fn set_default_authentication_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_authentication_method = input;
            self
        }
        /// <p>Specifies whether to enable the APNs VoIP channel for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether to enable the APNs VoIP channel for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.</p>
        pub fn private_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_key = Some(input.into());
            self
        }
        /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.</p>
        pub fn set_private_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.private_key = input;
            self
        }
        /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
        pub fn team_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.team_id = Some(input.into());
            self
        }
        /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
        pub fn set_team_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.team_id = input;
            self
        }
        /// <p>The authentication key to use for APNs tokens.</p>
        pub fn token_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_key = Some(input.into());
            self
        }
        /// <p>The authentication key to use for APNs tokens.</p>
        pub fn set_token_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token_key = input;
            self
        }
        /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.</p>
        pub fn token_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_key_id = Some(input.into());
            self
        }
        /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.</p>
        pub fn set_token_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ApnsVoipChannelRequest`](crate::model::ApnsVoipChannelRequest)
        pub fn build(self) -> crate::model::ApnsVoipChannelRequest {
            crate::model::ApnsVoipChannelRequest {
                bundle_id: self.bundle_id,
                certificate: self.certificate,
                default_authentication_method: self.default_authentication_method,
                enabled: self.enabled.unwrap_or_default(),
                private_key: self.private_key,
                team_id: self.team_id,
                token_key: self.token_key,
                token_key_id: self.token_key_id,
            }
        }
    }
}
impl ApnsVoipChannelRequest {
    /// Creates a new builder-style object to manufacture [`ApnsVoipChannelRequest`](crate::model::ApnsVoipChannelRequest)
    pub fn builder() -> crate::model::apns_voip_channel_request::Builder {
        crate::model::apns_voip_channel_request::Builder::default()
    }
}

/// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApnsSandboxChannelResponse {
    /// <p>The unique identifier for the application that the APNs sandbox channel applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date and time when the APNs sandbox channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.</p>
    pub default_authentication_method: std::option::Option<std::string::String>,
    /// <p>Specifies whether the APNs sandbox channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>Specifies whether the APNs sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
    pub has_token_key: bool,
    /// <p>(Deprecated) An identifier for the APNs sandbox channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the APNs sandbox channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the APNs sandbox channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the APNs sandbox channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The type of messaging or notification platform for the channel. For the APNs sandbox channel, this value is APNS_SANDBOX.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current version of the APNs sandbox channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for ApnsSandboxChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApnsSandboxChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field(
            "default_authentication_method",
            &self.default_authentication_method,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("has_token_key", &self.has_token_key);
        formatter.field("id", &self.id);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("platform", &self.platform);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`ApnsSandboxChannelResponse`](crate::model::ApnsSandboxChannelResponse)
pub mod apns_sandbox_channel_response {
    /// A builder for [`ApnsSandboxChannelResponse`](crate::model::ApnsSandboxChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) default_authentication_method: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) has_token_key: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the APNs sandbox channel applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the APNs sandbox channel applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date and time when the APNs sandbox channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time when the APNs sandbox channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.</p>
        pub fn default_authentication_method(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_authentication_method = Some(input.into());
            self
        }
        /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.</p>
        pub fn set_default_authentication_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_authentication_method = input;
            self
        }
        /// <p>Specifies whether the APNs sandbox channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the APNs sandbox channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>Specifies whether the APNs sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
        pub fn has_token_key(mut self, input: bool) -> Self {
            self.has_token_key = Some(input);
            self
        }
        /// <p>Specifies whether the APNs sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
        pub fn set_has_token_key(mut self, input: std::option::Option<bool>) -> Self {
            self.has_token_key = input;
            self
        }
        /// <p>(Deprecated) An identifier for the APNs sandbox channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the APNs sandbox channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the APNs sandbox channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the APNs sandbox channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the APNs sandbox channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the APNs sandbox channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time when the APNs sandbox channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time when the APNs sandbox channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the APNs sandbox channel, this value is APNS_SANDBOX.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the APNs sandbox channel, this value is APNS_SANDBOX.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current version of the APNs sandbox channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the APNs sandbox channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`ApnsSandboxChannelResponse`](crate::model::ApnsSandboxChannelResponse)
        pub fn build(self) -> crate::model::ApnsSandboxChannelResponse {
            crate::model::ApnsSandboxChannelResponse {
                application_id: self.application_id,
                creation_date: self.creation_date,
                default_authentication_method: self.default_authentication_method,
                enabled: self.enabled.unwrap_or_default(),
                has_credential: self.has_credential.unwrap_or_default(),
                has_token_key: self.has_token_key.unwrap_or_default(),
                id: self.id,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                platform: self.platform,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl ApnsSandboxChannelResponse {
    /// Creates a new builder-style object to manufacture [`ApnsSandboxChannelResponse`](crate::model::ApnsSandboxChannelResponse)
    pub fn builder() -> crate::model::apns_sandbox_channel_response::Builder {
        crate::model::apns_sandbox_channel_response::Builder::default()
    }
}

/// <p>Specifies the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApnsSandboxChannelRequest {
    /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.</p>
    pub certificate: std::option::Option<std::string::String>,
    /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment, key or certificate.</p>
    pub default_authentication_method: std::option::Option<std::string::String>,
    /// <p>Specifies whether to enable the APNs sandbox channel for the application.</p>
    pub enabled: bool,
    /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.</p>
    pub private_key: std::option::Option<std::string::String>,
    /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
    pub team_id: std::option::Option<std::string::String>,
    /// <p>The authentication key to use for APNs tokens.</p>
    pub token_key: std::option::Option<std::string::String>,
    /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.</p>
    pub token_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApnsSandboxChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApnsSandboxChannelRequest");
        formatter.field("bundle_id", &self.bundle_id);
        formatter.field("certificate", &self.certificate);
        formatter.field(
            "default_authentication_method",
            &self.default_authentication_method,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field("private_key", &self.private_key);
        formatter.field("team_id", &self.team_id);
        formatter.field("token_key", &self.token_key);
        formatter.field("token_key_id", &self.token_key_id);
        formatter.finish()
    }
}
/// See [`ApnsSandboxChannelRequest`](crate::model::ApnsSandboxChannelRequest)
pub mod apns_sandbox_channel_request {
    /// A builder for [`ApnsSandboxChannelRequest`](crate::model::ApnsSandboxChannelRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) certificate: std::option::Option<std::string::String>,
        pub(crate) default_authentication_method: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) private_key: std::option::Option<std::string::String>,
        pub(crate) team_id: std::option::Option<std::string::String>,
        pub(crate) token_key: std::option::Option<std::string::String>,
        pub(crate) token_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.</p>
        pub fn certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate = Some(input.into());
            self
        }
        /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.</p>
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.certificate = input;
            self
        }
        /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment, key or certificate.</p>
        pub fn default_authentication_method(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_authentication_method = Some(input.into());
            self
        }
        /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment, key or certificate.</p>
        pub fn set_default_authentication_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_authentication_method = input;
            self
        }
        /// <p>Specifies whether to enable the APNs sandbox channel for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether to enable the APNs sandbox channel for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.</p>
        pub fn private_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_key = Some(input.into());
            self
        }
        /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.</p>
        pub fn set_private_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.private_key = input;
            self
        }
        /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
        pub fn team_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.team_id = Some(input.into());
            self
        }
        /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
        pub fn set_team_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.team_id = input;
            self
        }
        /// <p>The authentication key to use for APNs tokens.</p>
        pub fn token_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_key = Some(input.into());
            self
        }
        /// <p>The authentication key to use for APNs tokens.</p>
        pub fn set_token_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token_key = input;
            self
        }
        /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.</p>
        pub fn token_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_key_id = Some(input.into());
            self
        }
        /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.</p>
        pub fn set_token_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ApnsSandboxChannelRequest`](crate::model::ApnsSandboxChannelRequest)
        pub fn build(self) -> crate::model::ApnsSandboxChannelRequest {
            crate::model::ApnsSandboxChannelRequest {
                bundle_id: self.bundle_id,
                certificate: self.certificate,
                default_authentication_method: self.default_authentication_method,
                enabled: self.enabled.unwrap_or_default(),
                private_key: self.private_key,
                team_id: self.team_id,
                token_key: self.token_key,
                token_key_id: self.token_key_id,
            }
        }
    }
}
impl ApnsSandboxChannelRequest {
    /// Creates a new builder-style object to manufacture [`ApnsSandboxChannelRequest`](crate::model::ApnsSandboxChannelRequest)
    pub fn builder() -> crate::model::apns_sandbox_channel_request::Builder {
        crate::model::apns_sandbox_channel_request::Builder::default()
    }
}

/// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApnsChannelResponse {
    /// <p>The unique identifier for the application that the APNs channel applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date and time when the APNs channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.</p>
    pub default_authentication_method: std::option::Option<std::string::String>,
    /// <p>Specifies whether the APNs channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>Specifies whether the APNs channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
    pub has_token_key: bool,
    /// <p>(Deprecated) An identifier for the APNs channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the APNs channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the APNs channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the APNs channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The type of messaging or notification platform for the channel. For the APNs channel, this value is APNS.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current version of the APNs channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for ApnsChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApnsChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field(
            "default_authentication_method",
            &self.default_authentication_method,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("has_token_key", &self.has_token_key);
        formatter.field("id", &self.id);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("platform", &self.platform);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`ApnsChannelResponse`](crate::model::ApnsChannelResponse)
pub mod apns_channel_response {
    /// A builder for [`ApnsChannelResponse`](crate::model::ApnsChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) default_authentication_method: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) has_token_key: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the APNs channel applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the APNs channel applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date and time when the APNs channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time when the APNs channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.</p>
        pub fn default_authentication_method(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_authentication_method = Some(input.into());
            self
        }
        /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.</p>
        pub fn set_default_authentication_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_authentication_method = input;
            self
        }
        /// <p>Specifies whether the APNs channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the APNs channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>Specifies whether the APNs channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
        pub fn has_token_key(mut self, input: bool) -> Self {
            self.has_token_key = Some(input);
            self
        }
        /// <p>Specifies whether the APNs channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
        pub fn set_has_token_key(mut self, input: std::option::Option<bool>) -> Self {
            self.has_token_key = input;
            self
        }
        /// <p>(Deprecated) An identifier for the APNs channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the APNs channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the APNs channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the APNs channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the APNs channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the APNs channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time when the APNs channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time when the APNs channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the APNs channel, this value is APNS.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the APNs channel, this value is APNS.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current version of the APNs channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the APNs channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`ApnsChannelResponse`](crate::model::ApnsChannelResponse)
        pub fn build(self) -> crate::model::ApnsChannelResponse {
            crate::model::ApnsChannelResponse {
                application_id: self.application_id,
                creation_date: self.creation_date,
                default_authentication_method: self.default_authentication_method,
                enabled: self.enabled.unwrap_or_default(),
                has_credential: self.has_credential.unwrap_or_default(),
                has_token_key: self.has_token_key.unwrap_or_default(),
                id: self.id,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                platform: self.platform,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl ApnsChannelResponse {
    /// Creates a new builder-style object to manufacture [`ApnsChannelResponse`](crate::model::ApnsChannelResponse)
    pub fn builder() -> crate::model::apns_channel_response::Builder {
        crate::model::apns_channel_response::Builder::default()
    }
}

/// <p>Specifies the status and settings of the APNs (Apple Push Notification service) channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApnsChannelRequest {
    /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.</p>
    pub certificate: std::option::Option<std::string::String>,
    /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.</p>
    pub default_authentication_method: std::option::Option<std::string::String>,
    /// <p>Specifies whether to enable the APNs channel for the application.</p>
    pub enabled: bool,
    /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.</p>
    pub private_key: std::option::Option<std::string::String>,
    /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
    pub team_id: std::option::Option<std::string::String>,
    /// <p>The authentication key to use for APNs tokens.</p>
    pub token_key: std::option::Option<std::string::String>,
    /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.</p>
    pub token_key_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApnsChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApnsChannelRequest");
        formatter.field("bundle_id", &self.bundle_id);
        formatter.field("certificate", &self.certificate);
        formatter.field(
            "default_authentication_method",
            &self.default_authentication_method,
        );
        formatter.field("enabled", &self.enabled);
        formatter.field("private_key", &self.private_key);
        formatter.field("team_id", &self.team_id);
        formatter.field("token_key", &self.token_key);
        formatter.field("token_key_id", &self.token_key_id);
        formatter.finish()
    }
}
/// See [`ApnsChannelRequest`](crate::model::ApnsChannelRequest)
pub mod apns_channel_request {
    /// A builder for [`ApnsChannelRequest`](crate::model::ApnsChannelRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) certificate: std::option::Option<std::string::String>,
        pub(crate) default_authentication_method: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) private_key: std::option::Option<std::string::String>,
        pub(crate) team_id: std::option::Option<std::string::String>,
        pub(crate) token_key: std::option::Option<std::string::String>,
        pub(crate) token_key_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.</p>
        pub fn certificate(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate = Some(input.into());
            self
        }
        /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.</p>
        pub fn set_certificate(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.certificate = input;
            self
        }
        /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.</p>
        pub fn default_authentication_method(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.default_authentication_method = Some(input.into());
            self
        }
        /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.</p>
        pub fn set_default_authentication_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_authentication_method = input;
            self
        }
        /// <p>Specifies whether to enable the APNs channel for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether to enable the APNs channel for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.</p>
        pub fn private_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.private_key = Some(input.into());
            self
        }
        /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.</p>
        pub fn set_private_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.private_key = input;
            self
        }
        /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
        pub fn team_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.team_id = Some(input.into());
            self
        }
        /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
        pub fn set_team_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.team_id = input;
            self
        }
        /// <p>The authentication key to use for APNs tokens.</p>
        pub fn token_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_key = Some(input.into());
            self
        }
        /// <p>The authentication key to use for APNs tokens.</p>
        pub fn set_token_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token_key = input;
            self
        }
        /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.</p>
        pub fn token_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.token_key_id = Some(input.into());
            self
        }
        /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.</p>
        pub fn set_token_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.token_key_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ApnsChannelRequest`](crate::model::ApnsChannelRequest)
        pub fn build(self) -> crate::model::ApnsChannelRequest {
            crate::model::ApnsChannelRequest {
                bundle_id: self.bundle_id,
                certificate: self.certificate,
                default_authentication_method: self.default_authentication_method,
                enabled: self.enabled.unwrap_or_default(),
                private_key: self.private_key,
                team_id: self.team_id,
                token_key: self.token_key,
                token_key_id: self.token_key_id,
            }
        }
    }
}
impl ApnsChannelRequest {
    /// Creates a new builder-style object to manufacture [`ApnsChannelRequest`](crate::model::ApnsChannelRequest)
    pub fn builder() -> crate::model::apns_channel_request::Builder {
        crate::model::apns_channel_request::Builder::default()
    }
}

/// <p>Provides information about the status and settings of the ADM (Amazon Device Messaging) channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdmChannelResponse {
    /// <p>The unique identifier for the application that the ADM channel applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date and time when the ADM channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>Specifies whether the ADM channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>(Deprecated) An identifier for the ADM channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the ADM channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the ADM channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the ADM channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The type of messaging or notification platform for the channel. For the ADM channel, this value is ADM.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current version of the ADM channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for AdmChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdmChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("enabled", &self.enabled);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("id", &self.id);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("platform", &self.platform);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`AdmChannelResponse`](crate::model::AdmChannelResponse)
pub mod adm_channel_response {
    /// A builder for [`AdmChannelResponse`](crate::model::AdmChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the ADM channel applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the ADM channel applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date and time when the ADM channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time when the ADM channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>Specifies whether the ADM channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the ADM channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>(Deprecated) An identifier for the ADM channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the ADM channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the ADM channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the ADM channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the ADM channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the ADM channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time when the ADM channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time when the ADM channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the ADM channel, this value is ADM.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The type of messaging or notification platform for the channel. For the ADM channel, this value is ADM.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current version of the ADM channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the ADM channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`AdmChannelResponse`](crate::model::AdmChannelResponse)
        pub fn build(self) -> crate::model::AdmChannelResponse {
            crate::model::AdmChannelResponse {
                application_id: self.application_id,
                creation_date: self.creation_date,
                enabled: self.enabled.unwrap_or_default(),
                has_credential: self.has_credential.unwrap_or_default(),
                id: self.id,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                platform: self.platform,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl AdmChannelResponse {
    /// Creates a new builder-style object to manufacture [`AdmChannelResponse`](crate::model::AdmChannelResponse)
    pub fn builder() -> crate::model::adm_channel_response::Builder {
        crate::model::adm_channel_response::Builder::default()
    }
}

/// <p>Specifies the status and settings of the ADM (Amazon Device Messaging) channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdmChannelRequest {
    /// <p>The Client ID that you received from Amazon to send messages by using ADM.</p>
    pub client_id: std::option::Option<std::string::String>,
    /// <p>The Client Secret that you received from Amazon to send messages by using ADM.</p>
    pub client_secret: std::option::Option<std::string::String>,
    /// <p>Specifies whether to enable the ADM channel for the application.</p>
    pub enabled: bool,
}
impl std::fmt::Debug for AdmChannelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdmChannelRequest");
        formatter.field("client_id", &self.client_id);
        formatter.field("client_secret", &self.client_secret);
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`AdmChannelRequest`](crate::model::AdmChannelRequest)
pub mod adm_channel_request {
    /// A builder for [`AdmChannelRequest`](crate::model::AdmChannelRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) client_id: std::option::Option<std::string::String>,
        pub(crate) client_secret: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The Client ID that you received from Amazon to send messages by using ADM.</p>
        pub fn client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_id = Some(input.into());
            self
        }
        /// <p>The Client ID that you received from Amazon to send messages by using ADM.</p>
        pub fn set_client_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.client_id = input;
            self
        }
        /// <p>The Client Secret that you received from Amazon to send messages by using ADM.</p>
        pub fn client_secret(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_secret = Some(input.into());
            self
        }
        /// <p>The Client Secret that you received from Amazon to send messages by using ADM.</p>
        pub fn set_client_secret(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_secret = input;
            self
        }
        /// <p>Specifies whether to enable the ADM channel for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether to enable the ADM channel for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AdmChannelRequest`](crate::model::AdmChannelRequest)
        pub fn build(self) -> crate::model::AdmChannelRequest {
            crate::model::AdmChannelRequest {
                client_id: self.client_id,
                client_secret: self.client_secret,
                enabled: self.enabled.unwrap_or_default(),
            }
        }
    }
}
impl AdmChannelRequest {
    /// Creates a new builder-style object to manufacture [`AdmChannelRequest`](crate::model::AdmChannelRequest)
    pub fn builder() -> crate::model::adm_channel_request::Builder {
        crate::model::adm_channel_request::Builder::default()
    }
}

/// <p>Specifies the tags (keys and values) for an application, campaign, message template, or segment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagsModel {
    /// <p>A string-to-string map of key-value pairs that defines the tags for an application, campaign, message template, or segment. Each of these resources can have a maximum of 50 tags.</p> <p>Each tag consists of a required tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for TagsModel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagsModel");
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`TagsModel`](crate::model::TagsModel)
pub mod tags_model {
    /// A builder for [`TagsModel`](crate::model::TagsModel)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that defines the tags for an application, campaign, message template, or segment. Each of these resources can have a maximum of 50 tags.</p> <p>Each tag consists of a required tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that defines the tags for an application, campaign, message template, or segment. Each of these resources can have a maximum of 50 tags.</p> <p>Each tag consists of a required tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`TagsModel`](crate::model::TagsModel)
        pub fn build(self) -> crate::model::TagsModel {
            crate::model::TagsModel { tags: self.tags }
        }
    }
}
impl TagsModel {
    /// Creates a new builder-style object to manufacture [`TagsModel`](crate::model::TagsModel)
    pub fn builder() -> crate::model::tags_model::Builder {
        crate::model::tags_model::Builder::default()
    }
}

/// <p>Provides information about which users and endpoints a message was sent to.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendUsersMessageResponse {
    /// <p>The unique identifier for the application that was used to send the message.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier that was assigned to the message request.</p>
    pub request_id: std::option::Option<std::string::String>,
    /// <p>An object that indicates which endpoints the message was sent to, for each user. The object lists user IDs and, for each user ID, provides the endpoint IDs that the message was sent to. For each endpoint ID, it provides an EndpointMessageResult object.</p>
    pub result: std::option::Option<
        std::collections::HashMap<
            std::string::String,
            std::collections::HashMap<std::string::String, crate::model::EndpointMessageResult>,
        >,
    >,
}
impl std::fmt::Debug for SendUsersMessageResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendUsersMessageResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("request_id", &self.request_id);
        formatter.field("result", &self.result);
        formatter.finish()
    }
}
/// See [`SendUsersMessageResponse`](crate::model::SendUsersMessageResponse)
pub mod send_users_message_response {
    /// A builder for [`SendUsersMessageResponse`](crate::model::SendUsersMessageResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        pub(crate) result: std::option::Option<
            std::collections::HashMap<
                std::string::String,
                std::collections::HashMap<std::string::String, crate::model::EndpointMessageResult>,
            >,
        >,
    }
    impl Builder {
        /// <p>The unique identifier for the application that was used to send the message.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that was used to send the message.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The unique identifier that was assigned to the message request.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier that was assigned to the message request.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Adds a key-value pair to `result`.
        ///
        /// To override the contents of this collection use [`set_result`](Self::set_result).
        ///
        /// <p>An object that indicates which endpoints the message was sent to, for each user. The object lists user IDs and, for each user ID, provides the endpoint IDs that the message was sent to. For each endpoint ID, it provides an EndpointMessageResult object.</p>
        pub fn result(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<
                std::collections::HashMap<std::string::String, crate::model::EndpointMessageResult>,
            >,
        ) -> Self {
            let mut hash_map = self.result.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.result = Some(hash_map);
            self
        }
        /// <p>An object that indicates which endpoints the message was sent to, for each user. The object lists user IDs and, for each user ID, provides the endpoint IDs that the message was sent to. For each endpoint ID, it provides an EndpointMessageResult object.</p>
        pub fn set_result(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    std::collections::HashMap<
                        std::string::String,
                        crate::model::EndpointMessageResult,
                    >,
                >,
            >,
        ) -> Self {
            self.result = input;
            self
        }
        /// Consumes the builder and constructs a [`SendUsersMessageResponse`](crate::model::SendUsersMessageResponse)
        pub fn build(self) -> crate::model::SendUsersMessageResponse {
            crate::model::SendUsersMessageResponse {
                application_id: self.application_id,
                request_id: self.request_id,
                result: self.result,
            }
        }
    }
}
impl SendUsersMessageResponse {
    /// Creates a new builder-style object to manufacture [`SendUsersMessageResponse`](crate::model::SendUsersMessageResponse)
    pub fn builder() -> crate::model::send_users_message_response::Builder {
        crate::model::send_users_message_response::Builder::default()
    }
}

/// <p>Provides information about the delivery status and results of sending a message directly to an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointMessageResult {
    /// <p>The endpoint address that the message was delivered to.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>The delivery status of the message. Possible values are:</p> <ul> <li><p>DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>OPT_OUT - The user who's associated with the endpoint has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint. Amazon Pinpoint won't attempt to send the message again.</p></li>    <li><p>SUCCESSFUL - The message was successfully delivered to the endpoint.</p></li> <li><p>TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint.</p></li> <li><p>TIMEOUT - The message couldn't be sent within the timeout period.</p></li> <li><p>UNKNOWN_FAILURE - An unknown error occurred.</p></li></ul>
    pub delivery_status: std::option::Option<crate::model::DeliveryStatus>,
    /// <p>The unique identifier for the message that was sent.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The downstream service status code for delivering the message.</p>
    pub status_code: i32,
    /// <p>The status message for delivering the message.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>For push notifications that are sent through the GCM channel, specifies whether the endpoint's device registration token was updated as part of delivering the message.</p>
    pub updated_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EndpointMessageResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointMessageResult");
        formatter.field("address", &self.address);
        formatter.field("delivery_status", &self.delivery_status);
        formatter.field("message_id", &self.message_id);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("updated_token", &self.updated_token);
        formatter.finish()
    }
}
/// See [`EndpointMessageResult`](crate::model::EndpointMessageResult)
pub mod endpoint_message_result {
    /// A builder for [`EndpointMessageResult`](crate::model::EndpointMessageResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) delivery_status: std::option::Option<crate::model::DeliveryStatus>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) status_code: std::option::Option<i32>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) updated_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The endpoint address that the message was delivered to.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The endpoint address that the message was delivered to.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// <p>The delivery status of the message. Possible values are:</p> <ul> <li><p>DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>OPT_OUT - The user who's associated with the endpoint has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint. Amazon Pinpoint won't attempt to send the message again.</p></li>    <li><p>SUCCESSFUL - The message was successfully delivered to the endpoint.</p></li> <li><p>TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint.</p></li> <li><p>TIMEOUT - The message couldn't be sent within the timeout period.</p></li> <li><p>UNKNOWN_FAILURE - An unknown error occurred.</p></li></ul>
        pub fn delivery_status(mut self, input: crate::model::DeliveryStatus) -> Self {
            self.delivery_status = Some(input);
            self
        }
        /// <p>The delivery status of the message. Possible values are:</p> <ul> <li><p>DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>OPT_OUT - The user who's associated with the endpoint has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint. Amazon Pinpoint won't attempt to send the message again.</p></li>    <li><p>SUCCESSFUL - The message was successfully delivered to the endpoint.</p></li> <li><p>TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint.</p></li> <li><p>TIMEOUT - The message couldn't be sent within the timeout period.</p></li> <li><p>UNKNOWN_FAILURE - An unknown error occurred.</p></li></ul>
        pub fn set_delivery_status(
            mut self,
            input: std::option::Option<crate::model::DeliveryStatus>,
        ) -> Self {
            self.delivery_status = input;
            self
        }
        /// <p>The unique identifier for the message that was sent.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the message that was sent.</p>
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The downstream service status code for delivering the message.</p>
        pub fn status_code(mut self, input: i32) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The downstream service status code for delivering the message.</p>
        pub fn set_status_code(mut self, input: std::option::Option<i32>) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for delivering the message.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for delivering the message.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>For push notifications that are sent through the GCM channel, specifies whether the endpoint's device registration token was updated as part of delivering the message.</p>
        pub fn updated_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_token = Some(input.into());
            self
        }
        /// <p>For push notifications that are sent through the GCM channel, specifies whether the endpoint's device registration token was updated as part of delivering the message.</p>
        pub fn set_updated_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.updated_token = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointMessageResult`](crate::model::EndpointMessageResult)
        pub fn build(self) -> crate::model::EndpointMessageResult {
            crate::model::EndpointMessageResult {
                address: self.address,
                delivery_status: self.delivery_status,
                message_id: self.message_id,
                status_code: self.status_code.unwrap_or_default(),
                status_message: self.status_message,
                updated_token: self.updated_token,
            }
        }
    }
}
impl EndpointMessageResult {
    /// Creates a new builder-style object to manufacture [`EndpointMessageResult`](crate::model::EndpointMessageResult)
    pub fn builder() -> crate::model::endpoint_message_result::Builder {
        crate::model::endpoint_message_result::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeliveryStatus {
    #[allow(missing_docs)] // documentation missing in model
    Duplicate,
    #[allow(missing_docs)] // documentation missing in model
    OptOut,
    #[allow(missing_docs)] // documentation missing in model
    PermanentFailure,
    #[allow(missing_docs)] // documentation missing in model
    Successful,
    #[allow(missing_docs)] // documentation missing in model
    TemporaryFailure,
    #[allow(missing_docs)] // documentation missing in model
    Throttled,
    #[allow(missing_docs)] // documentation missing in model
    UnknownFailure,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for DeliveryStatus {
    fn from(s: &str) -> Self {
        match s {
            "DUPLICATE" => DeliveryStatus::Duplicate,
            "OPT_OUT" => DeliveryStatus::OptOut,
            "PERMANENT_FAILURE" => DeliveryStatus::PermanentFailure,
            "SUCCESSFUL" => DeliveryStatus::Successful,
            "TEMPORARY_FAILURE" => DeliveryStatus::TemporaryFailure,
            "THROTTLED" => DeliveryStatus::Throttled,
            "UNKNOWN_FAILURE" => DeliveryStatus::UnknownFailure,
            other => DeliveryStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for DeliveryStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeliveryStatus::from(s))
    }
}
impl DeliveryStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeliveryStatus::Duplicate => "DUPLICATE",
            DeliveryStatus::OptOut => "OPT_OUT",
            DeliveryStatus::PermanentFailure => "PERMANENT_FAILURE",
            DeliveryStatus::Successful => "SUCCESSFUL",
            DeliveryStatus::TemporaryFailure => "TEMPORARY_FAILURE",
            DeliveryStatus::Throttled => "THROTTLED",
            DeliveryStatus::UnknownFailure => "UNKNOWN_FAILURE",
            DeliveryStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "DUPLICATE",
            "OPT_OUT",
            "PERMANENT_FAILURE",
            "SUCCESSFUL",
            "TEMPORARY_FAILURE",
            "THROTTLED",
            "UNKNOWN_FAILURE",
        ]
    }
}
impl AsRef<str> for DeliveryStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies the configuration and other settings for a message to send to all the endpoints that are associated with a list of users.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SendUsersMessageRequest {
    /// <p>A map of custom attribute-value pairs. For a push notification, Amazon Pinpoint adds these attributes to the data.pinpoint object in the body of the notification payload. Amazon Pinpoint also provides these attributes in the events that it generates for users-messages deliveries.</p>
    pub context:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The settings and content for the default message and any default messages that you defined for specific channels.</p>
    pub message_configuration: std::option::Option<crate::model::DirectMessageConfiguration>,
    /// <p>The message template to use for the message.</p>
    pub template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
    /// <p>The unique identifier for tracing the message. This identifier is visible to message recipients.</p>
    pub trace_id: std::option::Option<std::string::String>,
    /// <p>A map that associates user IDs with <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> objects. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object to tailor the message for a user by specifying settings such as content overrides and message variables.</p>
    pub users: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::EndpointSendConfiguration>,
    >,
}
impl std::fmt::Debug for SendUsersMessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SendUsersMessageRequest");
        formatter.field("context", &self.context);
        formatter.field("message_configuration", &self.message_configuration);
        formatter.field("template_configuration", &self.template_configuration);
        formatter.field("trace_id", &self.trace_id);
        formatter.field("users", &self.users);
        formatter.finish()
    }
}
/// See [`SendUsersMessageRequest`](crate::model::SendUsersMessageRequest)
pub mod send_users_message_request {
    /// A builder for [`SendUsersMessageRequest`](crate::model::SendUsersMessageRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) context: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) message_configuration:
            std::option::Option<crate::model::DirectMessageConfiguration>,
        pub(crate) template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
        pub(crate) trace_id: std::option::Option<std::string::String>,
        pub(crate) users: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::EndpointSendConfiguration>,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `context`.
        ///
        /// To override the contents of this collection use [`set_context`](Self::set_context).
        ///
        /// <p>A map of custom attribute-value pairs. For a push notification, Amazon Pinpoint adds these attributes to the data.pinpoint object in the body of the notification payload. Amazon Pinpoint also provides these attributes in the events that it generates for users-messages deliveries.</p>
        pub fn context(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.context.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.context = Some(hash_map);
            self
        }
        /// <p>A map of custom attribute-value pairs. For a push notification, Amazon Pinpoint adds these attributes to the data.pinpoint object in the body of the notification payload. Amazon Pinpoint also provides these attributes in the events that it generates for users-messages deliveries.</p>
        pub fn set_context(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.context = input;
            self
        }
        /// <p>The settings and content for the default message and any default messages that you defined for specific channels.</p>
        pub fn message_configuration(
            mut self,
            input: crate::model::DirectMessageConfiguration,
        ) -> Self {
            self.message_configuration = Some(input);
            self
        }
        /// <p>The settings and content for the default message and any default messages that you defined for specific channels.</p>
        pub fn set_message_configuration(
            mut self,
            input: std::option::Option<crate::model::DirectMessageConfiguration>,
        ) -> Self {
            self.message_configuration = input;
            self
        }
        /// <p>The message template to use for the message.</p>
        pub fn template_configuration(
            mut self,
            input: crate::model::TemplateConfiguration,
        ) -> Self {
            self.template_configuration = Some(input);
            self
        }
        /// <p>The message template to use for the message.</p>
        pub fn set_template_configuration(
            mut self,
            input: std::option::Option<crate::model::TemplateConfiguration>,
        ) -> Self {
            self.template_configuration = input;
            self
        }
        /// <p>The unique identifier for tracing the message. This identifier is visible to message recipients.</p>
        pub fn trace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.trace_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for tracing the message. This identifier is visible to message recipients.</p>
        pub fn set_trace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trace_id = input;
            self
        }
        /// Adds a key-value pair to `users`.
        ///
        /// To override the contents of this collection use [`set_users`](Self::set_users).
        ///
        /// <p>A map that associates user IDs with <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> objects. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object to tailor the message for a user by specifying settings such as content overrides and message variables.</p>
        pub fn users(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::EndpointSendConfiguration>,
        ) -> Self {
            let mut hash_map = self.users.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.users = Some(hash_map);
            self
        }
        /// <p>A map that associates user IDs with <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> objects. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object to tailor the message for a user by specifying settings such as content overrides and message variables.</p>
        pub fn set_users(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::EndpointSendConfiguration,
                >,
            >,
        ) -> Self {
            self.users = input;
            self
        }
        /// Consumes the builder and constructs a [`SendUsersMessageRequest`](crate::model::SendUsersMessageRequest)
        pub fn build(self) -> crate::model::SendUsersMessageRequest {
            crate::model::SendUsersMessageRequest {
                context: self.context,
                message_configuration: self.message_configuration,
                template_configuration: self.template_configuration,
                trace_id: self.trace_id,
                users: self.users,
            }
        }
    }
}
impl SendUsersMessageRequest {
    /// Creates a new builder-style object to manufacture [`SendUsersMessageRequest`](crate::model::SendUsersMessageRequest)
    pub fn builder() -> crate::model::send_users_message_request::Builder {
        crate::model::send_users_message_request::Builder::default()
    }
}

/// <p>Specifies the content, including message variables and attributes, to use in a message that's sent directly to an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointSendConfiguration {
    /// <p>The body of the message. If specified, this value overrides the default message body.</p>
    pub body_override: std::option::Option<std::string::String>,
    /// <p>A map of custom attributes to attach to the message for the address. Attribute names are case sensitive.</p> <p>For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
    pub context:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides all other values for the message.</p>
    pub raw_content: std::option::Option<std::string::String>,
    /// <p>A map of the message variables to merge with the variables specified for the default message (DefaultMessage.Substitutions). The variables specified in this map take precedence over all other variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The title or subject line of the message. If specified, this value overrides the default message title or subject line.</p>
    pub title_override: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EndpointSendConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointSendConfiguration");
        formatter.field("body_override", &self.body_override);
        formatter.field("context", &self.context);
        formatter.field("raw_content", &self.raw_content);
        formatter.field("substitutions", &self.substitutions);
        formatter.field("title_override", &self.title_override);
        formatter.finish()
    }
}
/// See [`EndpointSendConfiguration`](crate::model::EndpointSendConfiguration)
pub mod endpoint_send_configuration {
    /// A builder for [`EndpointSendConfiguration`](crate::model::EndpointSendConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body_override: std::option::Option<std::string::String>,
        pub(crate) context: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) raw_content: std::option::Option<std::string::String>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) title_override: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The body of the message. If specified, this value overrides the default message body.</p>
        pub fn body_override(mut self, input: impl Into<std::string::String>) -> Self {
            self.body_override = Some(input.into());
            self
        }
        /// <p>The body of the message. If specified, this value overrides the default message body.</p>
        pub fn set_body_override(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.body_override = input;
            self
        }
        /// Adds a key-value pair to `context`.
        ///
        /// To override the contents of this collection use [`set_context`](Self::set_context).
        ///
        /// <p>A map of custom attributes to attach to the message for the address. Attribute names are case sensitive.</p> <p>For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
        pub fn context(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.context.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.context = Some(hash_map);
            self
        }
        /// <p>A map of custom attributes to attach to the message for the address. Attribute names are case sensitive.</p> <p>For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
        pub fn set_context(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.context = input;
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides all other values for the message.</p>
        pub fn raw_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_content = Some(input.into());
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides all other values for the message.</p>
        pub fn set_raw_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_content = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>A map of the message variables to merge with the variables specified for the default message (DefaultMessage.Substitutions). The variables specified in this map take precedence over all other variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>A map of the message variables to merge with the variables specified for the default message (DefaultMessage.Substitutions). The variables specified in this map take precedence over all other variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// <p>The title or subject line of the message. If specified, this value overrides the default message title or subject line.</p>
        pub fn title_override(mut self, input: impl Into<std::string::String>) -> Self {
            self.title_override = Some(input.into());
            self
        }
        /// <p>The title or subject line of the message. If specified, this value overrides the default message title or subject line.</p>
        pub fn set_title_override(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.title_override = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointSendConfiguration`](crate::model::EndpointSendConfiguration)
        pub fn build(self) -> crate::model::EndpointSendConfiguration {
            crate::model::EndpointSendConfiguration {
                body_override: self.body_override,
                context: self.context,
                raw_content: self.raw_content,
                substitutions: self.substitutions,
                title_override: self.title_override,
            }
        }
    }
}
impl EndpointSendConfiguration {
    /// Creates a new builder-style object to manufacture [`EndpointSendConfiguration`](crate::model::EndpointSendConfiguration)
    pub fn builder() -> crate::model::endpoint_send_configuration::Builder {
        crate::model::endpoint_send_configuration::Builder::default()
    }
}

/// <p>Specifies the settings and content for the default message and any default messages that you tailored for specific channels.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DirectMessageConfiguration {
    /// <p>The default push notification message for the ADM (Amazon Device Messaging) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
    pub adm_message: std::option::Option<crate::model::AdmMessage>,
    /// <p>The default push notification message for the APNs (Apple Push Notification service) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
    pub apns_message: std::option::Option<crate::model::ApnsMessage>,
    /// <p>The default push notification message for the Baidu (Baidu Cloud Push) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
    pub baidu_message: std::option::Option<crate::model::BaiduMessage>,
    /// <p>The default message for all channels.</p>
    pub default_message: std::option::Option<crate::model::DefaultMessage>,
    /// <p>The default push notification message for all push notification channels.</p>
    pub default_push_notification_message:
        std::option::Option<crate::model::DefaultPushNotificationMessage>,
    /// <p>The default message for the email channel. This message overrides the default message (DefaultMessage).</p>
    pub email_message: std::option::Option<crate::model::EmailMessage>,
    /// <p>The default push notification message for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
    pub gcm_message: std::option::Option<crate::model::GcmMessage>,
    /// <p>The default message for the SMS channel. This message overrides the default message (DefaultMessage).</p>
    pub sms_message: std::option::Option<crate::model::SmsMessage>,
    /// <p>The default message for the voice channel. This message overrides the default message (DefaultMessage).</p>
    pub voice_message: std::option::Option<crate::model::VoiceMessage>,
}
impl std::fmt::Debug for DirectMessageConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DirectMessageConfiguration");
        formatter.field("adm_message", &self.adm_message);
        formatter.field("apns_message", &self.apns_message);
        formatter.field("baidu_message", &self.baidu_message);
        formatter.field("default_message", &self.default_message);
        formatter.field(
            "default_push_notification_message",
            &self.default_push_notification_message,
        );
        formatter.field("email_message", &self.email_message);
        formatter.field("gcm_message", &self.gcm_message);
        formatter.field("sms_message", &self.sms_message);
        formatter.field("voice_message", &self.voice_message);
        formatter.finish()
    }
}
/// See [`DirectMessageConfiguration`](crate::model::DirectMessageConfiguration)
pub mod direct_message_configuration {
    /// A builder for [`DirectMessageConfiguration`](crate::model::DirectMessageConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) adm_message: std::option::Option<crate::model::AdmMessage>,
        pub(crate) apns_message: std::option::Option<crate::model::ApnsMessage>,
        pub(crate) baidu_message: std::option::Option<crate::model::BaiduMessage>,
        pub(crate) default_message: std::option::Option<crate::model::DefaultMessage>,
        pub(crate) default_push_notification_message:
            std::option::Option<crate::model::DefaultPushNotificationMessage>,
        pub(crate) email_message: std::option::Option<crate::model::EmailMessage>,
        pub(crate) gcm_message: std::option::Option<crate::model::GcmMessage>,
        pub(crate) sms_message: std::option::Option<crate::model::SmsMessage>,
        pub(crate) voice_message: std::option::Option<crate::model::VoiceMessage>,
    }
    impl Builder {
        /// <p>The default push notification message for the ADM (Amazon Device Messaging) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
        pub fn adm_message(mut self, input: crate::model::AdmMessage) -> Self {
            self.adm_message = Some(input);
            self
        }
        /// <p>The default push notification message for the ADM (Amazon Device Messaging) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
        pub fn set_adm_message(
            mut self,
            input: std::option::Option<crate::model::AdmMessage>,
        ) -> Self {
            self.adm_message = input;
            self
        }
        /// <p>The default push notification message for the APNs (Apple Push Notification service) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
        pub fn apns_message(mut self, input: crate::model::ApnsMessage) -> Self {
            self.apns_message = Some(input);
            self
        }
        /// <p>The default push notification message for the APNs (Apple Push Notification service) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
        pub fn set_apns_message(
            mut self,
            input: std::option::Option<crate::model::ApnsMessage>,
        ) -> Self {
            self.apns_message = input;
            self
        }
        /// <p>The default push notification message for the Baidu (Baidu Cloud Push) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
        pub fn baidu_message(mut self, input: crate::model::BaiduMessage) -> Self {
            self.baidu_message = Some(input);
            self
        }
        /// <p>The default push notification message for the Baidu (Baidu Cloud Push) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
        pub fn set_baidu_message(
            mut self,
            input: std::option::Option<crate::model::BaiduMessage>,
        ) -> Self {
            self.baidu_message = input;
            self
        }
        /// <p>The default message for all channels.</p>
        pub fn default_message(mut self, input: crate::model::DefaultMessage) -> Self {
            self.default_message = Some(input);
            self
        }
        /// <p>The default message for all channels.</p>
        pub fn set_default_message(
            mut self,
            input: std::option::Option<crate::model::DefaultMessage>,
        ) -> Self {
            self.default_message = input;
            self
        }
        /// <p>The default push notification message for all push notification channels.</p>
        pub fn default_push_notification_message(
            mut self,
            input: crate::model::DefaultPushNotificationMessage,
        ) -> Self {
            self.default_push_notification_message = Some(input);
            self
        }
        /// <p>The default push notification message for all push notification channels.</p>
        pub fn set_default_push_notification_message(
            mut self,
            input: std::option::Option<crate::model::DefaultPushNotificationMessage>,
        ) -> Self {
            self.default_push_notification_message = input;
            self
        }
        /// <p>The default message for the email channel. This message overrides the default message (DefaultMessage).</p>
        pub fn email_message(mut self, input: crate::model::EmailMessage) -> Self {
            self.email_message = Some(input);
            self
        }
        /// <p>The default message for the email channel. This message overrides the default message (DefaultMessage).</p>
        pub fn set_email_message(
            mut self,
            input: std::option::Option<crate::model::EmailMessage>,
        ) -> Self {
            self.email_message = input;
            self
        }
        /// <p>The default push notification message for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
        pub fn gcm_message(mut self, input: crate::model::GcmMessage) -> Self {
            self.gcm_message = Some(input);
            self
        }
        /// <p>The default push notification message for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
        pub fn set_gcm_message(
            mut self,
            input: std::option::Option<crate::model::GcmMessage>,
        ) -> Self {
            self.gcm_message = input;
            self
        }
        /// <p>The default message for the SMS channel. This message overrides the default message (DefaultMessage).</p>
        pub fn sms_message(mut self, input: crate::model::SmsMessage) -> Self {
            self.sms_message = Some(input);
            self
        }
        /// <p>The default message for the SMS channel. This message overrides the default message (DefaultMessage).</p>
        pub fn set_sms_message(
            mut self,
            input: std::option::Option<crate::model::SmsMessage>,
        ) -> Self {
            self.sms_message = input;
            self
        }
        /// <p>The default message for the voice channel. This message overrides the default message (DefaultMessage).</p>
        pub fn voice_message(mut self, input: crate::model::VoiceMessage) -> Self {
            self.voice_message = Some(input);
            self
        }
        /// <p>The default message for the voice channel. This message overrides the default message (DefaultMessage).</p>
        pub fn set_voice_message(
            mut self,
            input: std::option::Option<crate::model::VoiceMessage>,
        ) -> Self {
            self.voice_message = input;
            self
        }
        /// Consumes the builder and constructs a [`DirectMessageConfiguration`](crate::model::DirectMessageConfiguration)
        pub fn build(self) -> crate::model::DirectMessageConfiguration {
            crate::model::DirectMessageConfiguration {
                adm_message: self.adm_message,
                apns_message: self.apns_message,
                baidu_message: self.baidu_message,
                default_message: self.default_message,
                default_push_notification_message: self.default_push_notification_message,
                email_message: self.email_message,
                gcm_message: self.gcm_message,
                sms_message: self.sms_message,
                voice_message: self.voice_message,
            }
        }
    }
}
impl DirectMessageConfiguration {
    /// Creates a new builder-style object to manufacture [`DirectMessageConfiguration`](crate::model::DirectMessageConfiguration)
    pub fn builder() -> crate::model::direct_message_configuration::Builder {
        crate::model::direct_message_configuration::Builder::default()
    }
}

/// <p>Specifies the settings for a one-time voice message that's sent directly to an endpoint through the voice channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VoiceMessage {
    /// <p>The text of the script to use for the voice message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The code for the language to use when synthesizing the text of the message script. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    pub language_code: std::option::Option<std::string::String>,
    /// <p>The long code to send the voice message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code in E.164 format, for example +12065550100, to ensure prompt and accurate delivery of the message.</p>
    pub origination_number: std::option::Option<std::string::String>,
    /// <p>The default message variables to use in the voice message. You can override the default variables with individual address variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The name of the voice to use when delivering the message. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    pub voice_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VoiceMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VoiceMessage");
        formatter.field("body", &self.body);
        formatter.field("language_code", &self.language_code);
        formatter.field("origination_number", &self.origination_number);
        formatter.field("substitutions", &self.substitutions);
        formatter.field("voice_id", &self.voice_id);
        formatter.finish()
    }
}
/// See [`VoiceMessage`](crate::model::VoiceMessage)
pub mod voice_message {
    /// A builder for [`VoiceMessage`](crate::model::VoiceMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<std::string::String>,
        pub(crate) origination_number: std::option::Option<std::string::String>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) voice_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The text of the script to use for the voice message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The text of the script to use for the voice message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The code for the language to use when synthesizing the text of the message script. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn language_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_code = Some(input.into());
            self
        }
        /// <p>The code for the language to use when synthesizing the text of the message script. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The long code to send the voice message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code in E.164 format, for example +12065550100, to ensure prompt and accurate delivery of the message.</p>
        pub fn origination_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.origination_number = Some(input.into());
            self
        }
        /// <p>The long code to send the voice message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code in E.164 format, for example +12065550100, to ensure prompt and accurate delivery of the message.</p>
        pub fn set_origination_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.origination_number = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>The default message variables to use in the voice message. You can override the default variables with individual address variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>The default message variables to use in the voice message. You can override the default variables with individual address variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// <p>The name of the voice to use when delivering the message. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn voice_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_id = Some(input.into());
            self
        }
        /// <p>The name of the voice to use when delivering the message. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn set_voice_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.voice_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceMessage`](crate::model::VoiceMessage)
        pub fn build(self) -> crate::model::VoiceMessage {
            crate::model::VoiceMessage {
                body: self.body,
                language_code: self.language_code,
                origination_number: self.origination_number,
                substitutions: self.substitutions,
                voice_id: self.voice_id,
            }
        }
    }
}
impl VoiceMessage {
    /// Creates a new builder-style object to manufacture [`VoiceMessage`](crate::model::VoiceMessage)
    pub fn builder() -> crate::model::voice_message::Builder {
        crate::model::voice_message::Builder::default()
    }
}

/// <p>Specifies the default settings for a one-time SMS message that's sent directly to an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SmsMessage {
    /// <p>The body of the SMS message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The SMS program name that you provided to AWS Support when you requested your dedicated number.</p>
    pub keyword: std::option::Option<std::string::String>,
    /// <p>This field is reserved for future use.</p>
    pub media_url: std::option::Option<std::string::String>,
    /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
    pub message_type: std::option::Option<crate::model::MessageType>,
    /// <p>The number to send the SMS message from. This value should be one of the dedicated long or short codes that's assigned to your AWS account. If you don't specify a long or short code, Amazon Pinpoint assigns a random long code to the SMS message and sends the message from that code.</p>
    pub origination_number: std::option::Option<std::string::String>,
    /// <p>The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region.</p>
    pub sender_id: std::option::Option<std::string::String>,
    /// <p>The message variables to use in the SMS message. You can override the default variables with individual address variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
    pub entity_id: std::option::Option<std::string::String>,
    /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
    pub template_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SmsMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SmsMessage");
        formatter.field("body", &self.body);
        formatter.field("keyword", &self.keyword);
        formatter.field("media_url", &self.media_url);
        formatter.field("message_type", &self.message_type);
        formatter.field("origination_number", &self.origination_number);
        formatter.field("sender_id", &self.sender_id);
        formatter.field("substitutions", &self.substitutions);
        formatter.field("entity_id", &self.entity_id);
        formatter.field("template_id", &self.template_id);
        formatter.finish()
    }
}
/// See [`SmsMessage`](crate::model::SmsMessage)
pub mod sms_message {
    /// A builder for [`SmsMessage`](crate::model::SmsMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) keyword: std::option::Option<std::string::String>,
        pub(crate) media_url: std::option::Option<std::string::String>,
        pub(crate) message_type: std::option::Option<crate::model::MessageType>,
        pub(crate) origination_number: std::option::Option<std::string::String>,
        pub(crate) sender_id: std::option::Option<std::string::String>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) entity_id: std::option::Option<std::string::String>,
        pub(crate) template_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The body of the SMS message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The body of the SMS message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The SMS program name that you provided to AWS Support when you requested your dedicated number.</p>
        pub fn keyword(mut self, input: impl Into<std::string::String>) -> Self {
            self.keyword = Some(input.into());
            self
        }
        /// <p>The SMS program name that you provided to AWS Support when you requested your dedicated number.</p>
        pub fn set_keyword(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.keyword = input;
            self
        }
        /// <p>This field is reserved for future use.</p>
        pub fn media_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_url = Some(input.into());
            self
        }
        /// <p>This field is reserved for future use.</p>
        pub fn set_media_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.media_url = input;
            self
        }
        /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
        pub fn message_type(mut self, input: crate::model::MessageType) -> Self {
            self.message_type = Some(input);
            self
        }
        /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
        pub fn set_message_type(
            mut self,
            input: std::option::Option<crate::model::MessageType>,
        ) -> Self {
            self.message_type = input;
            self
        }
        /// <p>The number to send the SMS message from. This value should be one of the dedicated long or short codes that's assigned to your AWS account. If you don't specify a long or short code, Amazon Pinpoint assigns a random long code to the SMS message and sends the message from that code.</p>
        pub fn origination_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.origination_number = Some(input.into());
            self
        }
        /// <p>The number to send the SMS message from. This value should be one of the dedicated long or short codes that's assigned to your AWS account. If you don't specify a long or short code, Amazon Pinpoint assigns a random long code to the SMS message and sends the message from that code.</p>
        pub fn set_origination_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.origination_number = input;
            self
        }
        /// <p>The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region.</p>
        pub fn sender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sender_id = Some(input.into());
            self
        }
        /// <p>The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region.</p>
        pub fn set_sender_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sender_id = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>The message variables to use in the SMS message. You can override the default variables with individual address variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>The message variables to use in the SMS message. You can override the default variables with individual address variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
        pub fn entity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.entity_id = Some(input.into());
            self
        }
        /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
        pub fn set_entity_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entity_id = input;
            self
        }
        /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
        pub fn template_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_id = Some(input.into());
            self
        }
        /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
        pub fn set_template_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.template_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SmsMessage`](crate::model::SmsMessage)
        pub fn build(self) -> crate::model::SmsMessage {
            crate::model::SmsMessage {
                body: self.body,
                keyword: self.keyword,
                media_url: self.media_url,
                message_type: self.message_type,
                origination_number: self.origination_number,
                sender_id: self.sender_id,
                substitutions: self.substitutions,
                entity_id: self.entity_id,
                template_id: self.template_id,
            }
        }
    }
}
impl SmsMessage {
    /// Creates a new builder-style object to manufacture [`SmsMessage`](crate::model::SmsMessage)
    pub fn builder() -> crate::model::sms_message::Builder {
        crate::model::sms_message::Builder::default()
    }
}

/// <p>Specifies the settings for a one-time message that's sent directly to an endpoint through the GCM channel. The GCM channel enables Amazon Pinpoint to send messages to the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GcmMessage {
    /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    pub action: std::option::Option<crate::model::Action>,
    /// <p>The body of the notification message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>An arbitrary string that identifies a group of messages that can be collapsed to ensure that only the last message is sent when delivery can resume. This helps avoid sending too many instances of the same messages when the recipient's device comes online again or becomes active.</p> <p>Amazon Pinpoint specifies this value in the Firebase Cloud Messaging (FCM) collapse_key parameter when it sends the notification message to FCM.</p>
    pub collapse_key: std::option::Option<std::string::String>,
    /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
    pub data:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The icon image name of the asset saved in your app.</p>
    pub icon_reference: std::option::Option<std::string::String>,
    /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
    pub image_icon_url: std::option::Option<std::string::String>,
    /// <p>The URL of an image to display in the push notification.</p>
    pub image_url: std::option::Option<std::string::String>,
    /// <p>para>normal - The notification might be delayed. Delivery is optimized for battery usage on the recipient's device. Use this value unless immediate delivery is required.</p>/listitem> <li><p>high - The notification is sent immediately and might wake a sleeping device.</p></li>/para> <p>Amazon Pinpoint specifies this value in the FCM priority parameter when it sends the notification message to FCM.</p> <p>The equivalent values for Apple Push Notification service (APNs) are 5, for normal, and 10, for high. If you specify an APNs value for this property, Amazon Pinpoint accepts and converts the value to the corresponding FCM value.</p>
    pub priority: std::option::Option<std::string::String>,
    /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
    pub raw_content: std::option::Option<std::string::String>,
    /// <p>The package name of the application where registration tokens must match in order for the recipient to receive the message.</p>
    pub restricted_package_name: std::option::Option<std::string::String>,
    /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
    pub silent_push: bool,
    /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
    pub small_image_icon_url: std::option::Option<std::string::String>,
    /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
    pub sound: std::option::Option<std::string::String>,
    /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The amount of time, in seconds, that FCM should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If you don't specify this value, FCM defaults to the maximum value, which is 2,419,200 seconds (28 days).</p> <p>Amazon Pinpoint specifies this value in the FCM time_to_live parameter when it sends the notification message to FCM.</p>
    pub time_to_live: i32,
    /// <p>The title to display above the notification message on the recipient's device.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GcmMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GcmMessage");
        formatter.field("action", &self.action);
        formatter.field("body", &self.body);
        formatter.field("collapse_key", &self.collapse_key);
        formatter.field("data", &self.data);
        formatter.field("icon_reference", &self.icon_reference);
        formatter.field("image_icon_url", &self.image_icon_url);
        formatter.field("image_url", &self.image_url);
        formatter.field("priority", &self.priority);
        formatter.field("raw_content", &self.raw_content);
        formatter.field("restricted_package_name", &self.restricted_package_name);
        formatter.field("silent_push", &self.silent_push);
        formatter.field("small_image_icon_url", &self.small_image_icon_url);
        formatter.field("sound", &self.sound);
        formatter.field("substitutions", &self.substitutions);
        formatter.field("time_to_live", &self.time_to_live);
        formatter.field("title", &self.title);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`GcmMessage`](crate::model::GcmMessage)
pub mod gcm_message {
    /// A builder for [`GcmMessage`](crate::model::GcmMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) collapse_key: std::option::Option<std::string::String>,
        pub(crate) data: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) icon_reference: std::option::Option<std::string::String>,
        pub(crate) image_icon_url: std::option::Option<std::string::String>,
        pub(crate) image_url: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<std::string::String>,
        pub(crate) raw_content: std::option::Option<std::string::String>,
        pub(crate) restricted_package_name: std::option::Option<std::string::String>,
        pub(crate) silent_push: std::option::Option<bool>,
        pub(crate) small_image_icon_url: std::option::Option<std::string::String>,
        pub(crate) sound: std::option::Option<std::string::String>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) time_to_live: std::option::Option<i32>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// <p>The body of the notification message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The body of the notification message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>An arbitrary string that identifies a group of messages that can be collapsed to ensure that only the last message is sent when delivery can resume. This helps avoid sending too many instances of the same messages when the recipient's device comes online again or becomes active.</p> <p>Amazon Pinpoint specifies this value in the Firebase Cloud Messaging (FCM) collapse_key parameter when it sends the notification message to FCM.</p>
        pub fn collapse_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.collapse_key = Some(input.into());
            self
        }
        /// <p>An arbitrary string that identifies a group of messages that can be collapsed to ensure that only the last message is sent when delivery can resume. This helps avoid sending too many instances of the same messages when the recipient's device comes online again or becomes active.</p> <p>Amazon Pinpoint specifies this value in the Firebase Cloud Messaging (FCM) collapse_key parameter when it sends the notification message to FCM.</p>
        pub fn set_collapse_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.collapse_key = input;
            self
        }
        /// Adds a key-value pair to `data`.
        ///
        /// To override the contents of this collection use [`set_data`](Self::set_data).
        ///
        /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
        pub fn data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.data.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.data = Some(hash_map);
            self
        }
        /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
        pub fn set_data(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.data = input;
            self
        }
        /// <p>The icon image name of the asset saved in your app.</p>
        pub fn icon_reference(mut self, input: impl Into<std::string::String>) -> Self {
            self.icon_reference = Some(input.into());
            self
        }
        /// <p>The icon image name of the asset saved in your app.</p>
        pub fn set_icon_reference(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.icon_reference = input;
            self
        }
        /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
        pub fn image_icon_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_icon_url = Some(input.into());
            self
        }
        /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
        pub fn set_image_icon_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_icon_url = input;
            self
        }
        /// <p>The URL of an image to display in the push notification.</p>
        pub fn image_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_url = Some(input.into());
            self
        }
        /// <p>The URL of an image to display in the push notification.</p>
        pub fn set_image_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_url = input;
            self
        }
        /// <p>para>normal - The notification might be delayed. Delivery is optimized for battery usage on the recipient's device. Use this value unless immediate delivery is required.</p>/listitem> <li><p>high - The notification is sent immediately and might wake a sleeping device.</p></li>/para> <p>Amazon Pinpoint specifies this value in the FCM priority parameter when it sends the notification message to FCM.</p> <p>The equivalent values for Apple Push Notification service (APNs) are 5, for normal, and 10, for high. If you specify an APNs value for this property, Amazon Pinpoint accepts and converts the value to the corresponding FCM value.</p>
        pub fn priority(mut self, input: impl Into<std::string::String>) -> Self {
            self.priority = Some(input.into());
            self
        }
        /// <p>para>normal - The notification might be delayed. Delivery is optimized for battery usage on the recipient's device. Use this value unless immediate delivery is required.</p>/listitem> <li><p>high - The notification is sent immediately and might wake a sleeping device.</p></li>/para> <p>Amazon Pinpoint specifies this value in the FCM priority parameter when it sends the notification message to FCM.</p> <p>The equivalent values for Apple Push Notification service (APNs) are 5, for normal, and 10, for high. If you specify an APNs value for this property, Amazon Pinpoint accepts and converts the value to the corresponding FCM value.</p>
        pub fn set_priority(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
        pub fn raw_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_content = Some(input.into());
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
        pub fn set_raw_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_content = input;
            self
        }
        /// <p>The package name of the application where registration tokens must match in order for the recipient to receive the message.</p>
        pub fn restricted_package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.restricted_package_name = Some(input.into());
            self
        }
        /// <p>The package name of the application where registration tokens must match in order for the recipient to receive the message.</p>
        pub fn set_restricted_package_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.restricted_package_name = input;
            self
        }
        /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
        pub fn silent_push(mut self, input: bool) -> Self {
            self.silent_push = Some(input);
            self
        }
        /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
        pub fn set_silent_push(mut self, input: std::option::Option<bool>) -> Self {
            self.silent_push = input;
            self
        }
        /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
        pub fn small_image_icon_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.small_image_icon_url = Some(input.into());
            self
        }
        /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
        pub fn set_small_image_icon_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.small_image_icon_url = input;
            self
        }
        /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
        pub fn sound(mut self, input: impl Into<std::string::String>) -> Self {
            self.sound = Some(input.into());
            self
        }
        /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
        pub fn set_sound(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sound = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// <p>The amount of time, in seconds, that FCM should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If you don't specify this value, FCM defaults to the maximum value, which is 2,419,200 seconds (28 days).</p> <p>Amazon Pinpoint specifies this value in the FCM time_to_live parameter when it sends the notification message to FCM.</p>
        pub fn time_to_live(mut self, input: i32) -> Self {
            self.time_to_live = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, that FCM should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If you don't specify this value, FCM defaults to the maximum value, which is 2,419,200 seconds (28 days).</p> <p>Amazon Pinpoint specifies this value in the FCM time_to_live parameter when it sends the notification message to FCM.</p>
        pub fn set_time_to_live(mut self, input: std::option::Option<i32>) -> Self {
            self.time_to_live = input;
            self
        }
        /// <p>The title to display above the notification message on the recipient's device.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title to display above the notification message on the recipient's device.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`GcmMessage`](crate::model::GcmMessage)
        pub fn build(self) -> crate::model::GcmMessage {
            crate::model::GcmMessage {
                action: self.action,
                body: self.body,
                collapse_key: self.collapse_key,
                data: self.data,
                icon_reference: self.icon_reference,
                image_icon_url: self.image_icon_url,
                image_url: self.image_url,
                priority: self.priority,
                raw_content: self.raw_content,
                restricted_package_name: self.restricted_package_name,
                silent_push: self.silent_push.unwrap_or_default(),
                small_image_icon_url: self.small_image_icon_url,
                sound: self.sound,
                substitutions: self.substitutions,
                time_to_live: self.time_to_live.unwrap_or_default(),
                title: self.title,
                url: self.url,
            }
        }
    }
}
impl GcmMessage {
    /// Creates a new builder-style object to manufacture [`GcmMessage`](crate::model::GcmMessage)
    pub fn builder() -> crate::model::gcm_message::Builder {
        crate::model::gcm_message::Builder::default()
    }
}

/// <p>Specifies the default settings and content for a one-time email message that's sent directly to an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EmailMessage {
    /// <p>The body of the email message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The email address to forward bounces and complaints to, if feedback forwarding is enabled.</p>
    pub feedback_forwarding_address: std::option::Option<std::string::String>,
    /// <p>The verified email address to send the email message from. The default value is the FromAddress specified for the email channel.</p>
    pub from_address: std::option::Option<std::string::String>,
    /// <p>The email message, represented as a raw MIME message.</p>
    pub raw_email: std::option::Option<crate::model::RawEmail>,
    /// <p>The reply-to email address(es) for the email message. If a recipient replies to the email, each reply-to address receives the reply.</p>
    pub reply_to_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The email message, composed of a subject, a text part, and an HTML part.</p>
    pub simple_email: std::option::Option<crate::model::SimpleEmail>,
    /// <p>The default message variables to use in the email message. You can override the default variables with individual address variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl std::fmt::Debug for EmailMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EmailMessage");
        formatter.field("body", &self.body);
        formatter.field(
            "feedback_forwarding_address",
            &self.feedback_forwarding_address,
        );
        formatter.field("from_address", &self.from_address);
        formatter.field("raw_email", &self.raw_email);
        formatter.field("reply_to_addresses", &self.reply_to_addresses);
        formatter.field("simple_email", &self.simple_email);
        formatter.field("substitutions", &self.substitutions);
        formatter.finish()
    }
}
/// See [`EmailMessage`](crate::model::EmailMessage)
pub mod email_message {
    /// A builder for [`EmailMessage`](crate::model::EmailMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) feedback_forwarding_address: std::option::Option<std::string::String>,
        pub(crate) from_address: std::option::Option<std::string::String>,
        pub(crate) raw_email: std::option::Option<crate::model::RawEmail>,
        pub(crate) reply_to_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) simple_email: std::option::Option<crate::model::SimpleEmail>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The body of the email message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The body of the email message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The email address to forward bounces and complaints to, if feedback forwarding is enabled.</p>
        pub fn feedback_forwarding_address(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.feedback_forwarding_address = Some(input.into());
            self
        }
        /// <p>The email address to forward bounces and complaints to, if feedback forwarding is enabled.</p>
        pub fn set_feedback_forwarding_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.feedback_forwarding_address = input;
            self
        }
        /// <p>The verified email address to send the email message from. The default value is the FromAddress specified for the email channel.</p>
        pub fn from_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.from_address = Some(input.into());
            self
        }
        /// <p>The verified email address to send the email message from. The default value is the FromAddress specified for the email channel.</p>
        pub fn set_from_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.from_address = input;
            self
        }
        /// <p>The email message, represented as a raw MIME message.</p>
        pub fn raw_email(mut self, input: crate::model::RawEmail) -> Self {
            self.raw_email = Some(input);
            self
        }
        /// <p>The email message, represented as a raw MIME message.</p>
        pub fn set_raw_email(mut self, input: std::option::Option<crate::model::RawEmail>) -> Self {
            self.raw_email = input;
            self
        }
        /// Appends an item to `reply_to_addresses`.
        ///
        /// To override the contents of this collection use [`set_reply_to_addresses`](Self::set_reply_to_addresses).
        ///
        /// <p>The reply-to email address(es) for the email message. If a recipient replies to the email, each reply-to address receives the reply.</p>
        pub fn reply_to_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.reply_to_addresses.unwrap_or_default();
            v.push(input.into());
            self.reply_to_addresses = Some(v);
            self
        }
        /// <p>The reply-to email address(es) for the email message. If a recipient replies to the email, each reply-to address receives the reply.</p>
        pub fn set_reply_to_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.reply_to_addresses = input;
            self
        }
        /// <p>The email message, composed of a subject, a text part, and an HTML part.</p>
        pub fn simple_email(mut self, input: crate::model::SimpleEmail) -> Self {
            self.simple_email = Some(input);
            self
        }
        /// <p>The email message, composed of a subject, a text part, and an HTML part.</p>
        pub fn set_simple_email(
            mut self,
            input: std::option::Option<crate::model::SimpleEmail>,
        ) -> Self {
            self.simple_email = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>The default message variables to use in the email message. You can override the default variables with individual address variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>The default message variables to use in the email message. You can override the default variables with individual address variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// Consumes the builder and constructs a [`EmailMessage`](crate::model::EmailMessage)
        pub fn build(self) -> crate::model::EmailMessage {
            crate::model::EmailMessage {
                body: self.body,
                feedback_forwarding_address: self.feedback_forwarding_address,
                from_address: self.from_address,
                raw_email: self.raw_email,
                reply_to_addresses: self.reply_to_addresses,
                simple_email: self.simple_email,
                substitutions: self.substitutions,
            }
        }
    }
}
impl EmailMessage {
    /// Creates a new builder-style object to manufacture [`EmailMessage`](crate::model::EmailMessage)
    pub fn builder() -> crate::model::email_message::Builder {
        crate::model::email_message::Builder::default()
    }
}

/// <p>Specifies the contents of an email message, composed of a subject, a text part, and an HTML part.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimpleEmail {
    /// <p>The body of the email message, in HTML format. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.</p>
    pub html_part: std::option::Option<crate::model::SimpleEmailPart>,
    /// <p>The subject line, or title, of the email.</p>
    pub subject: std::option::Option<crate::model::SimpleEmailPart>,
    /// <p>The body of the email message, in plain text format. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.</p>
    pub text_part: std::option::Option<crate::model::SimpleEmailPart>,
}
impl std::fmt::Debug for SimpleEmail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimpleEmail");
        formatter.field("html_part", &self.html_part);
        formatter.field("subject", &self.subject);
        formatter.field("text_part", &self.text_part);
        formatter.finish()
    }
}
/// See [`SimpleEmail`](crate::model::SimpleEmail)
pub mod simple_email {
    /// A builder for [`SimpleEmail`](crate::model::SimpleEmail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) html_part: std::option::Option<crate::model::SimpleEmailPart>,
        pub(crate) subject: std::option::Option<crate::model::SimpleEmailPart>,
        pub(crate) text_part: std::option::Option<crate::model::SimpleEmailPart>,
    }
    impl Builder {
        /// <p>The body of the email message, in HTML format. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.</p>
        pub fn html_part(mut self, input: crate::model::SimpleEmailPart) -> Self {
            self.html_part = Some(input);
            self
        }
        /// <p>The body of the email message, in HTML format. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.</p>
        pub fn set_html_part(
            mut self,
            input: std::option::Option<crate::model::SimpleEmailPart>,
        ) -> Self {
            self.html_part = input;
            self
        }
        /// <p>The subject line, or title, of the email.</p>
        pub fn subject(mut self, input: crate::model::SimpleEmailPart) -> Self {
            self.subject = Some(input);
            self
        }
        /// <p>The subject line, or title, of the email.</p>
        pub fn set_subject(
            mut self,
            input: std::option::Option<crate::model::SimpleEmailPart>,
        ) -> Self {
            self.subject = input;
            self
        }
        /// <p>The body of the email message, in plain text format. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.</p>
        pub fn text_part(mut self, input: crate::model::SimpleEmailPart) -> Self {
            self.text_part = Some(input);
            self
        }
        /// <p>The body of the email message, in plain text format. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.</p>
        pub fn set_text_part(
            mut self,
            input: std::option::Option<crate::model::SimpleEmailPart>,
        ) -> Self {
            self.text_part = input;
            self
        }
        /// Consumes the builder and constructs a [`SimpleEmail`](crate::model::SimpleEmail)
        pub fn build(self) -> crate::model::SimpleEmail {
            crate::model::SimpleEmail {
                html_part: self.html_part,
                subject: self.subject,
                text_part: self.text_part,
            }
        }
    }
}
impl SimpleEmail {
    /// Creates a new builder-style object to manufacture [`SimpleEmail`](crate::model::SimpleEmail)
    pub fn builder() -> crate::model::simple_email::Builder {
        crate::model::simple_email::Builder::default()
    }
}

/// <p>Specifies the subject or body of an email message, represented as textual email data and the applicable character set.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SimpleEmailPart {
    /// <p>The applicable character set for the message content.</p>
    pub charset: std::option::Option<std::string::String>,
    /// <p>The textual data of the message content.</p>
    pub data: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SimpleEmailPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SimpleEmailPart");
        formatter.field("charset", &self.charset);
        formatter.field("data", &self.data);
        formatter.finish()
    }
}
/// See [`SimpleEmailPart`](crate::model::SimpleEmailPart)
pub mod simple_email_part {
    /// A builder for [`SimpleEmailPart`](crate::model::SimpleEmailPart)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) charset: std::option::Option<std::string::String>,
        pub(crate) data: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The applicable character set for the message content.</p>
        pub fn charset(mut self, input: impl Into<std::string::String>) -> Self {
            self.charset = Some(input.into());
            self
        }
        /// <p>The applicable character set for the message content.</p>
        pub fn set_charset(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.charset = input;
            self
        }
        /// <p>The textual data of the message content.</p>
        pub fn data(mut self, input: impl Into<std::string::String>) -> Self {
            self.data = Some(input.into());
            self
        }
        /// <p>The textual data of the message content.</p>
        pub fn set_data(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data = input;
            self
        }
        /// Consumes the builder and constructs a [`SimpleEmailPart`](crate::model::SimpleEmailPart)
        pub fn build(self) -> crate::model::SimpleEmailPart {
            crate::model::SimpleEmailPart {
                charset: self.charset,
                data: self.data,
            }
        }
    }
}
impl SimpleEmailPart {
    /// Creates a new builder-style object to manufacture [`SimpleEmailPart`](crate::model::SimpleEmailPart)
    pub fn builder() -> crate::model::simple_email_part::Builder {
        crate::model::simple_email_part::Builder::default()
    }
}

/// <p>Specifies the contents of an email message, represented as a raw MIME message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RawEmail {
    /// <p>The email message, represented as a raw MIME message. The entire message must be base64 encoded.</p>
    pub data: std::option::Option<aws_smithy_types::Blob>,
}
impl std::fmt::Debug for RawEmail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RawEmail");
        formatter.field("data", &self.data);
        formatter.finish()
    }
}
/// See [`RawEmail`](crate::model::RawEmail)
pub mod raw_email {
    /// A builder for [`RawEmail`](crate::model::RawEmail)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data: std::option::Option<aws_smithy_types::Blob>,
    }
    impl Builder {
        /// <p>The email message, represented as a raw MIME message. The entire message must be base64 encoded.</p>
        pub fn data(mut self, input: aws_smithy_types::Blob) -> Self {
            self.data = Some(input);
            self
        }
        /// <p>The email message, represented as a raw MIME message. The entire message must be base64 encoded.</p>
        pub fn set_data(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.data = input;
            self
        }
        /// Consumes the builder and constructs a [`RawEmail`](crate::model::RawEmail)
        pub fn build(self) -> crate::model::RawEmail {
            crate::model::RawEmail { data: self.data }
        }
    }
}
impl RawEmail {
    /// Creates a new builder-style object to manufacture [`RawEmail`](crate::model::RawEmail)
    pub fn builder() -> crate::model::raw_email::Builder {
        crate::model::raw_email::Builder::default()
    }
}

/// <p>Specifies the default settings and content for a push notification that's sent directly to an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultPushNotificationMessage {
    /// <p>The default action to occur if a recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    pub action: std::option::Option<crate::model::Action>,
    /// <p>The default body of the notification message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The JSON data payload to use for the default push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
    pub data:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Specifies whether the default notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or delivering messages to an in-app notification center.</p>
    pub silent_push: bool,
    /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The default title to display above the notification message on a recipient's device.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p>The default URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DefaultPushNotificationMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultPushNotificationMessage");
        formatter.field("action", &self.action);
        formatter.field("body", &self.body);
        formatter.field("data", &self.data);
        formatter.field("silent_push", &self.silent_push);
        formatter.field("substitutions", &self.substitutions);
        formatter.field("title", &self.title);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`DefaultPushNotificationMessage`](crate::model::DefaultPushNotificationMessage)
pub mod default_push_notification_message {
    /// A builder for [`DefaultPushNotificationMessage`](crate::model::DefaultPushNotificationMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) data: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) silent_push: std::option::Option<bool>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The default action to occur if a recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The default action to occur if a recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// <p>The default body of the notification message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The default body of the notification message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// Adds a key-value pair to `data`.
        ///
        /// To override the contents of this collection use [`set_data`](Self::set_data).
        ///
        /// <p>The JSON data payload to use for the default push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
        pub fn data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.data.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.data = Some(hash_map);
            self
        }
        /// <p>The JSON data payload to use for the default push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
        pub fn set_data(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.data = input;
            self
        }
        /// <p>Specifies whether the default notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or delivering messages to an in-app notification center.</p>
        pub fn silent_push(mut self, input: bool) -> Self {
            self.silent_push = Some(input);
            self
        }
        /// <p>Specifies whether the default notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or delivering messages to an in-app notification center.</p>
        pub fn set_silent_push(mut self, input: std::option::Option<bool>) -> Self {
            self.silent_push = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// <p>The default title to display above the notification message on a recipient's device.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The default title to display above the notification message on a recipient's device.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The default URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The default URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultPushNotificationMessage`](crate::model::DefaultPushNotificationMessage)
        pub fn build(self) -> crate::model::DefaultPushNotificationMessage {
            crate::model::DefaultPushNotificationMessage {
                action: self.action,
                body: self.body,
                data: self.data,
                silent_push: self.silent_push.unwrap_or_default(),
                substitutions: self.substitutions,
                title: self.title,
                url: self.url,
            }
        }
    }
}
impl DefaultPushNotificationMessage {
    /// Creates a new builder-style object to manufacture [`DefaultPushNotificationMessage`](crate::model::DefaultPushNotificationMessage)
    pub fn builder() -> crate::model::default_push_notification_message::Builder {
        crate::model::default_push_notification_message::Builder::default()
    }
}

/// <p>Specifies the default message for all channels.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultMessage {
    /// <p>The default body of the message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The default message variables to use in the message. You can override these default variables with individual address variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
}
impl std::fmt::Debug for DefaultMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultMessage");
        formatter.field("body", &self.body);
        formatter.field("substitutions", &self.substitutions);
        formatter.finish()
    }
}
/// See [`DefaultMessage`](crate::model::DefaultMessage)
pub mod default_message {
    /// A builder for [`DefaultMessage`](crate::model::DefaultMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The default body of the message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The default body of the message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>The default message variables to use in the message. You can override these default variables with individual address variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>The default message variables to use in the message. You can override these default variables with individual address variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultMessage`](crate::model::DefaultMessage)
        pub fn build(self) -> crate::model::DefaultMessage {
            crate::model::DefaultMessage {
                body: self.body,
                substitutions: self.substitutions,
            }
        }
    }
}
impl DefaultMessage {
    /// Creates a new builder-style object to manufacture [`DefaultMessage`](crate::model::DefaultMessage)
    pub fn builder() -> crate::model::default_message::Builder {
        crate::model::default_message::Builder::default()
    }
}

/// <p>Specifies the settings for a one-time message that's sent directly to an endpoint through the Baidu (Baidu Cloud Push) channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BaiduMessage {
    /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    pub action: std::option::Option<crate::model::Action>,
    /// <p>The body of the notification message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
    pub data:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The icon image name of the asset saved in your app.</p>
    pub icon_reference: std::option::Option<std::string::String>,
    /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
    pub image_icon_url: std::option::Option<std::string::String>,
    /// <p>The URL of an image to display in the push notification.</p>
    pub image_url: std::option::Option<std::string::String>,
    /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
    pub raw_content: std::option::Option<std::string::String>,
    /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
    pub silent_push: bool,
    /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
    pub small_image_icon_url: std::option::Option<std::string::String>,
    /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
    pub sound: std::option::Option<std::string::String>,
    /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The amount of time, in seconds, that the Baidu Cloud Push service should store the message if the recipient's device is offline. The default value and maximum supported time is 604,800 seconds (7 days).</p>
    pub time_to_live: i32,
    /// <p>The title to display above the notification message on the recipient's device.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BaiduMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BaiduMessage");
        formatter.field("action", &self.action);
        formatter.field("body", &self.body);
        formatter.field("data", &self.data);
        formatter.field("icon_reference", &self.icon_reference);
        formatter.field("image_icon_url", &self.image_icon_url);
        formatter.field("image_url", &self.image_url);
        formatter.field("raw_content", &self.raw_content);
        formatter.field("silent_push", &self.silent_push);
        formatter.field("small_image_icon_url", &self.small_image_icon_url);
        formatter.field("sound", &self.sound);
        formatter.field("substitutions", &self.substitutions);
        formatter.field("time_to_live", &self.time_to_live);
        formatter.field("title", &self.title);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`BaiduMessage`](crate::model::BaiduMessage)
pub mod baidu_message {
    /// A builder for [`BaiduMessage`](crate::model::BaiduMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) data: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) icon_reference: std::option::Option<std::string::String>,
        pub(crate) image_icon_url: std::option::Option<std::string::String>,
        pub(crate) image_url: std::option::Option<std::string::String>,
        pub(crate) raw_content: std::option::Option<std::string::String>,
        pub(crate) silent_push: std::option::Option<bool>,
        pub(crate) small_image_icon_url: std::option::Option<std::string::String>,
        pub(crate) sound: std::option::Option<std::string::String>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) time_to_live: std::option::Option<i32>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// <p>The body of the notification message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The body of the notification message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// Adds a key-value pair to `data`.
        ///
        /// To override the contents of this collection use [`set_data`](Self::set_data).
        ///
        /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
        pub fn data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.data.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.data = Some(hash_map);
            self
        }
        /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
        pub fn set_data(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.data = input;
            self
        }
        /// <p>The icon image name of the asset saved in your app.</p>
        pub fn icon_reference(mut self, input: impl Into<std::string::String>) -> Self {
            self.icon_reference = Some(input.into());
            self
        }
        /// <p>The icon image name of the asset saved in your app.</p>
        pub fn set_icon_reference(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.icon_reference = input;
            self
        }
        /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
        pub fn image_icon_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_icon_url = Some(input.into());
            self
        }
        /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
        pub fn set_image_icon_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_icon_url = input;
            self
        }
        /// <p>The URL of an image to display in the push notification.</p>
        pub fn image_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_url = Some(input.into());
            self
        }
        /// <p>The URL of an image to display in the push notification.</p>
        pub fn set_image_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_url = input;
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
        pub fn raw_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_content = Some(input.into());
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
        pub fn set_raw_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_content = input;
            self
        }
        /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
        pub fn silent_push(mut self, input: bool) -> Self {
            self.silent_push = Some(input);
            self
        }
        /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
        pub fn set_silent_push(mut self, input: std::option::Option<bool>) -> Self {
            self.silent_push = input;
            self
        }
        /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
        pub fn small_image_icon_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.small_image_icon_url = Some(input.into());
            self
        }
        /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
        pub fn set_small_image_icon_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.small_image_icon_url = input;
            self
        }
        /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
        pub fn sound(mut self, input: impl Into<std::string::String>) -> Self {
            self.sound = Some(input.into());
            self
        }
        /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
        pub fn set_sound(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sound = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// <p>The amount of time, in seconds, that the Baidu Cloud Push service should store the message if the recipient's device is offline. The default value and maximum supported time is 604,800 seconds (7 days).</p>
        pub fn time_to_live(mut self, input: i32) -> Self {
            self.time_to_live = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, that the Baidu Cloud Push service should store the message if the recipient's device is offline. The default value and maximum supported time is 604,800 seconds (7 days).</p>
        pub fn set_time_to_live(mut self, input: std::option::Option<i32>) -> Self {
            self.time_to_live = input;
            self
        }
        /// <p>The title to display above the notification message on the recipient's device.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title to display above the notification message on the recipient's device.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`BaiduMessage`](crate::model::BaiduMessage)
        pub fn build(self) -> crate::model::BaiduMessage {
            crate::model::BaiduMessage {
                action: self.action,
                body: self.body,
                data: self.data,
                icon_reference: self.icon_reference,
                image_icon_url: self.image_icon_url,
                image_url: self.image_url,
                raw_content: self.raw_content,
                silent_push: self.silent_push.unwrap_or_default(),
                small_image_icon_url: self.small_image_icon_url,
                sound: self.sound,
                substitutions: self.substitutions,
                time_to_live: self.time_to_live.unwrap_or_default(),
                title: self.title,
                url: self.url,
            }
        }
    }
}
impl BaiduMessage {
    /// Creates a new builder-style object to manufacture [`BaiduMessage`](crate::model::BaiduMessage)
    pub fn builder() -> crate::model::baidu_message::Builder {
        crate::model::baidu_message::Builder::default()
    }
}

/// <p>Specifies the settings for a one-time message that's sent directly to an endpoint through the APNs (Apple Push Notification service) channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApnsMessage {
    /// <p>The type of push notification to send. Valid values are:</p> <ul><li><p>alert - For a standard notification that's displayed on recipients' devices and prompts a recipient to interact with the notification.</p></li> <li><p>background - For a silent notification that delivers content in the background and isn't displayed on recipients' devices.</p></li> <li><p>complication - For a notification that contains update information for an app’s complication timeline.</p></li> <li><p>fileprovider - For a notification that signals changes to a File Provider extension.</p></li> <li><p>mdm - For a notification that tells managed devices to contact the MDM server.</p></li> <li><p>voip - For a notification that provides information about an incoming VoIP call.</p></li></ul> <p>Amazon Pinpoint specifies this value in the apns-push-type request header when it sends the notification message to APNs. If you don't specify a value for this property, Amazon Pinpoint sets the value to alert or background automatically, based on the value that you specify for the SilentPush or RawContent property of the message.</p> <p>For more information about the apns-push-type request header, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/sending_notification_requests_to_apns">Sending Notification Requests to APNs</a> on the Apple Developer website.</p>
    pub apns_push_type: std::option::Option<std::string::String>,
    /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    pub action: std::option::Option<crate::model::Action>,
    /// <p>The key that indicates whether and how to modify the badge of your app's icon when the recipient receives the push notification. If this key isn't included in the dictionary, the badge doesn't change. To remove the badge, set this value to 0.</p>
    pub badge: i32,
    /// <p>The body of the notification message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The key that indicates the notification type for the push notification. This key is a value that's defined by the identifier property of one of your app's registered categories.</p>
    pub category: std::option::Option<std::string::String>,
    /// <p>An arbitrary identifier that, if assigned to multiple messages, APNs uses to coalesce the messages into a single push notification instead of delivering each message individually. This value can't exceed 64 bytes.</p> <p>Amazon Pinpoint specifies this value in the apns-collapse-id request header when it sends the notification message to APNs.</p>
    pub collapse_id: std::option::Option<std::string::String>,
    /// <p>The JSON payload to use for a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
    pub data:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The URL of an image or video to display in the push notification.</p>
    pub media_url: std::option::Option<std::string::String>,
    /// <p>The authentication method that you want Amazon Pinpoint to use when authenticating with APNs, CERTIFICATE or TOKEN.</p>
    pub preferred_authentication_method: std::option::Option<std::string::String>,
    /// <p>para>5 - Low priority, the notification might be delayed, delivered as part of a group, or throttled.</p>/listitem> <li><p>10 - High priority, the notification is sent immediately. This is the default value. A high priority notification should trigger an alert, play a sound, or badge your app's icon on the recipient's device.</p></li>/para> <p>Amazon Pinpoint specifies this value in the apns-priority request header when it sends the notification message to APNs.</p> <p>The equivalent values for Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), are normal, for 5, and high, for 10. If you specify an FCM value for this property, Amazon Pinpoint accepts and converts the value to the corresponding APNs value.</p>
    pub priority: std::option::Option<std::string::String>,
    /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p> <note><p>If you specify the raw content of an APNs push notification, the message payload has to include the content-available key. The value of the content-available key has to be an integer, and can only be 0 or 1. If you're sending a standard notification, set the value of content-available to 0. If you're sending a silent (background) notification, set the value of content-available to 1. Additionally, silent notification payloads can't include the alert, badge, or sound keys. For more information, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification">Generating a Remote Notification</a> and <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app">Pushing Background Updates to Your App</a> on the Apple Developer website.</p></note>
    pub raw_content: std::option::Option<std::string::String>,
    /// <p>Specifies whether the notification is a silent push notification. A silent (or background) push notification isn't displayed on recipients' devices. You can use silent push notifications to make small updates to your app, or to display messages in an in-app message center.</p> <p>Amazon Pinpoint uses this property to determine the correct value for the apns-push-type request header when it sends the notification message to APNs. If you specify a value of true for this property, Amazon Pinpoint sets the value for the apns-push-type header field to background.</p> <note><p>If you specify the raw content of an APNs push notification, the message payload has to include the content-available key. For silent (background) notifications, set the value of content-available to 1. Additionally, the message payload for a silent notification can't include the alert, badge, or sound keys. For more information, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification">Generating a Remote Notification</a> and <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app">Pushing Background Updates to Your App</a> on the Apple Developer website.</p> <p>Apple has indicated that they will throttle "excessive" background notifications based on current traffic volumes. To prevent your notifications being throttled, Apple recommends that you send no more than 3 silent push notifications to each recipient per hour.</p></note>
    pub silent_push: bool,
    /// <p>The key for the sound to play when the recipient receives the push notification. The value for this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
    pub sound: std::option::Option<std::string::String>,
    /// <p>The default message variables to use in the notification message. You can override these default variables with individual address variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The key that represents your app-specific identifier for grouping notifications. If you provide a Notification Content app extension, you can use this value to group your notifications together.</p>
    pub thread_id: std::option::Option<std::string::String>,
    /// <p>The amount of time, in seconds, that APNs should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If this value is 0, APNs treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>Amazon Pinpoint specifies this value in the apns-expiration request header when it sends the notification message to APNs.</p>
    pub time_to_live: i32,
    /// <p>The title to display above the notification message on the recipient's device.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApnsMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApnsMessage");
        formatter.field("apns_push_type", &self.apns_push_type);
        formatter.field("action", &self.action);
        formatter.field("badge", &self.badge);
        formatter.field("body", &self.body);
        formatter.field("category", &self.category);
        formatter.field("collapse_id", &self.collapse_id);
        formatter.field("data", &self.data);
        formatter.field("media_url", &self.media_url);
        formatter.field(
            "preferred_authentication_method",
            &self.preferred_authentication_method,
        );
        formatter.field("priority", &self.priority);
        formatter.field("raw_content", &self.raw_content);
        formatter.field("silent_push", &self.silent_push);
        formatter.field("sound", &self.sound);
        formatter.field("substitutions", &self.substitutions);
        formatter.field("thread_id", &self.thread_id);
        formatter.field("time_to_live", &self.time_to_live);
        formatter.field("title", &self.title);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`ApnsMessage`](crate::model::ApnsMessage)
pub mod apns_message {
    /// A builder for [`ApnsMessage`](crate::model::ApnsMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) apns_push_type: std::option::Option<std::string::String>,
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) badge: std::option::Option<i32>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) category: std::option::Option<std::string::String>,
        pub(crate) collapse_id: std::option::Option<std::string::String>,
        pub(crate) data: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) media_url: std::option::Option<std::string::String>,
        pub(crate) preferred_authentication_method: std::option::Option<std::string::String>,
        pub(crate) priority: std::option::Option<std::string::String>,
        pub(crate) raw_content: std::option::Option<std::string::String>,
        pub(crate) silent_push: std::option::Option<bool>,
        pub(crate) sound: std::option::Option<std::string::String>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) thread_id: std::option::Option<std::string::String>,
        pub(crate) time_to_live: std::option::Option<i32>,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of push notification to send. Valid values are:</p> <ul><li><p>alert - For a standard notification that's displayed on recipients' devices and prompts a recipient to interact with the notification.</p></li> <li><p>background - For a silent notification that delivers content in the background and isn't displayed on recipients' devices.</p></li> <li><p>complication - For a notification that contains update information for an app’s complication timeline.</p></li> <li><p>fileprovider - For a notification that signals changes to a File Provider extension.</p></li> <li><p>mdm - For a notification that tells managed devices to contact the MDM server.</p></li> <li><p>voip - For a notification that provides information about an incoming VoIP call.</p></li></ul> <p>Amazon Pinpoint specifies this value in the apns-push-type request header when it sends the notification message to APNs. If you don't specify a value for this property, Amazon Pinpoint sets the value to alert or background automatically, based on the value that you specify for the SilentPush or RawContent property of the message.</p> <p>For more information about the apns-push-type request header, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/sending_notification_requests_to_apns">Sending Notification Requests to APNs</a> on the Apple Developer website.</p>
        pub fn apns_push_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.apns_push_type = Some(input.into());
            self
        }
        /// <p>The type of push notification to send. Valid values are:</p> <ul><li><p>alert - For a standard notification that's displayed on recipients' devices and prompts a recipient to interact with the notification.</p></li> <li><p>background - For a silent notification that delivers content in the background and isn't displayed on recipients' devices.</p></li> <li><p>complication - For a notification that contains update information for an app’s complication timeline.</p></li> <li><p>fileprovider - For a notification that signals changes to a File Provider extension.</p></li> <li><p>mdm - For a notification that tells managed devices to contact the MDM server.</p></li> <li><p>voip - For a notification that provides information about an incoming VoIP call.</p></li></ul> <p>Amazon Pinpoint specifies this value in the apns-push-type request header when it sends the notification message to APNs. If you don't specify a value for this property, Amazon Pinpoint sets the value to alert or background automatically, based on the value that you specify for the SilentPush or RawContent property of the message.</p> <p>For more information about the apns-push-type request header, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/sending_notification_requests_to_apns">Sending Notification Requests to APNs</a> on the Apple Developer website.</p>
        pub fn set_apns_push_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.apns_push_type = input;
            self
        }
        /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// <p>The key that indicates whether and how to modify the badge of your app's icon when the recipient receives the push notification. If this key isn't included in the dictionary, the badge doesn't change. To remove the badge, set this value to 0.</p>
        pub fn badge(mut self, input: i32) -> Self {
            self.badge = Some(input);
            self
        }
        /// <p>The key that indicates whether and how to modify the badge of your app's icon when the recipient receives the push notification. If this key isn't included in the dictionary, the badge doesn't change. To remove the badge, set this value to 0.</p>
        pub fn set_badge(mut self, input: std::option::Option<i32>) -> Self {
            self.badge = input;
            self
        }
        /// <p>The body of the notification message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The body of the notification message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The key that indicates the notification type for the push notification. This key is a value that's defined by the identifier property of one of your app's registered categories.</p>
        pub fn category(mut self, input: impl Into<std::string::String>) -> Self {
            self.category = Some(input.into());
            self
        }
        /// <p>The key that indicates the notification type for the push notification. This key is a value that's defined by the identifier property of one of your app's registered categories.</p>
        pub fn set_category(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.category = input;
            self
        }
        /// <p>An arbitrary identifier that, if assigned to multiple messages, APNs uses to coalesce the messages into a single push notification instead of delivering each message individually. This value can't exceed 64 bytes.</p> <p>Amazon Pinpoint specifies this value in the apns-collapse-id request header when it sends the notification message to APNs.</p>
        pub fn collapse_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.collapse_id = Some(input.into());
            self
        }
        /// <p>An arbitrary identifier that, if assigned to multiple messages, APNs uses to coalesce the messages into a single push notification instead of delivering each message individually. This value can't exceed 64 bytes.</p> <p>Amazon Pinpoint specifies this value in the apns-collapse-id request header when it sends the notification message to APNs.</p>
        pub fn set_collapse_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.collapse_id = input;
            self
        }
        /// Adds a key-value pair to `data`.
        ///
        /// To override the contents of this collection use [`set_data`](Self::set_data).
        ///
        /// <p>The JSON payload to use for a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
        pub fn data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.data.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.data = Some(hash_map);
            self
        }
        /// <p>The JSON payload to use for a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
        pub fn set_data(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.data = input;
            self
        }
        /// <p>The URL of an image or video to display in the push notification.</p>
        pub fn media_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.media_url = Some(input.into());
            self
        }
        /// <p>The URL of an image or video to display in the push notification.</p>
        pub fn set_media_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.media_url = input;
            self
        }
        /// <p>The authentication method that you want Amazon Pinpoint to use when authenticating with APNs, CERTIFICATE or TOKEN.</p>
        pub fn preferred_authentication_method(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.preferred_authentication_method = Some(input.into());
            self
        }
        /// <p>The authentication method that you want Amazon Pinpoint to use when authenticating with APNs, CERTIFICATE or TOKEN.</p>
        pub fn set_preferred_authentication_method(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.preferred_authentication_method = input;
            self
        }
        /// <p>para>5 - Low priority, the notification might be delayed, delivered as part of a group, or throttled.</p>/listitem> <li><p>10 - High priority, the notification is sent immediately. This is the default value. A high priority notification should trigger an alert, play a sound, or badge your app's icon on the recipient's device.</p></li>/para> <p>Amazon Pinpoint specifies this value in the apns-priority request header when it sends the notification message to APNs.</p> <p>The equivalent values for Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), are normal, for 5, and high, for 10. If you specify an FCM value for this property, Amazon Pinpoint accepts and converts the value to the corresponding APNs value.</p>
        pub fn priority(mut self, input: impl Into<std::string::String>) -> Self {
            self.priority = Some(input.into());
            self
        }
        /// <p>para>5 - Low priority, the notification might be delayed, delivered as part of a group, or throttled.</p>/listitem> <li><p>10 - High priority, the notification is sent immediately. This is the default value. A high priority notification should trigger an alert, play a sound, or badge your app's icon on the recipient's device.</p></li>/para> <p>Amazon Pinpoint specifies this value in the apns-priority request header when it sends the notification message to APNs.</p> <p>The equivalent values for Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), are normal, for 5, and high, for 10. If you specify an FCM value for this property, Amazon Pinpoint accepts and converts the value to the corresponding APNs value.</p>
        pub fn set_priority(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.priority = input;
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p> <note><p>If you specify the raw content of an APNs push notification, the message payload has to include the content-available key. The value of the content-available key has to be an integer, and can only be 0 or 1. If you're sending a standard notification, set the value of content-available to 0. If you're sending a silent (background) notification, set the value of content-available to 1. Additionally, silent notification payloads can't include the alert, badge, or sound keys. For more information, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification">Generating a Remote Notification</a> and <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app">Pushing Background Updates to Your App</a> on the Apple Developer website.</p></note>
        pub fn raw_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_content = Some(input.into());
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p> <note><p>If you specify the raw content of an APNs push notification, the message payload has to include the content-available key. The value of the content-available key has to be an integer, and can only be 0 or 1. If you're sending a standard notification, set the value of content-available to 0. If you're sending a silent (background) notification, set the value of content-available to 1. Additionally, silent notification payloads can't include the alert, badge, or sound keys. For more information, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification">Generating a Remote Notification</a> and <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app">Pushing Background Updates to Your App</a> on the Apple Developer website.</p></note>
        pub fn set_raw_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_content = input;
            self
        }
        /// <p>Specifies whether the notification is a silent push notification. A silent (or background) push notification isn't displayed on recipients' devices. You can use silent push notifications to make small updates to your app, or to display messages in an in-app message center.</p> <p>Amazon Pinpoint uses this property to determine the correct value for the apns-push-type request header when it sends the notification message to APNs. If you specify a value of true for this property, Amazon Pinpoint sets the value for the apns-push-type header field to background.</p> <note><p>If you specify the raw content of an APNs push notification, the message payload has to include the content-available key. For silent (background) notifications, set the value of content-available to 1. Additionally, the message payload for a silent notification can't include the alert, badge, or sound keys. For more information, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification">Generating a Remote Notification</a> and <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app">Pushing Background Updates to Your App</a> on the Apple Developer website.</p> <p>Apple has indicated that they will throttle "excessive" background notifications based on current traffic volumes. To prevent your notifications being throttled, Apple recommends that you send no more than 3 silent push notifications to each recipient per hour.</p></note>
        pub fn silent_push(mut self, input: bool) -> Self {
            self.silent_push = Some(input);
            self
        }
        /// <p>Specifies whether the notification is a silent push notification. A silent (or background) push notification isn't displayed on recipients' devices. You can use silent push notifications to make small updates to your app, or to display messages in an in-app message center.</p> <p>Amazon Pinpoint uses this property to determine the correct value for the apns-push-type request header when it sends the notification message to APNs. If you specify a value of true for this property, Amazon Pinpoint sets the value for the apns-push-type header field to background.</p> <note><p>If you specify the raw content of an APNs push notification, the message payload has to include the content-available key. For silent (background) notifications, set the value of content-available to 1. Additionally, the message payload for a silent notification can't include the alert, badge, or sound keys. For more information, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification">Generating a Remote Notification</a> and <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app">Pushing Background Updates to Your App</a> on the Apple Developer website.</p> <p>Apple has indicated that they will throttle "excessive" background notifications based on current traffic volumes. To prevent your notifications being throttled, Apple recommends that you send no more than 3 silent push notifications to each recipient per hour.</p></note>
        pub fn set_silent_push(mut self, input: std::option::Option<bool>) -> Self {
            self.silent_push = input;
            self
        }
        /// <p>The key for the sound to play when the recipient receives the push notification. The value for this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
        pub fn sound(mut self, input: impl Into<std::string::String>) -> Self {
            self.sound = Some(input.into());
            self
        }
        /// <p>The key for the sound to play when the recipient receives the push notification. The value for this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
        pub fn set_sound(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sound = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>The default message variables to use in the notification message. You can override these default variables with individual address variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>The default message variables to use in the notification message. You can override these default variables with individual address variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// <p>The key that represents your app-specific identifier for grouping notifications. If you provide a Notification Content app extension, you can use this value to group your notifications together.</p>
        pub fn thread_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.thread_id = Some(input.into());
            self
        }
        /// <p>The key that represents your app-specific identifier for grouping notifications. If you provide a Notification Content app extension, you can use this value to group your notifications together.</p>
        pub fn set_thread_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.thread_id = input;
            self
        }
        /// <p>The amount of time, in seconds, that APNs should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If this value is 0, APNs treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>Amazon Pinpoint specifies this value in the apns-expiration request header when it sends the notification message to APNs.</p>
        pub fn time_to_live(mut self, input: i32) -> Self {
            self.time_to_live = Some(input);
            self
        }
        /// <p>The amount of time, in seconds, that APNs should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If this value is 0, APNs treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>Amazon Pinpoint specifies this value in the apns-expiration request header when it sends the notification message to APNs.</p>
        pub fn set_time_to_live(mut self, input: std::option::Option<i32>) -> Self {
            self.time_to_live = input;
            self
        }
        /// <p>The title to display above the notification message on the recipient's device.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title to display above the notification message on the recipient's device.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`ApnsMessage`](crate::model::ApnsMessage)
        pub fn build(self) -> crate::model::ApnsMessage {
            crate::model::ApnsMessage {
                apns_push_type: self.apns_push_type,
                action: self.action,
                badge: self.badge.unwrap_or_default(),
                body: self.body,
                category: self.category,
                collapse_id: self.collapse_id,
                data: self.data,
                media_url: self.media_url,
                preferred_authentication_method: self.preferred_authentication_method,
                priority: self.priority,
                raw_content: self.raw_content,
                silent_push: self.silent_push.unwrap_or_default(),
                sound: self.sound,
                substitutions: self.substitutions,
                thread_id: self.thread_id,
                time_to_live: self.time_to_live.unwrap_or_default(),
                title: self.title,
                url: self.url,
            }
        }
    }
}
impl ApnsMessage {
    /// Creates a new builder-style object to manufacture [`ApnsMessage`](crate::model::ApnsMessage)
    pub fn builder() -> crate::model::apns_message::Builder {
        crate::model::apns_message::Builder::default()
    }
}

/// <p>Specifies the settings for a one-time message that's sent directly to an endpoint through the ADM (Amazon Device Messaging) channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AdmMessage {
    /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    pub action: std::option::Option<crate::model::Action>,
    /// <p>The body of the notification message.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>An arbitrary string that indicates that multiple messages are logically the same and that Amazon Device Messaging (ADM) can drop previously enqueued messages in favor of this message.</p>
    pub consolidation_key: std::option::Option<std::string::String>,
    /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
    pub data:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The amount of time, in seconds, that ADM should store the message if the recipient's device is offline. Amazon Pinpoint specifies this value in the expiresAfter parameter when it sends the notification message to ADM.</p>
    pub expires_after: std::option::Option<std::string::String>,
    /// <p>The icon image name of the asset saved in your app.</p>
    pub icon_reference: std::option::Option<std::string::String>,
    /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
    pub image_icon_url: std::option::Option<std::string::String>,
    /// <p>The URL of an image to display in the push notification.</p>
    pub image_url: std::option::Option<std::string::String>,
    /// <p>The base64-encoded, MD5 checksum of the value specified by the Data property. ADM uses the MD5 value to verify the integrity of the data.</p>
    pub md5: std::option::Option<std::string::String>,
    /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
    pub raw_content: std::option::Option<std::string::String>,
    /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
    pub silent_push: bool,
    /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
    pub small_image_icon_url: std::option::Option<std::string::String>,
    /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
    pub sound: std::option::Option<std::string::String>,
    /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The title to display above the notification message on the recipient's device.</p>
    pub title: std::option::Option<std::string::String>,
    /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AdmMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AdmMessage");
        formatter.field("action", &self.action);
        formatter.field("body", &self.body);
        formatter.field("consolidation_key", &self.consolidation_key);
        formatter.field("data", &self.data);
        formatter.field("expires_after", &self.expires_after);
        formatter.field("icon_reference", &self.icon_reference);
        formatter.field("image_icon_url", &self.image_icon_url);
        formatter.field("image_url", &self.image_url);
        formatter.field("md5", &self.md5);
        formatter.field("raw_content", &self.raw_content);
        formatter.field("silent_push", &self.silent_push);
        formatter.field("small_image_icon_url", &self.small_image_icon_url);
        formatter.field("sound", &self.sound);
        formatter.field("substitutions", &self.substitutions);
        formatter.field("title", &self.title);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`AdmMessage`](crate::model::AdmMessage)
pub mod adm_message {
    /// A builder for [`AdmMessage`](crate::model::AdmMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) action: std::option::Option<crate::model::Action>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) consolidation_key: std::option::Option<std::string::String>,
        pub(crate) data: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) expires_after: std::option::Option<std::string::String>,
        pub(crate) icon_reference: std::option::Option<std::string::String>,
        pub(crate) image_icon_url: std::option::Option<std::string::String>,
        pub(crate) image_url: std::option::Option<std::string::String>,
        pub(crate) md5: std::option::Option<std::string::String>,
        pub(crate) raw_content: std::option::Option<std::string::String>,
        pub(crate) silent_push: std::option::Option<bool>,
        pub(crate) small_image_icon_url: std::option::Option<std::string::String>,
        pub(crate) sound: std::option::Option<std::string::String>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) title: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn action(mut self, input: crate::model::Action) -> Self {
            self.action = Some(input);
            self
        }
        /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
        pub fn set_action(mut self, input: std::option::Option<crate::model::Action>) -> Self {
            self.action = input;
            self
        }
        /// <p>The body of the notification message.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The body of the notification message.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>An arbitrary string that indicates that multiple messages are logically the same and that Amazon Device Messaging (ADM) can drop previously enqueued messages in favor of this message.</p>
        pub fn consolidation_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.consolidation_key = Some(input.into());
            self
        }
        /// <p>An arbitrary string that indicates that multiple messages are logically the same and that Amazon Device Messaging (ADM) can drop previously enqueued messages in favor of this message.</p>
        pub fn set_consolidation_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.consolidation_key = input;
            self
        }
        /// Adds a key-value pair to `data`.
        ///
        /// To override the contents of this collection use [`set_data`](Self::set_data).
        ///
        /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
        pub fn data(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.data.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.data = Some(hash_map);
            self
        }
        /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
        pub fn set_data(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.data = input;
            self
        }
        /// <p>The amount of time, in seconds, that ADM should store the message if the recipient's device is offline. Amazon Pinpoint specifies this value in the expiresAfter parameter when it sends the notification message to ADM.</p>
        pub fn expires_after(mut self, input: impl Into<std::string::String>) -> Self {
            self.expires_after = Some(input.into());
            self
        }
        /// <p>The amount of time, in seconds, that ADM should store the message if the recipient's device is offline. Amazon Pinpoint specifies this value in the expiresAfter parameter when it sends the notification message to ADM.</p>
        pub fn set_expires_after(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.expires_after = input;
            self
        }
        /// <p>The icon image name of the asset saved in your app.</p>
        pub fn icon_reference(mut self, input: impl Into<std::string::String>) -> Self {
            self.icon_reference = Some(input.into());
            self
        }
        /// <p>The icon image name of the asset saved in your app.</p>
        pub fn set_icon_reference(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.icon_reference = input;
            self
        }
        /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
        pub fn image_icon_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_icon_url = Some(input.into());
            self
        }
        /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
        pub fn set_image_icon_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.image_icon_url = input;
            self
        }
        /// <p>The URL of an image to display in the push notification.</p>
        pub fn image_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_url = Some(input.into());
            self
        }
        /// <p>The URL of an image to display in the push notification.</p>
        pub fn set_image_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_url = input;
            self
        }
        /// <p>The base64-encoded, MD5 checksum of the value specified by the Data property. ADM uses the MD5 value to verify the integrity of the data.</p>
        pub fn md5(mut self, input: impl Into<std::string::String>) -> Self {
            self.md5 = Some(input.into());
            self
        }
        /// <p>The base64-encoded, MD5 checksum of the value specified by the Data property. ADM uses the MD5 value to verify the integrity of the data.</p>
        pub fn set_md5(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.md5 = input;
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
        pub fn raw_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_content = Some(input.into());
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
        pub fn set_raw_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_content = input;
            self
        }
        /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
        pub fn silent_push(mut self, input: bool) -> Self {
            self.silent_push = Some(input);
            self
        }
        /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
        pub fn set_silent_push(mut self, input: std::option::Option<bool>) -> Self {
            self.silent_push = input;
            self
        }
        /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
        pub fn small_image_icon_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.small_image_icon_url = Some(input.into());
            self
        }
        /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
        pub fn set_small_image_icon_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.small_image_icon_url = input;
            self
        }
        /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
        pub fn sound(mut self, input: impl Into<std::string::String>) -> Self {
            self.sound = Some(input.into());
            self
        }
        /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
        pub fn set_sound(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sound = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// <p>The title to display above the notification message on the recipient's device.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.title = Some(input.into());
            self
        }
        /// <p>The title to display above the notification message on the recipient's device.</p>
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.title = input;
            self
        }
        /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`AdmMessage`](crate::model::AdmMessage)
        pub fn build(self) -> crate::model::AdmMessage {
            crate::model::AdmMessage {
                action: self.action,
                body: self.body,
                consolidation_key: self.consolidation_key,
                data: self.data,
                expires_after: self.expires_after,
                icon_reference: self.icon_reference,
                image_icon_url: self.image_icon_url,
                image_url: self.image_url,
                md5: self.md5,
                raw_content: self.raw_content,
                silent_push: self.silent_push.unwrap_or_default(),
                small_image_icon_url: self.small_image_icon_url,
                sound: self.sound,
                substitutions: self.substitutions,
                title: self.title,
                url: self.url,
            }
        }
    }
}
impl AdmMessage {
    /// Creates a new builder-style object to manufacture [`AdmMessage`](crate::model::AdmMessage)
    pub fn builder() -> crate::model::adm_message::Builder {
        crate::model::adm_message::Builder::default()
    }
}

/// <p>Provides information about the results of a request to send a message to an endpoint address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MessageResponse {
    /// <p>The unique identifier for the application that was used to send the message.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>A map that contains a multipart response for each address that the message was sent to. In the map, the endpoint ID is the key and the result is the value.</p>
    pub endpoint_result: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::EndpointMessageResult>,
    >,
    /// <p>The identifier for the original request that the message was delivered for.</p>
    pub request_id: std::option::Option<std::string::String>,
    /// <p>A map that contains a multipart response for each address (email address, phone number, or push notification token) that the message was sent to. In the map, the address is the key and the result is the value.</p>
    pub result: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::MessageResult>,
    >,
}
impl std::fmt::Debug for MessageResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MessageResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("endpoint_result", &self.endpoint_result);
        formatter.field("request_id", &self.request_id);
        formatter.field("result", &self.result);
        formatter.finish()
    }
}
/// See [`MessageResponse`](crate::model::MessageResponse)
pub mod message_response {
    /// A builder for [`MessageResponse`](crate::model::MessageResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) endpoint_result: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::EndpointMessageResult>,
        >,
        pub(crate) request_id: std::option::Option<std::string::String>,
        pub(crate) result: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::MessageResult>,
        >,
    }
    impl Builder {
        /// <p>The unique identifier for the application that was used to send the message.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that was used to send the message.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// Adds a key-value pair to `endpoint_result`.
        ///
        /// To override the contents of this collection use [`set_endpoint_result`](Self::set_endpoint_result).
        ///
        /// <p>A map that contains a multipart response for each address that the message was sent to. In the map, the endpoint ID is the key and the result is the value.</p>
        pub fn endpoint_result(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::EndpointMessageResult>,
        ) -> Self {
            let mut hash_map = self.endpoint_result.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.endpoint_result = Some(hash_map);
            self
        }
        /// <p>A map that contains a multipart response for each address that the message was sent to. In the map, the endpoint ID is the key and the result is the value.</p>
        pub fn set_endpoint_result(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::EndpointMessageResult>,
            >,
        ) -> Self {
            self.endpoint_result = input;
            self
        }
        /// <p>The identifier for the original request that the message was delivered for.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The identifier for the original request that the message was delivered for.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Adds a key-value pair to `result`.
        ///
        /// To override the contents of this collection use [`set_result`](Self::set_result).
        ///
        /// <p>A map that contains a multipart response for each address (email address, phone number, or push notification token) that the message was sent to. In the map, the address is the key and the result is the value.</p>
        pub fn result(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::MessageResult>,
        ) -> Self {
            let mut hash_map = self.result.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.result = Some(hash_map);
            self
        }
        /// <p>A map that contains a multipart response for each address (email address, phone number, or push notification token) that the message was sent to. In the map, the address is the key and the result is the value.</p>
        pub fn set_result(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::MessageResult>,
            >,
        ) -> Self {
            self.result = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageResponse`](crate::model::MessageResponse)
        pub fn build(self) -> crate::model::MessageResponse {
            crate::model::MessageResponse {
                application_id: self.application_id,
                endpoint_result: self.endpoint_result,
                request_id: self.request_id,
                result: self.result,
            }
        }
    }
}
impl MessageResponse {
    /// Creates a new builder-style object to manufacture [`MessageResponse`](crate::model::MessageResponse)
    pub fn builder() -> crate::model::message_response::Builder {
        crate::model::message_response::Builder::default()
    }
}

/// <p>Provides information about the results of sending a message directly to an endpoint address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MessageResult {
    /// <p>The delivery status of the message. Possible values are:</p> <ul> <li><p>DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li>   <li><p>OPT_OUT - The user who's associated with the endpoint address has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li>   <li><p>SUCCESSFUL - The message was successfully delivered to the endpoint address.</p></li> <li><p>TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint address.</p></li> <li><p>TIMEOUT - The message couldn't be sent within the timeout period.</p></li> <li><p>UNKNOWN_FAILURE - An unknown error occurred.</p></li></ul>
    pub delivery_status: std::option::Option<crate::model::DeliveryStatus>,
    /// <p>The unique identifier for the message that was sent.</p>
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The downstream service status code for delivering the message.</p>
    pub status_code: i32,
    /// <p>The status message for delivering the message.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>For push notifications that are sent through the GCM channel, specifies whether the endpoint's device registration token was updated as part of delivering the message.</p>
    pub updated_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MessageResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MessageResult");
        formatter.field("delivery_status", &self.delivery_status);
        formatter.field("message_id", &self.message_id);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("updated_token", &self.updated_token);
        formatter.finish()
    }
}
/// See [`MessageResult`](crate::model::MessageResult)
pub mod message_result {
    /// A builder for [`MessageResult`](crate::model::MessageResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) delivery_status: std::option::Option<crate::model::DeliveryStatus>,
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) status_code: std::option::Option<i32>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) updated_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The delivery status of the message. Possible values are:</p> <ul> <li><p>DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li>   <li><p>OPT_OUT - The user who's associated with the endpoint address has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li>   <li><p>SUCCESSFUL - The message was successfully delivered to the endpoint address.</p></li> <li><p>TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint address.</p></li> <li><p>TIMEOUT - The message couldn't be sent within the timeout period.</p></li> <li><p>UNKNOWN_FAILURE - An unknown error occurred.</p></li></ul>
        pub fn delivery_status(mut self, input: crate::model::DeliveryStatus) -> Self {
            self.delivery_status = Some(input);
            self
        }
        /// <p>The delivery status of the message. Possible values are:</p> <ul> <li><p>DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li>   <li><p>OPT_OUT - The user who's associated with the endpoint address has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li>   <li><p>SUCCESSFUL - The message was successfully delivered to the endpoint address.</p></li> <li><p>TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint address.</p></li> <li><p>TIMEOUT - The message couldn't be sent within the timeout period.</p></li> <li><p>UNKNOWN_FAILURE - An unknown error occurred.</p></li></ul>
        pub fn set_delivery_status(
            mut self,
            input: std::option::Option<crate::model::DeliveryStatus>,
        ) -> Self {
            self.delivery_status = input;
            self
        }
        /// <p>The unique identifier for the message that was sent.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the message that was sent.</p>
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The downstream service status code for delivering the message.</p>
        pub fn status_code(mut self, input: i32) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The downstream service status code for delivering the message.</p>
        pub fn set_status_code(mut self, input: std::option::Option<i32>) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for delivering the message.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for delivering the message.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>For push notifications that are sent through the GCM channel, specifies whether the endpoint's device registration token was updated as part of delivering the message.</p>
        pub fn updated_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_token = Some(input.into());
            self
        }
        /// <p>For push notifications that are sent through the GCM channel, specifies whether the endpoint's device registration token was updated as part of delivering the message.</p>
        pub fn set_updated_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.updated_token = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageResult`](crate::model::MessageResult)
        pub fn build(self) -> crate::model::MessageResult {
            crate::model::MessageResult {
                delivery_status: self.delivery_status,
                message_id: self.message_id,
                status_code: self.status_code.unwrap_or_default(),
                status_message: self.status_message,
                updated_token: self.updated_token,
            }
        }
    }
}
impl MessageResult {
    /// Creates a new builder-style object to manufacture [`MessageResult`](crate::model::MessageResult)
    pub fn builder() -> crate::model::message_result::Builder {
        crate::model::message_result::Builder::default()
    }
}

/// <p>Specifies the configuration and other settings for a message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MessageRequest {
    /// <p>A map of key-value pairs, where each key is an address and each value is an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-addressconfiguration">AddressConfiguration</a> object. An address can be a push notification token, a phone number, or an email address. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-addressconfiguration">AddressConfiguration</a> object to tailor the message for an address by specifying settings such as content overrides and message variables.</p>
    pub addresses: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::AddressConfiguration>,
    >,
    /// <p>A map of custom attributes to attach to the message. For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
    pub context:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A map of key-value pairs, where each key is an endpoint ID and each value is an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object to tailor the message for an endpoint by specifying settings such as content overrides and message variables.</p>
    pub endpoints: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::EndpointSendConfiguration>,
    >,
    /// <p>The settings and content for the default message and any default messages that you defined for specific channels.</p>
    pub message_configuration: std::option::Option<crate::model::DirectMessageConfiguration>,
    /// <p>The message template to use for the message.</p>
    pub template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
    /// <p>The unique identifier for tracing the message. This identifier is visible to message recipients.</p>
    pub trace_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MessageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MessageRequest");
        formatter.field("addresses", &self.addresses);
        formatter.field("context", &self.context);
        formatter.field("endpoints", &self.endpoints);
        formatter.field("message_configuration", &self.message_configuration);
        formatter.field("template_configuration", &self.template_configuration);
        formatter.field("trace_id", &self.trace_id);
        formatter.finish()
    }
}
/// See [`MessageRequest`](crate::model::MessageRequest)
pub mod message_request {
    /// A builder for [`MessageRequest`](crate::model::MessageRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) addresses: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::AddressConfiguration>,
        >,
        pub(crate) context: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) endpoints: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::EndpointSendConfiguration>,
        >,
        pub(crate) message_configuration:
            std::option::Option<crate::model::DirectMessageConfiguration>,
        pub(crate) template_configuration: std::option::Option<crate::model::TemplateConfiguration>,
        pub(crate) trace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Adds a key-value pair to `addresses`.
        ///
        /// To override the contents of this collection use [`set_addresses`](Self::set_addresses).
        ///
        /// <p>A map of key-value pairs, where each key is an address and each value is an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-addressconfiguration">AddressConfiguration</a> object. An address can be a push notification token, a phone number, or an email address. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-addressconfiguration">AddressConfiguration</a> object to tailor the message for an address by specifying settings such as content overrides and message variables.</p>
        pub fn addresses(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::AddressConfiguration>,
        ) -> Self {
            let mut hash_map = self.addresses.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.addresses = Some(hash_map);
            self
        }
        /// <p>A map of key-value pairs, where each key is an address and each value is an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-addressconfiguration">AddressConfiguration</a> object. An address can be a push notification token, a phone number, or an email address. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-addressconfiguration">AddressConfiguration</a> object to tailor the message for an address by specifying settings such as content overrides and message variables.</p>
        pub fn set_addresses(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::AddressConfiguration>,
            >,
        ) -> Self {
            self.addresses = input;
            self
        }
        /// Adds a key-value pair to `context`.
        ///
        /// To override the contents of this collection use [`set_context`](Self::set_context).
        ///
        /// <p>A map of custom attributes to attach to the message. For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
        pub fn context(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.context.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.context = Some(hash_map);
            self
        }
        /// <p>A map of custom attributes to attach to the message. For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
        pub fn set_context(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.context = input;
            self
        }
        /// Adds a key-value pair to `endpoints`.
        ///
        /// To override the contents of this collection use [`set_endpoints`](Self::set_endpoints).
        ///
        /// <p>A map of key-value pairs, where each key is an endpoint ID and each value is an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object to tailor the message for an endpoint by specifying settings such as content overrides and message variables.</p>
        pub fn endpoints(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::EndpointSendConfiguration>,
        ) -> Self {
            let mut hash_map = self.endpoints.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.endpoints = Some(hash_map);
            self
        }
        /// <p>A map of key-value pairs, where each key is an endpoint ID and each value is an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object to tailor the message for an endpoint by specifying settings such as content overrides and message variables.</p>
        pub fn set_endpoints(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::EndpointSendConfiguration,
                >,
            >,
        ) -> Self {
            self.endpoints = input;
            self
        }
        /// <p>The settings and content for the default message and any default messages that you defined for specific channels.</p>
        pub fn message_configuration(
            mut self,
            input: crate::model::DirectMessageConfiguration,
        ) -> Self {
            self.message_configuration = Some(input);
            self
        }
        /// <p>The settings and content for the default message and any default messages that you defined for specific channels.</p>
        pub fn set_message_configuration(
            mut self,
            input: std::option::Option<crate::model::DirectMessageConfiguration>,
        ) -> Self {
            self.message_configuration = input;
            self
        }
        /// <p>The message template to use for the message.</p>
        pub fn template_configuration(
            mut self,
            input: crate::model::TemplateConfiguration,
        ) -> Self {
            self.template_configuration = Some(input);
            self
        }
        /// <p>The message template to use for the message.</p>
        pub fn set_template_configuration(
            mut self,
            input: std::option::Option<crate::model::TemplateConfiguration>,
        ) -> Self {
            self.template_configuration = input;
            self
        }
        /// <p>The unique identifier for tracing the message. This identifier is visible to message recipients.</p>
        pub fn trace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.trace_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for tracing the message. This identifier is visible to message recipients.</p>
        pub fn set_trace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.trace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageRequest`](crate::model::MessageRequest)
        pub fn build(self) -> crate::model::MessageRequest {
            crate::model::MessageRequest {
                addresses: self.addresses,
                context: self.context,
                endpoints: self.endpoints,
                message_configuration: self.message_configuration,
                template_configuration: self.template_configuration,
                trace_id: self.trace_id,
            }
        }
    }
}
impl MessageRequest {
    /// Creates a new builder-style object to manufacture [`MessageRequest`](crate::model::MessageRequest)
    pub fn builder() -> crate::model::message_request::Builder {
        crate::model::message_request::Builder::default()
    }
}

/// <p>Specifies address-based configuration settings for a message that's sent directly to an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AddressConfiguration {
    /// <p>The message body to use instead of the default message body. This value overrides the default message body.</p>
    pub body_override: std::option::Option<std::string::String>,
    /// <p>The channel to use when sending the message.</p>
    pub channel_type: std::option::Option<crate::model::ChannelType>,
    /// <p>An object that maps custom attributes to attributes for the address and is attached to the message. Attribute names are case sensitive.</p> <p>For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
    pub context:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides all other values for the message.</p>
    pub raw_content: std::option::Option<std::string::String>,
    /// <p>A map of the message variables to merge with the variables specified by properties of the DefaultMessage object. The variables specified in this map take precedence over all other variables.</p>
    pub substitutions: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The message title to use instead of the default message title. This value overrides the default message title.</p>
    pub title_override: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AddressConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AddressConfiguration");
        formatter.field("body_override", &self.body_override);
        formatter.field("channel_type", &self.channel_type);
        formatter.field("context", &self.context);
        formatter.field("raw_content", &self.raw_content);
        formatter.field("substitutions", &self.substitutions);
        formatter.field("title_override", &self.title_override);
        formatter.finish()
    }
}
/// See [`AddressConfiguration`](crate::model::AddressConfiguration)
pub mod address_configuration {
    /// A builder for [`AddressConfiguration`](crate::model::AddressConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) body_override: std::option::Option<std::string::String>,
        pub(crate) channel_type: std::option::Option<crate::model::ChannelType>,
        pub(crate) context: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) raw_content: std::option::Option<std::string::String>,
        pub(crate) substitutions: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) title_override: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message body to use instead of the default message body. This value overrides the default message body.</p>
        pub fn body_override(mut self, input: impl Into<std::string::String>) -> Self {
            self.body_override = Some(input.into());
            self
        }
        /// <p>The message body to use instead of the default message body. This value overrides the default message body.</p>
        pub fn set_body_override(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.body_override = input;
            self
        }
        /// <p>The channel to use when sending the message.</p>
        pub fn channel_type(mut self, input: crate::model::ChannelType) -> Self {
            self.channel_type = Some(input);
            self
        }
        /// <p>The channel to use when sending the message.</p>
        pub fn set_channel_type(
            mut self,
            input: std::option::Option<crate::model::ChannelType>,
        ) -> Self {
            self.channel_type = input;
            self
        }
        /// Adds a key-value pair to `context`.
        ///
        /// To override the contents of this collection use [`set_context`](Self::set_context).
        ///
        /// <p>An object that maps custom attributes to attributes for the address and is attached to the message. Attribute names are case sensitive.</p> <p>For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
        pub fn context(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.context.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.context = Some(hash_map);
            self
        }
        /// <p>An object that maps custom attributes to attributes for the address and is attached to the message. Attribute names are case sensitive.</p> <p>For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
        pub fn set_context(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.context = input;
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides all other values for the message.</p>
        pub fn raw_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.raw_content = Some(input.into());
            self
        }
        /// <p>The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides all other values for the message.</p>
        pub fn set_raw_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.raw_content = input;
            self
        }
        /// Adds a key-value pair to `substitutions`.
        ///
        /// To override the contents of this collection use [`set_substitutions`](Self::set_substitutions).
        ///
        /// <p>A map of the message variables to merge with the variables specified by properties of the DefaultMessage object. The variables specified in this map take precedence over all other variables.</p>
        pub fn substitutions(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.substitutions.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.substitutions = Some(hash_map);
            self
        }
        /// <p>A map of the message variables to merge with the variables specified by properties of the DefaultMessage object. The variables specified in this map take precedence over all other variables.</p>
        pub fn set_substitutions(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.substitutions = input;
            self
        }
        /// <p>The message title to use instead of the default message title. This value overrides the default message title.</p>
        pub fn title_override(mut self, input: impl Into<std::string::String>) -> Self {
            self.title_override = Some(input.into());
            self
        }
        /// <p>The message title to use instead of the default message title. This value overrides the default message title.</p>
        pub fn set_title_override(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.title_override = input;
            self
        }
        /// Consumes the builder and constructs a [`AddressConfiguration`](crate::model::AddressConfiguration)
        pub fn build(self) -> crate::model::AddressConfiguration {
            crate::model::AddressConfiguration {
                body_override: self.body_override,
                channel_type: self.channel_type,
                context: self.context,
                raw_content: self.raw_content,
                substitutions: self.substitutions,
                title_override: self.title_override,
            }
        }
    }
}
impl AddressConfiguration {
    /// Creates a new builder-style object to manufacture [`AddressConfiguration`](crate::model::AddressConfiguration)
    pub fn builder() -> crate::model::address_configuration::Builder {
        crate::model::address_configuration::Builder::default()
    }
}

/// <p>Provides information about the type and the names of attributes that were removed from all the endpoints that are associated with an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AttributesResource {
    /// <p>The unique identifier for the application.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The type of attribute or attributes that were removed from the endpoints. Valid values are:</p> <ul><li><p>endpoint-custom-attributes - Custom attributes that describe endpoints.</p></li> <li><p>endpoint-metric-attributes - Custom metrics that your app reports to Amazon Pinpoint for endpoints.</p></li> <li><p>endpoint-user-attributes - Custom attributes that describe users.</p></li></ul>
    pub attribute_type: std::option::Option<std::string::String>,
    /// <p>An array that specifies the names of the attributes that were removed from the endpoints.</p>
    pub attributes: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for AttributesResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AttributesResource");
        formatter.field("application_id", &self.application_id);
        formatter.field("attribute_type", &self.attribute_type);
        formatter.field("attributes", &self.attributes);
        formatter.finish()
    }
}
/// See [`AttributesResource`](crate::model::AttributesResource)
pub mod attributes_resource {
    /// A builder for [`AttributesResource`](crate::model::AttributesResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) attribute_type: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>The unique identifier for the application.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The type of attribute or attributes that were removed from the endpoints. Valid values are:</p> <ul><li><p>endpoint-custom-attributes - Custom attributes that describe endpoints.</p></li> <li><p>endpoint-metric-attributes - Custom metrics that your app reports to Amazon Pinpoint for endpoints.</p></li> <li><p>endpoint-user-attributes - Custom attributes that describe users.</p></li></ul>
        pub fn attribute_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.attribute_type = Some(input.into());
            self
        }
        /// <p>The type of attribute or attributes that were removed from the endpoints. Valid values are:</p> <ul><li><p>endpoint-custom-attributes - Custom attributes that describe endpoints.</p></li> <li><p>endpoint-metric-attributes - Custom metrics that your app reports to Amazon Pinpoint for endpoints.</p></li> <li><p>endpoint-user-attributes - Custom attributes that describe users.</p></li></ul>
        pub fn set_attribute_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.attribute_type = input;
            self
        }
        /// Appends an item to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>An array that specifies the names of the attributes that were removed from the endpoints.</p>
        pub fn attributes(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.attributes.unwrap_or_default();
            v.push(input.into());
            self.attributes = Some(v);
            self
        }
        /// <p>An array that specifies the names of the attributes that were removed from the endpoints.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// Consumes the builder and constructs a [`AttributesResource`](crate::model::AttributesResource)
        pub fn build(self) -> crate::model::AttributesResource {
            crate::model::AttributesResource {
                application_id: self.application_id,
                attribute_type: self.attribute_type,
                attributes: self.attributes,
            }
        }
    }
}
impl AttributesResource {
    /// Creates a new builder-style object to manufacture [`AttributesResource`](crate::model::AttributesResource)
    pub fn builder() -> crate::model::attributes_resource::Builder {
        crate::model::attributes_resource::Builder::default()
    }
}

/// <p>Specifies one or more attributes to remove from all the endpoints that are associated with an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateAttributesRequest {
    /// <p>An array of the attributes to remove from all the endpoints that are associated with the application. The array can specify the complete, exact name of each attribute to remove or it can specify a glob pattern that an attribute name must match in order for the attribute to be removed.</p>
    pub blacklist: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for UpdateAttributesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateAttributesRequest");
        formatter.field("blacklist", &self.blacklist);
        formatter.finish()
    }
}
/// See [`UpdateAttributesRequest`](crate::model::UpdateAttributesRequest)
pub mod update_attributes_request {
    /// A builder for [`UpdateAttributesRequest`](crate::model::UpdateAttributesRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) blacklist: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `blacklist`.
        ///
        /// To override the contents of this collection use [`set_blacklist`](Self::set_blacklist).
        ///
        /// <p>An array of the attributes to remove from all the endpoints that are associated with the application. The array can specify the complete, exact name of each attribute to remove or it can specify a glob pattern that an attribute name must match in order for the attribute to be removed.</p>
        pub fn blacklist(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.blacklist.unwrap_or_default();
            v.push(input.into());
            self.blacklist = Some(v);
            self
        }
        /// <p>An array of the attributes to remove from all the endpoints that are associated with the application. The array can specify the complete, exact name of each attribute to remove or it can specify a glob pattern that an attribute name must match in order for the attribute to be removed.</p>
        pub fn set_blacklist(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.blacklist = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAttributesRequest`](crate::model::UpdateAttributesRequest)
        pub fn build(self) -> crate::model::UpdateAttributesRequest {
            crate::model::UpdateAttributesRequest {
                blacklist: self.blacklist,
            }
        }
    }
}
impl UpdateAttributesRequest {
    /// Creates a new builder-style object to manufacture [`UpdateAttributesRequest`](crate::model::UpdateAttributesRequest)
    pub fn builder() -> crate::model::update_attributes_request::Builder {
        crate::model::update_attributes_request::Builder::default()
    }
}

/// <p>Specifies settings for publishing event data to an Amazon Kinesis data stream or an Amazon Kinesis Data Firehose delivery stream.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventStream {
    /// <p>The unique identifier for the application to publish event data for.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream to publish event data to.</p> <p>For a Kinesis data stream, the ARN format is: arn:aws:kinesis:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:stream/<replaceable>stream_name</replaceable>
    /// </p> <p>For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:deliverystream/<replaceable>stream_name</replaceable>
    /// </p>
    pub destination_stream_arn: std::option::Option<std::string::String>,
    /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when publishing event data, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
    pub external_id: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the event stream was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The IAM user who last modified the event stream.</p>
    pub last_updated_by: std::option::Option<std::string::String>,
    /// <p>The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EventStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventStream");
        formatter.field("application_id", &self.application_id);
        formatter.field("destination_stream_arn", &self.destination_stream_arn);
        formatter.field("external_id", &self.external_id);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("last_updated_by", &self.last_updated_by);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`EventStream`](crate::model::EventStream)
pub mod event_stream {
    /// A builder for [`EventStream`](crate::model::EventStream)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) destination_stream_arn: std::option::Option<std::string::String>,
        pub(crate) external_id: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) last_updated_by: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the application to publish event data for.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application to publish event data for.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream to publish event data to.</p> <p>For a Kinesis data stream, the ARN format is: arn:aws:kinesis:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:stream/<replaceable>stream_name</replaceable>
        /// </p> <p>For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:deliverystream/<replaceable>stream_name</replaceable>
        /// </p>
        pub fn destination_stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_stream_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream to publish event data to.</p> <p>For a Kinesis data stream, the ARN format is: arn:aws:kinesis:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:stream/<replaceable>stream_name</replaceable>
        /// </p> <p>For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:deliverystream/<replaceable>stream_name</replaceable>
        /// </p>
        pub fn set_destination_stream_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_stream_arn = input;
            self
        }
        /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when publishing event data, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when publishing event data, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the event stream was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the event stream was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The IAM user who last modified the event stream.</p>
        pub fn last_updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_updated_by = Some(input.into());
            self
        }
        /// <p>The IAM user who last modified the event stream.</p>
        pub fn set_last_updated_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_updated_by = input;
            self
        }
        /// <p>The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`EventStream`](crate::model::EventStream)
        pub fn build(self) -> crate::model::EventStream {
            crate::model::EventStream {
                application_id: self.application_id,
                destination_stream_arn: self.destination_stream_arn,
                external_id: self.external_id,
                last_modified_date: self.last_modified_date,
                last_updated_by: self.last_updated_by,
                role_arn: self.role_arn,
            }
        }
    }
}
impl EventStream {
    /// Creates a new builder-style object to manufacture [`EventStream`](crate::model::EventStream)
    pub fn builder() -> crate::model::event_stream::Builder {
        crate::model::event_stream::Builder::default()
    }
}

/// <p>Specifies the Amazon Resource Name (ARN) of an event stream to publish events to and the AWS Identity and Access Management (IAM) role to use when publishing those events.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WriteEventStream {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream that you want to publish event data to.</p> <p>For a Kinesis data stream, the ARN format is: arn:aws:kinesis:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:stream/<replaceable>stream_name</replaceable>
    /// </p> <p>For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:deliverystream/<replaceable>stream_name</replaceable>
    /// </p>
    pub destination_stream_arn: std::option::Option<std::string::String>,
    /// <p>The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.</p>
    pub role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for WriteEventStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WriteEventStream");
        formatter.field("destination_stream_arn", &self.destination_stream_arn);
        formatter.field("role_arn", &self.role_arn);
        formatter.finish()
    }
}
/// See [`WriteEventStream`](crate::model::WriteEventStream)
pub mod write_event_stream {
    /// A builder for [`WriteEventStream`](crate::model::WriteEventStream)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_stream_arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream that you want to publish event data to.</p> <p>For a Kinesis data stream, the ARN format is: arn:aws:kinesis:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:stream/<replaceable>stream_name</replaceable>
        /// </p> <p>For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:deliverystream/<replaceable>stream_name</replaceable>
        /// </p>
        pub fn destination_stream_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_stream_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream that you want to publish event data to.</p> <p>For a Kinesis data stream, the ARN format is: arn:aws:kinesis:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:stream/<replaceable>stream_name</replaceable>
        /// </p> <p>For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:deliverystream/<replaceable>stream_name</replaceable>
        /// </p>
        pub fn set_destination_stream_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_stream_arn = input;
            self
        }
        /// <p>The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`WriteEventStream`](crate::model::WriteEventStream)
        pub fn build(self) -> crate::model::WriteEventStream {
            crate::model::WriteEventStream {
                destination_stream_arn: self.destination_stream_arn,
                role_arn: self.role_arn,
            }
        }
    }
}
impl WriteEventStream {
    /// Creates a new builder-style object to manufacture [`WriteEventStream`](crate::model::WriteEventStream)
    pub fn builder() -> crate::model::write_event_stream::Builder {
        crate::model::write_event_stream::Builder::default()
    }
}

/// <p>Provides information about endpoints and the events that they're associated with.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventsResponse {
    /// <p>A map that contains a multipart response for each endpoint. For each item in this object, the endpoint ID is the key and the item response is the value. If no item response exists, the value can also be one of the following: 202, the request was processed successfully; or 400, the payload wasn't valid or required fields were missing.</p>
    pub results: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ItemResponse>,
    >,
}
impl std::fmt::Debug for EventsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventsResponse");
        formatter.field("results", &self.results);
        formatter.finish()
    }
}
/// See [`EventsResponse`](crate::model::EventsResponse)
pub mod events_response {
    /// A builder for [`EventsResponse`](crate::model::EventsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) results: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ItemResponse>,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `results`.
        ///
        /// To override the contents of this collection use [`set_results`](Self::set_results).
        ///
        /// <p>A map that contains a multipart response for each endpoint. For each item in this object, the endpoint ID is the key and the item response is the value. If no item response exists, the value can also be one of the following: 202, the request was processed successfully; or 400, the payload wasn't valid or required fields were missing.</p>
        pub fn results(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::ItemResponse>,
        ) -> Self {
            let mut hash_map = self.results.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.results = Some(hash_map);
            self
        }
        /// <p>A map that contains a multipart response for each endpoint. For each item in this object, the endpoint ID is the key and the item response is the value. If no item response exists, the value can also be one of the following: 202, the request was processed successfully; or 400, the payload wasn't valid or required fields were missing.</p>
        pub fn set_results(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ItemResponse>,
            >,
        ) -> Self {
            self.results = input;
            self
        }
        /// Consumes the builder and constructs a [`EventsResponse`](crate::model::EventsResponse)
        pub fn build(self) -> crate::model::EventsResponse {
            crate::model::EventsResponse {
                results: self.results,
            }
        }
    }
}
impl EventsResponse {
    /// Creates a new builder-style object to manufacture [`EventsResponse`](crate::model::EventsResponse)
    pub fn builder() -> crate::model::events_response::Builder {
        crate::model::events_response::Builder::default()
    }
}

/// <p>Provides information about the results of a request to create or update an endpoint that's associated with an event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ItemResponse {
    /// <p>The response that was received after the endpoint data was accepted.</p>
    pub endpoint_item_response: std::option::Option<crate::model::EndpointItemResponse>,
    /// <p>A multipart response object that contains a key and a value for each event in the request. In each object, the event ID is the key and an EventItemResponse object is the value.</p>
    pub events_item_response: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::EventItemResponse>,
    >,
}
impl std::fmt::Debug for ItemResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ItemResponse");
        formatter.field("endpoint_item_response", &self.endpoint_item_response);
        formatter.field("events_item_response", &self.events_item_response);
        formatter.finish()
    }
}
/// See [`ItemResponse`](crate::model::ItemResponse)
pub mod item_response {
    /// A builder for [`ItemResponse`](crate::model::ItemResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint_item_response: std::option::Option<crate::model::EndpointItemResponse>,
        pub(crate) events_item_response: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::EventItemResponse>,
        >,
    }
    impl Builder {
        /// <p>The response that was received after the endpoint data was accepted.</p>
        pub fn endpoint_item_response(mut self, input: crate::model::EndpointItemResponse) -> Self {
            self.endpoint_item_response = Some(input);
            self
        }
        /// <p>The response that was received after the endpoint data was accepted.</p>
        pub fn set_endpoint_item_response(
            mut self,
            input: std::option::Option<crate::model::EndpointItemResponse>,
        ) -> Self {
            self.endpoint_item_response = input;
            self
        }
        /// Adds a key-value pair to `events_item_response`.
        ///
        /// To override the contents of this collection use [`set_events_item_response`](Self::set_events_item_response).
        ///
        /// <p>A multipart response object that contains a key and a value for each event in the request. In each object, the event ID is the key and an EventItemResponse object is the value.</p>
        pub fn events_item_response(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::EventItemResponse>,
        ) -> Self {
            let mut hash_map = self.events_item_response.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.events_item_response = Some(hash_map);
            self
        }
        /// <p>A multipart response object that contains a key and a value for each event in the request. In each object, the event ID is the key and an EventItemResponse object is the value.</p>
        pub fn set_events_item_response(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::EventItemResponse>,
            >,
        ) -> Self {
            self.events_item_response = input;
            self
        }
        /// Consumes the builder and constructs a [`ItemResponse`](crate::model::ItemResponse)
        pub fn build(self) -> crate::model::ItemResponse {
            crate::model::ItemResponse {
                endpoint_item_response: self.endpoint_item_response,
                events_item_response: self.events_item_response,
            }
        }
    }
}
impl ItemResponse {
    /// Creates a new builder-style object to manufacture [`ItemResponse`](crate::model::ItemResponse)
    pub fn builder() -> crate::model::item_response::Builder {
        crate::model::item_response::Builder::default()
    }
}

/// <p>Provides the status code and message that result from processing an event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventItemResponse {
    /// <p>A custom message that's returned in the response as a result of processing the event.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The status code that's returned in the response as a result of processing the event. Possible values are: 202, for events that were accepted; and, 400, for events that weren't valid.</p>
    pub status_code: i32,
}
impl std::fmt::Debug for EventItemResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventItemResponse");
        formatter.field("message", &self.message);
        formatter.field("status_code", &self.status_code);
        formatter.finish()
    }
}
/// See [`EventItemResponse`](crate::model::EventItemResponse)
pub mod event_item_response {
    /// A builder for [`EventItemResponse`](crate::model::EventItemResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) status_code: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>A custom message that's returned in the response as a result of processing the event.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>A custom message that's returned in the response as a result of processing the event.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The status code that's returned in the response as a result of processing the event. Possible values are: 202, for events that were accepted; and, 400, for events that weren't valid.</p>
        pub fn status_code(mut self, input: i32) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code that's returned in the response as a result of processing the event. Possible values are: 202, for events that were accepted; and, 400, for events that weren't valid.</p>
        pub fn set_status_code(mut self, input: std::option::Option<i32>) -> Self {
            self.status_code = input;
            self
        }
        /// Consumes the builder and constructs a [`EventItemResponse`](crate::model::EventItemResponse)
        pub fn build(self) -> crate::model::EventItemResponse {
            crate::model::EventItemResponse {
                message: self.message,
                status_code: self.status_code.unwrap_or_default(),
            }
        }
    }
}
impl EventItemResponse {
    /// Creates a new builder-style object to manufacture [`EventItemResponse`](crate::model::EventItemResponse)
    pub fn builder() -> crate::model::event_item_response::Builder {
        crate::model::event_item_response::Builder::default()
    }
}

/// <p>Provides the status code and message that result from processing data for an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointItemResponse {
    /// <p>The custom message that's returned in the response as a result of processing the endpoint data.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The status code that's returned in the response as a result of processing the endpoint data.</p>
    pub status_code: i32,
}
impl std::fmt::Debug for EndpointItemResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointItemResponse");
        formatter.field("message", &self.message);
        formatter.field("status_code", &self.status_code);
        formatter.finish()
    }
}
/// See [`EndpointItemResponse`](crate::model::EndpointItemResponse)
pub mod endpoint_item_response {
    /// A builder for [`EndpointItemResponse`](crate::model::EndpointItemResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) status_code: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The custom message that's returned in the response as a result of processing the endpoint data.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The custom message that's returned in the response as a result of processing the endpoint data.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The status code that's returned in the response as a result of processing the endpoint data.</p>
        pub fn status_code(mut self, input: i32) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code that's returned in the response as a result of processing the endpoint data.</p>
        pub fn set_status_code(mut self, input: std::option::Option<i32>) -> Self {
            self.status_code = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointItemResponse`](crate::model::EndpointItemResponse)
        pub fn build(self) -> crate::model::EndpointItemResponse {
            crate::model::EndpointItemResponse {
                message: self.message,
                status_code: self.status_code.unwrap_or_default(),
            }
        }
    }
}
impl EndpointItemResponse {
    /// Creates a new builder-style object to manufacture [`EndpointItemResponse`](crate::model::EndpointItemResponse)
    pub fn builder() -> crate::model::endpoint_item_response::Builder {
        crate::model::endpoint_item_response::Builder::default()
    }
}

/// <p>Specifies a batch of events to process.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventsRequest {
    /// <p>The batch of events to process. For each item in a batch, the endpoint ID acts as a key that has an EventsBatch object as its value.</p>
    pub batch_item: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::EventsBatch>,
    >,
}
impl std::fmt::Debug for EventsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventsRequest");
        formatter.field("batch_item", &self.batch_item);
        formatter.finish()
    }
}
/// See [`EventsRequest`](crate::model::EventsRequest)
pub mod events_request {
    /// A builder for [`EventsRequest`](crate::model::EventsRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) batch_item: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::EventsBatch>,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `batch_item`.
        ///
        /// To override the contents of this collection use [`set_batch_item`](Self::set_batch_item).
        ///
        /// <p>The batch of events to process. For each item in a batch, the endpoint ID acts as a key that has an EventsBatch object as its value.</p>
        pub fn batch_item(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::EventsBatch>,
        ) -> Self {
            let mut hash_map = self.batch_item.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.batch_item = Some(hash_map);
            self
        }
        /// <p>The batch of events to process. For each item in a batch, the endpoint ID acts as a key that has an EventsBatch object as its value.</p>
        pub fn set_batch_item(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::EventsBatch>,
            >,
        ) -> Self {
            self.batch_item = input;
            self
        }
        /// Consumes the builder and constructs a [`EventsRequest`](crate::model::EventsRequest)
        pub fn build(self) -> crate::model::EventsRequest {
            crate::model::EventsRequest {
                batch_item: self.batch_item,
            }
        }
    }
}
impl EventsRequest {
    /// Creates a new builder-style object to manufacture [`EventsRequest`](crate::model::EventsRequest)
    pub fn builder() -> crate::model::events_request::Builder {
        crate::model::events_request::Builder::default()
    }
}

/// <p>Specifies a batch of endpoints and events to process.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EventsBatch {
    /// <p>A set of properties and attributes that are associated with the endpoint.</p>
    pub endpoint: std::option::Option<crate::model::PublicEndpoint>,
    /// <p>A set of properties that are associated with the event.</p>
    pub events:
        std::option::Option<std::collections::HashMap<std::string::String, crate::model::Event>>,
}
impl std::fmt::Debug for EventsBatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EventsBatch");
        formatter.field("endpoint", &self.endpoint);
        formatter.field("events", &self.events);
        formatter.finish()
    }
}
/// See [`EventsBatch`](crate::model::EventsBatch)
pub mod events_batch {
    /// A builder for [`EventsBatch`](crate::model::EventsBatch)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint: std::option::Option<crate::model::PublicEndpoint>,
        pub(crate) events: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::Event>,
        >,
    }
    impl Builder {
        /// <p>A set of properties and attributes that are associated with the endpoint.</p>
        pub fn endpoint(mut self, input: crate::model::PublicEndpoint) -> Self {
            self.endpoint = Some(input);
            self
        }
        /// <p>A set of properties and attributes that are associated with the endpoint.</p>
        pub fn set_endpoint(
            mut self,
            input: std::option::Option<crate::model::PublicEndpoint>,
        ) -> Self {
            self.endpoint = input;
            self
        }
        /// Adds a key-value pair to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>A set of properties that are associated with the event.</p>
        pub fn events(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::Event>,
        ) -> Self {
            let mut hash_map = self.events.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.events = Some(hash_map);
            self
        }
        /// <p>A set of properties that are associated with the event.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::Event>,
            >,
        ) -> Self {
            self.events = input;
            self
        }
        /// Consumes the builder and constructs a [`EventsBatch`](crate::model::EventsBatch)
        pub fn build(self) -> crate::model::EventsBatch {
            crate::model::EventsBatch {
                endpoint: self.endpoint,
                events: self.events,
            }
        }
    }
}
impl EventsBatch {
    /// Creates a new builder-style object to manufacture [`EventsBatch`](crate::model::EventsBatch)
    pub fn builder() -> crate::model::events_batch::Builder {
        crate::model::events_batch::Builder::default()
    }
}

/// <p>Specifies information about an event that reports data to Amazon Pinpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Event {
    /// <p>The package name of the app that's recording the event.</p>
    pub app_package_name: std::option::Option<std::string::String>,
    /// <p>The title of the app that's recording the event.</p>
    pub app_title: std::option::Option<std::string::String>,
    /// <p>The version number of the app that's recording the event.</p>
    pub app_version_code: std::option::Option<std::string::String>,
    /// <p>One or more custom attributes that are associated with the event.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The version of the SDK that's running on the client device.</p>
    pub client_sdk_version: std::option::Option<std::string::String>,
    /// <p>The name of the event.</p>
    pub event_type: std::option::Option<std::string::String>,
    /// <p>One or more custom metrics that are associated with the event.</p>
    pub metrics: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
    /// <p>The name of the SDK that's being used to record the event.</p>
    pub sdk_name: std::option::Option<std::string::String>,
    /// <p>Information about the session in which the event occurred.</p>
    pub session: std::option::Option<crate::model::Session>,
    /// <p>The date and time, in ISO 8601 format, when the event occurred.</p>
    pub timestamp: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Event {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Event");
        formatter.field("app_package_name", &self.app_package_name);
        formatter.field("app_title", &self.app_title);
        formatter.field("app_version_code", &self.app_version_code);
        formatter.field("attributes", &self.attributes);
        formatter.field("client_sdk_version", &self.client_sdk_version);
        formatter.field("event_type", &self.event_type);
        formatter.field("metrics", &self.metrics);
        formatter.field("sdk_name", &self.sdk_name);
        formatter.field("session", &self.session);
        formatter.field("timestamp", &self.timestamp);
        formatter.finish()
    }
}
/// See [`Event`](crate::model::Event)
pub mod event {
    /// A builder for [`Event`](crate::model::Event)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_package_name: std::option::Option<std::string::String>,
        pub(crate) app_title: std::option::Option<std::string::String>,
        pub(crate) app_version_code: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) client_sdk_version: std::option::Option<std::string::String>,
        pub(crate) event_type: std::option::Option<std::string::String>,
        pub(crate) metrics:
            std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        pub(crate) sdk_name: std::option::Option<std::string::String>,
        pub(crate) session: std::option::Option<crate::model::Session>,
        pub(crate) timestamp: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The package name of the app that's recording the event.</p>
        pub fn app_package_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_package_name = Some(input.into());
            self
        }
        /// <p>The package name of the app that's recording the event.</p>
        pub fn set_app_package_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_package_name = input;
            self
        }
        /// <p>The title of the app that's recording the event.</p>
        pub fn app_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_title = Some(input.into());
            self
        }
        /// <p>The title of the app that's recording the event.</p>
        pub fn set_app_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_title = input;
            self
        }
        /// <p>The version number of the app that's recording the event.</p>
        pub fn app_version_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_version_code = Some(input.into());
            self
        }
        /// <p>The version number of the app that's recording the event.</p>
        pub fn set_app_version_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_version_code = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>One or more custom attributes that are associated with the event.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>One or more custom attributes that are associated with the event.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The version of the SDK that's running on the client device.</p>
        pub fn client_sdk_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.client_sdk_version = Some(input.into());
            self
        }
        /// <p>The version of the SDK that's running on the client device.</p>
        pub fn set_client_sdk_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_sdk_version = input;
            self
        }
        /// <p>The name of the event.</p>
        pub fn event_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.event_type = Some(input.into());
            self
        }
        /// <p>The name of the event.</p>
        pub fn set_event_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.event_type = input;
            self
        }
        /// Adds a key-value pair to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>One or more custom metrics that are associated with the event.</p>
        pub fn metrics(mut self, k: impl Into<std::string::String>, v: impl Into<f64>) -> Self {
            let mut hash_map = self.metrics.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metrics = Some(hash_map);
            self
        }
        /// <p>One or more custom metrics that are associated with the event.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>The name of the SDK that's being used to record the event.</p>
        pub fn sdk_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.sdk_name = Some(input.into());
            self
        }
        /// <p>The name of the SDK that's being used to record the event.</p>
        pub fn set_sdk_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sdk_name = input;
            self
        }
        /// <p>Information about the session in which the event occurred.</p>
        pub fn session(mut self, input: crate::model::Session) -> Self {
            self.session = Some(input);
            self
        }
        /// <p>Information about the session in which the event occurred.</p>
        pub fn set_session(mut self, input: std::option::Option<crate::model::Session>) -> Self {
            self.session = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the event occurred.</p>
        pub fn timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestamp = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the event occurred.</p>
        pub fn set_timestamp(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`Event`](crate::model::Event)
        pub fn build(self) -> crate::model::Event {
            crate::model::Event {
                app_package_name: self.app_package_name,
                app_title: self.app_title,
                app_version_code: self.app_version_code,
                attributes: self.attributes,
                client_sdk_version: self.client_sdk_version,
                event_type: self.event_type,
                metrics: self.metrics,
                sdk_name: self.sdk_name,
                session: self.session,
                timestamp: self.timestamp,
            }
        }
    }
}
impl Event {
    /// Creates a new builder-style object to manufacture [`Event`](crate::model::Event)
    pub fn builder() -> crate::model::event::Builder {
        crate::model::event::Builder::default()
    }
}

/// <p>Provides information about a session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Session {
    /// <p>The duration of the session, in milliseconds.</p>
    pub duration: i32,
    /// <p>The unique identifier for the session.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The date and time when the session began.</p>
    pub start_timestamp: std::option::Option<std::string::String>,
    /// <p>The date and time when the session ended.</p>
    pub stop_timestamp: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Session {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Session");
        formatter.field("duration", &self.duration);
        formatter.field("id", &self.id);
        formatter.field("start_timestamp", &self.start_timestamp);
        formatter.field("stop_timestamp", &self.stop_timestamp);
        formatter.finish()
    }
}
/// See [`Session`](crate::model::Session)
pub mod session {
    /// A builder for [`Session`](crate::model::Session)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) duration: std::option::Option<i32>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) start_timestamp: std::option::Option<std::string::String>,
        pub(crate) stop_timestamp: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The duration of the session, in milliseconds.</p>
        pub fn duration(mut self, input: i32) -> Self {
            self.duration = Some(input);
            self
        }
        /// <p>The duration of the session, in milliseconds.</p>
        pub fn set_duration(mut self, input: std::option::Option<i32>) -> Self {
            self.duration = input;
            self
        }
        /// <p>The unique identifier for the session.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the session.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The date and time when the session began.</p>
        pub fn start_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.start_timestamp = Some(input.into());
            self
        }
        /// <p>The date and time when the session began.</p>
        pub fn set_start_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.start_timestamp = input;
            self
        }
        /// <p>The date and time when the session ended.</p>
        pub fn stop_timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.stop_timestamp = Some(input.into());
            self
        }
        /// <p>The date and time when the session ended.</p>
        pub fn set_stop_timestamp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.stop_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`Session`](crate::model::Session)
        pub fn build(self) -> crate::model::Session {
            crate::model::Session {
                duration: self.duration.unwrap_or_default(),
                id: self.id,
                start_timestamp: self.start_timestamp,
                stop_timestamp: self.stop_timestamp,
            }
        }
    }
}
impl Session {
    /// Creates a new builder-style object to manufacture [`Session`](crate::model::Session)
    pub fn builder() -> crate::model::session::Builder {
        crate::model::session::Builder::default()
    }
}

/// <p>Specifies the properties and attributes of an endpoint that's associated with an event.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PublicEndpoint {
    /// <p>The unique identifier for the recipient, such as a device token, email address, or mobile phone number.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. You can use these attributes as filter criteria when you create segments.</p>
    pub attributes: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The channel that's used when sending messages or push notifications to the endpoint.</p>
    pub channel_type: std::option::Option<crate::model::ChannelType>,
    /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
    pub demographic: std::option::Option<crate::model::EndpointDemographic>,
    /// <p>The date and time, in ISO 8601 format, when the endpoint was last updated.</p>
    pub effective_date: std::option::Option<std::string::String>,
    /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
    pub endpoint_status: std::option::Option<std::string::String>,
    /// <p>The geographic information for the endpoint.</p>
    pub location: std::option::Option<crate::model::EndpointLocation>,
    /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
    pub metrics: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
    /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
    pub opt_out: std::option::Option<std::string::String>,
    /// <p>A unique identifier that's generated each time the endpoint is updated.</p>
    pub request_id: std::option::Option<std::string::String>,
    /// <p>One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.</p>
    pub user: std::option::Option<crate::model::EndpointUser>,
}
impl std::fmt::Debug for PublicEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublicEndpoint");
        formatter.field("address", &self.address);
        formatter.field("attributes", &self.attributes);
        formatter.field("channel_type", &self.channel_type);
        formatter.field("demographic", &self.demographic);
        formatter.field("effective_date", &self.effective_date);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.field("location", &self.location);
        formatter.field("metrics", &self.metrics);
        formatter.field("opt_out", &self.opt_out);
        formatter.field("request_id", &self.request_id);
        formatter.field("user", &self.user);
        formatter.finish()
    }
}
/// See [`PublicEndpoint`](crate::model::PublicEndpoint)
pub mod public_endpoint {
    /// A builder for [`PublicEndpoint`](crate::model::PublicEndpoint)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) channel_type: std::option::Option<crate::model::ChannelType>,
        pub(crate) demographic: std::option::Option<crate::model::EndpointDemographic>,
        pub(crate) effective_date: std::option::Option<std::string::String>,
        pub(crate) endpoint_status: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::EndpointLocation>,
        pub(crate) metrics:
            std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        pub(crate) opt_out: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        pub(crate) user: std::option::Option<crate::model::EndpointUser>,
    }
    impl Builder {
        /// <p>The unique identifier for the recipient, such as a device token, email address, or mobile phone number.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The unique identifier for the recipient, such as a device token, email address, or mobile phone number.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. You can use these attributes as filter criteria when you create segments.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. You can use these attributes as filter criteria when you create segments.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The channel that's used when sending messages or push notifications to the endpoint.</p>
        pub fn channel_type(mut self, input: crate::model::ChannelType) -> Self {
            self.channel_type = Some(input);
            self
        }
        /// <p>The channel that's used when sending messages or push notifications to the endpoint.</p>
        pub fn set_channel_type(
            mut self,
            input: std::option::Option<crate::model::ChannelType>,
        ) -> Self {
            self.channel_type = input;
            self
        }
        /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
        pub fn demographic(mut self, input: crate::model::EndpointDemographic) -> Self {
            self.demographic = Some(input);
            self
        }
        /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
        pub fn set_demographic(
            mut self,
            input: std::option::Option<crate::model::EndpointDemographic>,
        ) -> Self {
            self.demographic = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the endpoint was last updated.</p>
        pub fn effective_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the endpoint was last updated.</p>
        pub fn set_effective_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_date = input;
            self
        }
        /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
        pub fn endpoint_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_status = Some(input.into());
            self
        }
        /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// <p>The geographic information for the endpoint.</p>
        pub fn location(mut self, input: crate::model::EndpointLocation) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The geographic information for the endpoint.</p>
        pub fn set_location(
            mut self,
            input: std::option::Option<crate::model::EndpointLocation>,
        ) -> Self {
            self.location = input;
            self
        }
        /// Adds a key-value pair to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
        pub fn metrics(mut self, k: impl Into<std::string::String>, v: impl Into<f64>) -> Self {
            let mut hash_map = self.metrics.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metrics = Some(hash_map);
            self
        }
        /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
        pub fn opt_out(mut self, input: impl Into<std::string::String>) -> Self {
            self.opt_out = Some(input.into());
            self
        }
        /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
        pub fn set_opt_out(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.opt_out = input;
            self
        }
        /// <p>A unique identifier that's generated each time the endpoint is updated.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>A unique identifier that's generated each time the endpoint is updated.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// <p>One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.</p>
        pub fn user(mut self, input: crate::model::EndpointUser) -> Self {
            self.user = Some(input);
            self
        }
        /// <p>One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.</p>
        pub fn set_user(mut self, input: std::option::Option<crate::model::EndpointUser>) -> Self {
            self.user = input;
            self
        }
        /// Consumes the builder and constructs a [`PublicEndpoint`](crate::model::PublicEndpoint)
        pub fn build(self) -> crate::model::PublicEndpoint {
            crate::model::PublicEndpoint {
                address: self.address,
                attributes: self.attributes,
                channel_type: self.channel_type,
                demographic: self.demographic,
                effective_date: self.effective_date,
                endpoint_status: self.endpoint_status,
                location: self.location,
                metrics: self.metrics,
                opt_out: self.opt_out,
                request_id: self.request_id,
                user: self.user,
            }
        }
    }
}
impl PublicEndpoint {
    /// Creates a new builder-style object to manufacture [`PublicEndpoint`](crate::model::PublicEndpoint)
    pub fn builder() -> crate::model::public_endpoint::Builder {
        crate::model::public_endpoint::Builder::default()
    }
}

/// <p>Provides information about a phone number.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NumberValidateResponse {
    /// <p>The carrier or service provider that the phone number is currently registered with. In some countries and regions, this value may be the carrier or service provider that the phone number was originally registered with.</p>
    pub carrier: std::option::Option<std::string::String>,
    /// <p>The name of the city where the phone number was originally registered.</p>
    pub city: std::option::Option<std::string::String>,
    /// <p>The cleansed phone number, in E.164 format, for the location where the phone number was originally registered.</p>
    pub cleansed_phone_number_e164: std::option::Option<std::string::String>,
    /// <p>The cleansed phone number, in the format for the location where the phone number was originally registered.</p>
    pub cleansed_phone_number_national: std::option::Option<std::string::String>,
    /// <p>The name of the country or region where the phone number was originally registered.</p>
    pub country: std::option::Option<std::string::String>,
    /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.</p>
    pub country_code_iso2: std::option::Option<std::string::String>,
    /// <p>The numeric code for the country or region where the phone number was originally registered.</p>
    pub country_code_numeric: std::option::Option<std::string::String>,
    /// <p>The name of the county where the phone number was originally registered.</p>
    pub county: std::option::Option<std::string::String>,
    /// <p>The two-character code, in ISO 3166-1 alpha-2 format, that was sent in the request body.</p>
    pub original_country_code_iso2: std::option::Option<std::string::String>,
    /// <p>The phone number that was sent in the request body.</p>
    pub original_phone_number: std::option::Option<std::string::String>,
    /// <p>The description of the phone type. Valid values are: MOBILE, LANDLINE, VOIP,
    /// INVALID, PREPAID, and OTHER.</p>
    pub phone_type: std::option::Option<std::string::String>,
    /// <p>The phone type, represented by an integer. Valid values are: 0 (mobile), 1 (landline), 2 (VoIP), 3 (invalid), 4 (other), and 5 (prepaid).</p>
    pub phone_type_code: i32,
    /// <p>The time zone for the location where the phone number was originally registered.</p>
    pub timezone: std::option::Option<std::string::String>,
    /// <p>The postal or ZIP code for the location where the phone number was originally registered.</p>
    pub zip_code: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NumberValidateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NumberValidateResponse");
        formatter.field("carrier", &self.carrier);
        formatter.field("city", &self.city);
        formatter.field(
            "cleansed_phone_number_e164",
            &self.cleansed_phone_number_e164,
        );
        formatter.field(
            "cleansed_phone_number_national",
            &self.cleansed_phone_number_national,
        );
        formatter.field("country", &self.country);
        formatter.field("country_code_iso2", &self.country_code_iso2);
        formatter.field("country_code_numeric", &self.country_code_numeric);
        formatter.field("county", &self.county);
        formatter.field(
            "original_country_code_iso2",
            &self.original_country_code_iso2,
        );
        formatter.field("original_phone_number", &self.original_phone_number);
        formatter.field("phone_type", &self.phone_type);
        formatter.field("phone_type_code", &self.phone_type_code);
        formatter.field("timezone", &self.timezone);
        formatter.field("zip_code", &self.zip_code);
        formatter.finish()
    }
}
/// See [`NumberValidateResponse`](crate::model::NumberValidateResponse)
pub mod number_validate_response {
    /// A builder for [`NumberValidateResponse`](crate::model::NumberValidateResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) carrier: std::option::Option<std::string::String>,
        pub(crate) city: std::option::Option<std::string::String>,
        pub(crate) cleansed_phone_number_e164: std::option::Option<std::string::String>,
        pub(crate) cleansed_phone_number_national: std::option::Option<std::string::String>,
        pub(crate) country: std::option::Option<std::string::String>,
        pub(crate) country_code_iso2: std::option::Option<std::string::String>,
        pub(crate) country_code_numeric: std::option::Option<std::string::String>,
        pub(crate) county: std::option::Option<std::string::String>,
        pub(crate) original_country_code_iso2: std::option::Option<std::string::String>,
        pub(crate) original_phone_number: std::option::Option<std::string::String>,
        pub(crate) phone_type: std::option::Option<std::string::String>,
        pub(crate) phone_type_code: std::option::Option<i32>,
        pub(crate) timezone: std::option::Option<std::string::String>,
        pub(crate) zip_code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The carrier or service provider that the phone number is currently registered with. In some countries and regions, this value may be the carrier or service provider that the phone number was originally registered with.</p>
        pub fn carrier(mut self, input: impl Into<std::string::String>) -> Self {
            self.carrier = Some(input.into());
            self
        }
        /// <p>The carrier or service provider that the phone number is currently registered with. In some countries and regions, this value may be the carrier or service provider that the phone number was originally registered with.</p>
        pub fn set_carrier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.carrier = input;
            self
        }
        /// <p>The name of the city where the phone number was originally registered.</p>
        pub fn city(mut self, input: impl Into<std::string::String>) -> Self {
            self.city = Some(input.into());
            self
        }
        /// <p>The name of the city where the phone number was originally registered.</p>
        pub fn set_city(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.city = input;
            self
        }
        /// <p>The cleansed phone number, in E.164 format, for the location where the phone number was originally registered.</p>
        pub fn cleansed_phone_number_e164(mut self, input: impl Into<std::string::String>) -> Self {
            self.cleansed_phone_number_e164 = Some(input.into());
            self
        }
        /// <p>The cleansed phone number, in E.164 format, for the location where the phone number was originally registered.</p>
        pub fn set_cleansed_phone_number_e164(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cleansed_phone_number_e164 = input;
            self
        }
        /// <p>The cleansed phone number, in the format for the location where the phone number was originally registered.</p>
        pub fn cleansed_phone_number_national(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.cleansed_phone_number_national = Some(input.into());
            self
        }
        /// <p>The cleansed phone number, in the format for the location where the phone number was originally registered.</p>
        pub fn set_cleansed_phone_number_national(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.cleansed_phone_number_national = input;
            self
        }
        /// <p>The name of the country or region where the phone number was originally registered.</p>
        pub fn country(mut self, input: impl Into<std::string::String>) -> Self {
            self.country = Some(input.into());
            self
        }
        /// <p>The name of the country or region where the phone number was originally registered.</p>
        pub fn set_country(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.country = input;
            self
        }
        /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.</p>
        pub fn country_code_iso2(mut self, input: impl Into<std::string::String>) -> Self {
            self.country_code_iso2 = Some(input.into());
            self
        }
        /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.</p>
        pub fn set_country_code_iso2(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.country_code_iso2 = input;
            self
        }
        /// <p>The numeric code for the country or region where the phone number was originally registered.</p>
        pub fn country_code_numeric(mut self, input: impl Into<std::string::String>) -> Self {
            self.country_code_numeric = Some(input.into());
            self
        }
        /// <p>The numeric code for the country or region where the phone number was originally registered.</p>
        pub fn set_country_code_numeric(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.country_code_numeric = input;
            self
        }
        /// <p>The name of the county where the phone number was originally registered.</p>
        pub fn county(mut self, input: impl Into<std::string::String>) -> Self {
            self.county = Some(input.into());
            self
        }
        /// <p>The name of the county where the phone number was originally registered.</p>
        pub fn set_county(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.county = input;
            self
        }
        /// <p>The two-character code, in ISO 3166-1 alpha-2 format, that was sent in the request body.</p>
        pub fn original_country_code_iso2(mut self, input: impl Into<std::string::String>) -> Self {
            self.original_country_code_iso2 = Some(input.into());
            self
        }
        /// <p>The two-character code, in ISO 3166-1 alpha-2 format, that was sent in the request body.</p>
        pub fn set_original_country_code_iso2(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.original_country_code_iso2 = input;
            self
        }
        /// <p>The phone number that was sent in the request body.</p>
        pub fn original_phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.original_phone_number = Some(input.into());
            self
        }
        /// <p>The phone number that was sent in the request body.</p>
        pub fn set_original_phone_number(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.original_phone_number = input;
            self
        }
        /// <p>The description of the phone type. Valid values are: MOBILE, LANDLINE, VOIP,
        /// INVALID, PREPAID, and OTHER.</p>
        pub fn phone_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_type = Some(input.into());
            self
        }
        /// <p>The description of the phone type. Valid values are: MOBILE, LANDLINE, VOIP,
        /// INVALID, PREPAID, and OTHER.</p>
        pub fn set_phone_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_type = input;
            self
        }
        /// <p>The phone type, represented by an integer. Valid values are: 0 (mobile), 1 (landline), 2 (VoIP), 3 (invalid), 4 (other), and 5 (prepaid).</p>
        pub fn phone_type_code(mut self, input: i32) -> Self {
            self.phone_type_code = Some(input);
            self
        }
        /// <p>The phone type, represented by an integer. Valid values are: 0 (mobile), 1 (landline), 2 (VoIP), 3 (invalid), 4 (other), and 5 (prepaid).</p>
        pub fn set_phone_type_code(mut self, input: std::option::Option<i32>) -> Self {
            self.phone_type_code = input;
            self
        }
        /// <p>The time zone for the location where the phone number was originally registered.</p>
        pub fn timezone(mut self, input: impl Into<std::string::String>) -> Self {
            self.timezone = Some(input.into());
            self
        }
        /// <p>The time zone for the location where the phone number was originally registered.</p>
        pub fn set_timezone(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timezone = input;
            self
        }
        /// <p>The postal or ZIP code for the location where the phone number was originally registered.</p>
        pub fn zip_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.zip_code = Some(input.into());
            self
        }
        /// <p>The postal or ZIP code for the location where the phone number was originally registered.</p>
        pub fn set_zip_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.zip_code = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberValidateResponse`](crate::model::NumberValidateResponse)
        pub fn build(self) -> crate::model::NumberValidateResponse {
            crate::model::NumberValidateResponse {
                carrier: self.carrier,
                city: self.city,
                cleansed_phone_number_e164: self.cleansed_phone_number_e164,
                cleansed_phone_number_national: self.cleansed_phone_number_national,
                country: self.country,
                country_code_iso2: self.country_code_iso2,
                country_code_numeric: self.country_code_numeric,
                county: self.county,
                original_country_code_iso2: self.original_country_code_iso2,
                original_phone_number: self.original_phone_number,
                phone_type: self.phone_type,
                phone_type_code: self.phone_type_code.unwrap_or_default(),
                timezone: self.timezone,
                zip_code: self.zip_code,
            }
        }
    }
}
impl NumberValidateResponse {
    /// Creates a new builder-style object to manufacture [`NumberValidateResponse`](crate::model::NumberValidateResponse)
    pub fn builder() -> crate::model::number_validate_response::Builder {
        crate::model::number_validate_response::Builder::default()
    }
}

/// <p>Specifies a phone number to validate and retrieve information about.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NumberValidateRequest {
    /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.</p>
    pub iso_country_code: std::option::Option<std::string::String>,
    /// <p>The phone number to retrieve information about. The phone number that you provide should include a valid numeric country code. Otherwise, the operation might result in an error.</p>
    pub phone_number: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NumberValidateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NumberValidateRequest");
        formatter.field("iso_country_code", &self.iso_country_code);
        formatter.field("phone_number", &self.phone_number);
        formatter.finish()
    }
}
/// See [`NumberValidateRequest`](crate::model::NumberValidateRequest)
pub mod number_validate_request {
    /// A builder for [`NumberValidateRequest`](crate::model::NumberValidateRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) iso_country_code: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.</p>
        pub fn iso_country_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.iso_country_code = Some(input.into());
            self
        }
        /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.</p>
        pub fn set_iso_country_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.iso_country_code = input;
            self
        }
        /// <p>The phone number to retrieve information about. The phone number that you provide should include a valid numeric country code. Otherwise, the operation might result in an error.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>The phone number to retrieve information about. The phone number that you provide should include a valid numeric country code. Otherwise, the operation might result in an error.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberValidateRequest`](crate::model::NumberValidateRequest)
        pub fn build(self) -> crate::model::NumberValidateRequest {
            crate::model::NumberValidateRequest {
                iso_country_code: self.iso_country_code,
                phone_number: self.phone_number,
            }
        }
    }
}
impl NumberValidateRequest {
    /// Creates a new builder-style object to manufacture [`NumberValidateRequest`](crate::model::NumberValidateRequest)
    pub fn builder() -> crate::model::number_validate_request::Builder {
        crate::model::number_validate_request::Builder::default()
    }
}

/// <p>Provides information about all the versions of a specific message template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TemplateVersionsResponse {
    /// <p>An array of responses, one for each version of the message template.</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::TemplateVersionResponse>>,
    /// <p>The message that's returned from the API for the request to retrieve information about all the versions of the message template.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request to retrieve information about all the versions of the message template.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TemplateVersionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TemplateVersionsResponse");
        formatter.field("item", &self.item);
        formatter.field("message", &self.message);
        formatter.field("next_token", &self.next_token);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
/// See [`TemplateVersionsResponse`](crate::model::TemplateVersionsResponse)
pub mod template_versions_response {
    /// A builder for [`TemplateVersionsResponse`](crate::model::TemplateVersionsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::TemplateVersionResponse>>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each version of the message template.</p>
        pub fn item(mut self, input: impl Into<crate::model::TemplateVersionResponse>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each version of the message template.</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TemplateVersionResponse>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// <p>The message that's returned from the API for the request to retrieve information about all the versions of the message template.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that's returned from the API for the request to retrieve information about all the versions of the message template.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The unique identifier for the request to retrieve information about all the versions of the message template.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the request to retrieve information about all the versions of the message template.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateVersionsResponse`](crate::model::TemplateVersionsResponse)
        pub fn build(self) -> crate::model::TemplateVersionsResponse {
            crate::model::TemplateVersionsResponse {
                item: self.item,
                message: self.message,
                next_token: self.next_token,
                request_id: self.request_id,
            }
        }
    }
}
impl TemplateVersionsResponse {
    /// Creates a new builder-style object to manufacture [`TemplateVersionsResponse`](crate::model::TemplateVersionsResponse)
    pub fn builder() -> crate::model::template_versions_response::Builder {
        crate::model::template_versions_response::Builder::default()
    }
}

/// <p>Provides information about a specific version of a message template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TemplateVersionResponse {
    /// <p>The date, in ISO 8601 format, when the version of the message template was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>A JSON object that specifies the default values that are used for message variables in the version of the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
    pub default_substitutions: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the version of the message template was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The custom description of the version of the message template.</p>
    pub template_description: std::option::Option<std::string::String>,
    /// <p>The name of the message template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The type of channel that the message template is designed for. Possible values are: EMAIL, PUSH, SMS, and VOICE.</p>
    pub template_type: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the version of the message template. This value is an integer that Amazon Pinpoint automatically increments and assigns to each new version of a template.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TemplateVersionResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TemplateVersionResponse");
        formatter.field("creation_date", &self.creation_date);
        formatter.field("default_substitutions", &self.default_substitutions);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("template_description", &self.template_description);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_type", &self.template_type);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`TemplateVersionResponse`](crate::model::TemplateVersionResponse)
pub mod template_version_response {
    /// A builder for [`TemplateVersionResponse`](crate::model::TemplateVersionResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) default_substitutions: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) template_description: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_type: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The date, in ISO 8601 format, when the version of the message template was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the version of the message template was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>A JSON object that specifies the default values that are used for message variables in the version of the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
        pub fn default_substitutions(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_substitutions = Some(input.into());
            self
        }
        /// <p>A JSON object that specifies the default values that are used for message variables in the version of the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
        pub fn set_default_substitutions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_substitutions = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the version of the message template was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the version of the message template was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The custom description of the version of the message template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>The custom description of the version of the message template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// <p>The name of the message template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the message template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The type of channel that the message template is designed for. Possible values are: EMAIL, PUSH, SMS, and VOICE.</p>
        pub fn template_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_type = Some(input.into());
            self
        }
        /// <p>The type of channel that the message template is designed for. Possible values are: EMAIL, PUSH, SMS, and VOICE.</p>
        pub fn set_template_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_type = input;
            self
        }
        /// <p>The unique identifier for the version of the message template. This value is an integer that Amazon Pinpoint automatically increments and assigns to each new version of a template.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The unique identifier for the version of the message template. This value is an integer that Amazon Pinpoint automatically increments and assigns to each new version of a template.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateVersionResponse`](crate::model::TemplateVersionResponse)
        pub fn build(self) -> crate::model::TemplateVersionResponse {
            crate::model::TemplateVersionResponse {
                creation_date: self.creation_date,
                default_substitutions: self.default_substitutions,
                last_modified_date: self.last_modified_date,
                template_description: self.template_description,
                template_name: self.template_name,
                template_type: self.template_type,
                version: self.version,
            }
        }
    }
}
impl TemplateVersionResponse {
    /// Creates a new builder-style object to manufacture [`TemplateVersionResponse`](crate::model::TemplateVersionResponse)
    pub fn builder() -> crate::model::template_version_response::Builder {
        crate::model::template_version_response::Builder::default()
    }
}

/// <p>Provides information about all the message templates that are associated with your Amazon Pinpoint account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TemplatesResponse {
    /// <p>An array of responses, one for each message template that's associated with your Amazon Pinpoint account and meets any filter criteria that you specified in the request.</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::TemplateResponse>>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TemplatesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TemplatesResponse");
        formatter.field("item", &self.item);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`TemplatesResponse`](crate::model::TemplatesResponse)
pub mod templates_response {
    /// A builder for [`TemplatesResponse`](crate::model::TemplatesResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::TemplateResponse>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each message template that's associated with your Amazon Pinpoint account and meets any filter criteria that you specified in the request.</p>
        pub fn item(mut self, input: impl Into<crate::model::TemplateResponse>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each message template that's associated with your Amazon Pinpoint account and meets any filter criteria that you specified in the request.</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TemplateResponse>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplatesResponse`](crate::model::TemplatesResponse)
        pub fn build(self) -> crate::model::TemplatesResponse {
            crate::model::TemplatesResponse {
                item: self.item,
                next_token: self.next_token,
            }
        }
    }
}
impl TemplatesResponse {
    /// Creates a new builder-style object to manufacture [`TemplatesResponse`](crate::model::TemplatesResponse)
    pub fn builder() -> crate::model::templates_response::Builder {
        crate::model::templates_response::Builder::default()
    }
}

/// <p>Provides information about a message template that's associated with your Amazon Pinpoint account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TemplateResponse {
    /// <p>The Amazon Resource Name (ARN) of the message template. This value isn't included in a TemplateResponse object. To retrieve the ARN of a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the ARN for.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the message template was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object isn't included in a TemplateResponse object. To retrieve this object for a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the object for.</p>
    pub default_substitutions: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>A map of key-value pairs that identifies the tags that are associated with the message template. This object isn't included in a TemplateResponse object. To retrieve this object for a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the object for.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The custom description of the message template. This value isn't included in a TemplateResponse object. To retrieve the description of a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the description for.</p>
    pub template_description: std::option::Option<std::string::String>,
    /// <p>The name of the message template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The type of channel that the message template is designed for. Possible values are: EMAIL, PUSH, SMS, and VOICE.</p>
    pub template_type: std::option::Option<crate::model::TemplateType>,
    /// <p>The unique identifier, as an integer, for the active version of the message template.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TemplateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TemplateResponse");
        formatter.field("arn", &self.arn);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("default_substitutions", &self.default_substitutions);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_type", &self.template_type);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`TemplateResponse`](crate::model::TemplateResponse)
pub mod template_response {
    /// A builder for [`TemplateResponse`](crate::model::TemplateResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) default_substitutions: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_type: std::option::Option<crate::model::TemplateType>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the message template. This value isn't included in a TemplateResponse object. To retrieve the ARN of a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the ARN for.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the message template. This value isn't included in a TemplateResponse object. To retrieve the ARN of a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the ARN for.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object isn't included in a TemplateResponse object. To retrieve this object for a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the object for.</p>
        pub fn default_substitutions(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_substitutions = Some(input.into());
            self
        }
        /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object isn't included in a TemplateResponse object. To retrieve this object for a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the object for.</p>
        pub fn set_default_substitutions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_substitutions = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A map of key-value pairs that identifies the tags that are associated with the message template. This object isn't included in a TemplateResponse object. To retrieve this object for a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the object for.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A map of key-value pairs that identifies the tags that are associated with the message template. This object isn't included in a TemplateResponse object. To retrieve this object for a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the object for.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The custom description of the message template. This value isn't included in a TemplateResponse object. To retrieve the description of a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the description for.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>The custom description of the message template. This value isn't included in a TemplateResponse object. To retrieve the description of a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the description for.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// <p>The name of the message template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the message template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The type of channel that the message template is designed for. Possible values are: EMAIL, PUSH, SMS, and VOICE.</p>
        pub fn template_type(mut self, input: crate::model::TemplateType) -> Self {
            self.template_type = Some(input);
            self
        }
        /// <p>The type of channel that the message template is designed for. Possible values are: EMAIL, PUSH, SMS, and VOICE.</p>
        pub fn set_template_type(
            mut self,
            input: std::option::Option<crate::model::TemplateType>,
        ) -> Self {
            self.template_type = input;
            self
        }
        /// <p>The unique identifier, as an integer, for the active version of the message template.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The unique identifier, as an integer, for the active version of the message template.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateResponse`](crate::model::TemplateResponse)
        pub fn build(self) -> crate::model::TemplateResponse {
            crate::model::TemplateResponse {
                arn: self.arn,
                creation_date: self.creation_date,
                default_substitutions: self.default_substitutions,
                last_modified_date: self.last_modified_date,
                tags: self.tags,
                template_description: self.template_description,
                template_name: self.template_name,
                template_type: self.template_type,
                version: self.version,
            }
        }
    }
}
impl TemplateResponse {
    /// Creates a new builder-style object to manufacture [`TemplateResponse`](crate::model::TemplateResponse)
    pub fn builder() -> crate::model::template_response::Builder {
        crate::model::template_response::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TemplateType {
    #[allow(missing_docs)] // documentation missing in model
    Email,
    #[allow(missing_docs)] // documentation missing in model
    Inapp,
    #[allow(missing_docs)] // documentation missing in model
    Push,
    #[allow(missing_docs)] // documentation missing in model
    Sms,
    #[allow(missing_docs)] // documentation missing in model
    Voice,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for TemplateType {
    fn from(s: &str) -> Self {
        match s {
            "EMAIL" => TemplateType::Email,
            "INAPP" => TemplateType::Inapp,
            "PUSH" => TemplateType::Push,
            "SMS" => TemplateType::Sms,
            "VOICE" => TemplateType::Voice,
            other => TemplateType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for TemplateType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TemplateType::from(s))
    }
}
impl TemplateType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TemplateType::Email => "EMAIL",
            TemplateType::Inapp => "INAPP",
            TemplateType::Push => "PUSH",
            TemplateType::Sms => "SMS",
            TemplateType::Voice => "VOICE",
            TemplateType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["EMAIL", "INAPP", "PUSH", "SMS", "VOICE"]
    }
}
impl AsRef<str> for TemplateType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the status, configuration, and other settings for all the journeys that are associated with an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneysResponse {
    /// <p>An array of responses, one for each journey that's associated with the application.</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::JourneyResponse>>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for JourneysResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneysResponse");
        formatter.field("item", &self.item);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`JourneysResponse`](crate::model::JourneysResponse)
pub mod journeys_response {
    /// A builder for [`JourneysResponse`](crate::model::JourneysResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::JourneyResponse>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each journey that's associated with the application.</p>
        pub fn item(mut self, input: impl Into<crate::model::JourneyResponse>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each journey that's associated with the application.</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::JourneyResponse>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneysResponse`](crate::model::JourneysResponse)
        pub fn build(self) -> crate::model::JourneysResponse {
            crate::model::JourneysResponse {
                item: self.item,
                next_token: self.next_token,
            }
        }
    }
}
impl JourneysResponse {
    /// Creates a new builder-style object to manufacture [`JourneysResponse`](crate::model::JourneysResponse)
    pub fn builder() -> crate::model::journeys_response::Builder {
        crate::model::journeys_response::Builder::default()
    }
}

/// <p>Provides information about the content and settings for a message template that can be used in messages that are sent through the voice channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct VoiceTemplateResponse {
    /// <p>The Amazon Resource Name (ARN) of the message template.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The text of the script that's used in messages that are based on the message template, in plain text format.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the message template was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
    pub default_substitutions: std::option::Option<std::string::String>,
    /// <p>The code for the language that's used when synthesizing the text of the script in messages that are based on the message template. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    pub language_code: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The custom description of the message template.</p>
    pub template_description: std::option::Option<std::string::String>,
    /// <p>The name of the message template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The type of channel that the message template is designed for. For a voice template, this value is VOICE.</p>
    pub template_type: std::option::Option<crate::model::TemplateType>,
    /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
    pub version: std::option::Option<std::string::String>,
    /// <p>The name of the voice that's used when delivering messages that are based on the message template. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    pub voice_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for VoiceTemplateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("VoiceTemplateResponse");
        formatter.field("arn", &self.arn);
        formatter.field("body", &self.body);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("default_substitutions", &self.default_substitutions);
        formatter.field("language_code", &self.language_code);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_type", &self.template_type);
        formatter.field("version", &self.version);
        formatter.field("voice_id", &self.voice_id);
        formatter.finish()
    }
}
/// See [`VoiceTemplateResponse`](crate::model::VoiceTemplateResponse)
pub mod voice_template_response {
    /// A builder for [`VoiceTemplateResponse`](crate::model::VoiceTemplateResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) default_substitutions: std::option::Option<std::string::String>,
        pub(crate) language_code: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_type: std::option::Option<crate::model::TemplateType>,
        pub(crate) version: std::option::Option<std::string::String>,
        pub(crate) voice_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the message template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the message template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The text of the script that's used in messages that are based on the message template, in plain text format.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The text of the script that's used in messages that are based on the message template, in plain text format.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
        pub fn default_substitutions(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_substitutions = Some(input.into());
            self
        }
        /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
        pub fn set_default_substitutions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_substitutions = input;
            self
        }
        /// <p>The code for the language that's used when synthesizing the text of the script in messages that are based on the message template. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn language_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.language_code = Some(input.into());
            self
        }
        /// <p>The code for the language that's used when synthesizing the text of the script in messages that are based on the message template. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn set_language_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.language_code = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The custom description of the message template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>The custom description of the message template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// <p>The name of the message template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the message template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The type of channel that the message template is designed for. For a voice template, this value is VOICE.</p>
        pub fn template_type(mut self, input: crate::model::TemplateType) -> Self {
            self.template_type = Some(input);
            self
        }
        /// <p>The type of channel that the message template is designed for. For a voice template, this value is VOICE.</p>
        pub fn set_template_type(
            mut self,
            input: std::option::Option<crate::model::TemplateType>,
        ) -> Self {
            self.template_type = input;
            self
        }
        /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// <p>The name of the voice that's used when delivering messages that are based on the message template. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn voice_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.voice_id = Some(input.into());
            self
        }
        /// <p>The name of the voice that's used when delivering messages that are based on the message template. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
        pub fn set_voice_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.voice_id = input;
            self
        }
        /// Consumes the builder and constructs a [`VoiceTemplateResponse`](crate::model::VoiceTemplateResponse)
        pub fn build(self) -> crate::model::VoiceTemplateResponse {
            crate::model::VoiceTemplateResponse {
                arn: self.arn,
                body: self.body,
                creation_date: self.creation_date,
                default_substitutions: self.default_substitutions,
                language_code: self.language_code,
                last_modified_date: self.last_modified_date,
                tags: self.tags,
                template_description: self.template_description,
                template_name: self.template_name,
                template_type: self.template_type,
                version: self.version,
                voice_id: self.voice_id,
            }
        }
    }
}
impl VoiceTemplateResponse {
    /// Creates a new builder-style object to manufacture [`VoiceTemplateResponse`](crate::model::VoiceTemplateResponse)
    pub fn builder() -> crate::model::voice_template_response::Builder {
        crate::model::voice_template_response::Builder::default()
    }
}

/// <p>Provides information about all the endpoints that are associated with a user ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointsResponse {
    /// <p>An array of responses, one for each endpoint that's associated with the user ID.</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::EndpointResponse>>,
}
impl std::fmt::Debug for EndpointsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointsResponse");
        formatter.field("item", &self.item);
        formatter.finish()
    }
}
/// See [`EndpointsResponse`](crate::model::EndpointsResponse)
pub mod endpoints_response {
    /// A builder for [`EndpointsResponse`](crate::model::EndpointsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::EndpointResponse>>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each endpoint that's associated with the user ID.</p>
        pub fn item(mut self, input: impl Into<crate::model::EndpointResponse>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each endpoint that's associated with the user ID.</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EndpointResponse>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointsResponse`](crate::model::EndpointsResponse)
        pub fn build(self) -> crate::model::EndpointsResponse {
            crate::model::EndpointsResponse { item: self.item }
        }
    }
}
impl EndpointsResponse {
    /// Creates a new builder-style object to manufacture [`EndpointsResponse`](crate::model::EndpointsResponse)
    pub fn builder() -> crate::model::endpoints_response::Builder {
        crate::model::endpoints_response::Builder::default()
    }
}

/// <p>Provides information about the channel type and other settings for an endpoint.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EndpointResponse {
    /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For example, the address for a push-notification channel is typically the token provided by a push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. The address for the SMS channel is a phone number in E.164 format, such as +12065550100. The address for the email channel is an email address.</p>
    pub address: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the application that's associated with the endpoint.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments.</p>
    pub attributes: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>The channel that's used when sending messages or push notifications to the endpoint.</p>
    pub channel_type: std::option::Option<crate::model::ChannelType>,
    /// <p>A number from 0-99 that represents the cohort that the endpoint is assigned to. Endpoints are grouped into cohorts randomly, and each cohort contains approximately 1 percent of the endpoints for an application. Amazon Pinpoint assigns cohorts to the holdout or treatment allocations for campaigns.</p>
    pub cohort_id: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when the endpoint was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
    pub demographic: std::option::Option<crate::model::EndpointDemographic>,
    /// <p>The date and time, in ISO 8601 format, when the endpoint was last updated.</p>
    pub effective_date: std::option::Option<std::string::String>,
    /// <p>Specifies whether messages or push notifications are sent to the endpoint. Possible values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
    pub endpoint_status: std::option::Option<std::string::String>,
    /// <p>The unique identifier that you assigned to the endpoint. The identifier should be a globally unique identifier (GUID) to ensure that it doesn't conflict with other endpoint identifiers that are associated with the application.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The geographic information for the endpoint.</p>
    pub location: std::option::Option<crate::model::EndpointLocation>,
    /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
    pub metrics: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
    /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
    pub opt_out: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the most recent request to update the endpoint.</p>
    pub request_id: std::option::Option<std::string::String>,
    /// <p>One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.</p>
    pub user: std::option::Option<crate::model::EndpointUser>,
}
impl std::fmt::Debug for EndpointResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EndpointResponse");
        formatter.field("address", &self.address);
        formatter.field("application_id", &self.application_id);
        formatter.field("attributes", &self.attributes);
        formatter.field("channel_type", &self.channel_type);
        formatter.field("cohort_id", &self.cohort_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("demographic", &self.demographic);
        formatter.field("effective_date", &self.effective_date);
        formatter.field("endpoint_status", &self.endpoint_status);
        formatter.field("id", &self.id);
        formatter.field("location", &self.location);
        formatter.field("metrics", &self.metrics);
        formatter.field("opt_out", &self.opt_out);
        formatter.field("request_id", &self.request_id);
        formatter.field("user", &self.user);
        formatter.finish()
    }
}
/// See [`EndpointResponse`](crate::model::EndpointResponse)
pub mod endpoint_response {
    /// A builder for [`EndpointResponse`](crate::model::EndpointResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) address: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
        >,
        pub(crate) channel_type: std::option::Option<crate::model::ChannelType>,
        pub(crate) cohort_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) demographic: std::option::Option<crate::model::EndpointDemographic>,
        pub(crate) effective_date: std::option::Option<std::string::String>,
        pub(crate) endpoint_status: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) location: std::option::Option<crate::model::EndpointLocation>,
        pub(crate) metrics:
            std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        pub(crate) opt_out: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
        pub(crate) user: std::option::Option<crate::model::EndpointUser>,
    }
    impl Builder {
        /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For example, the address for a push-notification channel is typically the token provided by a push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. The address for the SMS channel is a phone number in E.164 format, such as +12065550100. The address for the email channel is an email address.</p>
        pub fn address(mut self, input: impl Into<std::string::String>) -> Self {
            self.address = Some(input.into());
            self
        }
        /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For example, the address for a push-notification channel is typically the token provided by a push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. The address for the SMS channel is a phone number in E.164 format, such as +12065550100. The address for the email channel is an email address.</p>
        pub fn set_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.address = input;
            self
        }
        /// <p>The unique identifier for the application that's associated with the endpoint.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that's associated with the endpoint.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>The channel that's used when sending messages or push notifications to the endpoint.</p>
        pub fn channel_type(mut self, input: crate::model::ChannelType) -> Self {
            self.channel_type = Some(input);
            self
        }
        /// <p>The channel that's used when sending messages or push notifications to the endpoint.</p>
        pub fn set_channel_type(
            mut self,
            input: std::option::Option<crate::model::ChannelType>,
        ) -> Self {
            self.channel_type = input;
            self
        }
        /// <p>A number from 0-99 that represents the cohort that the endpoint is assigned to. Endpoints are grouped into cohorts randomly, and each cohort contains approximately 1 percent of the endpoints for an application. Amazon Pinpoint assigns cohorts to the holdout or treatment allocations for campaigns.</p>
        pub fn cohort_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.cohort_id = Some(input.into());
            self
        }
        /// <p>A number from 0-99 that represents the cohort that the endpoint is assigned to. Endpoints are grouped into cohorts randomly, and each cohort contains approximately 1 percent of the endpoints for an application. Amazon Pinpoint assigns cohorts to the holdout or treatment allocations for campaigns.</p>
        pub fn set_cohort_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cohort_id = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the endpoint was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the endpoint was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
        pub fn demographic(mut self, input: crate::model::EndpointDemographic) -> Self {
            self.demographic = Some(input);
            self
        }
        /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
        pub fn set_demographic(
            mut self,
            input: std::option::Option<crate::model::EndpointDemographic>,
        ) -> Self {
            self.demographic = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the endpoint was last updated.</p>
        pub fn effective_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.effective_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the endpoint was last updated.</p>
        pub fn set_effective_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.effective_date = input;
            self
        }
        /// <p>Specifies whether messages or push notifications are sent to the endpoint. Possible values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
        pub fn endpoint_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint_status = Some(input.into());
            self
        }
        /// <p>Specifies whether messages or push notifications are sent to the endpoint. Possible values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
        pub fn set_endpoint_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.endpoint_status = input;
            self
        }
        /// <p>The unique identifier that you assigned to the endpoint. The identifier should be a globally unique identifier (GUID) to ensure that it doesn't conflict with other endpoint identifiers that are associated with the application.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier that you assigned to the endpoint. The identifier should be a globally unique identifier (GUID) to ensure that it doesn't conflict with other endpoint identifiers that are associated with the application.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The geographic information for the endpoint.</p>
        pub fn location(mut self, input: crate::model::EndpointLocation) -> Self {
            self.location = Some(input);
            self
        }
        /// <p>The geographic information for the endpoint.</p>
        pub fn set_location(
            mut self,
            input: std::option::Option<crate::model::EndpointLocation>,
        ) -> Self {
            self.location = input;
            self
        }
        /// Adds a key-value pair to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
        pub fn metrics(mut self, k: impl Into<std::string::String>, v: impl Into<f64>) -> Self {
            let mut hash_map = self.metrics.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metrics = Some(hash_map);
            self
        }
        /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<std::collections::HashMap<std::string::String, f64>>,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
        pub fn opt_out(mut self, input: impl Into<std::string::String>) -> Self {
            self.opt_out = Some(input.into());
            self
        }
        /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
        pub fn set_opt_out(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.opt_out = input;
            self
        }
        /// <p>The unique identifier for the most recent request to update the endpoint.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the most recent request to update the endpoint.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// <p>One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.</p>
        pub fn user(mut self, input: crate::model::EndpointUser) -> Self {
            self.user = Some(input);
            self
        }
        /// <p>One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.</p>
        pub fn set_user(mut self, input: std::option::Option<crate::model::EndpointUser>) -> Self {
            self.user = input;
            self
        }
        /// Consumes the builder and constructs a [`EndpointResponse`](crate::model::EndpointResponse)
        pub fn build(self) -> crate::model::EndpointResponse {
            crate::model::EndpointResponse {
                address: self.address,
                application_id: self.application_id,
                attributes: self.attributes,
                channel_type: self.channel_type,
                cohort_id: self.cohort_id,
                creation_date: self.creation_date,
                demographic: self.demographic,
                effective_date: self.effective_date,
                endpoint_status: self.endpoint_status,
                id: self.id,
                location: self.location,
                metrics: self.metrics,
                opt_out: self.opt_out,
                request_id: self.request_id,
                user: self.user,
            }
        }
    }
}
impl EndpointResponse {
    /// Creates a new builder-style object to manufacture [`EndpointResponse`](crate::model::EndpointResponse)
    pub fn builder() -> crate::model::endpoint_response::Builder {
        crate::model::endpoint_response::Builder::default()
    }
}

/// <p>Provides information about the content and settings for a message template that can be used in text messages that are sent through the SMS channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SmsTemplateResponse {
    /// <p>The Amazon Resource Name (ARN) of the message template.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The message body that's used in text messages that are based on the message template.</p>
    pub body: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the message template was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
    pub default_substitutions: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the recommender model that's used by the message template.</p>
    pub recommender_id: std::option::Option<std::string::String>,
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The custom description of the message template.</p>
    pub template_description: std::option::Option<std::string::String>,
    /// <p>The name of the message template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The type of channel that the message template is designed for. For an SMS template, this value is SMS.</p>
    pub template_type: std::option::Option<crate::model::TemplateType>,
    /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SmsTemplateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SmsTemplateResponse");
        formatter.field("arn", &self.arn);
        formatter.field("body", &self.body);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("default_substitutions", &self.default_substitutions);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("recommender_id", &self.recommender_id);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_type", &self.template_type);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`SmsTemplateResponse`](crate::model::SmsTemplateResponse)
pub mod sms_template_response {
    /// A builder for [`SmsTemplateResponse`](crate::model::SmsTemplateResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) body: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) default_substitutions: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) recommender_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_type: std::option::Option<crate::model::TemplateType>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the message template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the message template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The message body that's used in text messages that are based on the message template.</p>
        pub fn body(mut self, input: impl Into<std::string::String>) -> Self {
            self.body = Some(input.into());
            self
        }
        /// <p>The message body that's used in text messages that are based on the message template.</p>
        pub fn set_body(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.body = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
        pub fn default_substitutions(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_substitutions = Some(input.into());
            self
        }
        /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
        pub fn set_default_substitutions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_substitutions = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The unique identifier for the recommender model that's used by the message template.</p>
        pub fn recommender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommender_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the recommender model that's used by the message template.</p>
        pub fn set_recommender_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommender_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The custom description of the message template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>The custom description of the message template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// <p>The name of the message template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the message template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The type of channel that the message template is designed for. For an SMS template, this value is SMS.</p>
        pub fn template_type(mut self, input: crate::model::TemplateType) -> Self {
            self.template_type = Some(input);
            self
        }
        /// <p>The type of channel that the message template is designed for. For an SMS template, this value is SMS.</p>
        pub fn set_template_type(
            mut self,
            input: std::option::Option<crate::model::TemplateType>,
        ) -> Self {
            self.template_type = input;
            self
        }
        /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`SmsTemplateResponse`](crate::model::SmsTemplateResponse)
        pub fn build(self) -> crate::model::SmsTemplateResponse {
            crate::model::SmsTemplateResponse {
                arn: self.arn,
                body: self.body,
                creation_date: self.creation_date,
                default_substitutions: self.default_substitutions,
                last_modified_date: self.last_modified_date,
                recommender_id: self.recommender_id,
                tags: self.tags,
                template_description: self.template_description,
                template_name: self.template_name,
                template_type: self.template_type,
                version: self.version,
            }
        }
    }
}
impl SmsTemplateResponse {
    /// Creates a new builder-style object to manufacture [`SmsTemplateResponse`](crate::model::SmsTemplateResponse)
    pub fn builder() -> crate::model::sms_template_response::Builder {
        crate::model::sms_template_response::Builder::default()
    }
}

/// <p>Provides information about all the segments that are associated with an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SegmentsResponse {
    /// <p>An array of responses, one for each segment that's associated with the application (Segments resource) or each version of a segment that's associated with the application (Segment Versions resource).</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::SegmentResponse>>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SegmentsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SegmentsResponse");
        formatter.field("item", &self.item);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`SegmentsResponse`](crate::model::SegmentsResponse)
pub mod segments_response {
    /// A builder for [`SegmentsResponse`](crate::model::SegmentsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::SegmentResponse>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each segment that's associated with the application (Segments resource) or each version of a segment that's associated with the application (Segment Versions resource).</p>
        pub fn item(mut self, input: impl Into<crate::model::SegmentResponse>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each segment that's associated with the application (Segments resource) or each version of a segment that's associated with the application (Segment Versions resource).</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SegmentResponse>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`SegmentsResponse`](crate::model::SegmentsResponse)
        pub fn build(self) -> crate::model::SegmentsResponse {
            crate::model::SegmentsResponse {
                item: self.item,
                next_token: self.next_token,
            }
        }
    }
}
impl SegmentsResponse {
    /// Creates a new builder-style object to manufacture [`SegmentsResponse`](crate::model::SegmentsResponse)
    pub fn builder() -> crate::model::segments_response::Builder {
        crate::model::segments_response::Builder::default()
    }
}

/// <p>Provides information about the status and settings of all the import jobs that are associated with an application or segment. An import job is a job that imports endpoint definitions from one or more files.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportJobsResponse {
    /// <p>An array of responses, one for each import job that's associated with the application (Import Jobs resource) or segment (Segment Import Jobs resource).</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::ImportJobResponse>>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImportJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportJobsResponse");
        formatter.field("item", &self.item);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ImportJobsResponse`](crate::model::ImportJobsResponse)
pub mod import_jobs_response {
    /// A builder for [`ImportJobsResponse`](crate::model::ImportJobsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::ImportJobResponse>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each import job that's associated with the application (Import Jobs resource) or segment (Segment Import Jobs resource).</p>
        pub fn item(mut self, input: impl Into<crate::model::ImportJobResponse>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each import job that's associated with the application (Import Jobs resource) or segment (Segment Import Jobs resource).</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ImportJobResponse>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportJobsResponse`](crate::model::ImportJobsResponse)
        pub fn build(self) -> crate::model::ImportJobsResponse {
            crate::model::ImportJobsResponse {
                item: self.item,
                next_token: self.next_token,
            }
        }
    }
}
impl ImportJobsResponse {
    /// Creates a new builder-style object to manufacture [`ImportJobsResponse`](crate::model::ImportJobsResponse)
    pub fn builder() -> crate::model::import_jobs_response::Builder {
        crate::model::import_jobs_response::Builder::default()
    }
}

/// <p>Provides information about the status and settings of a job that imports endpoint definitions from one or more files. The files can be stored in an Amazon Simple Storage Service (Amazon S3) bucket or uploaded directly from a computer by using the Amazon Pinpoint console.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportJobResponse {
    /// <p>The unique identifier for the application that's associated with the import job.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The number of pieces that were processed successfully (completed) by the import job, as of the time of the request.</p>
    pub completed_pieces: i32,
    /// <p>The date, in ISO 8601 format, when the import job was completed.</p>
    pub completion_date: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the import job was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The resource settings that apply to the import job.</p>
    pub definition: std::option::Option<crate::model::ImportJobResource>,
    /// <p>The number of pieces that weren't processed successfully (failed) by the import job, as of the time of the request.</p>
    pub failed_pieces: i32,
    /// <p>An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the import job, if any.</p>
    pub failures: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The unique identifier for the import job.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The status of the import job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>The total number of endpoint definitions that weren't processed successfully (failed) by the import job, typically because an error, such as a syntax error, occurred.</p>
    pub total_failures: i32,
    /// <p>The total number of pieces that must be processed to complete the import job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the import job.</p>
    pub total_pieces: i32,
    /// <p>The total number of endpoint definitions that were processed by the import job.</p>
    pub total_processed: i32,
    /// <p>The job type. This value is IMPORT for import jobs.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImportJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportJobResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("completed_pieces", &self.completed_pieces);
        formatter.field("completion_date", &self.completion_date);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("definition", &self.definition);
        formatter.field("failed_pieces", &self.failed_pieces);
        formatter.field("failures", &self.failures);
        formatter.field("id", &self.id);
        formatter.field("job_status", &self.job_status);
        formatter.field("total_failures", &self.total_failures);
        formatter.field("total_pieces", &self.total_pieces);
        formatter.field("total_processed", &self.total_processed);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`ImportJobResponse`](crate::model::ImportJobResponse)
pub mod import_job_response {
    /// A builder for [`ImportJobResponse`](crate::model::ImportJobResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) completed_pieces: std::option::Option<i32>,
        pub(crate) completion_date: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) definition: std::option::Option<crate::model::ImportJobResource>,
        pub(crate) failed_pieces: std::option::Option<i32>,
        pub(crate) failures: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) total_failures: std::option::Option<i32>,
        pub(crate) total_pieces: std::option::Option<i32>,
        pub(crate) total_processed: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that's associated with the import job.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that's associated with the import job.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The number of pieces that were processed successfully (completed) by the import job, as of the time of the request.</p>
        pub fn completed_pieces(mut self, input: i32) -> Self {
            self.completed_pieces = Some(input);
            self
        }
        /// <p>The number of pieces that were processed successfully (completed) by the import job, as of the time of the request.</p>
        pub fn set_completed_pieces(mut self, input: std::option::Option<i32>) -> Self {
            self.completed_pieces = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the import job was completed.</p>
        pub fn completion_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.completion_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the import job was completed.</p>
        pub fn set_completion_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.completion_date = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the import job was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the import job was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The resource settings that apply to the import job.</p>
        pub fn definition(mut self, input: crate::model::ImportJobResource) -> Self {
            self.definition = Some(input);
            self
        }
        /// <p>The resource settings that apply to the import job.</p>
        pub fn set_definition(
            mut self,
            input: std::option::Option<crate::model::ImportJobResource>,
        ) -> Self {
            self.definition = input;
            self
        }
        /// <p>The number of pieces that weren't processed successfully (failed) by the import job, as of the time of the request.</p>
        pub fn failed_pieces(mut self, input: i32) -> Self {
            self.failed_pieces = Some(input);
            self
        }
        /// <p>The number of pieces that weren't processed successfully (failed) by the import job, as of the time of the request.</p>
        pub fn set_failed_pieces(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_pieces = input;
            self
        }
        /// Appends an item to `failures`.
        ///
        /// To override the contents of this collection use [`set_failures`](Self::set_failures).
        ///
        /// <p>An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the import job, if any.</p>
        pub fn failures(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.failures.unwrap_or_default();
            v.push(input.into());
            self.failures = Some(v);
            self
        }
        /// <p>An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the import job, if any.</p>
        pub fn set_failures(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.failures = input;
            self
        }
        /// <p>The unique identifier for the import job.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the import job.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The status of the import job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the import job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>The total number of endpoint definitions that weren't processed successfully (failed) by the import job, typically because an error, such as a syntax error, occurred.</p>
        pub fn total_failures(mut self, input: i32) -> Self {
            self.total_failures = Some(input);
            self
        }
        /// <p>The total number of endpoint definitions that weren't processed successfully (failed) by the import job, typically because an error, such as a syntax error, occurred.</p>
        pub fn set_total_failures(mut self, input: std::option::Option<i32>) -> Self {
            self.total_failures = input;
            self
        }
        /// <p>The total number of pieces that must be processed to complete the import job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the import job.</p>
        pub fn total_pieces(mut self, input: i32) -> Self {
            self.total_pieces = Some(input);
            self
        }
        /// <p>The total number of pieces that must be processed to complete the import job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the import job.</p>
        pub fn set_total_pieces(mut self, input: std::option::Option<i32>) -> Self {
            self.total_pieces = input;
            self
        }
        /// <p>The total number of endpoint definitions that were processed by the import job.</p>
        pub fn total_processed(mut self, input: i32) -> Self {
            self.total_processed = Some(input);
            self
        }
        /// <p>The total number of endpoint definitions that were processed by the import job.</p>
        pub fn set_total_processed(mut self, input: std::option::Option<i32>) -> Self {
            self.total_processed = input;
            self
        }
        /// <p>The job type. This value is IMPORT for import jobs.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The job type. This value is IMPORT for import jobs.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportJobResponse`](crate::model::ImportJobResponse)
        pub fn build(self) -> crate::model::ImportJobResponse {
            crate::model::ImportJobResponse {
                application_id: self.application_id,
                completed_pieces: self.completed_pieces.unwrap_or_default(),
                completion_date: self.completion_date,
                creation_date: self.creation_date,
                definition: self.definition,
                failed_pieces: self.failed_pieces.unwrap_or_default(),
                failures: self.failures,
                id: self.id,
                job_status: self.job_status,
                total_failures: self.total_failures.unwrap_or_default(),
                total_pieces: self.total_pieces.unwrap_or_default(),
                total_processed: self.total_processed.unwrap_or_default(),
                r#type: self.r#type,
            }
        }
    }
}
impl ImportJobResponse {
    /// Creates a new builder-style object to manufacture [`ImportJobResponse`](crate::model::ImportJobResponse)
    pub fn builder() -> crate::model::import_job_response::Builder {
        crate::model::import_job_response::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Completing,
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Failing,
    #[allow(missing_docs)] // documentation missing in model
    Initializing,
    #[allow(missing_docs)] // documentation missing in model
    PendingJob,
    #[allow(missing_docs)] // documentation missing in model
    PreparingForInitialization,
    #[allow(missing_docs)] // documentation missing in model
    Processing,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for JobStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => JobStatus::Completed,
            "COMPLETING" => JobStatus::Completing,
            "CREATED" => JobStatus::Created,
            "FAILED" => JobStatus::Failed,
            "FAILING" => JobStatus::Failing,
            "INITIALIZING" => JobStatus::Initializing,
            "PENDING_JOB" => JobStatus::PendingJob,
            "PREPARING_FOR_INITIALIZATION" => JobStatus::PreparingForInitialization,
            "PROCESSING" => JobStatus::Processing,
            other => JobStatus::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for JobStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobStatus::from(s))
    }
}
impl JobStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobStatus::Completed => "COMPLETED",
            JobStatus::Completing => "COMPLETING",
            JobStatus::Created => "CREATED",
            JobStatus::Failed => "FAILED",
            JobStatus::Failing => "FAILING",
            JobStatus::Initializing => "INITIALIZING",
            JobStatus::PendingJob => "PENDING_JOB",
            JobStatus::PreparingForInitialization => "PREPARING_FOR_INITIALIZATION",
            JobStatus::Processing => "PROCESSING",
            JobStatus::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "COMPLETING",
            "CREATED",
            "FAILED",
            "FAILING",
            "INITIALIZING",
            "PENDING_JOB",
            "PREPARING_FOR_INITIALIZATION",
            "PROCESSING",
        ]
    }
}
impl AsRef<str> for JobStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Provides information about the resource settings for a job that imports endpoint definitions from one or more files. The files can be stored in an Amazon Simple Storage Service (Amazon S3) bucket or uploaded directly from a computer by using the Amazon Pinpoint console.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportJobResource {
    /// <p>Specifies whether the import job creates a segment that contains the endpoints, when the endpoint definitions are imported.</p>
    pub define_segment: bool,
    /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
    pub external_id: std::option::Option<std::string::String>,
    /// <p>The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format.</p> <p>If the files are stored in an Amazon S3 location and that location contains multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.</p>
    pub format: std::option::Option<crate::model::Format>,
    /// <p>Specifies whether the import job registers the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.</p>
    pub register_endpoints: bool,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains.</p> <p>The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/<replaceable>file-name</replaceable>. The location can end with the key for an individual object or a prefix that qualifies multiple objects.</p>
    pub s3_url: std::option::Option<std::string::String>,
    /// <p>The identifier for the segment that the import job updates or adds endpoint definitions to, if the import job updates an existing segment.</p>
    pub segment_id: std::option::Option<std::string::String>,
    /// <p>The custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.</p>
    pub segment_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImportJobResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportJobResource");
        formatter.field("define_segment", &self.define_segment);
        formatter.field("external_id", &self.external_id);
        formatter.field("format", &self.format);
        formatter.field("register_endpoints", &self.register_endpoints);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("s3_url", &self.s3_url);
        formatter.field("segment_id", &self.segment_id);
        formatter.field("segment_name", &self.segment_name);
        formatter.finish()
    }
}
/// See [`ImportJobResource`](crate::model::ImportJobResource)
pub mod import_job_resource {
    /// A builder for [`ImportJobResource`](crate::model::ImportJobResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) define_segment: std::option::Option<bool>,
        pub(crate) external_id: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::Format>,
        pub(crate) register_endpoints: std::option::Option<bool>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) s3_url: std::option::Option<std::string::String>,
        pub(crate) segment_id: std::option::Option<std::string::String>,
        pub(crate) segment_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies whether the import job creates a segment that contains the endpoints, when the endpoint definitions are imported.</p>
        pub fn define_segment(mut self, input: bool) -> Self {
            self.define_segment = Some(input);
            self
        }
        /// <p>Specifies whether the import job creates a segment that contains the endpoints, when the endpoint definitions are imported.</p>
        pub fn set_define_segment(mut self, input: std::option::Option<bool>) -> Self {
            self.define_segment = input;
            self
        }
        /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input;
            self
        }
        /// <p>The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format.</p> <p>If the files are stored in an Amazon S3 location and that location contains multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.</p>
        pub fn format(mut self, input: crate::model::Format) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format.</p> <p>If the files are stored in an Amazon S3 location and that location contains multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.</p>
        pub fn set_format(mut self, input: std::option::Option<crate::model::Format>) -> Self {
            self.format = input;
            self
        }
        /// <p>Specifies whether the import job registers the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.</p>
        pub fn register_endpoints(mut self, input: bool) -> Self {
            self.register_endpoints = Some(input);
            self
        }
        /// <p>Specifies whether the import job registers the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.</p>
        pub fn set_register_endpoints(mut self, input: std::option::Option<bool>) -> Self {
            self.register_endpoints = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains.</p> <p>The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/<replaceable>file-name</replaceable>. The location can end with the key for an individual object or a prefix that qualifies multiple objects.</p>
        pub fn s3_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_url = Some(input.into());
            self
        }
        /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains.</p> <p>The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/<replaceable>file-name</replaceable>. The location can end with the key for an individual object or a prefix that qualifies multiple objects.</p>
        pub fn set_s3_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_url = input;
            self
        }
        /// <p>The identifier for the segment that the import job updates or adds endpoint definitions to, if the import job updates an existing segment.</p>
        pub fn segment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_id = Some(input.into());
            self
        }
        /// <p>The identifier for the segment that the import job updates or adds endpoint definitions to, if the import job updates an existing segment.</p>
        pub fn set_segment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_id = input;
            self
        }
        /// <p>The custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.</p>
        pub fn segment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_name = Some(input.into());
            self
        }
        /// <p>The custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.</p>
        pub fn set_segment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportJobResource`](crate::model::ImportJobResource)
        pub fn build(self) -> crate::model::ImportJobResource {
            crate::model::ImportJobResource {
                define_segment: self.define_segment.unwrap_or_default(),
                external_id: self.external_id,
                format: self.format,
                register_endpoints: self.register_endpoints.unwrap_or_default(),
                role_arn: self.role_arn,
                s3_url: self.s3_url,
                segment_id: self.segment_id,
                segment_name: self.segment_name,
            }
        }
    }
}
impl ImportJobResource {
    /// Creates a new builder-style object to manufacture [`ImportJobResource`](crate::model::ImportJobResource)
    pub fn builder() -> crate::model::import_job_resource::Builder {
        crate::model::import_job_resource::Builder::default()
    }
}

/// <p>Provides information about all the export jobs that are associated with an application or segment. An export job is a job that exports endpoint definitions to a file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportJobsResponse {
    /// <p>An array of responses, one for each export job that's associated with the application (Export Jobs resource) or segment (Segment Export Jobs resource).</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::ExportJobResponse>>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportJobsResponse");
        formatter.field("item", &self.item);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ExportJobsResponse`](crate::model::ExportJobsResponse)
pub mod export_jobs_response {
    /// A builder for [`ExportJobsResponse`](crate::model::ExportJobsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::ExportJobResponse>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each export job that's associated with the application (Export Jobs resource) or segment (Segment Export Jobs resource).</p>
        pub fn item(mut self, input: impl Into<crate::model::ExportJobResponse>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each export job that's associated with the application (Export Jobs resource) or segment (Segment Export Jobs resource).</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ExportJobResponse>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportJobsResponse`](crate::model::ExportJobsResponse)
        pub fn build(self) -> crate::model::ExportJobsResponse {
            crate::model::ExportJobsResponse {
                item: self.item,
                next_token: self.next_token,
            }
        }
    }
}
impl ExportJobsResponse {
    /// Creates a new builder-style object to manufacture [`ExportJobsResponse`](crate::model::ExportJobsResponse)
    pub fn builder() -> crate::model::export_jobs_response::Builder {
        crate::model::export_jobs_response::Builder::default()
    }
}

/// <p>Provides information about the status and settings of a job that exports endpoint definitions to a file. The file can be added directly to an Amazon Simple Storage Service (Amazon S3) bucket by using the Amazon Pinpoint API or downloaded directly to a computer by using the Amazon Pinpoint console.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportJobResponse {
    /// <p>The unique identifier for the application that's associated with the export job.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The number of pieces that were processed successfully (completed) by the export job, as of the time of the request.</p>
    pub completed_pieces: i32,
    /// <p>The date, in ISO 8601 format, when the export job was completed.</p>
    pub completion_date: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the export job was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The resource settings that apply to the export job.</p>
    pub definition: std::option::Option<crate::model::ExportJobResource>,
    /// <p>The number of pieces that weren't processed successfully (failed) by the export job, as of the time of the request.</p>
    pub failed_pieces: i32,
    /// <p>An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the export job, if any.</p>
    pub failures: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The unique identifier for the export job.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The status of the export job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.</p>
    pub job_status: std::option::Option<crate::model::JobStatus>,
    /// <p>The total number of endpoint definitions that weren't processed successfully (failed) by the export job, typically because an error, such as a syntax error, occurred.</p>
    pub total_failures: i32,
    /// <p>The total number of pieces that must be processed to complete the export job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the export job.</p>
    pub total_pieces: i32,
    /// <p>The total number of endpoint definitions that were processed by the export job.</p>
    pub total_processed: i32,
    /// <p>The job type. This value is EXPORT for export jobs.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ExportJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportJobResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("completed_pieces", &self.completed_pieces);
        formatter.field("completion_date", &self.completion_date);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("definition", &self.definition);
        formatter.field("failed_pieces", &self.failed_pieces);
        formatter.field("failures", &self.failures);
        formatter.field("id", &self.id);
        formatter.field("job_status", &self.job_status);
        formatter.field("total_failures", &self.total_failures);
        formatter.field("total_pieces", &self.total_pieces);
        formatter.field("total_processed", &self.total_processed);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`ExportJobResponse`](crate::model::ExportJobResponse)
pub mod export_job_response {
    /// A builder for [`ExportJobResponse`](crate::model::ExportJobResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) completed_pieces: std::option::Option<i32>,
        pub(crate) completion_date: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) definition: std::option::Option<crate::model::ExportJobResource>,
        pub(crate) failed_pieces: std::option::Option<i32>,
        pub(crate) failures: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) job_status: std::option::Option<crate::model::JobStatus>,
        pub(crate) total_failures: std::option::Option<i32>,
        pub(crate) total_pieces: std::option::Option<i32>,
        pub(crate) total_processed: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that's associated with the export job.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that's associated with the export job.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The number of pieces that were processed successfully (completed) by the export job, as of the time of the request.</p>
        pub fn completed_pieces(mut self, input: i32) -> Self {
            self.completed_pieces = Some(input);
            self
        }
        /// <p>The number of pieces that were processed successfully (completed) by the export job, as of the time of the request.</p>
        pub fn set_completed_pieces(mut self, input: std::option::Option<i32>) -> Self {
            self.completed_pieces = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the export job was completed.</p>
        pub fn completion_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.completion_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the export job was completed.</p>
        pub fn set_completion_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.completion_date = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the export job was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the export job was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The resource settings that apply to the export job.</p>
        pub fn definition(mut self, input: crate::model::ExportJobResource) -> Self {
            self.definition = Some(input);
            self
        }
        /// <p>The resource settings that apply to the export job.</p>
        pub fn set_definition(
            mut self,
            input: std::option::Option<crate::model::ExportJobResource>,
        ) -> Self {
            self.definition = input;
            self
        }
        /// <p>The number of pieces that weren't processed successfully (failed) by the export job, as of the time of the request.</p>
        pub fn failed_pieces(mut self, input: i32) -> Self {
            self.failed_pieces = Some(input);
            self
        }
        /// <p>The number of pieces that weren't processed successfully (failed) by the export job, as of the time of the request.</p>
        pub fn set_failed_pieces(mut self, input: std::option::Option<i32>) -> Self {
            self.failed_pieces = input;
            self
        }
        /// Appends an item to `failures`.
        ///
        /// To override the contents of this collection use [`set_failures`](Self::set_failures).
        ///
        /// <p>An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the export job, if any.</p>
        pub fn failures(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.failures.unwrap_or_default();
            v.push(input.into());
            self.failures = Some(v);
            self
        }
        /// <p>An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the export job, if any.</p>
        pub fn set_failures(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.failures = input;
            self
        }
        /// <p>The unique identifier for the export job.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the export job.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The status of the export job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.</p>
        pub fn job_status(mut self, input: crate::model::JobStatus) -> Self {
            self.job_status = Some(input);
            self
        }
        /// <p>The status of the export job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.</p>
        pub fn set_job_status(
            mut self,
            input: std::option::Option<crate::model::JobStatus>,
        ) -> Self {
            self.job_status = input;
            self
        }
        /// <p>The total number of endpoint definitions that weren't processed successfully (failed) by the export job, typically because an error, such as a syntax error, occurred.</p>
        pub fn total_failures(mut self, input: i32) -> Self {
            self.total_failures = Some(input);
            self
        }
        /// <p>The total number of endpoint definitions that weren't processed successfully (failed) by the export job, typically because an error, such as a syntax error, occurred.</p>
        pub fn set_total_failures(mut self, input: std::option::Option<i32>) -> Self {
            self.total_failures = input;
            self
        }
        /// <p>The total number of pieces that must be processed to complete the export job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the export job.</p>
        pub fn total_pieces(mut self, input: i32) -> Self {
            self.total_pieces = Some(input);
            self
        }
        /// <p>The total number of pieces that must be processed to complete the export job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the export job.</p>
        pub fn set_total_pieces(mut self, input: std::option::Option<i32>) -> Self {
            self.total_pieces = input;
            self
        }
        /// <p>The total number of endpoint definitions that were processed by the export job.</p>
        pub fn total_processed(mut self, input: i32) -> Self {
            self.total_processed = Some(input);
            self
        }
        /// <p>The total number of endpoint definitions that were processed by the export job.</p>
        pub fn set_total_processed(mut self, input: std::option::Option<i32>) -> Self {
            self.total_processed = input;
            self
        }
        /// <p>The job type. This value is EXPORT for export jobs.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The job type. This value is EXPORT for export jobs.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportJobResponse`](crate::model::ExportJobResponse)
        pub fn build(self) -> crate::model::ExportJobResponse {
            crate::model::ExportJobResponse {
                application_id: self.application_id,
                completed_pieces: self.completed_pieces.unwrap_or_default(),
                completion_date: self.completion_date,
                creation_date: self.creation_date,
                definition: self.definition,
                failed_pieces: self.failed_pieces.unwrap_or_default(),
                failures: self.failures,
                id: self.id,
                job_status: self.job_status,
                total_failures: self.total_failures.unwrap_or_default(),
                total_pieces: self.total_pieces.unwrap_or_default(),
                total_processed: self.total_processed.unwrap_or_default(),
                r#type: self.r#type,
            }
        }
    }
}
impl ExportJobResponse {
    /// Creates a new builder-style object to manufacture [`ExportJobResponse`](crate::model::ExportJobResponse)
    pub fn builder() -> crate::model::export_job_response::Builder {
        crate::model::export_job_response::Builder::default()
    }
}

/// <p>Provides information about the resource settings for a job that exports endpoint definitions to a file. The file can be added directly to an Amazon Simple Storage Service (Amazon S3) bucket by using the Amazon Pinpoint API or downloaded directly to a computer by using the Amazon Pinpoint console.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportJobResource {
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location where the endpoint definitions were exported to.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where the endpoint definitions were exported to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/.</p>
    pub s3_url_prefix: std::option::Option<std::string::String>,
    /// <p>The identifier for the segment that the endpoint definitions were exported from. If this value isn't present, Amazon Pinpoint exported definitions for all the endpoints that are associated with the application.</p>
    pub segment_id: std::option::Option<std::string::String>,
    /// <p>The version of the segment that the endpoint definitions were exported from.</p>
    pub segment_version: i32,
}
impl std::fmt::Debug for ExportJobResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportJobResource");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("s3_url_prefix", &self.s3_url_prefix);
        formatter.field("segment_id", &self.segment_id);
        formatter.field("segment_version", &self.segment_version);
        formatter.finish()
    }
}
/// See [`ExportJobResource`](crate::model::ExportJobResource)
pub mod export_job_resource {
    /// A builder for [`ExportJobResource`](crate::model::ExportJobResource)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) s3_url_prefix: std::option::Option<std::string::String>,
        pub(crate) segment_id: std::option::Option<std::string::String>,
        pub(crate) segment_version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location where the endpoint definitions were exported to.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location where the endpoint definitions were exported to.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where the endpoint definitions were exported to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/.</p>
        pub fn s3_url_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_url_prefix = Some(input.into());
            self
        }
        /// <p>The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where the endpoint definitions were exported to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/.</p>
        pub fn set_s3_url_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_url_prefix = input;
            self
        }
        /// <p>The identifier for the segment that the endpoint definitions were exported from. If this value isn't present, Amazon Pinpoint exported definitions for all the endpoints that are associated with the application.</p>
        pub fn segment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_id = Some(input.into());
            self
        }
        /// <p>The identifier for the segment that the endpoint definitions were exported from. If this value isn't present, Amazon Pinpoint exported definitions for all the endpoints that are associated with the application.</p>
        pub fn set_segment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_id = input;
            self
        }
        /// <p>The version of the segment that the endpoint definitions were exported from.</p>
        pub fn segment_version(mut self, input: i32) -> Self {
            self.segment_version = Some(input);
            self
        }
        /// <p>The version of the segment that the endpoint definitions were exported from.</p>
        pub fn set_segment_version(mut self, input: std::option::Option<i32>) -> Self {
            self.segment_version = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportJobResource`](crate::model::ExportJobResource)
        pub fn build(self) -> crate::model::ExportJobResource {
            crate::model::ExportJobResource {
                role_arn: self.role_arn,
                s3_url_prefix: self.s3_url_prefix,
                segment_id: self.segment_id,
                segment_version: self.segment_version.unwrap_or_default(),
            }
        }
    }
}
impl ExportJobResource {
    /// Creates a new builder-style object to manufacture [`ExportJobResource`](crate::model::ExportJobResource)
    pub fn builder() -> crate::model::export_job_resource::Builder {
        crate::model::export_job_resource::Builder::default()
    }
}

/// <p>Provides information about all the recommender model configurations that are associated with your Amazon Pinpoint account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRecommenderConfigurationsResponse {
    /// <p>An array of responses, one for each recommender model configuration that's associated with your Amazon Pinpoint account.</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::RecommenderConfigurationResponse>>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListRecommenderConfigurationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRecommenderConfigurationsResponse");
        formatter.field("item", &self.item);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListRecommenderConfigurationsResponse`](crate::model::ListRecommenderConfigurationsResponse)
pub mod list_recommender_configurations_response {
    /// A builder for [`ListRecommenderConfigurationsResponse`](crate::model::ListRecommenderConfigurationsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item:
            std::option::Option<std::vec::Vec<crate::model::RecommenderConfigurationResponse>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each recommender model configuration that's associated with your Amazon Pinpoint account.</p>
        pub fn item(
            mut self,
            input: impl Into<crate::model::RecommenderConfigurationResponse>,
        ) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each recommender model configuration that's associated with your Amazon Pinpoint account.</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::RecommenderConfigurationResponse>,
            >,
        ) -> Self {
            self.item = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRecommenderConfigurationsResponse`](crate::model::ListRecommenderConfigurationsResponse)
        pub fn build(self) -> crate::model::ListRecommenderConfigurationsResponse {
            crate::model::ListRecommenderConfigurationsResponse {
                item: self.item,
                next_token: self.next_token,
            }
        }
    }
}
impl ListRecommenderConfigurationsResponse {
    /// Creates a new builder-style object to manufacture [`ListRecommenderConfigurationsResponse`](crate::model::ListRecommenderConfigurationsResponse)
    pub fn builder() -> crate::model::list_recommender_configurations_response::Builder {
        crate::model::list_recommender_configurations_response::Builder::default()
    }
}

/// <p>Provides information about the content and settings for a message template that can be used in messages that are sent through a push notification channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PushNotificationTemplateResponse {
    /// <p>The message template that's used for the ADM (Amazon Device Messaging) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    pub adm: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
    /// <p>The message template that's used for the APNs (Apple Push Notification service) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    pub apns: std::option::Option<crate::model::ApnsPushNotificationTemplate>,
    /// <p>The Amazon Resource Name (ARN) of the message template.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The message template that's used for the Baidu (Baidu Cloud Push) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    pub baidu: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
    /// <p>The date, in ISO 8601 format, when the message template was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The default message template that's used for push notification channels.</p>
    pub default_value: std::option::Option<crate::model::DefaultPushNotificationTemplate>,
    /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
    pub default_substitutions: std::option::Option<std::string::String>,
    /// <p>The message template that's used for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    pub gcm: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
    /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the recommender model that's used by the message template.</p>
    pub recommender_id: std::option::Option<std::string::String>,
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The custom description of the message template.</p>
    pub template_description: std::option::Option<std::string::String>,
    /// <p>The name of the message template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The type of channel that the message template is designed for. For a push notification template, this value is PUSH.</p>
    pub template_type: std::option::Option<crate::model::TemplateType>,
    /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PushNotificationTemplateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PushNotificationTemplateResponse");
        formatter.field("adm", &self.adm);
        formatter.field("apns", &self.apns);
        formatter.field("arn", &self.arn);
        formatter.field("baidu", &self.baidu);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("default_value", &self.default_value);
        formatter.field("default_substitutions", &self.default_substitutions);
        formatter.field("gcm", &self.gcm);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("recommender_id", &self.recommender_id);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_type", &self.template_type);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`PushNotificationTemplateResponse`](crate::model::PushNotificationTemplateResponse)
pub mod push_notification_template_response {
    /// A builder for [`PushNotificationTemplateResponse`](crate::model::PushNotificationTemplateResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) adm: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        pub(crate) apns: std::option::Option<crate::model::ApnsPushNotificationTemplate>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) baidu: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) default_value:
            std::option::Option<crate::model::DefaultPushNotificationTemplate>,
        pub(crate) default_substitutions: std::option::Option<std::string::String>,
        pub(crate) gcm: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) recommender_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_type: std::option::Option<crate::model::TemplateType>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The message template that's used for the ADM (Amazon Device Messaging) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn adm(mut self, input: crate::model::AndroidPushNotificationTemplate) -> Self {
            self.adm = Some(input);
            self
        }
        /// <p>The message template that's used for the ADM (Amazon Device Messaging) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn set_adm(
            mut self,
            input: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        ) -> Self {
            self.adm = input;
            self
        }
        /// <p>The message template that's used for the APNs (Apple Push Notification service) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn apns(mut self, input: crate::model::ApnsPushNotificationTemplate) -> Self {
            self.apns = Some(input);
            self
        }
        /// <p>The message template that's used for the APNs (Apple Push Notification service) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn set_apns(
            mut self,
            input: std::option::Option<crate::model::ApnsPushNotificationTemplate>,
        ) -> Self {
            self.apns = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the message template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the message template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The message template that's used for the Baidu (Baidu Cloud Push) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn baidu(mut self, input: crate::model::AndroidPushNotificationTemplate) -> Self {
            self.baidu = Some(input);
            self
        }
        /// <p>The message template that's used for the Baidu (Baidu Cloud Push) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn set_baidu(
            mut self,
            input: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        ) -> Self {
            self.baidu = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The default message template that's used for push notification channels.</p>
        pub fn default_value(
            mut self,
            input: crate::model::DefaultPushNotificationTemplate,
        ) -> Self {
            self.default_value = Some(input);
            self
        }
        /// <p>The default message template that's used for push notification channels.</p>
        pub fn set_default(
            mut self,
            input: std::option::Option<crate::model::DefaultPushNotificationTemplate>,
        ) -> Self {
            self.default_value = input;
            self
        }
        /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
        pub fn default_substitutions(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_substitutions = Some(input.into());
            self
        }
        /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
        pub fn set_default_substitutions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_substitutions = input;
            self
        }
        /// <p>The message template that's used for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn gcm(mut self, input: crate::model::AndroidPushNotificationTemplate) -> Self {
            self.gcm = Some(input);
            self
        }
        /// <p>The message template that's used for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
        pub fn set_gcm(
            mut self,
            input: std::option::Option<crate::model::AndroidPushNotificationTemplate>,
        ) -> Self {
            self.gcm = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The unique identifier for the recommender model that's used by the message template.</p>
        pub fn recommender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommender_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the recommender model that's used by the message template.</p>
        pub fn set_recommender_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommender_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The custom description of the message template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>The custom description of the message template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// <p>The name of the message template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the message template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The type of channel that the message template is designed for. For a push notification template, this value is PUSH.</p>
        pub fn template_type(mut self, input: crate::model::TemplateType) -> Self {
            self.template_type = Some(input);
            self
        }
        /// <p>The type of channel that the message template is designed for. For a push notification template, this value is PUSH.</p>
        pub fn set_template_type(
            mut self,
            input: std::option::Option<crate::model::TemplateType>,
        ) -> Self {
            self.template_type = input;
            self
        }
        /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`PushNotificationTemplateResponse`](crate::model::PushNotificationTemplateResponse)
        pub fn build(self) -> crate::model::PushNotificationTemplateResponse {
            crate::model::PushNotificationTemplateResponse {
                adm: self.adm,
                apns: self.apns,
                arn: self.arn,
                baidu: self.baidu,
                creation_date: self.creation_date,
                default_value: self.default_value,
                default_substitutions: self.default_substitutions,
                gcm: self.gcm,
                last_modified_date: self.last_modified_date,
                recommender_id: self.recommender_id,
                tags: self.tags,
                template_description: self.template_description,
                template_name: self.template_name,
                template_type: self.template_type,
                version: self.version,
            }
        }
    }
}
impl PushNotificationTemplateResponse {
    /// Creates a new builder-style object to manufacture [`PushNotificationTemplateResponse`](crate::model::PushNotificationTemplateResponse)
    pub fn builder() -> crate::model::push_notification_template_response::Builder {
        crate::model::push_notification_template_response::Builder::default()
    }
}

/// <p>Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey, and provides information about that query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneyExecutionMetricsResponse {
    /// <p>The unique identifier for the application that the metric applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the journey that the metric applies to.</p>
    pub journey_id: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the journey and updated the data for the metric.</p>
    pub last_evaluated_time: std::option::Option<std::string::String>,
    /// <p>A JSON object that contains the results of the query. For information about the structure and contents of the results, see the <a href="https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    pub metrics:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for JourneyExecutionMetricsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneyExecutionMetricsResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("journey_id", &self.journey_id);
        formatter.field("last_evaluated_time", &self.last_evaluated_time);
        formatter.field("metrics", &self.metrics);
        formatter.finish()
    }
}
/// See [`JourneyExecutionMetricsResponse`](crate::model::JourneyExecutionMetricsResponse)
pub mod journey_execution_metrics_response {
    /// A builder for [`JourneyExecutionMetricsResponse`](crate::model::JourneyExecutionMetricsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) journey_id: std::option::Option<std::string::String>,
        pub(crate) last_evaluated_time: std::option::Option<std::string::String>,
        pub(crate) metrics: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the metric applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the metric applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The unique identifier for the journey that the metric applies to.</p>
        pub fn journey_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.journey_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the journey that the metric applies to.</p>
        pub fn set_journey_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.journey_id = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the journey and updated the data for the metric.</p>
        pub fn last_evaluated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_evaluated_time = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the journey and updated the data for the metric.</p>
        pub fn set_last_evaluated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_evaluated_time = input;
            self
        }
        /// Adds a key-value pair to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>A JSON object that contains the results of the query. For information about the structure and contents of the results, see the <a href="https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
        pub fn metrics(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metrics.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metrics = Some(hash_map);
            self
        }
        /// <p>A JSON object that contains the results of the query. For information about the structure and contents of the results, see the <a href="https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneyExecutionMetricsResponse`](crate::model::JourneyExecutionMetricsResponse)
        pub fn build(self) -> crate::model::JourneyExecutionMetricsResponse {
            crate::model::JourneyExecutionMetricsResponse {
                application_id: self.application_id,
                journey_id: self.journey_id,
                last_evaluated_time: self.last_evaluated_time,
                metrics: self.metrics,
            }
        }
    }
}
impl JourneyExecutionMetricsResponse {
    /// Creates a new builder-style object to manufacture [`JourneyExecutionMetricsResponse`](crate::model::JourneyExecutionMetricsResponse)
    pub fn builder() -> crate::model::journey_execution_metrics_response::Builder {
        crate::model::journey_execution_metrics_response::Builder::default()
    }
}

/// <p>Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey activity, and provides information about that query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneyExecutionActivityMetricsResponse {
    /// <p>The type of activity that the metric applies to. Possible values are:</p> <ul><li><p>CONDITIONAL_SPLIT - For a yes/no split activity, which is an activity that sends participants down one of two paths in a journey.</p></li> <li><p>HOLDOUT - For a holdout activity, which is an activity that stops a journey for a specified percentage of participants.</p></li> <li><p>MESSAGE - For an email activity, which is an activity that sends an email message to participants.</p></li> <li><p>MULTI_CONDITIONAL_SPLIT - For a multivariate split activity, which is an activity that sends participants down one of as many as five paths in a journey.</p></li> <li><p>RANDOM_SPLIT - For a random split activity, which is an activity that sends specified percentages of participants down one of as many as five paths in a journey.</p></li> <li><p>WAIT - For a wait activity, which is an activity that waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.</p></li></ul>
    pub activity_type: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the application that the metric applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the activity that the metric applies to.</p>
    pub journey_activity_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the journey that the metric applies to.</p>
    pub journey_id: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the execution status of the activity and updated the data for the metric.</p>
    pub last_evaluated_time: std::option::Option<std::string::String>,
    /// <p>A JSON object that contains the results of the query. The results vary depending on the type of activity (ActivityType). For information about the structure and contents of the results, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    pub metrics:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for JourneyExecutionActivityMetricsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneyExecutionActivityMetricsResponse");
        formatter.field("activity_type", &self.activity_type);
        formatter.field("application_id", &self.application_id);
        formatter.field("journey_activity_id", &self.journey_activity_id);
        formatter.field("journey_id", &self.journey_id);
        formatter.field("last_evaluated_time", &self.last_evaluated_time);
        formatter.field("metrics", &self.metrics);
        formatter.finish()
    }
}
/// See [`JourneyExecutionActivityMetricsResponse`](crate::model::JourneyExecutionActivityMetricsResponse)
pub mod journey_execution_activity_metrics_response {
    /// A builder for [`JourneyExecutionActivityMetricsResponse`](crate::model::JourneyExecutionActivityMetricsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) activity_type: std::option::Option<std::string::String>,
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) journey_activity_id: std::option::Option<std::string::String>,
        pub(crate) journey_id: std::option::Option<std::string::String>,
        pub(crate) last_evaluated_time: std::option::Option<std::string::String>,
        pub(crate) metrics: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The type of activity that the metric applies to. Possible values are:</p> <ul><li><p>CONDITIONAL_SPLIT - For a yes/no split activity, which is an activity that sends participants down one of two paths in a journey.</p></li> <li><p>HOLDOUT - For a holdout activity, which is an activity that stops a journey for a specified percentage of participants.</p></li> <li><p>MESSAGE - For an email activity, which is an activity that sends an email message to participants.</p></li> <li><p>MULTI_CONDITIONAL_SPLIT - For a multivariate split activity, which is an activity that sends participants down one of as many as five paths in a journey.</p></li> <li><p>RANDOM_SPLIT - For a random split activity, which is an activity that sends specified percentages of participants down one of as many as five paths in a journey.</p></li> <li><p>WAIT - For a wait activity, which is an activity that waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.</p></li></ul>
        pub fn activity_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.activity_type = Some(input.into());
            self
        }
        /// <p>The type of activity that the metric applies to. Possible values are:</p> <ul><li><p>CONDITIONAL_SPLIT - For a yes/no split activity, which is an activity that sends participants down one of two paths in a journey.</p></li> <li><p>HOLDOUT - For a holdout activity, which is an activity that stops a journey for a specified percentage of participants.</p></li> <li><p>MESSAGE - For an email activity, which is an activity that sends an email message to participants.</p></li> <li><p>MULTI_CONDITIONAL_SPLIT - For a multivariate split activity, which is an activity that sends participants down one of as many as five paths in a journey.</p></li> <li><p>RANDOM_SPLIT - For a random split activity, which is an activity that sends specified percentages of participants down one of as many as five paths in a journey.</p></li> <li><p>WAIT - For a wait activity, which is an activity that waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.</p></li></ul>
        pub fn set_activity_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.activity_type = input;
            self
        }
        /// <p>The unique identifier for the application that the metric applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the metric applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The unique identifier for the activity that the metric applies to.</p>
        pub fn journey_activity_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.journey_activity_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the activity that the metric applies to.</p>
        pub fn set_journey_activity_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.journey_activity_id = input;
            self
        }
        /// <p>The unique identifier for the journey that the metric applies to.</p>
        pub fn journey_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.journey_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the journey that the metric applies to.</p>
        pub fn set_journey_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.journey_id = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the execution status of the activity and updated the data for the metric.</p>
        pub fn last_evaluated_time(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_evaluated_time = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the execution status of the activity and updated the data for the metric.</p>
        pub fn set_last_evaluated_time(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_evaluated_time = input;
            self
        }
        /// Adds a key-value pair to `metrics`.
        ///
        /// To override the contents of this collection use [`set_metrics`](Self::set_metrics).
        ///
        /// <p>A JSON object that contains the results of the query. The results vary depending on the type of activity (ActivityType). For information about the structure and contents of the results, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
        pub fn metrics(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.metrics.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.metrics = Some(hash_map);
            self
        }
        /// <p>A JSON object that contains the results of the query. The results vary depending on the type of activity (ActivityType). For information about the structure and contents of the results, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
        pub fn set_metrics(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.metrics = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneyExecutionActivityMetricsResponse`](crate::model::JourneyExecutionActivityMetricsResponse)
        pub fn build(self) -> crate::model::JourneyExecutionActivityMetricsResponse {
            crate::model::JourneyExecutionActivityMetricsResponse {
                activity_type: self.activity_type,
                application_id: self.application_id,
                journey_activity_id: self.journey_activity_id,
                journey_id: self.journey_id,
                last_evaluated_time: self.last_evaluated_time,
                metrics: self.metrics,
            }
        }
    }
}
impl JourneyExecutionActivityMetricsResponse {
    /// Creates a new builder-style object to manufacture [`JourneyExecutionActivityMetricsResponse`](crate::model::JourneyExecutionActivityMetricsResponse)
    pub fn builder() -> crate::model::journey_execution_activity_metrics_response::Builder {
        crate::model::journey_execution_activity_metrics_response::Builder::default()
    }
}

/// <p>Provides the results of a query that retrieved the data for a standard engagement metric that applies to a journey, and provides information about that query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JourneyDateRangeKpiResponse {
    /// <p>The unique identifier for the application that the metric applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The unique identifier for the journey that the metric applies to.</p>
    pub journey_id: std::option::Option<std::string::String>,
    /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    pub kpi_name: std::option::Option<std::string::String>,
    /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
    pub kpi_result: std::option::Option<crate::model::BaseKpiResult>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Journey Engagement Metrics resource because the resource returns all results in a single page.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for JourneyDateRangeKpiResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JourneyDateRangeKpiResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("end_time", &self.end_time);
        formatter.field("journey_id", &self.journey_id);
        formatter.field("kpi_name", &self.kpi_name);
        formatter.field("kpi_result", &self.kpi_result);
        formatter.field("next_token", &self.next_token);
        formatter.field("start_time", &self.start_time);
        formatter.finish()
    }
}
/// See [`JourneyDateRangeKpiResponse`](crate::model::JourneyDateRangeKpiResponse)
pub mod journey_date_range_kpi_response {
    /// A builder for [`JourneyDateRangeKpiResponse`](crate::model::JourneyDateRangeKpiResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) journey_id: std::option::Option<std::string::String>,
        pub(crate) kpi_name: std::option::Option<std::string::String>,
        pub(crate) kpi_result: std::option::Option<crate::model::BaseKpiResult>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the metric applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the metric applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The unique identifier for the journey that the metric applies to.</p>
        pub fn journey_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.journey_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the journey that the metric applies to.</p>
        pub fn set_journey_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.journey_id = input;
            self
        }
        /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
        pub fn kpi_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.kpi_name = Some(input.into());
            self
        }
        /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
        pub fn set_kpi_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kpi_name = input;
            self
        }
        /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
        pub fn kpi_result(mut self, input: crate::model::BaseKpiResult) -> Self {
            self.kpi_result = Some(input);
            self
        }
        /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
        pub fn set_kpi_result(
            mut self,
            input: std::option::Option<crate::model::BaseKpiResult>,
        ) -> Self {
            self.kpi_result = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Journey Engagement Metrics resource because the resource returns all results in a single page.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Journey Engagement Metrics resource because the resource returns all results in a single page.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`JourneyDateRangeKpiResponse`](crate::model::JourneyDateRangeKpiResponse)
        pub fn build(self) -> crate::model::JourneyDateRangeKpiResponse {
            crate::model::JourneyDateRangeKpiResponse {
                application_id: self.application_id,
                end_time: self.end_time,
                journey_id: self.journey_id,
                kpi_name: self.kpi_name,
                kpi_result: self.kpi_result,
                next_token: self.next_token,
                start_time: self.start_time,
            }
        }
    }
}
impl JourneyDateRangeKpiResponse {
    /// Creates a new builder-style object to manufacture [`JourneyDateRangeKpiResponse`](crate::model::JourneyDateRangeKpiResponse)
    pub fn builder() -> crate::model::journey_date_range_kpi_response::Builder {
        crate::model::journey_date_range_kpi_response::Builder::default()
    }
}

/// <p>Provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BaseKpiResult {
    /// <p>An array of objects that provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.</p>
    pub rows: std::option::Option<std::vec::Vec<crate::model::ResultRow>>,
}
impl std::fmt::Debug for BaseKpiResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BaseKpiResult");
        formatter.field("rows", &self.rows);
        formatter.finish()
    }
}
/// See [`BaseKpiResult`](crate::model::BaseKpiResult)
pub mod base_kpi_result {
    /// A builder for [`BaseKpiResult`](crate::model::BaseKpiResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rows: std::option::Option<std::vec::Vec<crate::model::ResultRow>>,
    }
    impl Builder {
        /// Appends an item to `rows`.
        ///
        /// To override the contents of this collection use [`set_rows`](Self::set_rows).
        ///
        /// <p>An array of objects that provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.</p>
        pub fn rows(mut self, input: impl Into<crate::model::ResultRow>) -> Self {
            let mut v = self.rows.unwrap_or_default();
            v.push(input.into());
            self.rows = Some(v);
            self
        }
        /// <p>An array of objects that provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.</p>
        pub fn set_rows(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResultRow>>,
        ) -> Self {
            self.rows = input;
            self
        }
        /// Consumes the builder and constructs a [`BaseKpiResult`](crate::model::BaseKpiResult)
        pub fn build(self) -> crate::model::BaseKpiResult {
            crate::model::BaseKpiResult { rows: self.rows }
        }
    }
}
impl BaseKpiResult {
    /// Creates a new builder-style object to manufacture [`BaseKpiResult`](crate::model::BaseKpiResult)
    pub fn builder() -> crate::model::base_kpi_result::Builder {
        crate::model::base_kpi_result::Builder::default()
    }
}

/// <p>Provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultRow {
    /// <p>An array of objects that defines the field and field values that were used to group data in a result set that contains multiple results. This value is null if the data in a result set isn’t grouped.</p>
    pub grouped_bys: std::option::Option<std::vec::Vec<crate::model::ResultRowValue>>,
    /// <p>An array of objects that provides pre-aggregated values for a standard metric that applies to an application, campaign, or journey.</p>
    pub values: std::option::Option<std::vec::Vec<crate::model::ResultRowValue>>,
}
impl std::fmt::Debug for ResultRow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultRow");
        formatter.field("grouped_bys", &self.grouped_bys);
        formatter.field("values", &self.values);
        formatter.finish()
    }
}
/// See [`ResultRow`](crate::model::ResultRow)
pub mod result_row {
    /// A builder for [`ResultRow`](crate::model::ResultRow)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) grouped_bys: std::option::Option<std::vec::Vec<crate::model::ResultRowValue>>,
        pub(crate) values: std::option::Option<std::vec::Vec<crate::model::ResultRowValue>>,
    }
    impl Builder {
        /// Appends an item to `grouped_bys`.
        ///
        /// To override the contents of this collection use [`set_grouped_bys`](Self::set_grouped_bys).
        ///
        /// <p>An array of objects that defines the field and field values that were used to group data in a result set that contains multiple results. This value is null if the data in a result set isn’t grouped.</p>
        pub fn grouped_bys(mut self, input: impl Into<crate::model::ResultRowValue>) -> Self {
            let mut v = self.grouped_bys.unwrap_or_default();
            v.push(input.into());
            self.grouped_bys = Some(v);
            self
        }
        /// <p>An array of objects that defines the field and field values that were used to group data in a result set that contains multiple results. This value is null if the data in a result set isn’t grouped.</p>
        pub fn set_grouped_bys(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResultRowValue>>,
        ) -> Self {
            self.grouped_bys = input;
            self
        }
        /// Appends an item to `values`.
        ///
        /// To override the contents of this collection use [`set_values`](Self::set_values).
        ///
        /// <p>An array of objects that provides pre-aggregated values for a standard metric that applies to an application, campaign, or journey.</p>
        pub fn values(mut self, input: impl Into<crate::model::ResultRowValue>) -> Self {
            let mut v = self.values.unwrap_or_default();
            v.push(input.into());
            self.values = Some(v);
            self
        }
        /// <p>An array of objects that provides pre-aggregated values for a standard metric that applies to an application, campaign, or journey.</p>
        pub fn set_values(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResultRowValue>>,
        ) -> Self {
            self.values = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultRow`](crate::model::ResultRow)
        pub fn build(self) -> crate::model::ResultRow {
            crate::model::ResultRow {
                grouped_bys: self.grouped_bys,
                values: self.values,
            }
        }
    }
}
impl ResultRow {
    /// Creates a new builder-style object to manufacture [`ResultRow`](crate::model::ResultRow)
    pub fn builder() -> crate::model::result_row::Builder {
        crate::model::result_row::Builder::default()
    }
}

/// <p>Provides a single value and metadata about that value as part of an array of query results for a standard metric that applies to an application, campaign, or journey.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResultRowValue {
    /// <p>The friendly name of the metric whose value is specified by the Value property.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>The data type of the value specified by the Value property.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>In a Values object, the value for the metric that the query retrieved data for. In a GroupedBys object, the value for the field that was used to group data in a result set that contains multiple results (Values objects).</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResultRowValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResultRowValue");
        formatter.field("key", &self.key);
        formatter.field("r#type", &self.r#type);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ResultRowValue`](crate::model::ResultRowValue)
pub mod result_row_value {
    /// A builder for [`ResultRowValue`](crate::model::ResultRowValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The friendly name of the metric whose value is specified by the Value property.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The friendly name of the metric whose value is specified by the Value property.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The data type of the value specified by the Value property.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The data type of the value specified by the Value property.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>In a Values object, the value for the metric that the query retrieved data for. In a GroupedBys object, the value for the field that was used to group data in a result set that contains multiple results (Values objects).</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>In a Values object, the value for the metric that the query retrieved data for. In a GroupedBys object, the value for the field that was used to group data in a result set that contains multiple results (Values objects).</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ResultRowValue`](crate::model::ResultRowValue)
        pub fn build(self) -> crate::model::ResultRowValue {
            crate::model::ResultRowValue {
                key: self.key,
                r#type: self.r#type,
                value: self.value,
            }
        }
    }
}
impl ResultRowValue {
    /// Creates a new builder-style object to manufacture [`ResultRowValue`](crate::model::ResultRowValue)
    pub fn builder() -> crate::model::result_row_value::Builder {
        crate::model::result_row_value::Builder::default()
    }
}

/// <p>In-App Template Response.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InAppTemplateResponse {
    /// <p>The resource arn of the template.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The content of the message, can include up to 5 modals. Each modal must contain a message, a header, and background color. ImageUrl and buttons are optional.</p>
    pub content: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
    /// <p>The creation date of the template.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>Custom config to be sent to client.</p>
    pub custom_config:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The last modified date of the template.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The layout of the message.</p>
    pub layout: std::option::Option<crate::model::Layout>,
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The description of the template.</p>
    pub template_description: std::option::Option<std::string::String>,
    /// <p>The name of the template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The type of the template.</p>
    pub template_type: std::option::Option<crate::model::TemplateType>,
    /// <p>The version id of the template.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InAppTemplateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InAppTemplateResponse");
        formatter.field("arn", &self.arn);
        formatter.field("content", &self.content);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("custom_config", &self.custom_config);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("layout", &self.layout);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_type", &self.template_type);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`InAppTemplateResponse`](crate::model::InAppTemplateResponse)
pub mod in_app_template_response {
    /// A builder for [`InAppTemplateResponse`](crate::model::InAppTemplateResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) content: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) custom_config: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) layout: std::option::Option<crate::model::Layout>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_type: std::option::Option<crate::model::TemplateType>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The resource arn of the template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The resource arn of the template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Appends an item to `content`.
        ///
        /// To override the contents of this collection use [`set_content`](Self::set_content).
        ///
        /// <p>The content of the message, can include up to 5 modals. Each modal must contain a message, a header, and background color. ImageUrl and buttons are optional.</p>
        pub fn content(mut self, input: impl Into<crate::model::InAppMessageContent>) -> Self {
            let mut v = self.content.unwrap_or_default();
            v.push(input.into());
            self.content = Some(v);
            self
        }
        /// <p>The content of the message, can include up to 5 modals. Each modal must contain a message, a header, and background color. ImageUrl and buttons are optional.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
        ) -> Self {
            self.content = input;
            self
        }
        /// <p>The creation date of the template.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The creation date of the template.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// Adds a key-value pair to `custom_config`.
        ///
        /// To override the contents of this collection use [`set_custom_config`](Self::set_custom_config).
        ///
        /// <p>Custom config to be sent to client.</p>
        pub fn custom_config(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.custom_config.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.custom_config = Some(hash_map);
            self
        }
        /// <p>Custom config to be sent to client.</p>
        pub fn set_custom_config(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.custom_config = input;
            self
        }
        /// <p>The last modified date of the template.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The last modified date of the template.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The layout of the message.</p>
        pub fn layout(mut self, input: crate::model::Layout) -> Self {
            self.layout = Some(input);
            self
        }
        /// <p>The layout of the message.</p>
        pub fn set_layout(mut self, input: std::option::Option<crate::model::Layout>) -> Self {
            self.layout = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The description of the template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>The description of the template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// <p>The name of the template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The type of the template.</p>
        pub fn template_type(mut self, input: crate::model::TemplateType) -> Self {
            self.template_type = Some(input);
            self
        }
        /// <p>The type of the template.</p>
        pub fn set_template_type(
            mut self,
            input: std::option::Option<crate::model::TemplateType>,
        ) -> Self {
            self.template_type = input;
            self
        }
        /// <p>The version id of the template.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The version id of the template.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`InAppTemplateResponse`](crate::model::InAppTemplateResponse)
        pub fn build(self) -> crate::model::InAppTemplateResponse {
            crate::model::InAppTemplateResponse {
                arn: self.arn,
                content: self.content,
                creation_date: self.creation_date,
                custom_config: self.custom_config,
                last_modified_date: self.last_modified_date,
                layout: self.layout,
                tags: self.tags,
                template_description: self.template_description,
                template_name: self.template_name,
                template_type: self.template_type,
                version: self.version,
            }
        }
    }
}
impl InAppTemplateResponse {
    /// Creates a new builder-style object to manufacture [`InAppTemplateResponse`](crate::model::InAppTemplateResponse)
    pub fn builder() -> crate::model::in_app_template_response::Builder {
        crate::model::in_app_template_response::Builder::default()
    }
}

/// <p>Get in-app messages response object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InAppMessagesResponse {
    /// <p>List of targeted in-app message campaigns.</p>
    pub in_app_message_campaigns:
        std::option::Option<std::vec::Vec<crate::model::InAppMessageCampaign>>,
}
impl std::fmt::Debug for InAppMessagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InAppMessagesResponse");
        formatter.field("in_app_message_campaigns", &self.in_app_message_campaigns);
        formatter.finish()
    }
}
/// See [`InAppMessagesResponse`](crate::model::InAppMessagesResponse)
pub mod in_app_messages_response {
    /// A builder for [`InAppMessagesResponse`](crate::model::InAppMessagesResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) in_app_message_campaigns:
            std::option::Option<std::vec::Vec<crate::model::InAppMessageCampaign>>,
    }
    impl Builder {
        /// Appends an item to `in_app_message_campaigns`.
        ///
        /// To override the contents of this collection use [`set_in_app_message_campaigns`](Self::set_in_app_message_campaigns).
        ///
        /// <p>List of targeted in-app message campaigns.</p>
        pub fn in_app_message_campaigns(
            mut self,
            input: impl Into<crate::model::InAppMessageCampaign>,
        ) -> Self {
            let mut v = self.in_app_message_campaigns.unwrap_or_default();
            v.push(input.into());
            self.in_app_message_campaigns = Some(v);
            self
        }
        /// <p>List of targeted in-app message campaigns.</p>
        pub fn set_in_app_message_campaigns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InAppMessageCampaign>>,
        ) -> Self {
            self.in_app_message_campaigns = input;
            self
        }
        /// Consumes the builder and constructs a [`InAppMessagesResponse`](crate::model::InAppMessagesResponse)
        pub fn build(self) -> crate::model::InAppMessagesResponse {
            crate::model::InAppMessagesResponse {
                in_app_message_campaigns: self.in_app_message_campaigns,
            }
        }
    }
}
impl InAppMessagesResponse {
    /// Creates a new builder-style object to manufacture [`InAppMessagesResponse`](crate::model::InAppMessagesResponse)
    pub fn builder() -> crate::model::in_app_messages_response::Builder {
        crate::model::in_app_messages_response::Builder::default()
    }
}

/// <p>Targeted in-app message campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InAppMessageCampaign {
    /// <p>Campaign id of the corresponding campaign.</p>
    pub campaign_id: std::option::Option<std::string::String>,
    /// <p>Daily cap which controls the number of times any in-app messages can be shown to the endpoint during a day.</p>
    pub daily_cap: i32,
    /// <p>In-app message content with all fields required for rendering an in-app message.</p>
    pub in_app_message: std::option::Option<crate::model::InAppMessage>,
    /// <p>Priority of the in-app message.</p>
    pub priority: i32,
    /// <p>Schedule of the campaign.</p>
    pub schedule: std::option::Option<crate::model::InAppCampaignSchedule>,
    /// <p>Session cap which controls the number of times an in-app message can be shown to the endpoint during an application session.</p>
    pub session_cap: i32,
    /// <p>Total cap which controls the number of times an in-app message can be shown to the endpoint.</p>
    pub total_cap: i32,
    /// <p>Treatment id of the campaign.</p>
    pub treatment_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InAppMessageCampaign {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InAppMessageCampaign");
        formatter.field("campaign_id", &self.campaign_id);
        formatter.field("daily_cap", &self.daily_cap);
        formatter.field("in_app_message", &self.in_app_message);
        formatter.field("priority", &self.priority);
        formatter.field("schedule", &self.schedule);
        formatter.field("session_cap", &self.session_cap);
        formatter.field("total_cap", &self.total_cap);
        formatter.field("treatment_id", &self.treatment_id);
        formatter.finish()
    }
}
/// See [`InAppMessageCampaign`](crate::model::InAppMessageCampaign)
pub mod in_app_message_campaign {
    /// A builder for [`InAppMessageCampaign`](crate::model::InAppMessageCampaign)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) campaign_id: std::option::Option<std::string::String>,
        pub(crate) daily_cap: std::option::Option<i32>,
        pub(crate) in_app_message: std::option::Option<crate::model::InAppMessage>,
        pub(crate) priority: std::option::Option<i32>,
        pub(crate) schedule: std::option::Option<crate::model::InAppCampaignSchedule>,
        pub(crate) session_cap: std::option::Option<i32>,
        pub(crate) total_cap: std::option::Option<i32>,
        pub(crate) treatment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Campaign id of the corresponding campaign.</p>
        pub fn campaign_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.campaign_id = Some(input.into());
            self
        }
        /// <p>Campaign id of the corresponding campaign.</p>
        pub fn set_campaign_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.campaign_id = input;
            self
        }
        /// <p>Daily cap which controls the number of times any in-app messages can be shown to the endpoint during a day.</p>
        pub fn daily_cap(mut self, input: i32) -> Self {
            self.daily_cap = Some(input);
            self
        }
        /// <p>Daily cap which controls the number of times any in-app messages can be shown to the endpoint during a day.</p>
        pub fn set_daily_cap(mut self, input: std::option::Option<i32>) -> Self {
            self.daily_cap = input;
            self
        }
        /// <p>In-app message content with all fields required for rendering an in-app message.</p>
        pub fn in_app_message(mut self, input: crate::model::InAppMessage) -> Self {
            self.in_app_message = Some(input);
            self
        }
        /// <p>In-app message content with all fields required for rendering an in-app message.</p>
        pub fn set_in_app_message(
            mut self,
            input: std::option::Option<crate::model::InAppMessage>,
        ) -> Self {
            self.in_app_message = input;
            self
        }
        /// <p>Priority of the in-app message.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.priority = Some(input);
            self
        }
        /// <p>Priority of the in-app message.</p>
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.priority = input;
            self
        }
        /// <p>Schedule of the campaign.</p>
        pub fn schedule(mut self, input: crate::model::InAppCampaignSchedule) -> Self {
            self.schedule = Some(input);
            self
        }
        /// <p>Schedule of the campaign.</p>
        pub fn set_schedule(
            mut self,
            input: std::option::Option<crate::model::InAppCampaignSchedule>,
        ) -> Self {
            self.schedule = input;
            self
        }
        /// <p>Session cap which controls the number of times an in-app message can be shown to the endpoint during an application session.</p>
        pub fn session_cap(mut self, input: i32) -> Self {
            self.session_cap = Some(input);
            self
        }
        /// <p>Session cap which controls the number of times an in-app message can be shown to the endpoint during an application session.</p>
        pub fn set_session_cap(mut self, input: std::option::Option<i32>) -> Self {
            self.session_cap = input;
            self
        }
        /// <p>Total cap which controls the number of times an in-app message can be shown to the endpoint.</p>
        pub fn total_cap(mut self, input: i32) -> Self {
            self.total_cap = Some(input);
            self
        }
        /// <p>Total cap which controls the number of times an in-app message can be shown to the endpoint.</p>
        pub fn set_total_cap(mut self, input: std::option::Option<i32>) -> Self {
            self.total_cap = input;
            self
        }
        /// <p>Treatment id of the campaign.</p>
        pub fn treatment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.treatment_id = Some(input.into());
            self
        }
        /// <p>Treatment id of the campaign.</p>
        pub fn set_treatment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.treatment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`InAppMessageCampaign`](crate::model::InAppMessageCampaign)
        pub fn build(self) -> crate::model::InAppMessageCampaign {
            crate::model::InAppMessageCampaign {
                campaign_id: self.campaign_id,
                daily_cap: self.daily_cap.unwrap_or_default(),
                in_app_message: self.in_app_message,
                priority: self.priority.unwrap_or_default(),
                schedule: self.schedule,
                session_cap: self.session_cap.unwrap_or_default(),
                total_cap: self.total_cap.unwrap_or_default(),
                treatment_id: self.treatment_id,
            }
        }
    }
}
impl InAppMessageCampaign {
    /// Creates a new builder-style object to manufacture [`InAppMessageCampaign`](crate::model::InAppMessageCampaign)
    pub fn builder() -> crate::model::in_app_message_campaign::Builder {
        crate::model::in_app_message_campaign::Builder::default()
    }
}

/// <p>Schedule of the campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InAppCampaignSchedule {
    /// <p>The scheduled time after which the in-app message should not be shown. Timestamp is in ISO 8601 format.</p>
    pub end_date: std::option::Option<std::string::String>,
    /// <p>The event filter the SDK has to use to show the in-app message in the application.</p>
    pub event_filter: std::option::Option<crate::model::CampaignEventFilter>,
    /// <p>Time during which the in-app message should not be shown to the user.</p>
    pub quiet_time: std::option::Option<crate::model::QuietTime>,
}
impl std::fmt::Debug for InAppCampaignSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InAppCampaignSchedule");
        formatter.field("end_date", &self.end_date);
        formatter.field("event_filter", &self.event_filter);
        formatter.field("quiet_time", &self.quiet_time);
        formatter.finish()
    }
}
/// See [`InAppCampaignSchedule`](crate::model::InAppCampaignSchedule)
pub mod in_app_campaign_schedule {
    /// A builder for [`InAppCampaignSchedule`](crate::model::InAppCampaignSchedule)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) end_date: std::option::Option<std::string::String>,
        pub(crate) event_filter: std::option::Option<crate::model::CampaignEventFilter>,
        pub(crate) quiet_time: std::option::Option<crate::model::QuietTime>,
    }
    impl Builder {
        /// <p>The scheduled time after which the in-app message should not be shown. Timestamp is in ISO 8601 format.</p>
        pub fn end_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.end_date = Some(input.into());
            self
        }
        /// <p>The scheduled time after which the in-app message should not be shown. Timestamp is in ISO 8601 format.</p>
        pub fn set_end_date(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end_date = input;
            self
        }
        /// <p>The event filter the SDK has to use to show the in-app message in the application.</p>
        pub fn event_filter(mut self, input: crate::model::CampaignEventFilter) -> Self {
            self.event_filter = Some(input);
            self
        }
        /// <p>The event filter the SDK has to use to show the in-app message in the application.</p>
        pub fn set_event_filter(
            mut self,
            input: std::option::Option<crate::model::CampaignEventFilter>,
        ) -> Self {
            self.event_filter = input;
            self
        }
        /// <p>Time during which the in-app message should not be shown to the user.</p>
        pub fn quiet_time(mut self, input: crate::model::QuietTime) -> Self {
            self.quiet_time = Some(input);
            self
        }
        /// <p>Time during which the in-app message should not be shown to the user.</p>
        pub fn set_quiet_time(
            mut self,
            input: std::option::Option<crate::model::QuietTime>,
        ) -> Self {
            self.quiet_time = input;
            self
        }
        /// Consumes the builder and constructs a [`InAppCampaignSchedule`](crate::model::InAppCampaignSchedule)
        pub fn build(self) -> crate::model::InAppCampaignSchedule {
            crate::model::InAppCampaignSchedule {
                end_date: self.end_date,
                event_filter: self.event_filter,
                quiet_time: self.quiet_time,
            }
        }
    }
}
impl InAppCampaignSchedule {
    /// Creates a new builder-style object to manufacture [`InAppCampaignSchedule`](crate::model::InAppCampaignSchedule)
    pub fn builder() -> crate::model::in_app_campaign_schedule::Builder {
        crate::model::in_app_campaign_schedule::Builder::default()
    }
}

/// <p>Provides all fields required for building an in-app message.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InAppMessage {
    /// <p>In-app message content.</p>
    pub content: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
    /// <p>Custom config to be sent to SDK.</p>
    pub custom_config:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The layout of the message.</p>
    pub layout: std::option::Option<crate::model::Layout>,
}
impl std::fmt::Debug for InAppMessage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InAppMessage");
        formatter.field("content", &self.content);
        formatter.field("custom_config", &self.custom_config);
        formatter.field("layout", &self.layout);
        formatter.finish()
    }
}
/// See [`InAppMessage`](crate::model::InAppMessage)
pub mod in_app_message {
    /// A builder for [`InAppMessage`](crate::model::InAppMessage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
        pub(crate) custom_config: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) layout: std::option::Option<crate::model::Layout>,
    }
    impl Builder {
        /// Appends an item to `content`.
        ///
        /// To override the contents of this collection use [`set_content`](Self::set_content).
        ///
        /// <p>In-app message content.</p>
        pub fn content(mut self, input: impl Into<crate::model::InAppMessageContent>) -> Self {
            let mut v = self.content.unwrap_or_default();
            v.push(input.into());
            self.content = Some(v);
            self
        }
        /// <p>In-app message content.</p>
        pub fn set_content(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InAppMessageContent>>,
        ) -> Self {
            self.content = input;
            self
        }
        /// Adds a key-value pair to `custom_config`.
        ///
        /// To override the contents of this collection use [`set_custom_config`](Self::set_custom_config).
        ///
        /// <p>Custom config to be sent to SDK.</p>
        pub fn custom_config(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.custom_config.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.custom_config = Some(hash_map);
            self
        }
        /// <p>Custom config to be sent to SDK.</p>
        pub fn set_custom_config(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.custom_config = input;
            self
        }
        /// <p>The layout of the message.</p>
        pub fn layout(mut self, input: crate::model::Layout) -> Self {
            self.layout = Some(input);
            self
        }
        /// <p>The layout of the message.</p>
        pub fn set_layout(mut self, input: std::option::Option<crate::model::Layout>) -> Self {
            self.layout = input;
            self
        }
        /// Consumes the builder and constructs a [`InAppMessage`](crate::model::InAppMessage)
        pub fn build(self) -> crate::model::InAppMessage {
            crate::model::InAppMessage {
                content: self.content,
                custom_config: self.custom_config,
                layout: self.layout,
            }
        }
    }
}
impl InAppMessage {
    /// Creates a new builder-style object to manufacture [`InAppMessage`](crate::model::InAppMessage)
    pub fn builder() -> crate::model::in_app_message::Builder {
        crate::model::in_app_message::Builder::default()
    }
}

/// <p>Provides information about the content and settings for a message template that can be used in messages that are sent through the email channel.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EmailTemplateResponse {
    /// <p>The Amazon Resource Name (ARN) of the message template.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the message template was created.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
    pub default_substitutions: std::option::Option<std::string::String>,
    /// <p>The message body, in HTML format, that's used in email messages that are based on the message template.</p>
    pub html_part: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the recommender model that's used by the message template.</p>
    pub recommender_id: std::option::Option<std::string::String>,
    /// <p>The subject line, or title, that's used in email messages that are based on the message template.</p>
    pub subject: std::option::Option<std::string::String>,
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The custom description of the message template.</p>
    pub template_description: std::option::Option<std::string::String>,
    /// <p>The name of the message template.</p>
    pub template_name: std::option::Option<std::string::String>,
    /// <p>The type of channel that the message template is designed for. For an email template, this value is EMAIL.</p>
    pub template_type: std::option::Option<crate::model::TemplateType>,
    /// <p>The message body, in plain text format, that's used in email messages that are based on the message template.</p>
    pub text_part: std::option::Option<std::string::String>,
    /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
    pub version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EmailTemplateResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EmailTemplateResponse");
        formatter.field("arn", &self.arn);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("default_substitutions", &self.default_substitutions);
        formatter.field("html_part", &self.html_part);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("recommender_id", &self.recommender_id);
        formatter.field("subject", &self.subject);
        formatter.field("tags", &self.tags);
        formatter.field("template_description", &self.template_description);
        formatter.field("template_name", &self.template_name);
        formatter.field("template_type", &self.template_type);
        formatter.field("text_part", &self.text_part);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`EmailTemplateResponse`](crate::model::EmailTemplateResponse)
pub mod email_template_response {
    /// A builder for [`EmailTemplateResponse`](crate::model::EmailTemplateResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) default_substitutions: std::option::Option<std::string::String>,
        pub(crate) html_part: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) recommender_id: std::option::Option<std::string::String>,
        pub(crate) subject: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) template_description: std::option::Option<std::string::String>,
        pub(crate) template_name: std::option::Option<std::string::String>,
        pub(crate) template_type: std::option::Option<crate::model::TemplateType>,
        pub(crate) text_part: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the message template.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the message template.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was created.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
        pub fn default_substitutions(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_substitutions = Some(input.into());
            self
        }
        /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
        pub fn set_default_substitutions(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.default_substitutions = input;
            self
        }
        /// <p>The message body, in HTML format, that's used in email messages that are based on the message template.</p>
        pub fn html_part(mut self, input: impl Into<std::string::String>) -> Self {
            self.html_part = Some(input.into());
            self
        }
        /// <p>The message body, in HTML format, that's used in email messages that are based on the message template.</p>
        pub fn set_html_part(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.html_part = input;
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The unique identifier for the recommender model that's used by the message template.</p>
        pub fn recommender_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.recommender_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the recommender model that's used by the message template.</p>
        pub fn set_recommender_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommender_id = input;
            self
        }
        /// <p>The subject line, or title, that's used in email messages that are based on the message template.</p>
        pub fn subject(mut self, input: impl Into<std::string::String>) -> Self {
            self.subject = Some(input.into());
            self
        }
        /// <p>The subject line, or title, that's used in email messages that are based on the message template.</p>
        pub fn set_subject(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subject = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The custom description of the message template.</p>
        pub fn template_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_description = Some(input.into());
            self
        }
        /// <p>The custom description of the message template.</p>
        pub fn set_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_description = input;
            self
        }
        /// <p>The name of the message template.</p>
        pub fn template_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.template_name = Some(input.into());
            self
        }
        /// <p>The name of the message template.</p>
        pub fn set_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.template_name = input;
            self
        }
        /// <p>The type of channel that the message template is designed for. For an email template, this value is EMAIL.</p>
        pub fn template_type(mut self, input: crate::model::TemplateType) -> Self {
            self.template_type = Some(input);
            self
        }
        /// <p>The type of channel that the message template is designed for. For an email template, this value is EMAIL.</p>
        pub fn set_template_type(
            mut self,
            input: std::option::Option<crate::model::TemplateType>,
        ) -> Self {
            self.template_type = input;
            self
        }
        /// <p>The message body, in plain text format, that's used in email messages that are based on the message template.</p>
        pub fn text_part(mut self, input: impl Into<std::string::String>) -> Self {
            self.text_part = Some(input.into());
            self
        }
        /// <p>The message body, in plain text format, that's used in email messages that are based on the message template.</p>
        pub fn set_text_part(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.text_part = input;
            self
        }
        /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
        pub fn version(mut self, input: impl Into<std::string::String>) -> Self {
            self.version = Some(input.into());
            self
        }
        /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
        pub fn set_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`EmailTemplateResponse`](crate::model::EmailTemplateResponse)
        pub fn build(self) -> crate::model::EmailTemplateResponse {
            crate::model::EmailTemplateResponse {
                arn: self.arn,
                creation_date: self.creation_date,
                default_substitutions: self.default_substitutions,
                html_part: self.html_part,
                last_modified_date: self.last_modified_date,
                recommender_id: self.recommender_id,
                subject: self.subject,
                tags: self.tags,
                template_description: self.template_description,
                template_name: self.template_name,
                template_type: self.template_type,
                text_part: self.text_part,
                version: self.version,
            }
        }
    }
}
impl EmailTemplateResponse {
    /// Creates a new builder-style object to manufacture [`EmailTemplateResponse`](crate::model::EmailTemplateResponse)
    pub fn builder() -> crate::model::email_template_response::Builder {
        crate::model::email_template_response::Builder::default()
    }
}

/// <p>Provides information about the general settings and status of all channels for an application, including channels that aren't enabled for the application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChannelsResponse {
    /// <p>A map that contains a multipart response for each channel. For each item in this object, the ChannelType is the key and the Channel is the value.</p>
    pub channels: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::ChannelResponse>,
    >,
}
impl std::fmt::Debug for ChannelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChannelsResponse");
        formatter.field("channels", &self.channels);
        formatter.finish()
    }
}
/// See [`ChannelsResponse`](crate::model::ChannelsResponse)
pub mod channels_response {
    /// A builder for [`ChannelsResponse`](crate::model::ChannelsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) channels: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::ChannelResponse>,
        >,
    }
    impl Builder {
        /// Adds a key-value pair to `channels`.
        ///
        /// To override the contents of this collection use [`set_channels`](Self::set_channels).
        ///
        /// <p>A map that contains a multipart response for each channel. For each item in this object, the ChannelType is the key and the Channel is the value.</p>
        pub fn channels(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<crate::model::ChannelResponse>,
        ) -> Self {
            let mut hash_map = self.channels.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.channels = Some(hash_map);
            self
        }
        /// <p>A map that contains a multipart response for each channel. For each item in this object, the ChannelType is the key and the Channel is the value.</p>
        pub fn set_channels(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::ChannelResponse>,
            >,
        ) -> Self {
            self.channels = input;
            self
        }
        /// Consumes the builder and constructs a [`ChannelsResponse`](crate::model::ChannelsResponse)
        pub fn build(self) -> crate::model::ChannelsResponse {
            crate::model::ChannelsResponse {
                channels: self.channels,
            }
        }
    }
}
impl ChannelsResponse {
    /// Creates a new builder-style object to manufacture [`ChannelsResponse`](crate::model::ChannelsResponse)
    pub fn builder() -> crate::model::channels_response::Builder {
        crate::model::channels_response::Builder::default()
    }
}

/// <p>Provides information about the general settings and status of a channel for an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ChannelResponse {
    /// <p>The unique identifier for the application.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when the channel was enabled.</p>
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>Specifies whether the channel is enabled for the application.</p>
    pub enabled: bool,
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    pub has_credential: bool,
    /// <p>(Deprecated) An identifier for the channel. This property is retained only for backward compatibility.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the channel is archived.</p>
    pub is_archived: bool,
    /// <p>The user who last modified the channel.</p>
    pub last_modified_by: std::option::Option<std::string::String>,
    /// <p>The date and time, in ISO 8601 format, when the channel was last modified.</p>
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The current version of the channel.</p>
    pub version: i32,
}
impl std::fmt::Debug for ChannelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ChannelResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("creation_date", &self.creation_date);
        formatter.field("enabled", &self.enabled);
        formatter.field("has_credential", &self.has_credential);
        formatter.field("id", &self.id);
        formatter.field("is_archived", &self.is_archived);
        formatter.field("last_modified_by", &self.last_modified_by);
        formatter.field("last_modified_date", &self.last_modified_date);
        formatter.field("version", &self.version);
        formatter.finish()
    }
}
/// See [`ChannelResponse`](crate::model::ChannelResponse)
pub mod channel_response {
    /// A builder for [`ChannelResponse`](crate::model::ChannelResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) creation_date: std::option::Option<std::string::String>,
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) has_credential: std::option::Option<bool>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) is_archived: std::option::Option<bool>,
        pub(crate) last_modified_by: std::option::Option<std::string::String>,
        pub(crate) last_modified_date: std::option::Option<std::string::String>,
        pub(crate) version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The unique identifier for the application.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the channel was enabled.</p>
        pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.creation_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the channel was enabled.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>Specifies whether the channel is enabled for the application.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Specifies whether the channel is enabled for the application.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn has_credential(mut self, input: bool) -> Self {
            self.has_credential = Some(input);
            self
        }
        /// <p>(Not used) This property is retained only for backward compatibility.</p>
        pub fn set_has_credential(mut self, input: std::option::Option<bool>) -> Self {
            self.has_credential = input;
            self
        }
        /// <p>(Deprecated) An identifier for the channel. This property is retained only for backward compatibility.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>(Deprecated) An identifier for the channel. This property is retained only for backward compatibility.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the channel is archived.</p>
        pub fn is_archived(mut self, input: bool) -> Self {
            self.is_archived = Some(input);
            self
        }
        /// <p>Specifies whether the channel is archived.</p>
        pub fn set_is_archived(mut self, input: std::option::Option<bool>) -> Self {
            self.is_archived = input;
            self
        }
        /// <p>The user who last modified the channel.</p>
        pub fn last_modified_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_by = Some(input.into());
            self
        }
        /// <p>The user who last modified the channel.</p>
        pub fn set_last_modified_by(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_by = input;
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the channel was last modified.</p>
        pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_modified_date = Some(input.into());
            self
        }
        /// <p>The date and time, in ISO 8601 format, when the channel was last modified.</p>
        pub fn set_last_modified_date(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_modified_date = input;
            self
        }
        /// <p>The current version of the channel.</p>
        pub fn version(mut self, input: i32) -> Self {
            self.version = Some(input);
            self
        }
        /// <p>The current version of the channel.</p>
        pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
            self.version = input;
            self
        }
        /// Consumes the builder and constructs a [`ChannelResponse`](crate::model::ChannelResponse)
        pub fn build(self) -> crate::model::ChannelResponse {
            crate::model::ChannelResponse {
                application_id: self.application_id,
                creation_date: self.creation_date,
                enabled: self.enabled.unwrap_or_default(),
                has_credential: self.has_credential.unwrap_or_default(),
                id: self.id,
                is_archived: self.is_archived.unwrap_or_default(),
                last_modified_by: self.last_modified_by,
                last_modified_date: self.last_modified_date,
                version: self.version.unwrap_or_default(),
            }
        }
    }
}
impl ChannelResponse {
    /// Creates a new builder-style object to manufacture [`ChannelResponse`](crate::model::ChannelResponse)
    pub fn builder() -> crate::model::channel_response::Builder {
        crate::model::channel_response::Builder::default()
    }
}

/// <p>Provides information about the configuration and other settings for all the campaigns that are associated with an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignsResponse {
    /// <p>An array of responses, one for each campaign that's associated with the application.</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::CampaignResponse>>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CampaignsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignsResponse");
        formatter.field("item", &self.item);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`CampaignsResponse`](crate::model::CampaignsResponse)
pub mod campaigns_response {
    /// A builder for [`CampaignsResponse`](crate::model::CampaignsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::CampaignResponse>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each campaign that's associated with the application.</p>
        pub fn item(mut self, input: impl Into<crate::model::CampaignResponse>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each campaign that's associated with the application.</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CampaignResponse>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignsResponse`](crate::model::CampaignsResponse)
        pub fn build(self) -> crate::model::CampaignsResponse {
            crate::model::CampaignsResponse {
                item: self.item,
                next_token: self.next_token,
            }
        }
    }
}
impl CampaignsResponse {
    /// Creates a new builder-style object to manufacture [`CampaignsResponse`](crate::model::CampaignsResponse)
    pub fn builder() -> crate::model::campaigns_response::Builder {
        crate::model::campaigns_response::Builder::default()
    }
}

/// <p>Provides the results of a query that retrieved the data for a standard metric that applies to a campaign, and provides information about that query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CampaignDateRangeKpiResponse {
    /// <p>The unique identifier for the application that the metric applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the campaign that the metric applies to.</p>
    pub campaign_id: std::option::Option<std::string::String>,
    /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    pub kpi_name: std::option::Option<std::string::String>,
    /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
    pub kpi_result: std::option::Option<crate::model::BaseKpiResult>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Campaign Metrics resource because the resource returns all results in a single page.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for CampaignDateRangeKpiResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CampaignDateRangeKpiResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("campaign_id", &self.campaign_id);
        formatter.field("end_time", &self.end_time);
        formatter.field("kpi_name", &self.kpi_name);
        formatter.field("kpi_result", &self.kpi_result);
        formatter.field("next_token", &self.next_token);
        formatter.field("start_time", &self.start_time);
        formatter.finish()
    }
}
/// See [`CampaignDateRangeKpiResponse`](crate::model::CampaignDateRangeKpiResponse)
pub mod campaign_date_range_kpi_response {
    /// A builder for [`CampaignDateRangeKpiResponse`](crate::model::CampaignDateRangeKpiResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) campaign_id: std::option::Option<std::string::String>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) kpi_name: std::option::Option<std::string::String>,
        pub(crate) kpi_result: std::option::Option<crate::model::BaseKpiResult>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the metric applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the metric applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The unique identifier for the campaign that the metric applies to.</p>
        pub fn campaign_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.campaign_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the campaign that the metric applies to.</p>
        pub fn set_campaign_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.campaign_id = input;
            self
        }
        /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
        pub fn kpi_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.kpi_name = Some(input.into());
            self
        }
        /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
        pub fn set_kpi_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kpi_name = input;
            self
        }
        /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
        pub fn kpi_result(mut self, input: crate::model::BaseKpiResult) -> Self {
            self.kpi_result = Some(input);
            self
        }
        /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
        pub fn set_kpi_result(
            mut self,
            input: std::option::Option<crate::model::BaseKpiResult>,
        ) -> Self {
            self.kpi_result = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Campaign Metrics resource because the resource returns all results in a single page.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Campaign Metrics resource because the resource returns all results in a single page.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`CampaignDateRangeKpiResponse`](crate::model::CampaignDateRangeKpiResponse)
        pub fn build(self) -> crate::model::CampaignDateRangeKpiResponse {
            crate::model::CampaignDateRangeKpiResponse {
                application_id: self.application_id,
                campaign_id: self.campaign_id,
                end_time: self.end_time,
                kpi_name: self.kpi_name,
                kpi_result: self.kpi_result,
                next_token: self.next_token,
                start_time: self.start_time,
            }
        }
    }
}
impl CampaignDateRangeKpiResponse {
    /// Creates a new builder-style object to manufacture [`CampaignDateRangeKpiResponse`](crate::model::CampaignDateRangeKpiResponse)
    pub fn builder() -> crate::model::campaign_date_range_kpi_response::Builder {
        crate::model::campaign_date_range_kpi_response::Builder::default()
    }
}

/// <p>Provides information about the activities that were performed by a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActivitiesResponse {
    /// <p>An array of responses, one for each activity that was performed by the campaign.</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::ActivityResponse>>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ActivitiesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActivitiesResponse");
        formatter.field("item", &self.item);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ActivitiesResponse`](crate::model::ActivitiesResponse)
pub mod activities_response {
    /// A builder for [`ActivitiesResponse`](crate::model::ActivitiesResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::ActivityResponse>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each activity that was performed by the campaign.</p>
        pub fn item(mut self, input: impl Into<crate::model::ActivityResponse>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each activity that was performed by the campaign.</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ActivityResponse>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ActivitiesResponse`](crate::model::ActivitiesResponse)
        pub fn build(self) -> crate::model::ActivitiesResponse {
            crate::model::ActivitiesResponse {
                item: self.item,
                next_token: self.next_token,
            }
        }
    }
}
impl ActivitiesResponse {
    /// Creates a new builder-style object to manufacture [`ActivitiesResponse`](crate::model::ActivitiesResponse)
    pub fn builder() -> crate::model::activities_response::Builder {
        crate::model::activities_response::Builder::default()
    }
}

/// <p>Provides information about an activity that was performed by a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActivityResponse {
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    pub campaign_id: std::option::Option<std::string::String>,
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    pub end: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the activity.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    pub result: std::option::Option<std::string::String>,
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    pub scheduled_start: std::option::Option<std::string::String>,
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    pub start: std::option::Option<std::string::String>,
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    pub state: std::option::Option<std::string::String>,
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    pub successful_endpoint_count: i32,
    /// <p>The total number of time zones that were completed.</p>
    pub timezones_completed_count: i32,
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    pub timezones_total_count: i32,
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    pub total_endpoint_count: i32,
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    pub treatment_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ActivityResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActivityResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("campaign_id", &self.campaign_id);
        formatter.field("end", &self.end);
        formatter.field("id", &self.id);
        formatter.field("result", &self.result);
        formatter.field("scheduled_start", &self.scheduled_start);
        formatter.field("start", &self.start);
        formatter.field("state", &self.state);
        formatter.field("successful_endpoint_count", &self.successful_endpoint_count);
        formatter.field("timezones_completed_count", &self.timezones_completed_count);
        formatter.field("timezones_total_count", &self.timezones_total_count);
        formatter.field("total_endpoint_count", &self.total_endpoint_count);
        formatter.field("treatment_id", &self.treatment_id);
        formatter.finish()
    }
}
/// See [`ActivityResponse`](crate::model::ActivityResponse)
pub mod activity_response {
    /// A builder for [`ActivityResponse`](crate::model::ActivityResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) campaign_id: std::option::Option<std::string::String>,
        pub(crate) end: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) result: std::option::Option<std::string::String>,
        pub(crate) scheduled_start: std::option::Option<std::string::String>,
        pub(crate) start: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<std::string::String>,
        pub(crate) successful_endpoint_count: std::option::Option<i32>,
        pub(crate) timezones_completed_count: std::option::Option<i32>,
        pub(crate) timezones_total_count: std::option::Option<i32>,
        pub(crate) total_endpoint_count: std::option::Option<i32>,
        pub(crate) treatment_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the campaign applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the campaign applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The unique identifier for the campaign that the activity applies to.</p>
        pub fn campaign_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.campaign_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the campaign that the activity applies to.</p>
        pub fn set_campaign_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.campaign_id = input;
            self
        }
        /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
        pub fn end(mut self, input: impl Into<std::string::String>) -> Self {
            self.end = Some(input.into());
            self
        }
        /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
        pub fn set_end(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.end = input;
            self
        }
        /// <p>The unique identifier for the activity.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the activity.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
        pub fn result(mut self, input: impl Into<std::string::String>) -> Self {
            self.result = Some(input.into());
            self
        }
        /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
        pub fn set_result(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.result = input;
            self
        }
        /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
        pub fn scheduled_start(mut self, input: impl Into<std::string::String>) -> Self {
            self.scheduled_start = Some(input.into());
            self
        }
        /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
        pub fn set_scheduled_start(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.scheduled_start = input;
            self
        }
        /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
        pub fn start(mut self, input: impl Into<std::string::String>) -> Self {
            self.start = Some(input.into());
            self
        }
        /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
        pub fn set_start(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.start = input;
            self
        }
        /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
        pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
            self.state = Some(input.into());
            self
        }
        /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
        pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.state = input;
            self
        }
        /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
        pub fn successful_endpoint_count(mut self, input: i32) -> Self {
            self.successful_endpoint_count = Some(input);
            self
        }
        /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
        pub fn set_successful_endpoint_count(mut self, input: std::option::Option<i32>) -> Self {
            self.successful_endpoint_count = input;
            self
        }
        /// <p>The total number of time zones that were completed.</p>
        pub fn timezones_completed_count(mut self, input: i32) -> Self {
            self.timezones_completed_count = Some(input);
            self
        }
        /// <p>The total number of time zones that were completed.</p>
        pub fn set_timezones_completed_count(mut self, input: std::option::Option<i32>) -> Self {
            self.timezones_completed_count = input;
            self
        }
        /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
        pub fn timezones_total_count(mut self, input: i32) -> Self {
            self.timezones_total_count = Some(input);
            self
        }
        /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
        pub fn set_timezones_total_count(mut self, input: std::option::Option<i32>) -> Self {
            self.timezones_total_count = input;
            self
        }
        /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
        pub fn total_endpoint_count(mut self, input: i32) -> Self {
            self.total_endpoint_count = Some(input);
            self
        }
        /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
        pub fn set_total_endpoint_count(mut self, input: std::option::Option<i32>) -> Self {
            self.total_endpoint_count = input;
            self
        }
        /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
        pub fn treatment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.treatment_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
        pub fn set_treatment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.treatment_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ActivityResponse`](crate::model::ActivityResponse)
        pub fn build(self) -> crate::model::ActivityResponse {
            crate::model::ActivityResponse {
                application_id: self.application_id,
                campaign_id: self.campaign_id,
                end: self.end,
                id: self.id,
                result: self.result,
                scheduled_start: self.scheduled_start,
                start: self.start,
                state: self.state,
                successful_endpoint_count: self.successful_endpoint_count.unwrap_or_default(),
                timezones_completed_count: self.timezones_completed_count.unwrap_or_default(),
                timezones_total_count: self.timezones_total_count.unwrap_or_default(),
                total_endpoint_count: self.total_endpoint_count.unwrap_or_default(),
                treatment_id: self.treatment_id,
            }
        }
    }
}
impl ActivityResponse {
    /// Creates a new builder-style object to manufacture [`ActivityResponse`](crate::model::ActivityResponse)
    pub fn builder() -> crate::model::activity_response::Builder {
        crate::model::activity_response::Builder::default()
    }
}

/// <p>Provides information about all of your applications.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationsResponse {
    /// <p>An array of responses, one for each application that was returned.</p>
    pub item: std::option::Option<std::vec::Vec<crate::model::ApplicationResponse>>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApplicationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationsResponse");
        formatter.field("item", &self.item);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ApplicationsResponse`](crate::model::ApplicationsResponse)
pub mod applications_response {
    /// A builder for [`ApplicationsResponse`](crate::model::ApplicationsResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item: std::option::Option<std::vec::Vec<crate::model::ApplicationResponse>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `item`.
        ///
        /// To override the contents of this collection use [`set_item`](Self::set_item).
        ///
        /// <p>An array of responses, one for each application that was returned.</p>
        pub fn item(mut self, input: impl Into<crate::model::ApplicationResponse>) -> Self {
            let mut v = self.item.unwrap_or_default();
            v.push(input.into());
            self.item = Some(v);
            self
        }
        /// <p>An array of responses, one for each application that was returned.</p>
        pub fn set_item(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ApplicationResponse>>,
        ) -> Self {
            self.item = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationsResponse`](crate::model::ApplicationsResponse)
        pub fn build(self) -> crate::model::ApplicationsResponse {
            crate::model::ApplicationsResponse {
                item: self.item,
                next_token: self.next_token,
            }
        }
    }
}
impl ApplicationsResponse {
    /// Creates a new builder-style object to manufacture [`ApplicationsResponse`](crate::model::ApplicationsResponse)
    pub fn builder() -> crate::model::applications_response::Builder {
        crate::model::applications_response::Builder::default()
    }
}

/// <p>Provides information about an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationResponse {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The display name of the application. This name is displayed as the <b>Project name</b> on the Amazon Pinpoint console.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the application. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for ApplicationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationResponse");
        formatter.field("arn", &self.arn);
        formatter.field("id", &self.id);
        formatter.field("name", &self.name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`ApplicationResponse`](crate::model::ApplicationResponse)
pub mod application_response {
    /// A builder for [`ApplicationResponse`](crate::model::ApplicationResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the application.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the application.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The display name of the application. This name is displayed as the <b>Project name</b> on the Amazon Pinpoint console.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The display name of the application. This name is displayed as the <b>Project name</b> on the Amazon Pinpoint console.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the application. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the application. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationResponse`](crate::model::ApplicationResponse)
        pub fn build(self) -> crate::model::ApplicationResponse {
            crate::model::ApplicationResponse {
                arn: self.arn,
                id: self.id,
                name: self.name,
                tags: self.tags,
            }
        }
    }
}
impl ApplicationResponse {
    /// Creates a new builder-style object to manufacture [`ApplicationResponse`](crate::model::ApplicationResponse)
    pub fn builder() -> crate::model::application_response::Builder {
        crate::model::application_response::Builder::default()
    }
}

/// <p>Provides the results of a query that retrieved the data for a standard metric that applies to an application, and provides information about that query.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationDateRangeKpiResponse {
    /// <p>The unique identifier for the application that the metric applies to.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    pub end_time: std::option::Option<aws_smithy_types::Instant>,
    /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    pub kpi_name: std::option::Option<std::string::String>,
    /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
    pub kpi_result: std::option::Option<crate::model::BaseKpiResult>,
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Application Metrics resource because the resource returns all results in a single page.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    pub start_time: std::option::Option<aws_smithy_types::Instant>,
}
impl std::fmt::Debug for ApplicationDateRangeKpiResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationDateRangeKpiResponse");
        formatter.field("application_id", &self.application_id);
        formatter.field("end_time", &self.end_time);
        formatter.field("kpi_name", &self.kpi_name);
        formatter.field("kpi_result", &self.kpi_result);
        formatter.field("next_token", &self.next_token);
        formatter.field("start_time", &self.start_time);
        formatter.finish()
    }
}
/// See [`ApplicationDateRangeKpiResponse`](crate::model::ApplicationDateRangeKpiResponse)
pub mod application_date_range_kpi_response {
    /// A builder for [`ApplicationDateRangeKpiResponse`](crate::model::ApplicationDateRangeKpiResponse)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) end_time: std::option::Option<aws_smithy_types::Instant>,
        pub(crate) kpi_name: std::option::Option<std::string::String>,
        pub(crate) kpi_result: std::option::Option<crate::model::BaseKpiResult>,
        pub(crate) next_token: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The unique identifier for the application that the metric applies to.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the application that the metric applies to.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn end_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.end_time = Some(input);
            self
        }
        /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn set_end_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.end_time = input;
            self
        }
        /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
        pub fn kpi_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.kpi_name = Some(input.into());
            self
        }
        /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
        pub fn set_kpi_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.kpi_name = input;
            self
        }
        /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
        pub fn kpi_result(mut self, input: crate::model::BaseKpiResult) -> Self {
            self.kpi_result = Some(input);
            self
        }
        /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
        pub fn set_kpi_result(
            mut self,
            input: std::option::Option<crate::model::BaseKpiResult>,
        ) -> Self {
            self.kpi_result = input;
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Application Metrics resource because the resource returns all results in a single page.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Application Metrics resource because the resource returns all results in a single page.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn start_time(mut self, input: aws_smithy_types::Instant) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::Instant>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationDateRangeKpiResponse`](crate::model::ApplicationDateRangeKpiResponse)
        pub fn build(self) -> crate::model::ApplicationDateRangeKpiResponse {
            crate::model::ApplicationDateRangeKpiResponse {
                application_id: self.application_id,
                end_time: self.end_time,
                kpi_name: self.kpi_name,
                kpi_result: self.kpi_result,
                next_token: self.next_token,
                start_time: self.start_time,
            }
        }
    }
}
impl ApplicationDateRangeKpiResponse {
    /// Creates a new builder-style object to manufacture [`ApplicationDateRangeKpiResponse`](crate::model::ApplicationDateRangeKpiResponse)
    pub fn builder() -> crate::model::application_date_range_kpi_response::Builder {
        crate::model::application_date_range_kpi_response::Builder::default()
    }
}

/// <p>Provides information about a request to create a message template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateTemplateMessageBody {
    /// <p>The Amazon Resource Name (ARN) of the message template that was created.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The message that's returned from the API for the request to create the message template.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request to create the message template.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateTemplateMessageBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateTemplateMessageBody");
        formatter.field("arn", &self.arn);
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
/// See [`CreateTemplateMessageBody`](crate::model::CreateTemplateMessageBody)
pub mod create_template_message_body {
    /// A builder for [`CreateTemplateMessageBody`](crate::model::CreateTemplateMessageBody)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the message template that was created.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the message template that was created.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The message that's returned from the API for the request to create the message template.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that's returned from the API for the request to create the message template.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request to create the message template.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the request to create the message template.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateTemplateMessageBody`](crate::model::CreateTemplateMessageBody)
        pub fn build(self) -> crate::model::CreateTemplateMessageBody {
            crate::model::CreateTemplateMessageBody {
                arn: self.arn,
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl CreateTemplateMessageBody {
    /// Creates a new builder-style object to manufacture [`CreateTemplateMessageBody`](crate::model::CreateTemplateMessageBody)
    pub fn builder() -> crate::model::create_template_message_body::Builder {
        crate::model::create_template_message_body::Builder::default()
    }
}

/// <p>Specifies Amazon Pinpoint configuration settings for retrieving and processing recommendation data from a recommender model.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateRecommenderConfigurationShape {
    /// <p>A map of key-value pairs that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>In the map, the key is the name of a custom attribute and the value is a custom display name for that attribute. The display name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The following restrictions apply to these names:</p> <ul><li><p>An attribute name must start with a letter or number and it can contain up to 50 characters. The characters can be letters, numbers, underscores (_), or hyphens (-). Attribute names are case sensitive and must be unique.</p></li> <li><p>An attribute display name must start with a letter or number and it can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p></li></ul> <p>This object is required if the configuration invokes an AWS Lambda function (RecommendationTransformerUri) to process recommendation data. Otherwise, don't include this object in your request.</p>
    pub attributes:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A custom description of the configuration for the recommender model. The description can contain up to 128 characters. The characters can be letters, numbers, spaces, or the following symbols: _ ; () , ‐.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>A custom name of the configuration for the recommender model. The name must start with a letter or number and it can contain up to 128 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of Amazon Pinpoint ID to associate with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Valid values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Associate each user in the model with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Associate each user in the model with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If you specify this value, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
    pub recommendation_provider_id_type: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
    pub recommendation_provider_role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the recommender model to retrieve recommendation data from. This value must match the ARN of an Amazon Personalize campaign.</p>
    pub recommendation_provider_uri: std::option::Option<std::string::String>,
    /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function to invoke for additional processing of recommendation data that's retrieved from the recommender model.</p>
    pub recommendation_transformer_uri: std::option::Option<std::string::String>,
    /// <p>A custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This value is required if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p> <p>This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The name can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-). These restrictions don't apply to attribute values.</p>
    pub recommendations_display_name: std::option::Option<std::string::String>,
    /// <p>The number of recommended items to retrieve from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables. The minimum value is 1. The maximum value is 5. The default value is 5.</p> <p>To use multiple recommended items and custom attributes with message variables, you have to use an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
    pub recommendations_per_message: i32,
}
impl std::fmt::Debug for CreateRecommenderConfigurationShape {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateRecommenderConfigurationShape");
        formatter.field("attributes", &self.attributes);
        formatter.field("description", &self.description);
        formatter.field("name", &self.name);
        formatter.field(
            "recommendation_provider_id_type",
            &self.recommendation_provider_id_type,
        );
        formatter.field(
            "recommendation_provider_role_arn",
            &self.recommendation_provider_role_arn,
        );
        formatter.field(
            "recommendation_provider_uri",
            &self.recommendation_provider_uri,
        );
        formatter.field(
            "recommendation_transformer_uri",
            &self.recommendation_transformer_uri,
        );
        formatter.field(
            "recommendations_display_name",
            &self.recommendations_display_name,
        );
        formatter.field(
            "recommendations_per_message",
            &self.recommendations_per_message,
        );
        formatter.finish()
    }
}
/// See [`CreateRecommenderConfigurationShape`](crate::model::CreateRecommenderConfigurationShape)
pub mod create_recommender_configuration_shape {
    /// A builder for [`CreateRecommenderConfigurationShape`](crate::model::CreateRecommenderConfigurationShape)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attributes: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) recommendation_provider_id_type: std::option::Option<std::string::String>,
        pub(crate) recommendation_provider_role_arn: std::option::Option<std::string::String>,
        pub(crate) recommendation_provider_uri: std::option::Option<std::string::String>,
        pub(crate) recommendation_transformer_uri: std::option::Option<std::string::String>,
        pub(crate) recommendations_display_name: std::option::Option<std::string::String>,
        pub(crate) recommendations_per_message: std::option::Option<i32>,
    }
    impl Builder {
        /// Adds a key-value pair to `attributes`.
        ///
        /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
        ///
        /// <p>A map of key-value pairs that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>In the map, the key is the name of a custom attribute and the value is a custom display name for that attribute. The display name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The following restrictions apply to these names:</p> <ul><li><p>An attribute name must start with a letter or number and it can contain up to 50 characters. The characters can be letters, numbers, underscores (_), or hyphens (-). Attribute names are case sensitive and must be unique.</p></li> <li><p>An attribute display name must start with a letter or number and it can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p></li></ul> <p>This object is required if the configuration invokes an AWS Lambda function (RecommendationTransformerUri) to process recommendation data. Otherwise, don't include this object in your request.</p>
        pub fn attributes(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.attributes.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.attributes = Some(hash_map);
            self
        }
        /// <p>A map of key-value pairs that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>In the map, the key is the name of a custom attribute and the value is a custom display name for that attribute. The display name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The following restrictions apply to these names:</p> <ul><li><p>An attribute name must start with a letter or number and it can contain up to 50 characters. The characters can be letters, numbers, underscores (_), or hyphens (-). Attribute names are case sensitive and must be unique.</p></li> <li><p>An attribute display name must start with a letter or number and it can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p></li></ul> <p>This object is required if the configuration invokes an AWS Lambda function (RecommendationTransformerUri) to process recommendation data. Otherwise, don't include this object in your request.</p>
        pub fn set_attributes(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.attributes = input;
            self
        }
        /// <p>A custom description of the configuration for the recommender model. The description can contain up to 128 characters. The characters can be letters, numbers, spaces, or the following symbols: _ ; () , ‐.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A custom description of the configuration for the recommender model. The description can contain up to 128 characters. The characters can be letters, numbers, spaces, or the following symbols: _ ; () , ‐.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>A custom name of the configuration for the recommender model. The name must start with a letter or number and it can contain up to 128 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A custom name of the configuration for the recommender model. The name must start with a letter or number and it can contain up to 128 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of Amazon Pinpoint ID to associate with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Valid values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Associate each user in the model with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Associate each user in the model with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If you specify this value, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
        pub fn recommendation_provider_id_type(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_provider_id_type = Some(input.into());
            self
        }
        /// <p>The type of Amazon Pinpoint ID to associate with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Valid values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Associate each user in the model with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Associate each user in the model with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If you specify this value, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
        pub fn set_recommendation_provider_id_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_provider_id_type = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
        pub fn recommendation_provider_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_provider_role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
        pub fn set_recommendation_provider_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_provider_role_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the recommender model to retrieve recommendation data from. This value must match the ARN of an Amazon Personalize campaign.</p>
        pub fn recommendation_provider_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_provider_uri = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the recommender model to retrieve recommendation data from. This value must match the ARN of an Amazon Personalize campaign.</p>
        pub fn set_recommendation_provider_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_provider_uri = input;
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function to invoke for additional processing of recommendation data that's retrieved from the recommender model.</p>
        pub fn recommendation_transformer_uri(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendation_transformer_uri = Some(input.into());
            self
        }
        /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function to invoke for additional processing of recommendation data that's retrieved from the recommender model.</p>
        pub fn set_recommendation_transformer_uri(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendation_transformer_uri = input;
            self
        }
        /// <p>A custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This value is required if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p> <p>This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The name can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-). These restrictions don't apply to attribute values.</p>
        pub fn recommendations_display_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.recommendations_display_name = Some(input.into());
            self
        }
        /// <p>A custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This value is required if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p> <p>This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The name can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-). These restrictions don't apply to attribute values.</p>
        pub fn set_recommendations_display_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.recommendations_display_name = input;
            self
        }
        /// <p>The number of recommended items to retrieve from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables. The minimum value is 1. The maximum value is 5. The default value is 5.</p> <p>To use multiple recommended items and custom attributes with message variables, you have to use an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
        pub fn recommendations_per_message(mut self, input: i32) -> Self {
            self.recommendations_per_message = Some(input);
            self
        }
        /// <p>The number of recommended items to retrieve from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables. The minimum value is 1. The maximum value is 5. The default value is 5.</p> <p>To use multiple recommended items and custom attributes with message variables, you have to use an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
        pub fn set_recommendations_per_message(mut self, input: std::option::Option<i32>) -> Self {
            self.recommendations_per_message = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateRecommenderConfigurationShape`](crate::model::CreateRecommenderConfigurationShape)
        pub fn build(self) -> crate::model::CreateRecommenderConfigurationShape {
            crate::model::CreateRecommenderConfigurationShape {
                attributes: self.attributes,
                description: self.description,
                name: self.name,
                recommendation_provider_id_type: self.recommendation_provider_id_type,
                recommendation_provider_role_arn: self.recommendation_provider_role_arn,
                recommendation_provider_uri: self.recommendation_provider_uri,
                recommendation_transformer_uri: self.recommendation_transformer_uri,
                recommendations_display_name: self.recommendations_display_name,
                recommendations_per_message: self.recommendations_per_message.unwrap_or_default(),
            }
        }
    }
}
impl CreateRecommenderConfigurationShape {
    /// Creates a new builder-style object to manufacture [`CreateRecommenderConfigurationShape`](crate::model::CreateRecommenderConfigurationShape)
    pub fn builder() -> crate::model::create_recommender_configuration_shape::Builder {
        crate::model::create_recommender_configuration_shape::Builder::default()
    }
}

/// <p>Provides information about a request to create a message template.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TemplateCreateMessageBody {
    /// <p>The Amazon Resource Name (ARN) of the message template that was created.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The message that's returned from the API for the request to create the message template.</p>
    pub message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the request to create the message template.</p>
    pub request_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TemplateCreateMessageBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TemplateCreateMessageBody");
        formatter.field("arn", &self.arn);
        formatter.field("message", &self.message);
        formatter.field("request_id", &self.request_id);
        formatter.finish()
    }
}
/// See [`TemplateCreateMessageBody`](crate::model::TemplateCreateMessageBody)
pub mod template_create_message_body {
    /// A builder for [`TemplateCreateMessageBody`](crate::model::TemplateCreateMessageBody)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) request_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the message template that was created.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the message template that was created.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The message that's returned from the API for the request to create the message template.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that's returned from the API for the request to create the message template.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>The unique identifier for the request to create the message template.</p>
        pub fn request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.request_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the request to create the message template.</p>
        pub fn set_request_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.request_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TemplateCreateMessageBody`](crate::model::TemplateCreateMessageBody)
        pub fn build(self) -> crate::model::TemplateCreateMessageBody {
            crate::model::TemplateCreateMessageBody {
                arn: self.arn,
                message: self.message,
                request_id: self.request_id,
            }
        }
    }
}
impl TemplateCreateMessageBody {
    /// Creates a new builder-style object to manufacture [`TemplateCreateMessageBody`](crate::model::TemplateCreateMessageBody)
    pub fn builder() -> crate::model::template_create_message_body::Builder {
        crate::model::template_create_message_body::Builder::default()
    }
}

/// <p>Specifies the settings for a job that imports endpoint definitions from an Amazon Simple Storage Service (Amazon S3) bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ImportJobRequest {
    /// <p>Specifies whether to create a segment that contains the endpoints, when the endpoint definitions are imported.</p>
    pub define_segment: bool,
    /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
    pub external_id: std::option::Option<std::string::String>,
    /// <p>The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format. If the Amazon S3 location stores multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.</p>
    pub format: std::option::Option<crate::model::Format>,
    /// <p>Specifies whether to register the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.</p>
    pub register_endpoints: bool,
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains.</p> <p>The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/<replaceable>file-name</replaceable>. The location can end with the key for an individual object or a prefix that qualifies multiple objects.</p>
    pub s3_url: std::option::Option<std::string::String>,
    /// <p>The identifier for the segment to update or add the imported endpoint definitions to, if the import job is meant to update an existing segment.</p>
    pub segment_id: std::option::Option<std::string::String>,
    /// <p>A custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.</p>
    pub segment_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ImportJobRequest");
        formatter.field("define_segment", &self.define_segment);
        formatter.field("external_id", &self.external_id);
        formatter.field("format", &self.format);
        formatter.field("register_endpoints", &self.register_endpoints);
        formatter.field("role_arn", &self.role_arn);
        formatter.field("s3_url", &self.s3_url);
        formatter.field("segment_id", &self.segment_id);
        formatter.field("segment_name", &self.segment_name);
        formatter.finish()
    }
}
/// See [`ImportJobRequest`](crate::model::ImportJobRequest)
pub mod import_job_request {
    /// A builder for [`ImportJobRequest`](crate::model::ImportJobRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) define_segment: std::option::Option<bool>,
        pub(crate) external_id: std::option::Option<std::string::String>,
        pub(crate) format: std::option::Option<crate::model::Format>,
        pub(crate) register_endpoints: std::option::Option<bool>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) s3_url: std::option::Option<std::string::String>,
        pub(crate) segment_id: std::option::Option<std::string::String>,
        pub(crate) segment_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies whether to create a segment that contains the endpoints, when the endpoint definitions are imported.</p>
        pub fn define_segment(mut self, input: bool) -> Self {
            self.define_segment = Some(input);
            self
        }
        /// <p>Specifies whether to create a segment that contains the endpoints, when the endpoint definitions are imported.</p>
        pub fn set_define_segment(mut self, input: std::option::Option<bool>) -> Self {
            self.define_segment = input;
            self
        }
        /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.external_id = Some(input.into());
            self
        }
        /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.external_id = input;
            self
        }
        /// <p>The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format. If the Amazon S3 location stores multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.</p>
        pub fn format(mut self, input: crate::model::Format) -> Self {
            self.format = Some(input);
            self
        }
        /// <p>The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format. If the Amazon S3 location stores multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.</p>
        pub fn set_format(mut self, input: std::option::Option<crate::model::Format>) -> Self {
            self.format = input;
            self
        }
        /// <p>Specifies whether to register the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.</p>
        pub fn register_endpoints(mut self, input: bool) -> Self {
            self.register_endpoints = Some(input);
            self
        }
        /// <p>Specifies whether to register the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.</p>
        pub fn set_register_endpoints(mut self, input: std::option::Option<bool>) -> Self {
            self.register_endpoints = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains.</p> <p>The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/<replaceable>file-name</replaceable>. The location can end with the key for an individual object or a prefix that qualifies multiple objects.</p>
        pub fn s3_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_url = Some(input.into());
            self
        }
        /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains.</p> <p>The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/<replaceable>file-name</replaceable>. The location can end with the key for an individual object or a prefix that qualifies multiple objects.</p>
        pub fn set_s3_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.s3_url = input;
            self
        }
        /// <p>The identifier for the segment to update or add the imported endpoint definitions to, if the import job is meant to update an existing segment.</p>
        pub fn segment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_id = Some(input.into());
            self
        }
        /// <p>The identifier for the segment to update or add the imported endpoint definitions to, if the import job is meant to update an existing segment.</p>
        pub fn set_segment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_id = input;
            self
        }
        /// <p>A custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.</p>
        pub fn segment_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_name = Some(input.into());
            self
        }
        /// <p>A custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.</p>
        pub fn set_segment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ImportJobRequest`](crate::model::ImportJobRequest)
        pub fn build(self) -> crate::model::ImportJobRequest {
            crate::model::ImportJobRequest {
                define_segment: self.define_segment.unwrap_or_default(),
                external_id: self.external_id,
                format: self.format,
                register_endpoints: self.register_endpoints.unwrap_or_default(),
                role_arn: self.role_arn,
                s3_url: self.s3_url,
                segment_id: self.segment_id,
                segment_name: self.segment_name,
            }
        }
    }
}
impl ImportJobRequest {
    /// Creates a new builder-style object to manufacture [`ImportJobRequest`](crate::model::ImportJobRequest)
    pub fn builder() -> crate::model::import_job_request::Builder {
        crate::model::import_job_request::Builder::default()
    }
}

/// <p>Specifies the settings for a job that exports endpoint definitions to an Amazon Simple Storage Service (Amazon S3) bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ExportJobRequest {
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location where you want to export endpoint definitions to.</p>
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where you want to export endpoint definitions to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/.</p>
    pub s3_url_prefix: std::option::Option<std::string::String>,
    /// <p>The identifier for the segment to export endpoint definitions from. If you don't specify this value, Amazon Pinpoint exports definitions for all the endpoints that are associated with the application.</p>
    pub segment_id: std::option::Option<std::string::String>,
    /// <p>The version of the segment to export endpoint definitions from, if specified.</p>
    pub segment_version: i32,
}
impl std::fmt::Debug for ExportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ExportJobRequest");
        formatter.field("role_arn", &self.role_arn);
        formatter.field("s3_url_prefix", &self.s3_url_prefix);
        formatter.field("segment_id", &self.segment_id);
        formatter.field("segment_version", &self.segment_version);
        formatter.finish()
    }
}
/// See [`ExportJobRequest`](crate::model::ExportJobRequest)
pub mod export_job_request {
    /// A builder for [`ExportJobRequest`](crate::model::ExportJobRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) s3_url_prefix: std::option::Option<std::string::String>,
        pub(crate) segment_id: std::option::Option<std::string::String>,
        pub(crate) segment_version: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location where you want to export endpoint definitions to.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location where you want to export endpoint definitions to.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where you want to export endpoint definitions to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/.</p>
        pub fn s3_url_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.s3_url_prefix = Some(input.into());
            self
        }
        /// <p>The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where you want to export endpoint definitions to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/.</p>
        pub fn set_s3_url_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s3_url_prefix = input;
            self
        }
        /// <p>The identifier for the segment to export endpoint definitions from. If you don't specify this value, Amazon Pinpoint exports definitions for all the endpoints that are associated with the application.</p>
        pub fn segment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.segment_id = Some(input.into());
            self
        }
        /// <p>The identifier for the segment to export endpoint definitions from. If you don't specify this value, Amazon Pinpoint exports definitions for all the endpoints that are associated with the application.</p>
        pub fn set_segment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.segment_id = input;
            self
        }
        /// <p>The version of the segment to export endpoint definitions from, if specified.</p>
        pub fn segment_version(mut self, input: i32) -> Self {
            self.segment_version = Some(input);
            self
        }
        /// <p>The version of the segment to export endpoint definitions from, if specified.</p>
        pub fn set_segment_version(mut self, input: std::option::Option<i32>) -> Self {
            self.segment_version = input;
            self
        }
        /// Consumes the builder and constructs a [`ExportJobRequest`](crate::model::ExportJobRequest)
        pub fn build(self) -> crate::model::ExportJobRequest {
            crate::model::ExportJobRequest {
                role_arn: self.role_arn,
                s3_url_prefix: self.s3_url_prefix,
                segment_id: self.segment_id,
                segment_version: self.segment_version.unwrap_or_default(),
            }
        }
    }
}
impl ExportJobRequest {
    /// Creates a new builder-style object to manufacture [`ExportJobRequest`](crate::model::ExportJobRequest)
    pub fn builder() -> crate::model::export_job_request::Builder {
        crate::model::export_job_request::Builder::default()
    }
}

/// <p>Specifies the display name of an application and the tags to associate with the application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateApplicationRequest {
    /// <p>The display name of the application. This name is displayed as the <b>Project name</b> on the Amazon Pinpoint console.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the application. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for CreateApplicationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateApplicationRequest");
        formatter.field("name", &self.name);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`CreateApplicationRequest`](crate::model::CreateApplicationRequest)
pub mod create_application_request {
    /// A builder for [`CreateApplicationRequest`](crate::model::CreateApplicationRequest)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The display name of the application. This name is displayed as the <b>Project name</b> on the Amazon Pinpoint console.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The display name of the application. This name is displayed as the <b>Project name</b> on the Amazon Pinpoint console.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the application. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the application. Each tag consists of a required tag key and an associated tag value.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`CreateApplicationRequest`](crate::model::CreateApplicationRequest)
        pub fn build(self) -> crate::model::CreateApplicationRequest {
            crate::model::CreateApplicationRequest {
                name: self.name,
                tags: self.tags,
            }
        }
    }
}
impl CreateApplicationRequest {
    /// Creates a new builder-style object to manufacture [`CreateApplicationRequest`](crate::model::CreateApplicationRequest)
    pub fn builder() -> crate::model::create_application_request::Builder {
        crate::model::create_application_request::Builder::default()
    }
}
