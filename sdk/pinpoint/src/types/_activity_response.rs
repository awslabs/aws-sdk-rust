// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides information about an activity that was performed by a campaign.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ActivityResponse {
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub application_id: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    pub campaign_id: ::std::option::Option<::std::string::String>,
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    pub end: ::std::option::Option<::std::string::String>,
    /// <p>The unique identifier for the activity.</p>
    pub id: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    pub result: ::std::option::Option<::std::string::String>,
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    pub scheduled_start: ::std::option::Option<::std::string::String>,
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    pub start: ::std::option::Option<::std::string::String>,
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    pub state: ::std::option::Option<::std::string::String>,
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    pub successful_endpoint_count: ::std::option::Option<i32>,
    /// <p>The total number of time zones that were completed.</p>
    pub timezones_completed_count: ::std::option::Option<i32>,
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    pub timezones_total_count: ::std::option::Option<i32>,
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    pub total_endpoint_count: ::std::option::Option<i32>,
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    pub treatment_id: ::std::option::Option<::std::string::String>,
    /// <p>A JSON object that contains metrics relating to the campaign execution for this campaign activity. For information about the structure and contents of the results, see <a href="https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html">Standard Amazon Pinpoint analytics metrics</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p>
    pub execution_metrics: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl ActivityResponse {
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn application_id(&self) -> ::std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    pub fn campaign_id(&self) -> ::std::option::Option<&str> {
        self.campaign_id.as_deref()
    }
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    pub fn end(&self) -> ::std::option::Option<&str> {
        self.end.as_deref()
    }
    /// <p>The unique identifier for the activity.</p>
    pub fn id(&self) -> ::std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    pub fn result(&self) -> ::std::option::Option<&str> {
        self.result.as_deref()
    }
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    pub fn scheduled_start(&self) -> ::std::option::Option<&str> {
        self.scheduled_start.as_deref()
    }
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    pub fn start(&self) -> ::std::option::Option<&str> {
        self.start.as_deref()
    }
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    pub fn state(&self) -> ::std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    pub fn successful_endpoint_count(&self) -> ::std::option::Option<i32> {
        self.successful_endpoint_count
    }
    /// <p>The total number of time zones that were completed.</p>
    pub fn timezones_completed_count(&self) -> ::std::option::Option<i32> {
        self.timezones_completed_count
    }
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    pub fn timezones_total_count(&self) -> ::std::option::Option<i32> {
        self.timezones_total_count
    }
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    pub fn total_endpoint_count(&self) -> ::std::option::Option<i32> {
        self.total_endpoint_count
    }
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    pub fn treatment_id(&self) -> ::std::option::Option<&str> {
        self.treatment_id.as_deref()
    }
    /// <p>A JSON object that contains metrics relating to the campaign execution for this campaign activity. For information about the structure and contents of the results, see <a href="https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html">Standard Amazon Pinpoint analytics metrics</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p>
    pub fn execution_metrics(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.execution_metrics.as_ref()
    }
}
impl ActivityResponse {
    /// Creates a new builder-style object to manufacture [`ActivityResponse`](crate::types::ActivityResponse).
    pub fn builder() -> crate::types::builders::ActivityResponseBuilder {
        crate::types::builders::ActivityResponseBuilder::default()
    }
}

/// A builder for [`ActivityResponse`](crate::types::ActivityResponse).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct ActivityResponseBuilder {
    pub(crate) application_id: ::std::option::Option<::std::string::String>,
    pub(crate) campaign_id: ::std::option::Option<::std::string::String>,
    pub(crate) end: ::std::option::Option<::std::string::String>,
    pub(crate) id: ::std::option::Option<::std::string::String>,
    pub(crate) result: ::std::option::Option<::std::string::String>,
    pub(crate) scheduled_start: ::std::option::Option<::std::string::String>,
    pub(crate) start: ::std::option::Option<::std::string::String>,
    pub(crate) state: ::std::option::Option<::std::string::String>,
    pub(crate) successful_endpoint_count: ::std::option::Option<i32>,
    pub(crate) timezones_completed_count: ::std::option::Option<i32>,
    pub(crate) timezones_total_count: ::std::option::Option<i32>,
    pub(crate) total_endpoint_count: ::std::option::Option<i32>,
    pub(crate) treatment_id: ::std::option::Option<::std::string::String>,
    pub(crate) execution_metrics: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
}
impl ActivityResponseBuilder {
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    /// This field is required.
    pub fn application_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.application_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn set_application_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.application_id = input;
        self
    }
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn get_application_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.application_id
    }
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    /// This field is required.
    pub fn campaign_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.campaign_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    pub fn set_campaign_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.campaign_id = input;
        self
    }
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    pub fn get_campaign_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.campaign_id
    }
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    pub fn end(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.end = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    pub fn set_end(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.end = input;
        self
    }
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    pub fn get_end(&self) -> &::std::option::Option<::std::string::String> {
        &self.end
    }
    /// <p>The unique identifier for the activity.</p>
    /// This field is required.
    pub fn id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the activity.</p>
    pub fn set_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>The unique identifier for the activity.</p>
    pub fn get_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.id
    }
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    pub fn result(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.result = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    pub fn set_result(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.result = input;
        self
    }
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    pub fn get_result(&self) -> &::std::option::Option<::std::string::String> {
        &self.result
    }
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    pub fn scheduled_start(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.scheduled_start = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    pub fn set_scheduled_start(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.scheduled_start = input;
        self
    }
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    pub fn get_scheduled_start(&self) -> &::std::option::Option<::std::string::String> {
        &self.scheduled_start
    }
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    pub fn start(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.start = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    pub fn set_start(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.start = input;
        self
    }
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    pub fn get_start(&self) -> &::std::option::Option<::std::string::String> {
        &self.start
    }
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    pub fn state(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.state = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    pub fn set_state(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.state = input;
        self
    }
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    pub fn get_state(&self) -> &::std::option::Option<::std::string::String> {
        &self.state
    }
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    pub fn successful_endpoint_count(mut self, input: i32) -> Self {
        self.successful_endpoint_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    pub fn set_successful_endpoint_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.successful_endpoint_count = input;
        self
    }
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    pub fn get_successful_endpoint_count(&self) -> &::std::option::Option<i32> {
        &self.successful_endpoint_count
    }
    /// <p>The total number of time zones that were completed.</p>
    pub fn timezones_completed_count(mut self, input: i32) -> Self {
        self.timezones_completed_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of time zones that were completed.</p>
    pub fn set_timezones_completed_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.timezones_completed_count = input;
        self
    }
    /// <p>The total number of time zones that were completed.</p>
    pub fn get_timezones_completed_count(&self) -> &::std::option::Option<i32> {
        &self.timezones_completed_count
    }
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    pub fn timezones_total_count(mut self, input: i32) -> Self {
        self.timezones_total_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    pub fn set_timezones_total_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.timezones_total_count = input;
        self
    }
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    pub fn get_timezones_total_count(&self) -> &::std::option::Option<i32> {
        &self.timezones_total_count
    }
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    pub fn total_endpoint_count(mut self, input: i32) -> Self {
        self.total_endpoint_count = ::std::option::Option::Some(input);
        self
    }
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    pub fn set_total_endpoint_count(mut self, input: ::std::option::Option<i32>) -> Self {
        self.total_endpoint_count = input;
        self
    }
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    pub fn get_total_endpoint_count(&self) -> &::std::option::Option<i32> {
        &self.total_endpoint_count
    }
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    pub fn treatment_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.treatment_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    pub fn set_treatment_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.treatment_id = input;
        self
    }
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    pub fn get_treatment_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.treatment_id
    }
    /// Adds a key-value pair to `execution_metrics`.
    ///
    /// To override the contents of this collection use [`set_execution_metrics`](Self::set_execution_metrics).
    ///
    /// <p>A JSON object that contains metrics relating to the campaign execution for this campaign activity. For information about the structure and contents of the results, see <a href="https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html">Standard Amazon Pinpoint analytics metrics</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p>
    pub fn execution_metrics(
        mut self,
        k: impl ::std::convert::Into<::std::string::String>,
        v: impl ::std::convert::Into<::std::string::String>,
    ) -> Self {
        let mut hash_map = self.execution_metrics.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.execution_metrics = ::std::option::Option::Some(hash_map);
        self
    }
    /// <p>A JSON object that contains metrics relating to the campaign execution for this campaign activity. For information about the structure and contents of the results, see <a href="https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html">Standard Amazon Pinpoint analytics metrics</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p>
    pub fn set_execution_metrics(
        mut self,
        input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    ) -> Self {
        self.execution_metrics = input;
        self
    }
    /// <p>A JSON object that contains metrics relating to the campaign execution for this campaign activity. For information about the structure and contents of the results, see <a href="https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html">Standard Amazon Pinpoint analytics metrics</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p>
    pub fn get_execution_metrics(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.execution_metrics
    }
    /// Consumes the builder and constructs a [`ActivityResponse`](crate::types::ActivityResponse).
    pub fn build(self) -> crate::types::ActivityResponse {
        crate::types::ActivityResponse {
            application_id: self.application_id,
            campaign_id: self.campaign_id,
            end: self.end,
            id: self.id,
            result: self.result,
            scheduled_start: self.scheduled_start,
            start: self.start,
            state: self.state,
            successful_endpoint_count: self.successful_endpoint_count,
            timezones_completed_count: self.timezones_completed_count,
            timezones_total_count: self.timezones_total_count,
            total_endpoint_count: self.total_endpoint_count,
            treatment_id: self.treatment_id,
            execution_metrics: self.execution_metrics,
        }
    }
}
