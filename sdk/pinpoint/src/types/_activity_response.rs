// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides information about an activity that was performed by a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActivityResponse {
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    #[doc(hidden)]
    pub campaign_id: std::option::Option<std::string::String>,
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    #[doc(hidden)]
    pub end: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the activity.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    #[doc(hidden)]
    pub result: std::option::Option<std::string::String>,
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    #[doc(hidden)]
    pub scheduled_start: std::option::Option<std::string::String>,
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    #[doc(hidden)]
    pub start: std::option::Option<std::string::String>,
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    #[doc(hidden)]
    pub state: std::option::Option<std::string::String>,
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    #[doc(hidden)]
    pub successful_endpoint_count: i32,
    /// <p>The total number of time zones that were completed.</p>
    #[doc(hidden)]
    pub timezones_completed_count: i32,
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    #[doc(hidden)]
    pub timezones_total_count: i32,
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    #[doc(hidden)]
    pub total_endpoint_count: i32,
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    #[doc(hidden)]
    pub treatment_id: std::option::Option<std::string::String>,
}
impl ActivityResponse {
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    pub fn campaign_id(&self) -> std::option::Option<&str> {
        self.campaign_id.as_deref()
    }
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    pub fn end(&self) -> std::option::Option<&str> {
        self.end.as_deref()
    }
    /// <p>The unique identifier for the activity.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    pub fn result(&self) -> std::option::Option<&str> {
        self.result.as_deref()
    }
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    pub fn scheduled_start(&self) -> std::option::Option<&str> {
        self.scheduled_start.as_deref()
    }
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    pub fn start(&self) -> std::option::Option<&str> {
        self.start.as_deref()
    }
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    pub fn state(&self) -> std::option::Option<&str> {
        self.state.as_deref()
    }
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    pub fn successful_endpoint_count(&self) -> i32 {
        self.successful_endpoint_count
    }
    /// <p>The total number of time zones that were completed.</p>
    pub fn timezones_completed_count(&self) -> i32 {
        self.timezones_completed_count
    }
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    pub fn timezones_total_count(&self) -> i32 {
        self.timezones_total_count
    }
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    pub fn total_endpoint_count(&self) -> i32 {
        self.total_endpoint_count
    }
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    pub fn treatment_id(&self) -> std::option::Option<&str> {
        self.treatment_id.as_deref()
    }
}
impl ActivityResponse {
    /// Creates a new builder-style object to manufacture [`ActivityResponse`](crate::types::ActivityResponse).
    pub fn builder() -> crate::types::builders::ActivityResponseBuilder {
        crate::types::builders::ActivityResponseBuilder::default()
    }
}

/// A builder for [`ActivityResponse`](crate::types::ActivityResponse).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ActivityResponseBuilder {
    pub(crate) application_id: std::option::Option<std::string::String>,
    pub(crate) campaign_id: std::option::Option<std::string::String>,
    pub(crate) end: std::option::Option<std::string::String>,
    pub(crate) id: std::option::Option<std::string::String>,
    pub(crate) result: std::option::Option<std::string::String>,
    pub(crate) scheduled_start: std::option::Option<std::string::String>,
    pub(crate) start: std::option::Option<std::string::String>,
    pub(crate) state: std::option::Option<std::string::String>,
    pub(crate) successful_endpoint_count: std::option::Option<i32>,
    pub(crate) timezones_completed_count: std::option::Option<i32>,
    pub(crate) timezones_total_count: std::option::Option<i32>,
    pub(crate) total_endpoint_count: std::option::Option<i32>,
    pub(crate) treatment_id: std::option::Option<std::string::String>,
}
impl ActivityResponseBuilder {
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.application_id = Some(input.into());
        self
    }
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.application_id = input;
        self
    }
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    pub fn campaign_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.campaign_id = Some(input.into());
        self
    }
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    pub fn set_campaign_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.campaign_id = input;
        self
    }
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    pub fn end(mut self, input: impl Into<std::string::String>) -> Self {
        self.end = Some(input.into());
        self
    }
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    pub fn set_end(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.end = input;
        self
    }
    /// <p>The unique identifier for the activity.</p>
    pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
        self.id = Some(input.into());
        self
    }
    /// <p>The unique identifier for the activity.</p>
    pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.id = input;
        self
    }
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    pub fn result(mut self, input: impl Into<std::string::String>) -> Self {
        self.result = Some(input.into());
        self
    }
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    pub fn set_result(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.result = input;
        self
    }
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    pub fn scheduled_start(mut self, input: impl Into<std::string::String>) -> Self {
        self.scheduled_start = Some(input.into());
        self
    }
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    pub fn set_scheduled_start(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.scheduled_start = input;
        self
    }
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    pub fn start(mut self, input: impl Into<std::string::String>) -> Self {
        self.start = Some(input.into());
        self
    }
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    pub fn set_start(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.start = input;
        self
    }
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    pub fn state(mut self, input: impl Into<std::string::String>) -> Self {
        self.state = Some(input.into());
        self
    }
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    pub fn set_state(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.state = input;
        self
    }
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    pub fn successful_endpoint_count(mut self, input: i32) -> Self {
        self.successful_endpoint_count = Some(input);
        self
    }
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    pub fn set_successful_endpoint_count(mut self, input: std::option::Option<i32>) -> Self {
        self.successful_endpoint_count = input;
        self
    }
    /// <p>The total number of time zones that were completed.</p>
    pub fn timezones_completed_count(mut self, input: i32) -> Self {
        self.timezones_completed_count = Some(input);
        self
    }
    /// <p>The total number of time zones that were completed.</p>
    pub fn set_timezones_completed_count(mut self, input: std::option::Option<i32>) -> Self {
        self.timezones_completed_count = input;
        self
    }
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    pub fn timezones_total_count(mut self, input: i32) -> Self {
        self.timezones_total_count = Some(input);
        self
    }
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    pub fn set_timezones_total_count(mut self, input: std::option::Option<i32>) -> Self {
        self.timezones_total_count = input;
        self
    }
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    pub fn total_endpoint_count(mut self, input: i32) -> Self {
        self.total_endpoint_count = Some(input);
        self
    }
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    pub fn set_total_endpoint_count(mut self, input: std::option::Option<i32>) -> Self {
        self.total_endpoint_count = input;
        self
    }
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    pub fn treatment_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.treatment_id = Some(input.into());
        self
    }
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    pub fn set_treatment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.treatment_id = input;
        self
    }
    /// Consumes the builder and constructs a [`ActivityResponse`](crate::types::ActivityResponse).
    pub fn build(self) -> crate::types::ActivityResponse {
        crate::types::ActivityResponse {
            application_id: self.application_id,
            campaign_id: self.campaign_id,
            end: self.end,
            id: self.id,
            result: self.result,
            scheduled_start: self.scheduled_start,
            start: self.start,
            state: self.state,
            successful_endpoint_count: self.successful_endpoint_count.unwrap_or_default(),
            timezones_completed_count: self.timezones_completed_count.unwrap_or_default(),
            timezones_total_count: self.timezones_total_count.unwrap_or_default(),
            total_endpoint_count: self.total_endpoint_count.unwrap_or_default(),
            treatment_id: self.treatment_id,
        }
    }
}
