// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Specifies the configuration and other settings for a campaign.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct WriteCampaignRequest {
    /// <p>An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.</p>
    pub additional_treatments: ::std::option::Option<::std::vec::Vec<crate::types::WriteTreatmentResource>>,
    /// <p>The delivery configuration settings for sending the campaign through a custom channel. This object is required if the MessageConfiguration object for the campaign specifies a CustomMessage object.</p>
    pub custom_delivery_configuration: ::std::option::Option<crate::types::CustomDeliveryConfiguration>,
    /// <p>A custom description of the campaign.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub holdout_percent: ::std::option::Option<i32>,
    /// <p>The settings for the AWS Lambda function to invoke as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub hook: ::std::option::Option<crate::types::CampaignHook>,
    /// <p>Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub is_paused: ::std::option::Option<bool>,
    /// <p>The messaging limits for the campaign.</p>
    pub limits: ::std::option::Option<crate::types::CampaignLimits>,
    /// <p>The message configuration settings for the campaign.</p>
    pub message_configuration: ::std::option::Option<crate::types::MessageConfiguration>,
    /// <p>A custom name for the campaign.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The schedule settings for the campaign.</p>
    pub schedule: ::std::option::Option<crate::types::Schedule>,
    /// <p>The unique identifier for the segment to associate with the campaign.</p>
    pub segment_id: ::std::option::Option<::std::string::String>,
    /// <p>The version of the segment to associate with the campaign.</p>
    pub segment_version: ::std::option::Option<i32>,
    /// <note>
    /// <p>As of <b>22-05-2023</b> tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html">Tags</a> in the <i>API Reference for Amazon Pinpoint</i>, <a href="https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html">resourcegroupstaggingapi</a> commands in the <i>AWS Command Line Interface Documentation</i> or <a href="https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html">resourcegroupstaggingapi</a> in the <i>AWS SDK</i>.</p>
    /// </note>
    /// <p>(Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    /// <p>The message template to use for the campaign.</p>
    pub template_configuration: ::std::option::Option<crate::types::TemplateConfiguration>,
    /// <p>A custom description of the default treatment for the campaign.</p>
    pub treatment_description: ::std::option::Option<::std::string::String>,
    /// <p>A custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub treatment_name: ::std::option::Option<::std::string::String>,
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub priority: ::std::option::Option<i32>,
}
impl WriteCampaignRequest {
    /// <p>An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.additional_treatments.is_none()`.
    pub fn additional_treatments(&self) -> &[crate::types::WriteTreatmentResource] {
        self.additional_treatments.as_deref().unwrap_or_default()
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel. This object is required if the MessageConfiguration object for the campaign specifies a CustomMessage object.</p>
    pub fn custom_delivery_configuration(&self) -> ::std::option::Option<&crate::types::CustomDeliveryConfiguration> {
        self.custom_delivery_configuration.as_ref()
    }
    /// <p>A custom description of the campaign.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn holdout_percent(&self) -> ::std::option::Option<i32> {
        self.holdout_percent
    }
    /// <p>The settings for the AWS Lambda function to invoke as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn hook(&self) -> ::std::option::Option<&crate::types::CampaignHook> {
        self.hook.as_ref()
    }
    /// <p>Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn is_paused(&self) -> ::std::option::Option<bool> {
        self.is_paused
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn limits(&self) -> ::std::option::Option<&crate::types::CampaignLimits> {
        self.limits.as_ref()
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn message_configuration(&self) -> ::std::option::Option<&crate::types::MessageConfiguration> {
        self.message_configuration.as_ref()
    }
    /// <p>A custom name for the campaign.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn schedule(&self) -> ::std::option::Option<&crate::types::Schedule> {
        self.schedule.as_ref()
    }
    /// <p>The unique identifier for the segment to associate with the campaign.</p>
    pub fn segment_id(&self) -> ::std::option::Option<&str> {
        self.segment_id.as_deref()
    }
    /// <p>The version of the segment to associate with the campaign.</p>
    pub fn segment_version(&self) -> ::std::option::Option<i32> {
        self.segment_version
    }
    /// <note>
    /// <p>As of <b>22-05-2023</b> tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html">Tags</a> in the <i>API Reference for Amazon Pinpoint</i>, <a href="https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html">resourcegroupstaggingapi</a> commands in the <i>AWS Command Line Interface Documentation</i> or <a href="https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html">resourcegroupstaggingapi</a> in the <i>AWS SDK</i>.</p>
    /// </note>
    /// <p>(Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn tags(&self) -> ::std::option::Option<&::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The message template to use for the campaign.</p>
    pub fn template_configuration(&self) -> ::std::option::Option<&crate::types::TemplateConfiguration> {
        self.template_configuration.as_ref()
    }
    /// <p>A custom description of the default treatment for the campaign.</p>
    pub fn treatment_description(&self) -> ::std::option::Option<&str> {
        self.treatment_description.as_deref()
    }
    /// <p>A custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn treatment_name(&self) -> ::std::option::Option<&str> {
        self.treatment_name.as_deref()
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn priority(&self) -> ::std::option::Option<i32> {
        self.priority
    }
}
impl WriteCampaignRequest {
    /// Creates a new builder-style object to manufacture [`WriteCampaignRequest`](crate::types::WriteCampaignRequest).
    pub fn builder() -> crate::types::builders::WriteCampaignRequestBuilder {
        crate::types::builders::WriteCampaignRequestBuilder::default()
    }
}

/// A builder for [`WriteCampaignRequest`](crate::types::WriteCampaignRequest).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct WriteCampaignRequestBuilder {
    pub(crate) additional_treatments: ::std::option::Option<::std::vec::Vec<crate::types::WriteTreatmentResource>>,
    pub(crate) custom_delivery_configuration: ::std::option::Option<crate::types::CustomDeliveryConfiguration>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) holdout_percent: ::std::option::Option<i32>,
    pub(crate) hook: ::std::option::Option<crate::types::CampaignHook>,
    pub(crate) is_paused: ::std::option::Option<bool>,
    pub(crate) limits: ::std::option::Option<crate::types::CampaignLimits>,
    pub(crate) message_configuration: ::std::option::Option<crate::types::MessageConfiguration>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) schedule: ::std::option::Option<crate::types::Schedule>,
    pub(crate) segment_id: ::std::option::Option<::std::string::String>,
    pub(crate) segment_version: ::std::option::Option<i32>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>,
    pub(crate) template_configuration: ::std::option::Option<crate::types::TemplateConfiguration>,
    pub(crate) treatment_description: ::std::option::Option<::std::string::String>,
    pub(crate) treatment_name: ::std::option::Option<::std::string::String>,
    pub(crate) priority: ::std::option::Option<i32>,
}
impl WriteCampaignRequestBuilder {
    /// Appends an item to `additional_treatments`.
    ///
    /// To override the contents of this collection use [`set_additional_treatments`](Self::set_additional_treatments).
    ///
    /// <p>An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.</p>
    pub fn additional_treatments(mut self, input: crate::types::WriteTreatmentResource) -> Self {
        let mut v = self.additional_treatments.unwrap_or_default();
        v.push(input);
        self.additional_treatments = ::std::option::Option::Some(v);
        self
    }
    /// <p>An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.</p>
    pub fn set_additional_treatments(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::WriteTreatmentResource>>) -> Self {
        self.additional_treatments = input;
        self
    }
    /// <p>An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.</p>
    pub fn get_additional_treatments(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::WriteTreatmentResource>> {
        &self.additional_treatments
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel. This object is required if the MessageConfiguration object for the campaign specifies a CustomMessage object.</p>
    pub fn custom_delivery_configuration(mut self, input: crate::types::CustomDeliveryConfiguration) -> Self {
        self.custom_delivery_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel. This object is required if the MessageConfiguration object for the campaign specifies a CustomMessage object.</p>
    pub fn set_custom_delivery_configuration(mut self, input: ::std::option::Option<crate::types::CustomDeliveryConfiguration>) -> Self {
        self.custom_delivery_configuration = input;
        self
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel. This object is required if the MessageConfiguration object for the campaign specifies a CustomMessage object.</p>
    pub fn get_custom_delivery_configuration(&self) -> &::std::option::Option<crate::types::CustomDeliveryConfiguration> {
        &self.custom_delivery_configuration
    }
    /// <p>A custom description of the campaign.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A custom description of the campaign.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>A custom description of the campaign.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn holdout_percent(mut self, input: i32) -> Self {
        self.holdout_percent = ::std::option::Option::Some(input);
        self
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn set_holdout_percent(mut self, input: ::std::option::Option<i32>) -> Self {
        self.holdout_percent = input;
        self
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn get_holdout_percent(&self) -> &::std::option::Option<i32> {
        &self.holdout_percent
    }
    /// <p>The settings for the AWS Lambda function to invoke as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn hook(mut self, input: crate::types::CampaignHook) -> Self {
        self.hook = ::std::option::Option::Some(input);
        self
    }
    /// <p>The settings for the AWS Lambda function to invoke as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn set_hook(mut self, input: ::std::option::Option<crate::types::CampaignHook>) -> Self {
        self.hook = input;
        self
    }
    /// <p>The settings for the AWS Lambda function to invoke as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn get_hook(&self) -> &::std::option::Option<crate::types::CampaignHook> {
        &self.hook
    }
    /// <p>Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn is_paused(mut self, input: bool) -> Self {
        self.is_paused = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn set_is_paused(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_paused = input;
        self
    }
    /// <p>Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn get_is_paused(&self) -> &::std::option::Option<bool> {
        &self.is_paused
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn limits(mut self, input: crate::types::CampaignLimits) -> Self {
        self.limits = ::std::option::Option::Some(input);
        self
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn set_limits(mut self, input: ::std::option::Option<crate::types::CampaignLimits>) -> Self {
        self.limits = input;
        self
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn get_limits(&self) -> &::std::option::Option<crate::types::CampaignLimits> {
        &self.limits
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn message_configuration(mut self, input: crate::types::MessageConfiguration) -> Self {
        self.message_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn set_message_configuration(mut self, input: ::std::option::Option<crate::types::MessageConfiguration>) -> Self {
        self.message_configuration = input;
        self
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn get_message_configuration(&self) -> &::std::option::Option<crate::types::MessageConfiguration> {
        &self.message_configuration
    }
    /// <p>A custom name for the campaign.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A custom name for the campaign.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>A custom name for the campaign.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn schedule(mut self, input: crate::types::Schedule) -> Self {
        self.schedule = ::std::option::Option::Some(input);
        self
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn set_schedule(mut self, input: ::std::option::Option<crate::types::Schedule>) -> Self {
        self.schedule = input;
        self
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn get_schedule(&self) -> &::std::option::Option<crate::types::Schedule> {
        &self.schedule
    }
    /// <p>The unique identifier for the segment to associate with the campaign.</p>
    pub fn segment_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.segment_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the segment to associate with the campaign.</p>
    pub fn set_segment_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.segment_id = input;
        self
    }
    /// <p>The unique identifier for the segment to associate with the campaign.</p>
    pub fn get_segment_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.segment_id
    }
    /// <p>The version of the segment to associate with the campaign.</p>
    pub fn segment_version(mut self, input: i32) -> Self {
        self.segment_version = ::std::option::Option::Some(input);
        self
    }
    /// <p>The version of the segment to associate with the campaign.</p>
    pub fn set_segment_version(mut self, input: ::std::option::Option<i32>) -> Self {
        self.segment_version = input;
        self
    }
    /// <p>The version of the segment to associate with the campaign.</p>
    pub fn get_segment_version(&self) -> &::std::option::Option<i32> {
        &self.segment_version
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <note>
    /// <p>As of <b>22-05-2023</b> tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html">Tags</a> in the <i>API Reference for Amazon Pinpoint</i>, <a href="https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html">resourcegroupstaggingapi</a> commands in the <i>AWS Command Line Interface Documentation</i> or <a href="https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html">resourcegroupstaggingapi</a> in the <i>AWS SDK</i>.</p>
    /// </note>
    /// <p>(Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
        hash_map.insert(k.into(), v.into());
        self.tags = ::std::option::Option::Some(hash_map);
        self
    }
    /// <note>
    /// <p>As of <b>22-05-2023</b> tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html">Tags</a> in the <i>API Reference for Amazon Pinpoint</i>, <a href="https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html">resourcegroupstaggingapi</a> commands in the <i>AWS Command Line Interface Documentation</i> or <a href="https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html">resourcegroupstaggingapi</a> in the <i>AWS SDK</i>.</p>
    /// </note>
    /// <p>(Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input;
        self
    }
    /// <note>
    /// <p>As of <b>22-05-2023</b> tags has been deprecated for update operations. After this date any value in tags is not processed and an error code is not returned. To manage tags we recommend using either <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/tags-resource-arn.html">Tags</a> in the <i>API Reference for Amazon Pinpoint</i>, <a href="https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html">resourcegroupstaggingapi</a> commands in the <i>AWS Command Line Interface Documentation</i> or <a href="https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/services/resourcegroupstaggingapi/package-summary.html">resourcegroupstaggingapi</a> in the <i>AWS SDK</i>.</p>
    /// </note>
    /// <p>(Deprecated) A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>The message template to use for the campaign.</p>
    pub fn template_configuration(mut self, input: crate::types::TemplateConfiguration) -> Self {
        self.template_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The message template to use for the campaign.</p>
    pub fn set_template_configuration(mut self, input: ::std::option::Option<crate::types::TemplateConfiguration>) -> Self {
        self.template_configuration = input;
        self
    }
    /// <p>The message template to use for the campaign.</p>
    pub fn get_template_configuration(&self) -> &::std::option::Option<crate::types::TemplateConfiguration> {
        &self.template_configuration
    }
    /// <p>A custom description of the default treatment for the campaign.</p>
    pub fn treatment_description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.treatment_description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A custom description of the default treatment for the campaign.</p>
    pub fn set_treatment_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.treatment_description = input;
        self
    }
    /// <p>A custom description of the default treatment for the campaign.</p>
    pub fn get_treatment_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.treatment_description
    }
    /// <p>A custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn treatment_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.treatment_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn set_treatment_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.treatment_name = input;
        self
    }
    /// <p>A custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn get_treatment_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.treatment_name
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn priority(mut self, input: i32) -> Self {
        self.priority = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn set_priority(mut self, input: ::std::option::Option<i32>) -> Self {
        self.priority = input;
        self
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn get_priority(&self) -> &::std::option::Option<i32> {
        &self.priority
    }
    /// Consumes the builder and constructs a [`WriteCampaignRequest`](crate::types::WriteCampaignRequest).
    pub fn build(self) -> crate::types::WriteCampaignRequest {
        crate::types::WriteCampaignRequest {
            additional_treatments: self.additional_treatments,
            custom_delivery_configuration: self.custom_delivery_configuration,
            description: self.description,
            holdout_percent: self.holdout_percent,
            hook: self.hook,
            is_paused: self.is_paused,
            limits: self.limits,
            message_configuration: self.message_configuration,
            name: self.name,
            schedule: self.schedule,
            segment_id: self.segment_id,
            segment_version: self.segment_version,
            tags: self.tags,
            template_configuration: self.template_configuration,
            treatment_description: self.treatment_description,
            treatment_name: self.treatment_name,
            priority: self.priority,
        }
    }
}
