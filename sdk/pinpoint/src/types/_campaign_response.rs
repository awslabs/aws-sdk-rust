// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides information about the status, configuration, and other settings for a campaign.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct CampaignResponse  {
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    pub additional_treatments: ::std::option::Option<::std::vec::Vec::<crate::types::TreatmentResource>>,
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub application_id: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub arn: ::std::option::Option<::std::string::String>,
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    pub creation_date: ::std::option::Option<::std::string::String>,
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    pub custom_delivery_configuration: ::std::option::Option<crate::types::CustomDeliveryConfiguration>,
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    pub default_state: ::std::option::Option<crate::types::CampaignState>,
    /// <p>The custom description of the campaign.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub holdout_percent: ::std::option::Option<i32>,
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub hook: ::std::option::Option<crate::types::CampaignHook>,
    /// <p>The unique identifier for the campaign.</p>
    pub id: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub is_paused: ::std::option::Option<bool>,
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    pub last_modified_date: ::std::option::Option<::std::string::String>,
    /// <p>The messaging limits for the campaign.</p>
    pub limits: ::std::option::Option<crate::types::CampaignLimits>,
    /// <p>The message configuration settings for the campaign.</p>
    pub message_configuration: ::std::option::Option<crate::types::MessageConfiguration>,
    /// <p>The name of the campaign.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The schedule settings for the campaign.</p>
    pub schedule: ::std::option::Option<crate::types::Schedule>,
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    pub segment_id: ::std::option::Option<::std::string::String>,
    /// <p>The version number of the segment that's associated with the campaign.</p>
    pub segment_version: ::std::option::Option<i32>,
    /// <p>The current status of the campaign.</p>
    pub state: ::std::option::Option<crate::types::CampaignState>,
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub tags: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>,
    /// <p>The message template that’s used for the campaign.</p>
    pub template_configuration: ::std::option::Option<crate::types::TemplateConfiguration>,
    /// <p>The custom description of the default treatment for the campaign.</p>
    pub treatment_description: ::std::option::Option<::std::string::String>,
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub treatment_name: ::std::option::Option<::std::string::String>,
    /// <p>The version number of the campaign.</p>
    pub version: ::std::option::Option<i32>,
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub priority: ::std::option::Option<i32>,
}
impl  CampaignResponse  {
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    /// 
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.additional_treatments.is_none()`.
    pub fn additional_treatments(&self) -> & [crate::types::TreatmentResource] {
        self.additional_treatments.as_deref()
        .unwrap_or_default()
    }
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn application_id(&self) -> ::std::option::Option<& str> {
        self.application_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub fn arn(&self) -> ::std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    pub fn creation_date(&self) -> ::std::option::Option<& str> {
        self.creation_date.as_deref()
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    pub fn custom_delivery_configuration(&self) -> ::std::option::Option<& crate::types::CustomDeliveryConfiguration> {
        self.custom_delivery_configuration.as_ref()
    }
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    pub fn default_state(&self) -> ::std::option::Option<& crate::types::CampaignState> {
        self.default_state.as_ref()
    }
    /// <p>The custom description of the campaign.</p>
    pub fn description(&self) -> ::std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn holdout_percent(&self) -> ::std::option::Option<i32> {
        self.holdout_percent
    }
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn hook(&self) -> ::std::option::Option<& crate::types::CampaignHook> {
        self.hook.as_ref()
    }
    /// <p>The unique identifier for the campaign.</p>
    pub fn id(&self) -> ::std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn is_paused(&self) -> ::std::option::Option<bool> {
        self.is_paused
    }
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    pub fn last_modified_date(&self) -> ::std::option::Option<& str> {
        self.last_modified_date.as_deref()
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn limits(&self) -> ::std::option::Option<& crate::types::CampaignLimits> {
        self.limits.as_ref()
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn message_configuration(&self) -> ::std::option::Option<& crate::types::MessageConfiguration> {
        self.message_configuration.as_ref()
    }
    /// <p>The name of the campaign.</p>
    pub fn name(&self) -> ::std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn schedule(&self) -> ::std::option::Option<& crate::types::Schedule> {
        self.schedule.as_ref()
    }
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    pub fn segment_id(&self) -> ::std::option::Option<& str> {
        self.segment_id.as_deref()
    }
    /// <p>The version number of the segment that's associated with the campaign.</p>
    pub fn segment_version(&self) -> ::std::option::Option<i32> {
        self.segment_version
    }
    /// <p>The current status of the campaign.</p>
    pub fn state(&self) -> ::std::option::Option<& crate::types::CampaignState> {
        self.state.as_ref()
    }
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn tags(&self) -> ::std::option::Option<& ::std::collections::HashMap::<::std::string::String, ::std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The message template that’s used for the campaign.</p>
    pub fn template_configuration(&self) -> ::std::option::Option<& crate::types::TemplateConfiguration> {
        self.template_configuration.as_ref()
    }
    /// <p>The custom description of the default treatment for the campaign.</p>
    pub fn treatment_description(&self) -> ::std::option::Option<& str> {
        self.treatment_description.as_deref()
    }
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn treatment_name(&self) -> ::std::option::Option<& str> {
        self.treatment_name.as_deref()
    }
    /// <p>The version number of the campaign.</p>
    pub fn version(&self) -> ::std::option::Option<i32> {
        self.version
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn priority(&self) -> ::std::option::Option<i32> {
        self.priority
    }
}
impl CampaignResponse {
    /// Creates a new builder-style object to manufacture [`CampaignResponse`](crate::types::CampaignResponse).
    pub fn builder() -> crate::types::builders::CampaignResponseBuilder {
        crate::types::builders::CampaignResponseBuilder::default()
    }
}

/// A builder for [`CampaignResponse`](crate::types::CampaignResponse).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct CampaignResponseBuilder {
    pub(crate) additional_treatments: ::std::option::Option<::std::vec::Vec::<crate::types::TreatmentResource>>,
    pub(crate) application_id: ::std::option::Option<::std::string::String>,
    pub(crate) arn: ::std::option::Option<::std::string::String>,
    pub(crate) creation_date: ::std::option::Option<::std::string::String>,
    pub(crate) custom_delivery_configuration: ::std::option::Option<crate::types::CustomDeliveryConfiguration>,
    pub(crate) default_state: ::std::option::Option<crate::types::CampaignState>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) holdout_percent: ::std::option::Option<i32>,
    pub(crate) hook: ::std::option::Option<crate::types::CampaignHook>,
    pub(crate) id: ::std::option::Option<::std::string::String>,
    pub(crate) is_paused: ::std::option::Option<bool>,
    pub(crate) last_modified_date: ::std::option::Option<::std::string::String>,
    pub(crate) limits: ::std::option::Option<crate::types::CampaignLimits>,
    pub(crate) message_configuration: ::std::option::Option<crate::types::MessageConfiguration>,
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) schedule: ::std::option::Option<crate::types::Schedule>,
    pub(crate) segment_id: ::std::option::Option<::std::string::String>,
    pub(crate) segment_version: ::std::option::Option<i32>,
    pub(crate) state: ::std::option::Option<crate::types::CampaignState>,
    pub(crate) tags: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>,
    pub(crate) template_configuration: ::std::option::Option<crate::types::TemplateConfiguration>,
    pub(crate) treatment_description: ::std::option::Option<::std::string::String>,
    pub(crate) treatment_name: ::std::option::Option<::std::string::String>,
    pub(crate) version: ::std::option::Option<i32>,
    pub(crate) priority: ::std::option::Option<i32>,
}
impl CampaignResponseBuilder {
    /// Appends an item to `additional_treatments`.
    ///
    /// To override the contents of this collection use [`set_additional_treatments`](Self::set_additional_treatments).
    ///
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    pub fn additional_treatments(mut self, input: crate::types::TreatmentResource) -> Self {
        let mut v = self.additional_treatments.unwrap_or_default();
                        v.push(input);
                        self.additional_treatments = ::std::option::Option::Some(v);
                        self
    }
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    pub fn set_additional_treatments(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::types::TreatmentResource>>) -> Self {
        self.additional_treatments = input; self
    }
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    pub fn get_additional_treatments(&self) -> &::std::option::Option<::std::vec::Vec::<crate::types::TreatmentResource>> {
        &self.additional_treatments
    }
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    /// This field is required.
    pub fn application_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.application_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn set_application_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.application_id = input; self
    }
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn get_application_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.application_id
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    /// This field is required.
    pub fn arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub fn set_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.arn = input; self
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub fn get_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.arn
    }
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    /// This field is required.
    pub fn creation_date(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.creation_date = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    pub fn set_creation_date(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.creation_date = input; self
    }
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    pub fn get_creation_date(&self) -> &::std::option::Option<::std::string::String> {
        &self.creation_date
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    pub fn custom_delivery_configuration(mut self, input: crate::types::CustomDeliveryConfiguration) -> Self {
        self.custom_delivery_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    pub fn set_custom_delivery_configuration(mut self, input: ::std::option::Option<crate::types::CustomDeliveryConfiguration>) -> Self {
        self.custom_delivery_configuration = input; self
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    pub fn get_custom_delivery_configuration(&self) -> &::std::option::Option<crate::types::CustomDeliveryConfiguration> {
        &self.custom_delivery_configuration
    }
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    pub fn default_state(mut self, input: crate::types::CampaignState) -> Self {
        self.default_state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    pub fn set_default_state(mut self, input: ::std::option::Option<crate::types::CampaignState>) -> Self {
        self.default_state = input; self
    }
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    pub fn get_default_state(&self) -> &::std::option::Option<crate::types::CampaignState> {
        &self.default_state
    }
    /// <p>The custom description of the campaign.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The custom description of the campaign.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input; self
    }
    /// <p>The custom description of the campaign.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn holdout_percent(mut self, input: i32) -> Self {
        self.holdout_percent = ::std::option::Option::Some(input);
        self
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn set_holdout_percent(mut self, input: ::std::option::Option<i32>) -> Self {
        self.holdout_percent = input; self
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn get_holdout_percent(&self) -> &::std::option::Option<i32> {
        &self.holdout_percent
    }
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn hook(mut self, input: crate::types::CampaignHook) -> Self {
        self.hook = ::std::option::Option::Some(input);
        self
    }
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn set_hook(mut self, input: ::std::option::Option<crate::types::CampaignHook>) -> Self {
        self.hook = input; self
    }
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn get_hook(&self) -> &::std::option::Option<crate::types::CampaignHook> {
        &self.hook
    }
    /// <p>The unique identifier for the campaign.</p>
    /// This field is required.
    pub fn id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the campaign.</p>
    pub fn set_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.id = input; self
    }
    /// <p>The unique identifier for the campaign.</p>
    pub fn get_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.id
    }
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn is_paused(mut self, input: bool) -> Self {
        self.is_paused = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn set_is_paused(mut self, input: ::std::option::Option<bool>) -> Self {
        self.is_paused = input; self
    }
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn get_is_paused(&self) -> &::std::option::Option<bool> {
        &self.is_paused
    }
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    /// This field is required.
    pub fn last_modified_date(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.last_modified_date = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    pub fn set_last_modified_date(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.last_modified_date = input; self
    }
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    pub fn get_last_modified_date(&self) -> &::std::option::Option<::std::string::String> {
        &self.last_modified_date
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn limits(mut self, input: crate::types::CampaignLimits) -> Self {
        self.limits = ::std::option::Option::Some(input);
        self
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn set_limits(mut self, input: ::std::option::Option<crate::types::CampaignLimits>) -> Self {
        self.limits = input; self
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn get_limits(&self) -> &::std::option::Option<crate::types::CampaignLimits> {
        &self.limits
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn message_configuration(mut self, input: crate::types::MessageConfiguration) -> Self {
        self.message_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn set_message_configuration(mut self, input: ::std::option::Option<crate::types::MessageConfiguration>) -> Self {
        self.message_configuration = input; self
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn get_message_configuration(&self) -> &::std::option::Option<crate::types::MessageConfiguration> {
        &self.message_configuration
    }
    /// <p>The name of the campaign.</p>
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the campaign.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input; self
    }
    /// <p>The name of the campaign.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn schedule(mut self, input: crate::types::Schedule) -> Self {
        self.schedule = ::std::option::Option::Some(input);
        self
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn set_schedule(mut self, input: ::std::option::Option<crate::types::Schedule>) -> Self {
        self.schedule = input; self
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn get_schedule(&self) -> &::std::option::Option<crate::types::Schedule> {
        &self.schedule
    }
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    /// This field is required.
    pub fn segment_id(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.segment_id = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    pub fn set_segment_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.segment_id = input; self
    }
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    pub fn get_segment_id(&self) -> &::std::option::Option<::std::string::String> {
        &self.segment_id
    }
    /// <p>The version number of the segment that's associated with the campaign.</p>
    /// This field is required.
    pub fn segment_version(mut self, input: i32) -> Self {
        self.segment_version = ::std::option::Option::Some(input);
        self
    }
    /// <p>The version number of the segment that's associated with the campaign.</p>
    pub fn set_segment_version(mut self, input: ::std::option::Option<i32>) -> Self {
        self.segment_version = input; self
    }
    /// <p>The version number of the segment that's associated with the campaign.</p>
    pub fn get_segment_version(&self) -> &::std::option::Option<i32> {
        &self.segment_version
    }
    /// <p>The current status of the campaign.</p>
    pub fn state(mut self, input: crate::types::CampaignState) -> Self {
        self.state = ::std::option::Option::Some(input);
        self
    }
    /// <p>The current status of the campaign.</p>
    pub fn set_state(mut self, input: ::std::option::Option<crate::types::CampaignState>) -> Self {
        self.state = input; self
    }
    /// <p>The current status of the campaign.</p>
    pub fn get_state(&self) -> &::std::option::Option<crate::types::CampaignState> {
        &self.state
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
                        hash_map.insert(k.into(), v.into());
                        self.tags = ::std::option::Option::Some(hash_map);
                        self
    }
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>) -> Self {
        self.tags = input; self
    }
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>> {
        &self.tags
    }
    /// <p>The message template that’s used for the campaign.</p>
    pub fn template_configuration(mut self, input: crate::types::TemplateConfiguration) -> Self {
        self.template_configuration = ::std::option::Option::Some(input);
        self
    }
    /// <p>The message template that’s used for the campaign.</p>
    pub fn set_template_configuration(mut self, input: ::std::option::Option<crate::types::TemplateConfiguration>) -> Self {
        self.template_configuration = input; self
    }
    /// <p>The message template that’s used for the campaign.</p>
    pub fn get_template_configuration(&self) -> &::std::option::Option<crate::types::TemplateConfiguration> {
        &self.template_configuration
    }
    /// <p>The custom description of the default treatment for the campaign.</p>
    pub fn treatment_description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.treatment_description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The custom description of the default treatment for the campaign.</p>
    pub fn set_treatment_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.treatment_description = input; self
    }
    /// <p>The custom description of the default treatment for the campaign.</p>
    pub fn get_treatment_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.treatment_description
    }
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn treatment_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.treatment_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn set_treatment_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.treatment_name = input; self
    }
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn get_treatment_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.treatment_name
    }
    /// <p>The version number of the campaign.</p>
    pub fn version(mut self, input: i32) -> Self {
        self.version = ::std::option::Option::Some(input);
        self
    }
    /// <p>The version number of the campaign.</p>
    pub fn set_version(mut self, input: ::std::option::Option<i32>) -> Self {
        self.version = input; self
    }
    /// <p>The version number of the campaign.</p>
    pub fn get_version(&self) -> &::std::option::Option<i32> {
        &self.version
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn priority(mut self, input: i32) -> Self {
        self.priority = ::std::option::Option::Some(input);
        self
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn set_priority(mut self, input: ::std::option::Option<i32>) -> Self {
        self.priority = input; self
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn get_priority(&self) -> &::std::option::Option<i32> {
        &self.priority
    }
    /// Consumes the builder and constructs a [`CampaignResponse`](crate::types::CampaignResponse).
    pub fn build(self) -> crate::types::CampaignResponse {
        crate::types::CampaignResponse {
            additional_treatments: self.additional_treatments
            ,
            application_id: self.application_id
            ,
            arn: self.arn
            ,
            creation_date: self.creation_date
            ,
            custom_delivery_configuration: self.custom_delivery_configuration
            ,
            default_state: self.default_state
            ,
            description: self.description
            ,
            holdout_percent: self.holdout_percent
            ,
            hook: self.hook
            ,
            id: self.id
            ,
            is_paused: self.is_paused
            ,
            last_modified_date: self.last_modified_date
            ,
            limits: self.limits
            ,
            message_configuration: self.message_configuration
            ,
            name: self.name
            ,
            schedule: self.schedule
            ,
            segment_id: self.segment_id
            ,
            segment_version: self.segment_version
            ,
            state: self.state
            ,
            tags: self.tags
            ,
            template_configuration: self.template_configuration
            ,
            treatment_description: self.treatment_description
            ,
            treatment_name: self.treatment_name
            ,
            version: self.version
            ,
            priority: self.priority
            ,
        }
    }
}

