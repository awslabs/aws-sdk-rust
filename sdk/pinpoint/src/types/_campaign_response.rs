// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Provides information about the status, configuration, and other settings for a campaign.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CampaignResponse  {
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    #[doc(hidden)]
    pub additional_treatments: std::option::Option<std::vec::Vec<crate::types::TreatmentResource>>,
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<std::string::String>,
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    #[doc(hidden)]
    pub custom_delivery_configuration: std::option::Option<crate::types::CustomDeliveryConfiguration>,
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    #[doc(hidden)]
    pub default_state: std::option::Option<crate::types::CampaignState>,
    /// <p>The custom description of the campaign.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    #[doc(hidden)]
    pub holdout_percent: i32,
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    #[doc(hidden)]
    pub hook: std::option::Option<crate::types::CampaignHook>,
    /// <p>The unique identifier for the campaign.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    #[doc(hidden)]
    pub is_paused: bool,
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    #[doc(hidden)]
    pub last_modified_date: std::option::Option<std::string::String>,
    /// <p>The messaging limits for the campaign.</p>
    #[doc(hidden)]
    pub limits: std::option::Option<crate::types::CampaignLimits>,
    /// <p>The message configuration settings for the campaign.</p>
    #[doc(hidden)]
    pub message_configuration: std::option::Option<crate::types::MessageConfiguration>,
    /// <p>The name of the campaign.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The schedule settings for the campaign.</p>
    #[doc(hidden)]
    pub schedule: std::option::Option<crate::types::Schedule>,
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    #[doc(hidden)]
    pub segment_id: std::option::Option<std::string::String>,
    /// <p>The version number of the segment that's associated with the campaign.</p>
    #[doc(hidden)]
    pub segment_version: i32,
    /// <p>The current status of the campaign.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::types::CampaignState>,
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The message template that’s used for the campaign.</p>
    #[doc(hidden)]
    pub template_configuration: std::option::Option<crate::types::TemplateConfiguration>,
    /// <p>The custom description of the default treatment for the campaign.</p>
    #[doc(hidden)]
    pub treatment_description: std::option::Option<std::string::String>,
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    #[doc(hidden)]
    pub treatment_name: std::option::Option<std::string::String>,
    /// <p>The version number of the campaign.</p>
    #[doc(hidden)]
    pub version: i32,
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    #[doc(hidden)]
    pub priority: i32,
}
impl CampaignResponse {
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    pub fn additional_treatments(&self) -> std::option::Option<& [crate::types::TreatmentResource]> {
        self.additional_treatments.as_deref()
    }
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn application_id(&self) -> std::option::Option<& str> {
        self.application_id.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub fn arn(&self) -> std::option::Option<& str> {
        self.arn.as_deref()
    }
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    pub fn creation_date(&self) -> std::option::Option<& str> {
        self.creation_date.as_deref()
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    pub fn custom_delivery_configuration(&self) -> std::option::Option<& crate::types::CustomDeliveryConfiguration> {
        self.custom_delivery_configuration.as_ref()
    }
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    pub fn default_state(&self) -> std::option::Option<& crate::types::CampaignState> {
        self.default_state.as_ref()
    }
    /// <p>The custom description of the campaign.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn holdout_percent(&self) -> i32 {
        self.holdout_percent
    }
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn hook(&self) -> std::option::Option<& crate::types::CampaignHook> {
        self.hook.as_ref()
    }
    /// <p>The unique identifier for the campaign.</p>
    pub fn id(&self) -> std::option::Option<& str> {
        self.id.as_deref()
    }
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn is_paused(&self) -> bool {
        self.is_paused
    }
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    pub fn last_modified_date(&self) -> std::option::Option<& str> {
        self.last_modified_date.as_deref()
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn limits(&self) -> std::option::Option<& crate::types::CampaignLimits> {
        self.limits.as_ref()
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn message_configuration(&self) -> std::option::Option<& crate::types::MessageConfiguration> {
        self.message_configuration.as_ref()
    }
    /// <p>The name of the campaign.</p>
    pub fn name(&self) -> std::option::Option<& str> {
        self.name.as_deref()
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn schedule(&self) -> std::option::Option<& crate::types::Schedule> {
        self.schedule.as_ref()
    }
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    pub fn segment_id(&self) -> std::option::Option<& str> {
        self.segment_id.as_deref()
    }
    /// <p>The version number of the segment that's associated with the campaign.</p>
    pub fn segment_version(&self) -> i32 {
        self.segment_version
    }
    /// <p>The current status of the campaign.</p>
    pub fn state(&self) -> std::option::Option<& crate::types::CampaignState> {
        self.state.as_ref()
    }
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn tags(&self) -> std::option::Option<& std::collections::HashMap<std::string::String, std::string::String>> {
        self.tags.as_ref()
    }
    /// <p>The message template that’s used for the campaign.</p>
    pub fn template_configuration(&self) -> std::option::Option<& crate::types::TemplateConfiguration> {
        self.template_configuration.as_ref()
    }
    /// <p>The custom description of the default treatment for the campaign.</p>
    pub fn treatment_description(&self) -> std::option::Option<& str> {
        self.treatment_description.as_deref()
    }
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn treatment_name(&self) -> std::option::Option<& str> {
        self.treatment_name.as_deref()
    }
    /// <p>The version number of the campaign.</p>
    pub fn version(&self) -> i32 {
        self.version
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn priority(&self) -> i32 {
        self.priority
    }
}
impl CampaignResponse {
    /// Creates a new builder-style object to manufacture [`CampaignResponse`](crate::types::CampaignResponse).
    pub fn builder() -> crate::types::builders::CampaignResponseBuilder {
        crate::types::builders::CampaignResponseBuilder::default()
    }
}

/// A builder for [`CampaignResponse`](crate::types::CampaignResponse).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct CampaignResponseBuilder {
    pub(crate) additional_treatments: std::option::Option<std::vec::Vec<crate::types::TreatmentResource>>,
    pub(crate) application_id: std::option::Option<std::string::String>,
    pub(crate) arn: std::option::Option<std::string::String>,
    pub(crate) creation_date: std::option::Option<std::string::String>,
    pub(crate) custom_delivery_configuration: std::option::Option<crate::types::CustomDeliveryConfiguration>,
    pub(crate) default_state: std::option::Option<crate::types::CampaignState>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) holdout_percent: std::option::Option<i32>,
    pub(crate) hook: std::option::Option<crate::types::CampaignHook>,
    pub(crate) id: std::option::Option<std::string::String>,
    pub(crate) is_paused: std::option::Option<bool>,
    pub(crate) last_modified_date: std::option::Option<std::string::String>,
    pub(crate) limits: std::option::Option<crate::types::CampaignLimits>,
    pub(crate) message_configuration: std::option::Option<crate::types::MessageConfiguration>,
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) schedule: std::option::Option<crate::types::Schedule>,
    pub(crate) segment_id: std::option::Option<std::string::String>,
    pub(crate) segment_version: std::option::Option<i32>,
    pub(crate) state: std::option::Option<crate::types::CampaignState>,
    pub(crate) tags: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    pub(crate) template_configuration: std::option::Option<crate::types::TemplateConfiguration>,
    pub(crate) treatment_description: std::option::Option<std::string::String>,
    pub(crate) treatment_name: std::option::Option<std::string::String>,
    pub(crate) version: std::option::Option<i32>,
    pub(crate) priority: std::option::Option<i32>,
}
impl CampaignResponseBuilder {
    /// Appends an item to `additional_treatments`.
    ///
    /// To override the contents of this collection use [`set_additional_treatments`](Self::set_additional_treatments).
    ///
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    pub fn additional_treatments(mut self, input: crate::types::TreatmentResource) -> Self {
        let mut v = self.additional_treatments.unwrap_or_default();
                        v.push(input);
                        self.additional_treatments = Some(v);
                        self
    }
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    pub fn set_additional_treatments(mut self, input: std::option::Option<std::vec::Vec<crate::types::TreatmentResource>>) -> Self {
        self.additional_treatments = input; self
    }
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.application_id = Some(input.into());
        self
    }
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    pub fn set_application_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.application_id = input; self
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
        self.arn = Some(input.into());
        self
    }
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.arn = input; self
    }
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    pub fn creation_date(mut self, input: impl Into<std::string::String>) -> Self {
        self.creation_date = Some(input.into());
        self
    }
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    pub fn set_creation_date(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.creation_date = input; self
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    pub fn custom_delivery_configuration(mut self, input: crate::types::CustomDeliveryConfiguration) -> Self {
        self.custom_delivery_configuration = Some(input);
        self
    }
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    pub fn set_custom_delivery_configuration(mut self, input: std::option::Option<crate::types::CustomDeliveryConfiguration>) -> Self {
        self.custom_delivery_configuration = input; self
    }
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    pub fn default_state(mut self, input: crate::types::CampaignState) -> Self {
        self.default_state = Some(input);
        self
    }
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    pub fn set_default_state(mut self, input: std::option::Option<crate::types::CampaignState>) -> Self {
        self.default_state = input; self
    }
    /// <p>The custom description of the campaign.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>The custom description of the campaign.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input; self
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn holdout_percent(mut self, input: i32) -> Self {
        self.holdout_percent = Some(input);
        self
    }
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    pub fn set_holdout_percent(mut self, input: std::option::Option<i32>) -> Self {
        self.holdout_percent = input; self
    }
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn hook(mut self, input: crate::types::CampaignHook) -> Self {
        self.hook = Some(input);
        self
    }
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    pub fn set_hook(mut self, input: std::option::Option<crate::types::CampaignHook>) -> Self {
        self.hook = input; self
    }
    /// <p>The unique identifier for the campaign.</p>
    pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
        self.id = Some(input.into());
        self
    }
    /// <p>The unique identifier for the campaign.</p>
    pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.id = input; self
    }
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn is_paused(mut self, input: bool) -> Self {
        self.is_paused = Some(input);
        self
    }
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    pub fn set_is_paused(mut self, input: std::option::Option<bool>) -> Self {
        self.is_paused = input; self
    }
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    pub fn last_modified_date(mut self, input: impl Into<std::string::String>) -> Self {
        self.last_modified_date = Some(input.into());
        self
    }
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    pub fn set_last_modified_date(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.last_modified_date = input; self
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn limits(mut self, input: crate::types::CampaignLimits) -> Self {
        self.limits = Some(input);
        self
    }
    /// <p>The messaging limits for the campaign.</p>
    pub fn set_limits(mut self, input: std::option::Option<crate::types::CampaignLimits>) -> Self {
        self.limits = input; self
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn message_configuration(mut self, input: crate::types::MessageConfiguration) -> Self {
        self.message_configuration = Some(input);
        self
    }
    /// <p>The message configuration settings for the campaign.</p>
    pub fn set_message_configuration(mut self, input: std::option::Option<crate::types::MessageConfiguration>) -> Self {
        self.message_configuration = input; self
    }
    /// <p>The name of the campaign.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the campaign.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input; self
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn schedule(mut self, input: crate::types::Schedule) -> Self {
        self.schedule = Some(input);
        self
    }
    /// <p>The schedule settings for the campaign.</p>
    pub fn set_schedule(mut self, input: std::option::Option<crate::types::Schedule>) -> Self {
        self.schedule = input; self
    }
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    pub fn segment_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.segment_id = Some(input.into());
        self
    }
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    pub fn set_segment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.segment_id = input; self
    }
    /// <p>The version number of the segment that's associated with the campaign.</p>
    pub fn segment_version(mut self, input: i32) -> Self {
        self.segment_version = Some(input);
        self
    }
    /// <p>The version number of the segment that's associated with the campaign.</p>
    pub fn set_segment_version(mut self, input: std::option::Option<i32>) -> Self {
        self.segment_version = input; self
    }
    /// <p>The current status of the campaign.</p>
    pub fn state(mut self, input: crate::types::CampaignState) -> Self {
        self.state = Some(input);
        self
    }
    /// <p>The current status of the campaign.</p>
    pub fn set_state(mut self, input: std::option::Option<crate::types::CampaignState>) -> Self {
        self.state = input; self
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn tags(mut self, k: impl Into<std::string::String>, v: impl Into<std::string::String>) -> Self {
        let mut hash_map = self.tags.unwrap_or_default();
                        hash_map.insert(k.into(), v.into());
                        self.tags = Some(hash_map);
                        self
    }
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    pub fn set_tags(mut self, input: std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>) -> Self {
        self.tags = input; self
    }
    /// <p>The message template that’s used for the campaign.</p>
    pub fn template_configuration(mut self, input: crate::types::TemplateConfiguration) -> Self {
        self.template_configuration = Some(input);
        self
    }
    /// <p>The message template that’s used for the campaign.</p>
    pub fn set_template_configuration(mut self, input: std::option::Option<crate::types::TemplateConfiguration>) -> Self {
        self.template_configuration = input; self
    }
    /// <p>The custom description of the default treatment for the campaign.</p>
    pub fn treatment_description(mut self, input: impl Into<std::string::String>) -> Self {
        self.treatment_description = Some(input.into());
        self
    }
    /// <p>The custom description of the default treatment for the campaign.</p>
    pub fn set_treatment_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.treatment_description = input; self
    }
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn treatment_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.treatment_name = Some(input.into());
        self
    }
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    pub fn set_treatment_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.treatment_name = input; self
    }
    /// <p>The version number of the campaign.</p>
    pub fn version(mut self, input: i32) -> Self {
        self.version = Some(input);
        self
    }
    /// <p>The version number of the campaign.</p>
    pub fn set_version(mut self, input: std::option::Option<i32>) -> Self {
        self.version = input; self
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn priority(mut self, input: i32) -> Self {
        self.priority = Some(input);
        self
    }
    /// <p>Defines the priority of the campaign, used to decide the order of messages displayed to user if there are multiple messages scheduled to be displayed at the same moment.</p>
    pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
        self.priority = input; self
    }
    /// Consumes the builder and constructs a [`CampaignResponse`](crate::types::CampaignResponse).
    pub fn build(self) -> crate::types::CampaignResponse {
        crate::types::CampaignResponse {
            additional_treatments: self.additional_treatments
            ,
            application_id: self.application_id
            ,
            arn: self.arn
            ,
            creation_date: self.creation_date
            ,
            custom_delivery_configuration: self.custom_delivery_configuration
            ,
            default_state: self.default_state
            ,
            description: self.description
            ,
            holdout_percent: self.holdout_percent
                .unwrap_or_default()
            ,
            hook: self.hook
            ,
            id: self.id
            ,
            is_paused: self.is_paused
                .unwrap_or_default()
            ,
            last_modified_date: self.last_modified_date
            ,
            limits: self.limits
            ,
            message_configuration: self.message_configuration
            ,
            name: self.name
            ,
            schedule: self.schedule
            ,
            segment_id: self.segment_id
            ,
            segment_version: self.segment_version
                .unwrap_or_default()
            ,
            state: self.state
            ,
            tags: self.tags
            ,
            template_configuration: self.template_configuration
            ,
            treatment_description: self.treatment_description
            ,
            treatment_name: self.treatment_name
            ,
            version: self.version
                .unwrap_or_default()
            ,
            priority: self.priority
                .unwrap_or_default()
            ,
        }
    }
}

