// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>The maximum number of alarms for a deployment group (10) was exceeded.</p>
    AlarmsLimitExceededException(crate::error::AlarmsLimitExceededException),
    /// <p>An application with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    ApplicationAlreadyExistsException(crate::error::ApplicationAlreadyExistsException),
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>More applications were attempted to be created than are allowed.</p>
    ApplicationLimitExceededException(crate::error::ApplicationLimitExceededException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p> The specified ARN is not supported. For example, it might be an ARN for a resource that is not expected. </p>
    ArnNotSupportedException(crate::error::ArnNotSupportedException),
    /// <p>The maximum number of names or IDs allowed for this request (100) was exceeded.</p>
    BatchLimitExceededException(crate::error::BatchLimitExceededException),
    /// <p>A bucket name is required, but was not provided.</p>
    BucketNameFilterRequiredException(crate::error::BucketNameFilterRequiredException),
    /// <p>The deployment is already complete.</p>
    DeploymentAlreadyCompletedException(crate::error::DeploymentAlreadyCompletedException),
    /// <p>A deployment configuration with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    DeploymentConfigAlreadyExistsException(crate::error::DeploymentConfigAlreadyExistsException),
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::error::DeploymentConfigDoesNotExistException),
    /// <p>The deployment configuration is still in use.</p>
    DeploymentConfigInUseException(crate::error::DeploymentConfigInUseException),
    /// <p>The deployment configurations limit was exceeded.</p>
    DeploymentConfigLimitExceededException(crate::error::DeploymentConfigLimitExceededException),
    /// <p>The deployment configuration name was not specified.</p>
    DeploymentConfigNameRequiredException(crate::error::DeploymentConfigNameRequiredException),
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>A deployment group with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    DeploymentGroupAlreadyExistsException(crate::error::DeploymentGroupAlreadyExistsException),
    /// <p>The named deployment group with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentGroupDoesNotExistException(crate::error::DeploymentGroupDoesNotExistException),
    /// <p> The deployment groups limit was exceeded.</p>
    DeploymentGroupLimitExceededException(crate::error::DeploymentGroupLimitExceededException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::error::DeploymentGroupNameRequiredException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>The deployment does not have a status of Ready and can't continue yet.</p>
    DeploymentIsNotInReadyStateException(crate::error::DeploymentIsNotInReadyStateException),
    /// <p>The number of allowed deployments was exceeded.</p>
    DeploymentLimitExceededException(crate::error::DeploymentLimitExceededException),
    /// <p>The specified deployment has not started.</p>
    DeploymentNotStartedException(crate::error::DeploymentNotStartedException),
    /// <p> The provided target ID does not belong to the attempted deployment. </p>
    DeploymentTargetDoesNotExistException(crate::error::DeploymentTargetDoesNotExistException),
    /// <p> A deployment target ID was not provided. </p>
    DeploymentTargetIdRequiredException(crate::error::DeploymentTargetIdRequiredException),
    /// <p> The maximum number of targets that can be associated with an Amazon ECS or Lambda deployment was exceeded. The target list of both types of deployments must have exactly one item. This exception does not apply to EC2/On-premises deployments. </p>
    DeploymentTargetListSizeExceededException(crate::error::DeploymentTargetListSizeExceededException),
    /// <p>The description is too long.</p>
    DescriptionTooLongException(crate::error::DescriptionTooLongException),
    /// <p> The Amazon ECS service is associated with more than one deployment groups. An Amazon ECS service can be associated with only one deployment group. </p>
    EcsServiceMappingLimitExceededException(crate::error::EcsServiceMappingLimitExceededException),
    /// <p>No GitHub account connection exists with the named specified in the call.</p>
    GitHubAccountTokenDoesNotExistException(crate::error::GitHubAccountTokenDoesNotExistException),
    /// <p>The call is missing a required GitHub account connection name.</p>
    GitHubAccountTokenNameRequiredException(crate::error::GitHubAccountTokenNameRequiredException),
    /// <p>No IAM ARN was included in the request. You must use an IAM session ARN or IAM user ARN in the request.</p>
    IamArnRequiredException(crate::error::IamArnRequiredException),
    /// <p>The request included an IAM session ARN that has already been used to register a different instance.</p>
    IamSessionArnAlreadyRegisteredException(crate::error::IamSessionArnAlreadyRegisteredException),
    /// <p>The specified IAM user ARN is already registered with an on-premises instance.</p>
    IamUserArnAlreadyRegisteredException(crate::error::IamUserArnAlreadyRegisteredException),
    /// <p>An IAM user ARN was not specified.</p>
    IamUserArnRequiredException(crate::error::IamUserArnRequiredException),
    /// <p>The specified instance does not exist in the deployment group.</p>
    #[deprecated(note = "This exception is deprecated, use DeploymentTargetDoesNotExistException instead.")]
    InstanceDoesNotExistException(crate::error::InstanceDoesNotExistException),
    /// <p>The instance ID was not specified.</p>
    #[deprecated(note = "This exception is deprecated, use DeploymentTargetIdRequiredException instead.")]
    InstanceIdRequiredException(crate::error::InstanceIdRequiredException),
    /// <p>The maximum number of allowed on-premises instances in a single call was exceeded.</p>
    InstanceLimitExceededException(crate::error::InstanceLimitExceededException),
    /// <p>The specified on-premises instance name is already registered.</p>
    InstanceNameAlreadyRegisteredException(crate::error::InstanceNameAlreadyRegisteredException),
    /// <p>An on-premises instance name was not specified.</p>
    InstanceNameRequiredException(crate::error::InstanceNameRequiredException),
    /// <p>The specified on-premises instance is not registered.</p>
    InstanceNotRegisteredException(crate::error::InstanceNotRegisteredException),
    /// <p>The format of the alarm configuration is invalid. Possible causes include:</p> 
    /// <ul> 
    /// <li> <p>The alarm list is null.</p> </li> 
    /// <li> <p>The alarm object is null.</p> </li> 
    /// <li> <p>The alarm name is empty or null or exceeds the limit of 255 characters.</p> </li> 
    /// <li> <p>Two alarms with the same name have been specified.</p> </li> 
    /// <li> <p>The alarm configuration is enabled, but the alarm list is empty.</p> </li> 
    /// </ul>
    InvalidAlarmConfigException(crate::error::InvalidAlarmConfigException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p> The specified ARN is not in a valid format. </p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The automatic rollback configuration was specified in an invalid format. For example, automatic rollback is enabled, but an invalid triggering event type or no event types were listed.</p>
    InvalidAutoRollbackConfigException(crate::error::InvalidAutoRollbackConfigException),
    /// <p>The Auto Scaling group was specified in an invalid format or does not exist.</p>
    InvalidAutoScalingGroupException(crate::error::InvalidAutoScalingGroupException),
    /// <p>The configuration for the blue/green deployment group was provided in an invalid format. For information about deployment configuration format, see <code>CreateDeploymentConfig</code>.</p>
    InvalidBlueGreenDeploymentConfigurationException(crate::error::InvalidBlueGreenDeploymentConfigurationException),
    /// <p>The bucket name either doesn't exist or was specified in an invalid format.</p>
    InvalidBucketNameFilterException(crate::error::InvalidBucketNameFilterException),
    /// <p>The computePlatform is invalid. The computePlatform should be <code>Lambda</code>, <code>Server</code>, or <code>ECS</code>.</p>
    InvalidComputePlatformException(crate::error::InvalidComputePlatformException),
    /// <p>The deployed state filter was specified in an invalid format.</p>
    InvalidDeployedStateFilterException(crate::error::InvalidDeployedStateFilterException),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::error::InvalidDeploymentConfigNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::error::InvalidDeploymentGroupNameException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p>An instance type was specified for an in-place deployment. Instance types are supported for blue/green deployments only.</p>
    InvalidDeploymentInstanceTypeException(crate::error::InvalidDeploymentInstanceTypeException),
    /// <p>The specified deployment status doesn't exist or cannot be determined.</p>
    InvalidDeploymentStatusException(crate::error::InvalidDeploymentStatusException),
    /// <p>An invalid deployment style was specified. Valid deployment types include "IN_PLACE" and "BLUE_GREEN." Valid deployment options include "WITH_TRAFFIC_CONTROL" and "WITHOUT_TRAFFIC_CONTROL."</p>
    InvalidDeploymentStyleException(crate::error::InvalidDeploymentStyleException),
    /// <p> The target ID provided was not valid. </p>
    InvalidDeploymentTargetIdException(crate::error::InvalidDeploymentTargetIdException),
    /// <p> The wait type is invalid. </p>
    InvalidDeploymentWaitTypeException(crate::error::InvalidDeploymentWaitTypeException),
    /// <p>A call was submitted that specified both Ec2TagFilters and Ec2TagSet, but only one of these data types can be used in a single call.</p>
    InvalidEc2TagCombinationException(crate::error::InvalidEc2TagCombinationException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidEc2TagException(crate::error::InvalidEc2TagException),
    /// <p> The Amazon ECS service identifier is not valid. </p>
    InvalidEcsServiceException(crate::error::InvalidEcsServiceException),
    /// <p>The external ID was specified in an invalid format.</p>
    InvalidExternalIdException(crate::error::InvalidExternalIdException),
    /// <p>An invalid fileExistsBehavior option was specified to determine how CodeDeploy handles files or directories that already exist in a deployment target location, but weren't part of the previous successful deployment. Valid values include "DISALLOW," "OVERWRITE," and "RETAIN."</p>
    InvalidFileExistsBehaviorException(crate::error::InvalidFileExistsBehaviorException),
    /// <p>The GitHub token is not valid.</p>
    InvalidGitHubAccountTokenException(crate::error::InvalidGitHubAccountTokenException),
    /// <p>The format of the specified GitHub account connection name is invalid.</p>
    InvalidGitHubAccountTokenNameException(crate::error::InvalidGitHubAccountTokenNameException),
    /// <p>The IAM session ARN was specified in an invalid format.</p>
    InvalidIamSessionArnException(crate::error::InvalidIamSessionArnException),
    /// <p>The IAM user ARN was specified in an invalid format.</p>
    InvalidIamUserArnException(crate::error::InvalidIamUserArnException),
    /// <p>The IgnoreApplicationStopFailures value is invalid. For Lambda deployments, <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code> or <code>false</code> is expected.</p>
    InvalidIgnoreApplicationStopFailuresValueException(crate::error::InvalidIgnoreApplicationStopFailuresValueException),
    /// <p>The input was specified in an invalid format.</p>
    InvalidInputException(crate::error::InvalidInputException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// <p>The specified instance status does not exist.</p>
    InvalidInstanceStatusException(crate::error::InvalidInstanceStatusException),
    /// <p>An invalid instance type was specified for instances in a blue/green deployment. Valid values include "Blue" for an original environment and "Green" for a replacement environment.</p>
    InvalidInstanceTypeException(crate::error::InvalidInstanceTypeException),
    /// <p>The specified key prefix filter was specified in an invalid format.</p>
    InvalidKeyPrefixFilterException(crate::error::InvalidKeyPrefixFilterException),
    /// <p>A lifecycle event hook is invalid. Review the <code>hooks</code> section in your AppSpec file to ensure the lifecycle events and <code>hooks</code> functions are valid.</p>
    InvalidLifecycleEventHookExecutionIdException(crate::error::InvalidLifecycleEventHookExecutionIdException),
    /// <p>The result of a Lambda validation function that verifies a lifecycle event is invalid. It should return <code>Succeeded</code> or <code>Failed</code>.</p>
    InvalidLifecycleEventHookExecutionStatusException(crate::error::InvalidLifecycleEventHookExecutionStatusException),
    /// <p>An invalid load balancer name, or no load balancer name, was specified.</p>
    InvalidLoadBalancerInfoException(crate::error::InvalidLoadBalancerInfoException),
    /// <p>The minimum healthy instance value was specified in an invalid format.</p>
    InvalidMinimumHealthyHostValueException(crate::error::InvalidMinimumHealthyHostValueException),
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>A call was submitted that specified both OnPremisesTagFilters and OnPremisesTagSet, but only one of these data types can be used in a single call.</p>
    InvalidOnPremisesTagCombinationException(crate::error::InvalidOnPremisesTagCombinationException),
    /// <p>An invalid operation was detected.</p>
    InvalidOperationException(crate::error::InvalidOperationException),
    /// <p>The registration status was specified in an invalid format.</p>
    InvalidRegistrationStatusException(crate::error::InvalidRegistrationStatusException),
    /// <p>The revision was specified in an invalid format.</p>
    InvalidRevisionException(crate::error::InvalidRevisionException),
    /// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
    InvalidRoleException(crate::error::InvalidRoleException),
    /// <p>The column name to sort by is either not present or was specified in an invalid format.</p>
    InvalidSortByException(crate::error::InvalidSortByException),
    /// <p>The sort order was specified in an invalid format.</p>
    InvalidSortOrderException(crate::error::InvalidSortOrderException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p>The tag filter was specified in an invalid format.</p>
    InvalidTagFilterException(crate::error::InvalidTagFilterException),
    /// <p> The specified tags are not valid. </p>
    InvalidTagsToAddException(crate::error::InvalidTagsToAddException),
    /// <p> The target filter name is invalid. </p>
    InvalidTargetFilterNameException(crate::error::InvalidTargetFilterNameException),
    /// <p> A target group pair associated with this deployment is not valid. </p>
    InvalidTargetGroupPairException(crate::error::InvalidTargetGroupPairException),
    /// <p>The target instance configuration is invalid. Possible causes include:</p> 
    /// <ul> 
    /// <li> <p>Configuration data for target instances was entered for an in-place deployment.</p> </li> 
    /// <li> <p>The limit of 10 tags for a tag type was exceeded.</p> </li> 
    /// <li> <p>The combined length of the tag names exceeded the limit. </p> </li> 
    /// <li> <p>A specified tag is not currently applied to any instances.</p> </li> 
    /// </ul>
    InvalidTargetInstancesException(crate::error::InvalidTargetInstancesException),
    /// <p>The specified time range was specified in an invalid format.</p>
    InvalidTimeRangeException(crate::error::InvalidTimeRangeException),
    /// <p> The configuration that specifies how traffic is routed during a deployment is invalid.</p>
    InvalidTrafficRoutingConfigurationException(crate::error::InvalidTrafficRoutingConfigurationException),
    /// <p>The trigger was specified in an invalid format.</p>
    InvalidTriggerConfigException(crate::error::InvalidTriggerConfigException),
    /// <p>The UpdateOutdatedInstancesOnly value is invalid. For Lambda deployments, <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code> or <code>false</code> is expected.</p>
    InvalidUpdateOutdatedInstancesOnlyValueException(crate::error::InvalidUpdateOutdatedInstancesOnlyValueException),
    /// <p>An attempt to return the status of an already completed lifecycle event occurred.</p>
    LifecycleEventAlreadyCompletedException(crate::error::LifecycleEventAlreadyCompletedException),
    /// <p>The limit for lifecycle hooks was exceeded.</p>
    LifecycleHookLimitExceededException(crate::error::LifecycleHookLimitExceededException),
    /// <p>Both an IAM user ARN and an IAM session ARN were included in the request. Use only one ARN type.</p>
    MultipleIamArnsProvidedException(crate::error::MultipleIamArnsProvidedException),
    /// <p>The API used does not support the deployment.</p>
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    /// <p> The ARN of a resource is required, but was not found. </p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// <p>The specified resource could not be validated.</p>
    ResourceValidationException(crate::error::ResourceValidationException),
    /// <p>The named revision does not exist with the IAM user or Amazon Web Services account.</p>
    RevisionDoesNotExistException(crate::error::RevisionDoesNotExistException),
    /// <p>The revision ID was not specified.</p>
    RevisionRequiredException(crate::error::RevisionRequiredException),
    /// <p>The role ID was not specified.</p>
    RoleRequiredException(crate::error::RoleRequiredException),
    /// <p>The maximum allowed number of tags was exceeded.</p>
    TagLimitExceededException(crate::error::TagLimitExceededException),
    /// <p>A tag was not specified.</p>
    TagRequiredException(crate::error::TagRequiredException),
    /// <p>The number of tag groups included in the tag set list exceeded the maximum allowed limit of 3.</p>
    TagSetListLimitExceededException(crate::error::TagSetListLimitExceededException),
    /// <p>An API function was called too frequently.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The maximum allowed number of triggers was exceeded.</p>
    TriggerTargetsLimitExceededException(crate::error::TriggerTargetsLimitExceededException),
    /// <p>A call was submitted that is not supported for the specified deployment type.</p>
    UnsupportedActionForDeploymentTypeException(crate::error::UnsupportedActionForDeploymentTypeException),
    /// 
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    /// 
    /// When logging an error from the SDK, it is recommended that you either wrap the error in
    /// [`DisplayErrorContext`](crate::types::DisplayErrorContext), use another
    /// error reporter library that visits the error's cause/source chain, or call
    /// [`Error::source`](std::error::Error::source) for more details about the underlying cause.
    /// 
    Unhandled(crate::error::Unhandled)
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AlarmsLimitExceededException(inner) => inner.fmt(f),
            Error::ApplicationAlreadyExistsException(inner) => inner.fmt(f),
            Error::ApplicationDoesNotExistException(inner) => inner.fmt(f),
            Error::ApplicationLimitExceededException(inner) => inner.fmt(f),
            Error::ApplicationNameRequiredException(inner) => inner.fmt(f),
            Error::ArnNotSupportedException(inner) => inner.fmt(f),
            Error::BatchLimitExceededException(inner) => inner.fmt(f),
            Error::BucketNameFilterRequiredException(inner) => inner.fmt(f),
            Error::DeploymentAlreadyCompletedException(inner) => inner.fmt(f),
            Error::DeploymentConfigAlreadyExistsException(inner) => inner.fmt(f),
            Error::DeploymentConfigDoesNotExistException(inner) => inner.fmt(f),
            Error::DeploymentConfigInUseException(inner) => inner.fmt(f),
            Error::DeploymentConfigLimitExceededException(inner) => inner.fmt(f),
            Error::DeploymentConfigNameRequiredException(inner) => inner.fmt(f),
            Error::DeploymentDoesNotExistException(inner) => inner.fmt(f),
            Error::DeploymentGroupAlreadyExistsException(inner) => inner.fmt(f),
            Error::DeploymentGroupDoesNotExistException(inner) => inner.fmt(f),
            Error::DeploymentGroupLimitExceededException(inner) => inner.fmt(f),
            Error::DeploymentGroupNameRequiredException(inner) => inner.fmt(f),
            Error::DeploymentIdRequiredException(inner) => inner.fmt(f),
            Error::DeploymentIsNotInReadyStateException(inner) => inner.fmt(f),
            Error::DeploymentLimitExceededException(inner) => inner.fmt(f),
            Error::DeploymentNotStartedException(inner) => inner.fmt(f),
            Error::DeploymentTargetDoesNotExistException(inner) => inner.fmt(f),
            Error::DeploymentTargetIdRequiredException(inner) => inner.fmt(f),
            Error::DeploymentTargetListSizeExceededException(inner) => inner.fmt(f),
            Error::DescriptionTooLongException(inner) => inner.fmt(f),
            Error::EcsServiceMappingLimitExceededException(inner) => inner.fmt(f),
            Error::GitHubAccountTokenDoesNotExistException(inner) => inner.fmt(f),
            Error::GitHubAccountTokenNameRequiredException(inner) => inner.fmt(f),
            Error::IamArnRequiredException(inner) => inner.fmt(f),
            Error::IamSessionArnAlreadyRegisteredException(inner) => inner.fmt(f),
            Error::IamUserArnAlreadyRegisteredException(inner) => inner.fmt(f),
            Error::IamUserArnRequiredException(inner) => inner.fmt(f),
            Error::InstanceDoesNotExistException(inner) => inner.fmt(f),
            Error::InstanceIdRequiredException(inner) => inner.fmt(f),
            Error::InstanceLimitExceededException(inner) => inner.fmt(f),
            Error::InstanceNameAlreadyRegisteredException(inner) => inner.fmt(f),
            Error::InstanceNameRequiredException(inner) => inner.fmt(f),
            Error::InstanceNotRegisteredException(inner) => inner.fmt(f),
            Error::InvalidAlarmConfigException(inner) => inner.fmt(f),
            Error::InvalidApplicationNameException(inner) => inner.fmt(f),
            Error::InvalidArnException(inner) => inner.fmt(f),
            Error::InvalidAutoRollbackConfigException(inner) => inner.fmt(f),
            Error::InvalidAutoScalingGroupException(inner) => inner.fmt(f),
            Error::InvalidBlueGreenDeploymentConfigurationException(inner) => inner.fmt(f),
            Error::InvalidBucketNameFilterException(inner) => inner.fmt(f),
            Error::InvalidComputePlatformException(inner) => inner.fmt(f),
            Error::InvalidDeployedStateFilterException(inner) => inner.fmt(f),
            Error::InvalidDeploymentConfigNameException(inner) => inner.fmt(f),
            Error::InvalidDeploymentGroupNameException(inner) => inner.fmt(f),
            Error::InvalidDeploymentIdException(inner) => inner.fmt(f),
            Error::InvalidDeploymentInstanceTypeException(inner) => inner.fmt(f),
            Error::InvalidDeploymentStatusException(inner) => inner.fmt(f),
            Error::InvalidDeploymentStyleException(inner) => inner.fmt(f),
            Error::InvalidDeploymentTargetIdException(inner) => inner.fmt(f),
            Error::InvalidDeploymentWaitTypeException(inner) => inner.fmt(f),
            Error::InvalidEc2TagCombinationException(inner) => inner.fmt(f),
            Error::InvalidEc2TagException(inner) => inner.fmt(f),
            Error::InvalidEcsServiceException(inner) => inner.fmt(f),
            Error::InvalidExternalIdException(inner) => inner.fmt(f),
            Error::InvalidFileExistsBehaviorException(inner) => inner.fmt(f),
            Error::InvalidGitHubAccountTokenException(inner) => inner.fmt(f),
            Error::InvalidGitHubAccountTokenNameException(inner) => inner.fmt(f),
            Error::InvalidIamSessionArnException(inner) => inner.fmt(f),
            Error::InvalidIamUserArnException(inner) => inner.fmt(f),
            Error::InvalidIgnoreApplicationStopFailuresValueException(inner) => inner.fmt(f),
            Error::InvalidInputException(inner) => inner.fmt(f),
            Error::InvalidInstanceNameException(inner) => inner.fmt(f),
            Error::InvalidInstanceStatusException(inner) => inner.fmt(f),
            Error::InvalidInstanceTypeException(inner) => inner.fmt(f),
            Error::InvalidKeyPrefixFilterException(inner) => inner.fmt(f),
            Error::InvalidLifecycleEventHookExecutionIdException(inner) => inner.fmt(f),
            Error::InvalidLifecycleEventHookExecutionStatusException(inner) => inner.fmt(f),
            Error::InvalidLoadBalancerInfoException(inner) => inner.fmt(f),
            Error::InvalidMinimumHealthyHostValueException(inner) => inner.fmt(f),
            Error::InvalidNextTokenException(inner) => inner.fmt(f),
            Error::InvalidOnPremisesTagCombinationException(inner) => inner.fmt(f),
            Error::InvalidOperationException(inner) => inner.fmt(f),
            Error::InvalidRegistrationStatusException(inner) => inner.fmt(f),
            Error::InvalidRevisionException(inner) => inner.fmt(f),
            Error::InvalidRoleException(inner) => inner.fmt(f),
            Error::InvalidSortByException(inner) => inner.fmt(f),
            Error::InvalidSortOrderException(inner) => inner.fmt(f),
            Error::InvalidTagException(inner) => inner.fmt(f),
            Error::InvalidTagFilterException(inner) => inner.fmt(f),
            Error::InvalidTagsToAddException(inner) => inner.fmt(f),
            Error::InvalidTargetFilterNameException(inner) => inner.fmt(f),
            Error::InvalidTargetGroupPairException(inner) => inner.fmt(f),
            Error::InvalidTargetInstancesException(inner) => inner.fmt(f),
            Error::InvalidTimeRangeException(inner) => inner.fmt(f),
            Error::InvalidTrafficRoutingConfigurationException(inner) => inner.fmt(f),
            Error::InvalidTriggerConfigException(inner) => inner.fmt(f),
            Error::InvalidUpdateOutdatedInstancesOnlyValueException(inner) => inner.fmt(f),
            Error::LifecycleEventAlreadyCompletedException(inner) => inner.fmt(f),
            Error::LifecycleHookLimitExceededException(inner) => inner.fmt(f),
            Error::MultipleIamArnsProvidedException(inner) => inner.fmt(f),
            Error::OperationNotSupportedException(inner) => inner.fmt(f),
            Error::ResourceArnRequiredException(inner) => inner.fmt(f),
            Error::ResourceValidationException(inner) => inner.fmt(f),
            Error::RevisionDoesNotExistException(inner) => inner.fmt(f),
            Error::RevisionRequiredException(inner) => inner.fmt(f),
            Error::RoleRequiredException(inner) => inner.fmt(f),
            Error::TagLimitExceededException(inner) => inner.fmt(f),
            Error::TagRequiredException(inner) => inner.fmt(f),
            Error::TagSetListLimitExceededException(inner) => inner.fmt(f),
            Error::ThrottlingException(inner) => inner.fmt(f),
            Error::TriggerTargetsLimitExceededException(inner) => inner.fmt(f),
            Error::UnsupportedActionForDeploymentTypeException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f)
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AddTagsToOnPremisesInstancesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::AddTagsToOnPremisesInstancesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::AddTagsToOnPremisesInstancesError> for Error {
    fn from(err: crate::error::AddTagsToOnPremisesInstancesError) -> Self {
        match err.kind {
            crate::error::AddTagsToOnPremisesInstancesErrorKind::InstanceLimitExceededException(inner) => Error::InstanceLimitExceededException(inner),
            crate::error::AddTagsToOnPremisesInstancesErrorKind::InstanceNameRequiredException(inner) => Error::InstanceNameRequiredException(inner),
            crate::error::AddTagsToOnPremisesInstancesErrorKind::InstanceNotRegisteredException(inner) => Error::InstanceNotRegisteredException(inner),
            crate::error::AddTagsToOnPremisesInstancesErrorKind::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::AddTagsToOnPremisesInstancesErrorKind::InvalidTagException(inner) => Error::InvalidTagException(inner),
            crate::error::AddTagsToOnPremisesInstancesErrorKind::TagLimitExceededException(inner) => Error::TagLimitExceededException(inner),
            crate::error::AddTagsToOnPremisesInstancesErrorKind::TagRequiredException(inner) => Error::TagRequiredException(inner),
            crate::error::AddTagsToOnPremisesInstancesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetApplicationRevisionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchGetApplicationRevisionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::BatchGetApplicationRevisionsError> for Error {
    fn from(err: crate::error::BatchGetApplicationRevisionsError) -> Self {
        match err.kind {
            crate::error::BatchGetApplicationRevisionsErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::BatchGetApplicationRevisionsErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::BatchGetApplicationRevisionsErrorKind::BatchLimitExceededException(inner) => Error::BatchLimitExceededException(inner),
            crate::error::BatchGetApplicationRevisionsErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::BatchGetApplicationRevisionsErrorKind::InvalidRevisionException(inner) => Error::InvalidRevisionException(inner),
            crate::error::BatchGetApplicationRevisionsErrorKind::RevisionRequiredException(inner) => Error::RevisionRequiredException(inner),
            crate::error::BatchGetApplicationRevisionsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetApplicationsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchGetApplicationsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::BatchGetApplicationsError> for Error {
    fn from(err: crate::error::BatchGetApplicationsError) -> Self {
        match err.kind {
            crate::error::BatchGetApplicationsErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::BatchGetApplicationsErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::BatchGetApplicationsErrorKind::BatchLimitExceededException(inner) => Error::BatchLimitExceededException(inner),
            crate::error::BatchGetApplicationsErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::BatchGetApplicationsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentGroupsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentGroupsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::BatchGetDeploymentGroupsError> for Error {
    fn from(err: crate::error::BatchGetDeploymentGroupsError) -> Self {
        match err.kind {
            crate::error::BatchGetDeploymentGroupsErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::BatchGetDeploymentGroupsErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::BatchGetDeploymentGroupsErrorKind::BatchLimitExceededException(inner) => Error::BatchLimitExceededException(inner),
            crate::error::BatchGetDeploymentGroupsErrorKind::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::BatchGetDeploymentGroupsErrorKind::DeploymentGroupNameRequiredException(inner) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::BatchGetDeploymentGroupsErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::BatchGetDeploymentGroupsErrorKind::InvalidDeploymentGroupNameException(inner) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::BatchGetDeploymentGroupsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentInstancesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentInstancesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::BatchGetDeploymentInstancesError> for Error {
    fn from(err: crate::error::BatchGetDeploymentInstancesError) -> Self {
        match err.kind {
            crate::error::BatchGetDeploymentInstancesErrorKind::BatchLimitExceededException(inner) => Error::BatchLimitExceededException(inner),
            crate::error::BatchGetDeploymentInstancesErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::BatchGetDeploymentInstancesErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::BatchGetDeploymentInstancesErrorKind::InstanceIdRequiredException(inner) => Error::InstanceIdRequiredException(inner),
            crate::error::BatchGetDeploymentInstancesErrorKind::InvalidComputePlatformException(inner) => Error::InvalidComputePlatformException(inner),
            crate::error::BatchGetDeploymentInstancesErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::BatchGetDeploymentInstancesErrorKind::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::BatchGetDeploymentInstancesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::BatchGetDeploymentsError> for Error {
    fn from(err: crate::error::BatchGetDeploymentsError) -> Self {
        match err.kind {
            crate::error::BatchGetDeploymentsErrorKind::BatchLimitExceededException(inner) => Error::BatchLimitExceededException(inner),
            crate::error::BatchGetDeploymentsErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::BatchGetDeploymentsErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::BatchGetDeploymentsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentTargetsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentTargetsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::BatchGetDeploymentTargetsError> for Error {
    fn from(err: crate::error::BatchGetDeploymentTargetsError) -> Self {
        match err.kind {
            crate::error::BatchGetDeploymentTargetsErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::BatchGetDeploymentTargetsErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::BatchGetDeploymentTargetsErrorKind::DeploymentNotStartedException(inner) => Error::DeploymentNotStartedException(inner),
            crate::error::BatchGetDeploymentTargetsErrorKind::DeploymentTargetDoesNotExistException(inner) => Error::DeploymentTargetDoesNotExistException(inner),
            crate::error::BatchGetDeploymentTargetsErrorKind::DeploymentTargetIdRequiredException(inner) => Error::DeploymentTargetIdRequiredException(inner),
            crate::error::BatchGetDeploymentTargetsErrorKind::DeploymentTargetListSizeExceededException(inner) => Error::DeploymentTargetListSizeExceededException(inner),
            crate::error::BatchGetDeploymentTargetsErrorKind::InstanceDoesNotExistException(inner) => Error::InstanceDoesNotExistException(inner),
            crate::error::BatchGetDeploymentTargetsErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::BatchGetDeploymentTargetsErrorKind::InvalidDeploymentTargetIdException(inner) => Error::InvalidDeploymentTargetIdException(inner),
            crate::error::BatchGetDeploymentTargetsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetOnPremisesInstancesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchGetOnPremisesInstancesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::BatchGetOnPremisesInstancesError> for Error {
    fn from(err: crate::error::BatchGetOnPremisesInstancesError) -> Self {
        match err.kind {
            crate::error::BatchGetOnPremisesInstancesErrorKind::BatchLimitExceededException(inner) => Error::BatchLimitExceededException(inner),
            crate::error::BatchGetOnPremisesInstancesErrorKind::InstanceNameRequiredException(inner) => Error::InstanceNameRequiredException(inner),
            crate::error::BatchGetOnPremisesInstancesErrorKind::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::BatchGetOnPremisesInstancesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ContinueDeploymentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ContinueDeploymentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ContinueDeploymentError> for Error {
    fn from(err: crate::error::ContinueDeploymentError) -> Self {
        match err.kind {
            crate::error::ContinueDeploymentErrorKind::DeploymentAlreadyCompletedException(inner) => Error::DeploymentAlreadyCompletedException(inner),
            crate::error::ContinueDeploymentErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::ContinueDeploymentErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::ContinueDeploymentErrorKind::DeploymentIsNotInReadyStateException(inner) => Error::DeploymentIsNotInReadyStateException(inner),
            crate::error::ContinueDeploymentErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::ContinueDeploymentErrorKind::InvalidDeploymentStatusException(inner) => Error::InvalidDeploymentStatusException(inner),
            crate::error::ContinueDeploymentErrorKind::InvalidDeploymentWaitTypeException(inner) => Error::InvalidDeploymentWaitTypeException(inner),
            crate::error::ContinueDeploymentErrorKind::UnsupportedActionForDeploymentTypeException(inner) => Error::UnsupportedActionForDeploymentTypeException(inner),
            crate::error::ContinueDeploymentErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateApplicationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateApplicationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::CreateApplicationError> for Error {
    fn from(err: crate::error::CreateApplicationError) -> Self {
        match err.kind {
            crate::error::CreateApplicationErrorKind::ApplicationAlreadyExistsException(inner) => Error::ApplicationAlreadyExistsException(inner),
            crate::error::CreateApplicationErrorKind::ApplicationLimitExceededException(inner) => Error::ApplicationLimitExceededException(inner),
            crate::error::CreateApplicationErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::CreateApplicationErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::CreateApplicationErrorKind::InvalidComputePlatformException(inner) => Error::InvalidComputePlatformException(inner),
            crate::error::CreateApplicationErrorKind::InvalidTagsToAddException(inner) => Error::InvalidTagsToAddException(inner),
            crate::error::CreateApplicationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateDeploymentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateDeploymentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::CreateDeploymentError> for Error {
    fn from(err: crate::error::CreateDeploymentError) -> Self {
        match err.kind {
            crate::error::CreateDeploymentErrorKind::AlarmsLimitExceededException(inner) => Error::AlarmsLimitExceededException(inner),
            crate::error::CreateDeploymentErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::CreateDeploymentErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::CreateDeploymentErrorKind::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::CreateDeploymentErrorKind::DeploymentGroupDoesNotExistException(inner) => Error::DeploymentGroupDoesNotExistException(inner),
            crate::error::CreateDeploymentErrorKind::DeploymentGroupNameRequiredException(inner) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::CreateDeploymentErrorKind::DeploymentLimitExceededException(inner) => Error::DeploymentLimitExceededException(inner),
            crate::error::CreateDeploymentErrorKind::DescriptionTooLongException(inner) => Error::DescriptionTooLongException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidAlarmConfigException(inner) => Error::InvalidAlarmConfigException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidAutoRollbackConfigException(inner) => Error::InvalidAutoRollbackConfigException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidAutoScalingGroupException(inner) => Error::InvalidAutoScalingGroupException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidDeploymentConfigNameException(inner) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidDeploymentGroupNameException(inner) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidFileExistsBehaviorException(inner) => Error::InvalidFileExistsBehaviorException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidGitHubAccountTokenException(inner) => Error::InvalidGitHubAccountTokenException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidIgnoreApplicationStopFailuresValueException(inner) => Error::InvalidIgnoreApplicationStopFailuresValueException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidLoadBalancerInfoException(inner) => Error::InvalidLoadBalancerInfoException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidRevisionException(inner) => Error::InvalidRevisionException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidRoleException(inner) => Error::InvalidRoleException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidTargetInstancesException(inner) => Error::InvalidTargetInstancesException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidTrafficRoutingConfigurationException(inner) => Error::InvalidTrafficRoutingConfigurationException(inner),
            crate::error::CreateDeploymentErrorKind::InvalidUpdateOutdatedInstancesOnlyValueException(inner) => Error::InvalidUpdateOutdatedInstancesOnlyValueException(inner),
            crate::error::CreateDeploymentErrorKind::RevisionDoesNotExistException(inner) => Error::RevisionDoesNotExistException(inner),
            crate::error::CreateDeploymentErrorKind::RevisionRequiredException(inner) => Error::RevisionRequiredException(inner),
            crate::error::CreateDeploymentErrorKind::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::error::CreateDeploymentErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateDeploymentConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateDeploymentConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::CreateDeploymentConfigError> for Error {
    fn from(err: crate::error::CreateDeploymentConfigError) -> Self {
        match err.kind {
            crate::error::CreateDeploymentConfigErrorKind::DeploymentConfigAlreadyExistsException(inner) => Error::DeploymentConfigAlreadyExistsException(inner),
            crate::error::CreateDeploymentConfigErrorKind::DeploymentConfigLimitExceededException(inner) => Error::DeploymentConfigLimitExceededException(inner),
            crate::error::CreateDeploymentConfigErrorKind::DeploymentConfigNameRequiredException(inner) => Error::DeploymentConfigNameRequiredException(inner),
            crate::error::CreateDeploymentConfigErrorKind::InvalidComputePlatformException(inner) => Error::InvalidComputePlatformException(inner),
            crate::error::CreateDeploymentConfigErrorKind::InvalidDeploymentConfigNameException(inner) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::CreateDeploymentConfigErrorKind::InvalidMinimumHealthyHostValueException(inner) => Error::InvalidMinimumHealthyHostValueException(inner),
            crate::error::CreateDeploymentConfigErrorKind::InvalidTrafficRoutingConfigurationException(inner) => Error::InvalidTrafficRoutingConfigurationException(inner),
            crate::error::CreateDeploymentConfigErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateDeploymentGroupError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateDeploymentGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::CreateDeploymentGroupError> for Error {
    fn from(err: crate::error::CreateDeploymentGroupError) -> Self {
        match err.kind {
            crate::error::CreateDeploymentGroupErrorKind::AlarmsLimitExceededException(inner) => Error::AlarmsLimitExceededException(inner),
            crate::error::CreateDeploymentGroupErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::CreateDeploymentGroupErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::CreateDeploymentGroupErrorKind::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::CreateDeploymentGroupErrorKind::DeploymentGroupAlreadyExistsException(inner) => Error::DeploymentGroupAlreadyExistsException(inner),
            crate::error::CreateDeploymentGroupErrorKind::DeploymentGroupLimitExceededException(inner) => Error::DeploymentGroupLimitExceededException(inner),
            crate::error::CreateDeploymentGroupErrorKind::DeploymentGroupNameRequiredException(inner) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::CreateDeploymentGroupErrorKind::EcsServiceMappingLimitExceededException(inner) => Error::EcsServiceMappingLimitExceededException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidAlarmConfigException(inner) => Error::InvalidAlarmConfigException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidAutoRollbackConfigException(inner) => Error::InvalidAutoRollbackConfigException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidAutoScalingGroupException(inner) => Error::InvalidAutoScalingGroupException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidBlueGreenDeploymentConfigurationException(inner) => Error::InvalidBlueGreenDeploymentConfigurationException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidDeploymentConfigNameException(inner) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidDeploymentGroupNameException(inner) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidDeploymentStyleException(inner) => Error::InvalidDeploymentStyleException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidEc2TagCombinationException(inner) => Error::InvalidEc2TagCombinationException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidEc2TagException(inner) => Error::InvalidEc2TagException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidEcsServiceException(inner) => Error::InvalidEcsServiceException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidLoadBalancerInfoException(inner) => Error::InvalidLoadBalancerInfoException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidOnPremisesTagCombinationException(inner) => Error::InvalidOnPremisesTagCombinationException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidRoleException(inner) => Error::InvalidRoleException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidTagException(inner) => Error::InvalidTagException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidTagsToAddException(inner) => Error::InvalidTagsToAddException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidTargetGroupPairException(inner) => Error::InvalidTargetGroupPairException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidTrafficRoutingConfigurationException(inner) => Error::InvalidTrafficRoutingConfigurationException(inner),
            crate::error::CreateDeploymentGroupErrorKind::InvalidTriggerConfigException(inner) => Error::InvalidTriggerConfigException(inner),
            crate::error::CreateDeploymentGroupErrorKind::LifecycleHookLimitExceededException(inner) => Error::LifecycleHookLimitExceededException(inner),
            crate::error::CreateDeploymentGroupErrorKind::RoleRequiredException(inner) => Error::RoleRequiredException(inner),
            crate::error::CreateDeploymentGroupErrorKind::TagSetListLimitExceededException(inner) => Error::TagSetListLimitExceededException(inner),
            crate::error::CreateDeploymentGroupErrorKind::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::error::CreateDeploymentGroupErrorKind::TriggerTargetsLimitExceededException(inner) => Error::TriggerTargetsLimitExceededException(inner),
            crate::error::CreateDeploymentGroupErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteApplicationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteApplicationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::DeleteApplicationError> for Error {
    fn from(err: crate::error::DeleteApplicationError) -> Self {
        match err.kind {
            crate::error::DeleteApplicationErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::DeleteApplicationErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::DeleteApplicationErrorKind::InvalidRoleException(inner) => Error::InvalidRoleException(inner),
            crate::error::DeleteApplicationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteDeploymentConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteDeploymentConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::DeleteDeploymentConfigError> for Error {
    fn from(err: crate::error::DeleteDeploymentConfigError) -> Self {
        match err.kind {
            crate::error::DeleteDeploymentConfigErrorKind::DeploymentConfigInUseException(inner) => Error::DeploymentConfigInUseException(inner),
            crate::error::DeleteDeploymentConfigErrorKind::DeploymentConfigNameRequiredException(inner) => Error::DeploymentConfigNameRequiredException(inner),
            crate::error::DeleteDeploymentConfigErrorKind::InvalidDeploymentConfigNameException(inner) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::DeleteDeploymentConfigErrorKind::InvalidOperationException(inner) => Error::InvalidOperationException(inner),
            crate::error::DeleteDeploymentConfigErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteDeploymentGroupError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteDeploymentGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::DeleteDeploymentGroupError> for Error {
    fn from(err: crate::error::DeleteDeploymentGroupError) -> Self {
        match err.kind {
            crate::error::DeleteDeploymentGroupErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::DeleteDeploymentGroupErrorKind::DeploymentGroupNameRequiredException(inner) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::DeleteDeploymentGroupErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::DeleteDeploymentGroupErrorKind::InvalidDeploymentGroupNameException(inner) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::DeleteDeploymentGroupErrorKind::InvalidRoleException(inner) => Error::InvalidRoleException(inner),
            crate::error::DeleteDeploymentGroupErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteGitHubAccountTokenError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteGitHubAccountTokenError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::DeleteGitHubAccountTokenError> for Error {
    fn from(err: crate::error::DeleteGitHubAccountTokenError) -> Self {
        match err.kind {
            crate::error::DeleteGitHubAccountTokenErrorKind::GitHubAccountTokenDoesNotExistException(inner) => Error::GitHubAccountTokenDoesNotExistException(inner),
            crate::error::DeleteGitHubAccountTokenErrorKind::GitHubAccountTokenNameRequiredException(inner) => Error::GitHubAccountTokenNameRequiredException(inner),
            crate::error::DeleteGitHubAccountTokenErrorKind::InvalidGitHubAccountTokenNameException(inner) => Error::InvalidGitHubAccountTokenNameException(inner),
            crate::error::DeleteGitHubAccountTokenErrorKind::OperationNotSupportedException(inner) => Error::OperationNotSupportedException(inner),
            crate::error::DeleteGitHubAccountTokenErrorKind::ResourceValidationException(inner) => Error::ResourceValidationException(inner),
            crate::error::DeleteGitHubAccountTokenErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteResourcesByExternalIdError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteResourcesByExternalIdError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::DeleteResourcesByExternalIdError> for Error {
    fn from(err: crate::error::DeleteResourcesByExternalIdError) -> Self {
        match err.kind {
            crate::error::DeleteResourcesByExternalIdErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeregisterOnPremisesInstanceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeregisterOnPremisesInstanceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::DeregisterOnPremisesInstanceError> for Error {
    fn from(err: crate::error::DeregisterOnPremisesInstanceError) -> Self {
        match err.kind {
            crate::error::DeregisterOnPremisesInstanceErrorKind::InstanceNameRequiredException(inner) => Error::InstanceNameRequiredException(inner),
            crate::error::DeregisterOnPremisesInstanceErrorKind::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::DeregisterOnPremisesInstanceErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetApplicationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetApplicationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetApplicationError> for Error {
    fn from(err: crate::error::GetApplicationError) -> Self {
        match err.kind {
            crate::error::GetApplicationErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::GetApplicationErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::GetApplicationErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::GetApplicationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetApplicationRevisionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetApplicationRevisionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetApplicationRevisionError> for Error {
    fn from(err: crate::error::GetApplicationRevisionError) -> Self {
        match err.kind {
            crate::error::GetApplicationRevisionErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::GetApplicationRevisionErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::GetApplicationRevisionErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::GetApplicationRevisionErrorKind::InvalidRevisionException(inner) => Error::InvalidRevisionException(inner),
            crate::error::GetApplicationRevisionErrorKind::RevisionDoesNotExistException(inner) => Error::RevisionDoesNotExistException(inner),
            crate::error::GetApplicationRevisionErrorKind::RevisionRequiredException(inner) => Error::RevisionRequiredException(inner),
            crate::error::GetApplicationRevisionErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDeploymentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDeploymentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetDeploymentError> for Error {
    fn from(err: crate::error::GetDeploymentError) -> Self {
        match err.kind {
            crate::error::GetDeploymentErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::GetDeploymentErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::GetDeploymentErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::GetDeploymentErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDeploymentConfigError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDeploymentConfigError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetDeploymentConfigError> for Error {
    fn from(err: crate::error::GetDeploymentConfigError) -> Self {
        match err.kind {
            crate::error::GetDeploymentConfigErrorKind::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::GetDeploymentConfigErrorKind::DeploymentConfigNameRequiredException(inner) => Error::DeploymentConfigNameRequiredException(inner),
            crate::error::GetDeploymentConfigErrorKind::InvalidComputePlatformException(inner) => Error::InvalidComputePlatformException(inner),
            crate::error::GetDeploymentConfigErrorKind::InvalidDeploymentConfigNameException(inner) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::GetDeploymentConfigErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDeploymentGroupError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDeploymentGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetDeploymentGroupError> for Error {
    fn from(err: crate::error::GetDeploymentGroupError) -> Self {
        match err.kind {
            crate::error::GetDeploymentGroupErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::GetDeploymentGroupErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::GetDeploymentGroupErrorKind::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::GetDeploymentGroupErrorKind::DeploymentGroupDoesNotExistException(inner) => Error::DeploymentGroupDoesNotExistException(inner),
            crate::error::GetDeploymentGroupErrorKind::DeploymentGroupNameRequiredException(inner) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::GetDeploymentGroupErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::GetDeploymentGroupErrorKind::InvalidDeploymentGroupNameException(inner) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::GetDeploymentGroupErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDeploymentInstanceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDeploymentInstanceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetDeploymentInstanceError> for Error {
    fn from(err: crate::error::GetDeploymentInstanceError) -> Self {
        match err.kind {
            crate::error::GetDeploymentInstanceErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::GetDeploymentInstanceErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::GetDeploymentInstanceErrorKind::InstanceDoesNotExistException(inner) => Error::InstanceDoesNotExistException(inner),
            crate::error::GetDeploymentInstanceErrorKind::InstanceIdRequiredException(inner) => Error::InstanceIdRequiredException(inner),
            crate::error::GetDeploymentInstanceErrorKind::InvalidComputePlatformException(inner) => Error::InvalidComputePlatformException(inner),
            crate::error::GetDeploymentInstanceErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::GetDeploymentInstanceErrorKind::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::GetDeploymentInstanceErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDeploymentTargetError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDeploymentTargetError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetDeploymentTargetError> for Error {
    fn from(err: crate::error::GetDeploymentTargetError) -> Self {
        match err.kind {
            crate::error::GetDeploymentTargetErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::GetDeploymentTargetErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::GetDeploymentTargetErrorKind::DeploymentNotStartedException(inner) => Error::DeploymentNotStartedException(inner),
            crate::error::GetDeploymentTargetErrorKind::DeploymentTargetDoesNotExistException(inner) => Error::DeploymentTargetDoesNotExistException(inner),
            crate::error::GetDeploymentTargetErrorKind::DeploymentTargetIdRequiredException(inner) => Error::DeploymentTargetIdRequiredException(inner),
            crate::error::GetDeploymentTargetErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::GetDeploymentTargetErrorKind::InvalidDeploymentTargetIdException(inner) => Error::InvalidDeploymentTargetIdException(inner),
            crate::error::GetDeploymentTargetErrorKind::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::GetDeploymentTargetErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetOnPremisesInstanceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetOnPremisesInstanceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::GetOnPremisesInstanceError> for Error {
    fn from(err: crate::error::GetOnPremisesInstanceError) -> Self {
        match err.kind {
            crate::error::GetOnPremisesInstanceErrorKind::InstanceNameRequiredException(inner) => Error::InstanceNameRequiredException(inner),
            crate::error::GetOnPremisesInstanceErrorKind::InstanceNotRegisteredException(inner) => Error::InstanceNotRegisteredException(inner),
            crate::error::GetOnPremisesInstanceErrorKind::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::GetOnPremisesInstanceErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListApplicationRevisionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListApplicationRevisionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListApplicationRevisionsError> for Error {
    fn from(err: crate::error::ListApplicationRevisionsError) -> Self {
        match err.kind {
            crate::error::ListApplicationRevisionsErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::ListApplicationRevisionsErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::ListApplicationRevisionsErrorKind::BucketNameFilterRequiredException(inner) => Error::BucketNameFilterRequiredException(inner),
            crate::error::ListApplicationRevisionsErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::ListApplicationRevisionsErrorKind::InvalidBucketNameFilterException(inner) => Error::InvalidBucketNameFilterException(inner),
            crate::error::ListApplicationRevisionsErrorKind::InvalidDeployedStateFilterException(inner) => Error::InvalidDeployedStateFilterException(inner),
            crate::error::ListApplicationRevisionsErrorKind::InvalidKeyPrefixFilterException(inner) => Error::InvalidKeyPrefixFilterException(inner),
            crate::error::ListApplicationRevisionsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListApplicationRevisionsErrorKind::InvalidSortByException(inner) => Error::InvalidSortByException(inner),
            crate::error::ListApplicationRevisionsErrorKind::InvalidSortOrderException(inner) => Error::InvalidSortOrderException(inner),
            crate::error::ListApplicationRevisionsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListApplicationsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListApplicationsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListApplicationsError> for Error {
    fn from(err: crate::error::ListApplicationsError) -> Self {
        match err.kind {
            crate::error::ListApplicationsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListApplicationsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDeploymentConfigsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListDeploymentConfigsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListDeploymentConfigsError> for Error {
    fn from(err: crate::error::ListDeploymentConfigsError) -> Self {
        match err.kind {
            crate::error::ListDeploymentConfigsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListDeploymentConfigsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDeploymentGroupsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListDeploymentGroupsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListDeploymentGroupsError> for Error {
    fn from(err: crate::error::ListDeploymentGroupsError) -> Self {
        match err.kind {
            crate::error::ListDeploymentGroupsErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::ListDeploymentGroupsErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::ListDeploymentGroupsErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::ListDeploymentGroupsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListDeploymentGroupsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDeploymentInstancesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListDeploymentInstancesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListDeploymentInstancesError> for Error {
    fn from(err: crate::error::ListDeploymentInstancesError) -> Self {
        match err.kind {
            crate::error::ListDeploymentInstancesErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::ListDeploymentInstancesErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::ListDeploymentInstancesErrorKind::DeploymentNotStartedException(inner) => Error::DeploymentNotStartedException(inner),
            crate::error::ListDeploymentInstancesErrorKind::InvalidComputePlatformException(inner) => Error::InvalidComputePlatformException(inner),
            crate::error::ListDeploymentInstancesErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::ListDeploymentInstancesErrorKind::InvalidDeploymentInstanceTypeException(inner) => Error::InvalidDeploymentInstanceTypeException(inner),
            crate::error::ListDeploymentInstancesErrorKind::InvalidInstanceStatusException(inner) => Error::InvalidInstanceStatusException(inner),
            crate::error::ListDeploymentInstancesErrorKind::InvalidInstanceTypeException(inner) => Error::InvalidInstanceTypeException(inner),
            crate::error::ListDeploymentInstancesErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListDeploymentInstancesErrorKind::InvalidTargetFilterNameException(inner) => Error::InvalidTargetFilterNameException(inner),
            crate::error::ListDeploymentInstancesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDeploymentsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListDeploymentsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListDeploymentsError> for Error {
    fn from(err: crate::error::ListDeploymentsError) -> Self {
        match err.kind {
            crate::error::ListDeploymentsErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::ListDeploymentsErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::ListDeploymentsErrorKind::DeploymentGroupDoesNotExistException(inner) => Error::DeploymentGroupDoesNotExistException(inner),
            crate::error::ListDeploymentsErrorKind::DeploymentGroupNameRequiredException(inner) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::ListDeploymentsErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::ListDeploymentsErrorKind::InvalidDeploymentGroupNameException(inner) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::ListDeploymentsErrorKind::InvalidDeploymentStatusException(inner) => Error::InvalidDeploymentStatusException(inner),
            crate::error::ListDeploymentsErrorKind::InvalidExternalIdException(inner) => Error::InvalidExternalIdException(inner),
            crate::error::ListDeploymentsErrorKind::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::error::ListDeploymentsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListDeploymentsErrorKind::InvalidTimeRangeException(inner) => Error::InvalidTimeRangeException(inner),
            crate::error::ListDeploymentsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDeploymentTargetsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListDeploymentTargetsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListDeploymentTargetsError> for Error {
    fn from(err: crate::error::ListDeploymentTargetsError) -> Self {
        match err.kind {
            crate::error::ListDeploymentTargetsErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::ListDeploymentTargetsErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::ListDeploymentTargetsErrorKind::DeploymentNotStartedException(inner) => Error::DeploymentNotStartedException(inner),
            crate::error::ListDeploymentTargetsErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::ListDeploymentTargetsErrorKind::InvalidDeploymentInstanceTypeException(inner) => Error::InvalidDeploymentInstanceTypeException(inner),
            crate::error::ListDeploymentTargetsErrorKind::InvalidInstanceStatusException(inner) => Error::InvalidInstanceStatusException(inner),
            crate::error::ListDeploymentTargetsErrorKind::InvalidInstanceTypeException(inner) => Error::InvalidInstanceTypeException(inner),
            crate::error::ListDeploymentTargetsErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListDeploymentTargetsErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListGitHubAccountTokenNamesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListGitHubAccountTokenNamesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListGitHubAccountTokenNamesError> for Error {
    fn from(err: crate::error::ListGitHubAccountTokenNamesError) -> Self {
        match err.kind {
            crate::error::ListGitHubAccountTokenNamesErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListGitHubAccountTokenNamesErrorKind::OperationNotSupportedException(inner) => Error::OperationNotSupportedException(inner),
            crate::error::ListGitHubAccountTokenNamesErrorKind::ResourceValidationException(inner) => Error::ResourceValidationException(inner),
            crate::error::ListGitHubAccountTokenNamesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListOnPremisesInstancesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListOnPremisesInstancesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListOnPremisesInstancesError> for Error {
    fn from(err: crate::error::ListOnPremisesInstancesError) -> Self {
        match err.kind {
            crate::error::ListOnPremisesInstancesErrorKind::InvalidNextTokenException(inner) => Error::InvalidNextTokenException(inner),
            crate::error::ListOnPremisesInstancesErrorKind::InvalidRegistrationStatusException(inner) => Error::InvalidRegistrationStatusException(inner),
            crate::error::ListOnPremisesInstancesErrorKind::InvalidTagFilterException(inner) => Error::InvalidTagFilterException(inner),
            crate::error::ListOnPremisesInstancesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err.kind {
            crate::error::ListTagsForResourceErrorKind::ArnNotSupportedException(inner) => Error::ArnNotSupportedException(inner),
            crate::error::ListTagsForResourceErrorKind::InvalidArnException(inner) => Error::InvalidArnException(inner),
            crate::error::ListTagsForResourceErrorKind::ResourceArnRequiredException(inner) => Error::ResourceArnRequiredException(inner),
            crate::error::ListTagsForResourceErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutLifecycleEventHookExecutionStatusError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutLifecycleEventHookExecutionStatusError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::PutLifecycleEventHookExecutionStatusError> for Error {
    fn from(err: crate::error::PutLifecycleEventHookExecutionStatusError) -> Self {
        match err.kind {
            crate::error::PutLifecycleEventHookExecutionStatusErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusErrorKind::InvalidLifecycleEventHookExecutionIdException(inner) => Error::InvalidLifecycleEventHookExecutionIdException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusErrorKind::InvalidLifecycleEventHookExecutionStatusException(inner) => Error::InvalidLifecycleEventHookExecutionStatusException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusErrorKind::LifecycleEventAlreadyCompletedException(inner) => Error::LifecycleEventAlreadyCompletedException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusErrorKind::UnsupportedActionForDeploymentTypeException(inner) => Error::UnsupportedActionForDeploymentTypeException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RegisterApplicationRevisionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RegisterApplicationRevisionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::RegisterApplicationRevisionError> for Error {
    fn from(err: crate::error::RegisterApplicationRevisionError) -> Self {
        match err.kind {
            crate::error::RegisterApplicationRevisionErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::RegisterApplicationRevisionErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::RegisterApplicationRevisionErrorKind::DescriptionTooLongException(inner) => Error::DescriptionTooLongException(inner),
            crate::error::RegisterApplicationRevisionErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::RegisterApplicationRevisionErrorKind::InvalidRevisionException(inner) => Error::InvalidRevisionException(inner),
            crate::error::RegisterApplicationRevisionErrorKind::RevisionRequiredException(inner) => Error::RevisionRequiredException(inner),
            crate::error::RegisterApplicationRevisionErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RegisterOnPremisesInstanceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RegisterOnPremisesInstanceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::RegisterOnPremisesInstanceError> for Error {
    fn from(err: crate::error::RegisterOnPremisesInstanceError) -> Self {
        match err.kind {
            crate::error::RegisterOnPremisesInstanceErrorKind::IamArnRequiredException(inner) => Error::IamArnRequiredException(inner),
            crate::error::RegisterOnPremisesInstanceErrorKind::IamSessionArnAlreadyRegisteredException(inner) => Error::IamSessionArnAlreadyRegisteredException(inner),
            crate::error::RegisterOnPremisesInstanceErrorKind::IamUserArnAlreadyRegisteredException(inner) => Error::IamUserArnAlreadyRegisteredException(inner),
            crate::error::RegisterOnPremisesInstanceErrorKind::IamUserArnRequiredException(inner) => Error::IamUserArnRequiredException(inner),
            crate::error::RegisterOnPremisesInstanceErrorKind::InstanceNameAlreadyRegisteredException(inner) => Error::InstanceNameAlreadyRegisteredException(inner),
            crate::error::RegisterOnPremisesInstanceErrorKind::InstanceNameRequiredException(inner) => Error::InstanceNameRequiredException(inner),
            crate::error::RegisterOnPremisesInstanceErrorKind::InvalidIamSessionArnException(inner) => Error::InvalidIamSessionArnException(inner),
            crate::error::RegisterOnPremisesInstanceErrorKind::InvalidIamUserArnException(inner) => Error::InvalidIamUserArnException(inner),
            crate::error::RegisterOnPremisesInstanceErrorKind::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::RegisterOnPremisesInstanceErrorKind::MultipleIamArnsProvidedException(inner) => Error::MultipleIamArnsProvidedException(inner),
            crate::error::RegisterOnPremisesInstanceErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RemoveTagsFromOnPremisesInstancesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::RemoveTagsFromOnPremisesInstancesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::RemoveTagsFromOnPremisesInstancesError> for Error {
    fn from(err: crate::error::RemoveTagsFromOnPremisesInstancesError) -> Self {
        match err.kind {
            crate::error::RemoveTagsFromOnPremisesInstancesErrorKind::InstanceLimitExceededException(inner) => Error::InstanceLimitExceededException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesErrorKind::InstanceNameRequiredException(inner) => Error::InstanceNameRequiredException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesErrorKind::InstanceNotRegisteredException(inner) => Error::InstanceNotRegisteredException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesErrorKind::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesErrorKind::InvalidTagException(inner) => Error::InvalidTagException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesErrorKind::TagLimitExceededException(inner) => Error::TagLimitExceededException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesErrorKind::TagRequiredException(inner) => Error::TagRequiredException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::SkipWaitTimeForInstanceTerminationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::SkipWaitTimeForInstanceTerminationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::SkipWaitTimeForInstanceTerminationError> for Error {
    fn from(err: crate::error::SkipWaitTimeForInstanceTerminationError) -> Self {
        match err.kind {
            crate::error::SkipWaitTimeForInstanceTerminationErrorKind::DeploymentAlreadyCompletedException(inner) => Error::DeploymentAlreadyCompletedException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationErrorKind::DeploymentNotStartedException(inner) => Error::DeploymentNotStartedException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationErrorKind::UnsupportedActionForDeploymentTypeException(inner) => Error::UnsupportedActionForDeploymentTypeException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::StopDeploymentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::StopDeploymentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::StopDeploymentError> for Error {
    fn from(err: crate::error::StopDeploymentError) -> Self {
        match err.kind {
            crate::error::StopDeploymentErrorKind::DeploymentAlreadyCompletedException(inner) => Error::DeploymentAlreadyCompletedException(inner),
            crate::error::StopDeploymentErrorKind::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::StopDeploymentErrorKind::DeploymentGroupDoesNotExistException(inner) => Error::DeploymentGroupDoesNotExistException(inner),
            crate::error::StopDeploymentErrorKind::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::StopDeploymentErrorKind::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::StopDeploymentErrorKind::UnsupportedActionForDeploymentTypeException(inner) => Error::UnsupportedActionForDeploymentTypeException(inner),
            crate::error::StopDeploymentErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err.kind {
            crate::error::TagResourceErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::TagResourceErrorKind::ArnNotSupportedException(inner) => Error::ArnNotSupportedException(inner),
            crate::error::TagResourceErrorKind::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::TagResourceErrorKind::DeploymentGroupDoesNotExistException(inner) => Error::DeploymentGroupDoesNotExistException(inner),
            crate::error::TagResourceErrorKind::InvalidArnException(inner) => Error::InvalidArnException(inner),
            crate::error::TagResourceErrorKind::InvalidTagsToAddException(inner) => Error::InvalidTagsToAddException(inner),
            crate::error::TagResourceErrorKind::ResourceArnRequiredException(inner) => Error::ResourceArnRequiredException(inner),
            crate::error::TagResourceErrorKind::TagRequiredException(inner) => Error::TagRequiredException(inner),
            crate::error::TagResourceErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err.kind {
            crate::error::UntagResourceErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::UntagResourceErrorKind::ArnNotSupportedException(inner) => Error::ArnNotSupportedException(inner),
            crate::error::UntagResourceErrorKind::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::UntagResourceErrorKind::DeploymentGroupDoesNotExistException(inner) => Error::DeploymentGroupDoesNotExistException(inner),
            crate::error::UntagResourceErrorKind::InvalidArnException(inner) => Error::InvalidArnException(inner),
            crate::error::UntagResourceErrorKind::InvalidTagsToAddException(inner) => Error::InvalidTagsToAddException(inner),
            crate::error::UntagResourceErrorKind::ResourceArnRequiredException(inner) => Error::ResourceArnRequiredException(inner),
            crate::error::UntagResourceErrorKind::TagRequiredException(inner) => Error::TagRequiredException(inner),
            crate::error::UntagResourceErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateApplicationError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateApplicationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::UpdateApplicationError> for Error {
    fn from(err: crate::error::UpdateApplicationError) -> Self {
        match err.kind {
            crate::error::UpdateApplicationErrorKind::ApplicationAlreadyExistsException(inner) => Error::ApplicationAlreadyExistsException(inner),
            crate::error::UpdateApplicationErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::UpdateApplicationErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::UpdateApplicationErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::UpdateApplicationErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDeploymentGroupError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateDeploymentGroupError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(crate::error::Unhandled::new(err.into())),
        }
    }
}
impl From<crate::error::UpdateDeploymentGroupError> for Error {
    fn from(err: crate::error::UpdateDeploymentGroupError) -> Self {
        match err.kind {
            crate::error::UpdateDeploymentGroupErrorKind::AlarmsLimitExceededException(inner) => Error::AlarmsLimitExceededException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::DeploymentGroupAlreadyExistsException(inner) => Error::DeploymentGroupAlreadyExistsException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::DeploymentGroupDoesNotExistException(inner) => Error::DeploymentGroupDoesNotExistException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::DeploymentGroupNameRequiredException(inner) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::EcsServiceMappingLimitExceededException(inner) => Error::EcsServiceMappingLimitExceededException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidAlarmConfigException(inner) => Error::InvalidAlarmConfigException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidAutoRollbackConfigException(inner) => Error::InvalidAutoRollbackConfigException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidAutoScalingGroupException(inner) => Error::InvalidAutoScalingGroupException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidBlueGreenDeploymentConfigurationException(inner) => Error::InvalidBlueGreenDeploymentConfigurationException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidDeploymentConfigNameException(inner) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidDeploymentGroupNameException(inner) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidDeploymentStyleException(inner) => Error::InvalidDeploymentStyleException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidEc2TagCombinationException(inner) => Error::InvalidEc2TagCombinationException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidEc2TagException(inner) => Error::InvalidEc2TagException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidEcsServiceException(inner) => Error::InvalidEcsServiceException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidLoadBalancerInfoException(inner) => Error::InvalidLoadBalancerInfoException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidOnPremisesTagCombinationException(inner) => Error::InvalidOnPremisesTagCombinationException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidRoleException(inner) => Error::InvalidRoleException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidTagException(inner) => Error::InvalidTagException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidTargetGroupPairException(inner) => Error::InvalidTargetGroupPairException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidTrafficRoutingConfigurationException(inner) => Error::InvalidTrafficRoutingConfigurationException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::InvalidTriggerConfigException(inner) => Error::InvalidTriggerConfigException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::LifecycleHookLimitExceededException(inner) => Error::LifecycleHookLimitExceededException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::TagSetListLimitExceededException(inner) => Error::TagSetListLimitExceededException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::TriggerTargetsLimitExceededException(inner) => Error::TriggerTargetsLimitExceededException(inner),
            crate::error::UpdateDeploymentGroupErrorKind::Unhandled(inner) => Error::Unhandled(crate::error::Unhandled::new(inner.into())),
        }
    }
}
impl std::error::Error for Error {}

