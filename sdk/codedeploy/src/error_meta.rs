// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>The maximum number of alarms for a deployment group (10) was exceeded.</p>
    AlarmsLimitExceededException(crate::error::AlarmsLimitExceededException),
    /// <p>An application with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    ApplicationAlreadyExistsException(crate::error::ApplicationAlreadyExistsException),
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>More applications were attempted to be created than are allowed.</p>
    ApplicationLimitExceededException(crate::error::ApplicationLimitExceededException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p> The specified ARN is not supported. For example, it might be an ARN for a resource that is not expected. </p>
    ArnNotSupportedException(crate::error::ArnNotSupportedException),
    /// <p>The maximum number of names or IDs allowed for this request (100) was exceeded.</p>
    BatchLimitExceededException(crate::error::BatchLimitExceededException),
    /// <p>A bucket name is required, but was not provided.</p>
    BucketNameFilterRequiredException(crate::error::BucketNameFilterRequiredException),
    /// <p>The deployment is already complete.</p>
    DeploymentAlreadyCompletedException(crate::error::DeploymentAlreadyCompletedException),
    /// <p>A deployment configuration with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    DeploymentConfigAlreadyExistsException(crate::error::DeploymentConfigAlreadyExistsException),
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::error::DeploymentConfigDoesNotExistException),
    /// <p>The deployment configuration is still in use.</p>
    DeploymentConfigInUseException(crate::error::DeploymentConfigInUseException),
    /// <p>The deployment configurations limit was exceeded.</p>
    DeploymentConfigLimitExceededException(crate::error::DeploymentConfigLimitExceededException),
    /// <p>The deployment configuration name was not specified.</p>
    DeploymentConfigNameRequiredException(crate::error::DeploymentConfigNameRequiredException),
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>A deployment group with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    DeploymentGroupAlreadyExistsException(crate::error::DeploymentGroupAlreadyExistsException),
    /// <p>The named deployment group with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentGroupDoesNotExistException(crate::error::DeploymentGroupDoesNotExistException),
    /// <p> The deployment groups limit was exceeded.</p>
    DeploymentGroupLimitExceededException(crate::error::DeploymentGroupLimitExceededException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::error::DeploymentGroupNameRequiredException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>The deployment does not have a status of Ready and can't continue yet.</p>
    DeploymentIsNotInReadyStateException(crate::error::DeploymentIsNotInReadyStateException),
    /// <p>The number of allowed deployments was exceeded.</p>
    DeploymentLimitExceededException(crate::error::DeploymentLimitExceededException),
    /// <p>The specified deployment has not started.</p>
    DeploymentNotStartedException(crate::error::DeploymentNotStartedException),
    /// <p> The provided target ID does not belong to the attempted deployment. </p>
    DeploymentTargetDoesNotExistException(crate::error::DeploymentTargetDoesNotExistException),
    /// <p> A deployment target ID was not provided. </p>
    DeploymentTargetIdRequiredException(crate::error::DeploymentTargetIdRequiredException),
    /// <p> The maximum number of targets that can be associated with an Amazon ECS or Lambda deployment was exceeded. The target list of both types of deployments must have exactly one item. This exception does not apply to EC2/On-premises deployments. </p>
    DeploymentTargetListSizeExceededException(
        crate::error::DeploymentTargetListSizeExceededException,
    ),
    /// <p>The description is too long.</p>
    DescriptionTooLongException(crate::error::DescriptionTooLongException),
    /// <p> The Amazon ECS service is associated with more than one deployment groups. An Amazon ECS service can be associated with only one deployment group. </p>
    EcsServiceMappingLimitExceededException(crate::error::EcsServiceMappingLimitExceededException),
    /// <p>No GitHub account connection exists with the named specified in the call.</p>
    GitHubAccountTokenDoesNotExistException(crate::error::GitHubAccountTokenDoesNotExistException),
    /// <p>The call is missing a required GitHub account connection name.</p>
    GitHubAccountTokenNameRequiredException(crate::error::GitHubAccountTokenNameRequiredException),
    /// <p>No IAM ARN was included in the request. You must use an IAM session ARN or IAM user ARN in the request.</p>
    IamArnRequiredException(crate::error::IamArnRequiredException),
    /// <p>The request included an IAM session ARN that has already been used to register a different instance.</p>
    IamSessionArnAlreadyRegisteredException(crate::error::IamSessionArnAlreadyRegisteredException),
    /// <p>The specified IAM user ARN is already registered with an on-premises instance.</p>
    IamUserArnAlreadyRegisteredException(crate::error::IamUserArnAlreadyRegisteredException),
    /// <p>An IAM user ARN was not specified.</p>
    IamUserArnRequiredException(crate::error::IamUserArnRequiredException),
    /// <p>The specified instance does not exist in the deployment group.</p>
    #[deprecated(
        note = "This exception is deprecated, use DeploymentTargetDoesNotExistException instead."
    )]
    InstanceDoesNotExistException(crate::error::InstanceDoesNotExistException),
    /// <p>The instance ID was not specified.</p>
    #[deprecated(
        note = "This exception is deprecated, use DeploymentTargetIdRequiredException instead."
    )]
    InstanceIdRequiredException(crate::error::InstanceIdRequiredException),
    /// <p>The maximum number of allowed on-premises instances in a single call was exceeded.</p>
    InstanceLimitExceededException(crate::error::InstanceLimitExceededException),
    /// <p>The specified on-premises instance name is already registered.</p>
    InstanceNameAlreadyRegisteredException(crate::error::InstanceNameAlreadyRegisteredException),
    /// <p>An on-premises instance name was not specified.</p>
    InstanceNameRequiredException(crate::error::InstanceNameRequiredException),
    /// <p>The specified on-premises instance is not registered.</p>
    InstanceNotRegisteredException(crate::error::InstanceNotRegisteredException),
    /// <p>The format of the alarm configuration is invalid. Possible causes include:</p>
    /// <ul>
    /// <li> <p>The alarm list is null.</p> </li>
    /// <li> <p>The alarm object is null.</p> </li>
    /// <li> <p>The alarm name is empty or null or exceeds the limit of 255 characters.</p> </li>
    /// <li> <p>Two alarms with the same name have been specified.</p> </li>
    /// <li> <p>The alarm configuration is enabled, but the alarm list is empty.</p> </li>
    /// </ul>
    InvalidAlarmConfigException(crate::error::InvalidAlarmConfigException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p> The specified ARN is not in a valid format. </p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p>The automatic rollback configuration was specified in an invalid format. For example, automatic rollback is enabled, but an invalid triggering event type or no event types were listed.</p>
    InvalidAutoRollbackConfigException(crate::error::InvalidAutoRollbackConfigException),
    /// <p>The Auto Scaling group was specified in an invalid format or does not exist.</p>
    InvalidAutoScalingGroupException(crate::error::InvalidAutoScalingGroupException),
    /// <p>The configuration for the blue/green deployment group was provided in an invalid format. For information about deployment configuration format, see <code>CreateDeploymentConfig</code>.</p>
    InvalidBlueGreenDeploymentConfigurationException(
        crate::error::InvalidBlueGreenDeploymentConfigurationException,
    ),
    /// <p>The bucket name either doesn't exist or was specified in an invalid format.</p>
    InvalidBucketNameFilterException(crate::error::InvalidBucketNameFilterException),
    /// <p>The computePlatform is invalid. The computePlatform should be <code>Lambda</code>, <code>Server</code>, or <code>ECS</code>.</p>
    InvalidComputePlatformException(crate::error::InvalidComputePlatformException),
    /// <p>The deployed state filter was specified in an invalid format.</p>
    InvalidDeployedStateFilterException(crate::error::InvalidDeployedStateFilterException),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::error::InvalidDeploymentConfigNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::error::InvalidDeploymentGroupNameException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p>An instance type was specified for an in-place deployment. Instance types are supported for blue/green deployments only.</p>
    InvalidDeploymentInstanceTypeException(crate::error::InvalidDeploymentInstanceTypeException),
    /// <p>The specified deployment status doesn't exist or cannot be determined.</p>
    InvalidDeploymentStatusException(crate::error::InvalidDeploymentStatusException),
    /// <p>An invalid deployment style was specified. Valid deployment types include "IN_PLACE" and "BLUE_GREEN." Valid deployment options include "WITH_TRAFFIC_CONTROL" and "WITHOUT_TRAFFIC_CONTROL."</p>
    InvalidDeploymentStyleException(crate::error::InvalidDeploymentStyleException),
    /// <p> The target ID provided was not valid. </p>
    InvalidDeploymentTargetIdException(crate::error::InvalidDeploymentTargetIdException),
    /// <p> The wait type is invalid. </p>
    InvalidDeploymentWaitTypeException(crate::error::InvalidDeploymentWaitTypeException),
    /// <p>A call was submitted that specified both Ec2TagFilters and Ec2TagSet, but only one of these data types can be used in a single call.</p>
    InvalidEc2TagCombinationException(crate::error::InvalidEc2TagCombinationException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidEc2TagException(crate::error::InvalidEc2TagException),
    /// <p> The Amazon ECS service identifier is not valid. </p>
    InvalidEcsServiceException(crate::error::InvalidEcsServiceException),
    /// <p>The external ID was specified in an invalid format.</p>
    InvalidExternalIdException(crate::error::InvalidExternalIdException),
    /// <p>An invalid fileExistsBehavior option was specified to determine how CodeDeploy handles files or directories that already exist in a deployment target location, but weren't part of the previous successful deployment. Valid values include "DISALLOW," "OVERWRITE," and "RETAIN."</p>
    InvalidFileExistsBehaviorException(crate::error::InvalidFileExistsBehaviorException),
    /// <p>The GitHub token is not valid.</p>
    InvalidGitHubAccountTokenException(crate::error::InvalidGitHubAccountTokenException),
    /// <p>The format of the specified GitHub account connection name is invalid.</p>
    InvalidGitHubAccountTokenNameException(crate::error::InvalidGitHubAccountTokenNameException),
    /// <p>The IAM session ARN was specified in an invalid format.</p>
    InvalidIamSessionArnException(crate::error::InvalidIamSessionArnException),
    /// <p>The IAM user ARN was specified in an invalid format.</p>
    InvalidIamUserArnException(crate::error::InvalidIamUserArnException),
    /// <p>The IgnoreApplicationStopFailures value is invalid. For Lambda deployments, <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code> or <code>false</code> is expected.</p>
    InvalidIgnoreApplicationStopFailuresValueException(
        crate::error::InvalidIgnoreApplicationStopFailuresValueException,
    ),
    /// <p>The input was specified in an invalid format.</p>
    InvalidInputException(crate::error::InvalidInputException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// <p>The specified instance status does not exist.</p>
    InvalidInstanceStatusException(crate::error::InvalidInstanceStatusException),
    /// <p>An invalid instance type was specified for instances in a blue/green deployment. Valid values include "Blue" for an original environment and "Green" for a replacement environment.</p>
    InvalidInstanceTypeException(crate::error::InvalidInstanceTypeException),
    /// <p>The specified key prefix filter was specified in an invalid format.</p>
    InvalidKeyPrefixFilterException(crate::error::InvalidKeyPrefixFilterException),
    /// <p>A lifecycle event hook is invalid. Review the <code>hooks</code> section in your AppSpec file to ensure the lifecycle events and <code>hooks</code> functions are valid.</p>
    InvalidLifecycleEventHookExecutionIdException(
        crate::error::InvalidLifecycleEventHookExecutionIdException,
    ),
    /// <p>The result of a Lambda validation function that verifies a lifecycle event is invalid. It should return <code>Succeeded</code> or <code>Failed</code>.</p>
    InvalidLifecycleEventHookExecutionStatusException(
        crate::error::InvalidLifecycleEventHookExecutionStatusException,
    ),
    /// <p>An invalid load balancer name, or no load balancer name, was specified.</p>
    InvalidLoadBalancerInfoException(crate::error::InvalidLoadBalancerInfoException),
    /// <p>The minimum healthy instance value was specified in an invalid format.</p>
    InvalidMinimumHealthyHostValueException(crate::error::InvalidMinimumHealthyHostValueException),
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>A call was submitted that specified both OnPremisesTagFilters and OnPremisesTagSet, but only one of these data types can be used in a single call.</p>
    InvalidOnPremisesTagCombinationException(
        crate::error::InvalidOnPremisesTagCombinationException,
    ),
    /// <p>An invalid operation was detected.</p>
    InvalidOperationException(crate::error::InvalidOperationException),
    /// <p>The registration status was specified in an invalid format.</p>
    InvalidRegistrationStatusException(crate::error::InvalidRegistrationStatusException),
    /// <p>The revision was specified in an invalid format.</p>
    InvalidRevisionException(crate::error::InvalidRevisionException),
    /// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
    InvalidRoleException(crate::error::InvalidRoleException),
    /// <p>The column name to sort by is either not present or was specified in an invalid format.</p>
    InvalidSortByException(crate::error::InvalidSortByException),
    /// <p>The sort order was specified in an invalid format.</p>
    InvalidSortOrderException(crate::error::InvalidSortOrderException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p>The tag filter was specified in an invalid format.</p>
    InvalidTagFilterException(crate::error::InvalidTagFilterException),
    /// <p> The specified tags are not valid. </p>
    InvalidTagsToAddException(crate::error::InvalidTagsToAddException),
    /// <p> The target filter name is invalid. </p>
    InvalidTargetFilterNameException(crate::error::InvalidTargetFilterNameException),
    /// <p> A target group pair associated with this deployment is not valid. </p>
    InvalidTargetGroupPairException(crate::error::InvalidTargetGroupPairException),
    /// <p>The target instance configuration is invalid. Possible causes include:</p>
    /// <ul>
    /// <li> <p>Configuration data for target instances was entered for an in-place deployment.</p> </li>
    /// <li> <p>The limit of 10 tags for a tag type was exceeded.</p> </li>
    /// <li> <p>The combined length of the tag names exceeded the limit. </p> </li>
    /// <li> <p>A specified tag is not currently applied to any instances.</p> </li>
    /// </ul>
    InvalidTargetInstancesException(crate::error::InvalidTargetInstancesException),
    /// <p>The specified time range was specified in an invalid format.</p>
    InvalidTimeRangeException(crate::error::InvalidTimeRangeException),
    /// <p> The configuration that specifies how traffic is routed during a deployment is invalid.</p>
    InvalidTrafficRoutingConfigurationException(
        crate::error::InvalidTrafficRoutingConfigurationException,
    ),
    /// <p>The trigger was specified in an invalid format.</p>
    InvalidTriggerConfigException(crate::error::InvalidTriggerConfigException),
    /// <p>The UpdateOutdatedInstancesOnly value is invalid. For Lambda deployments, <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code> or <code>false</code> is expected.</p>
    InvalidUpdateOutdatedInstancesOnlyValueException(
        crate::error::InvalidUpdateOutdatedInstancesOnlyValueException,
    ),
    /// <p>An attempt to return the status of an already completed lifecycle event occurred.</p>
    LifecycleEventAlreadyCompletedException(crate::error::LifecycleEventAlreadyCompletedException),
    /// <p>The limit for lifecycle hooks was exceeded.</p>
    LifecycleHookLimitExceededException(crate::error::LifecycleHookLimitExceededException),
    /// <p>Both an IAM user ARN and an IAM session ARN were included in the request. Use only one ARN type.</p>
    MultipleIamArnsProvidedException(crate::error::MultipleIamArnsProvidedException),
    /// <p>The API used does not support the deployment.</p>
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    /// <p> The ARN of a resource is required, but was not found. </p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// <p>The specified resource could not be validated.</p>
    ResourceValidationException(crate::error::ResourceValidationException),
    /// <p>The named revision does not exist with the IAM user or Amazon Web Services account.</p>
    RevisionDoesNotExistException(crate::error::RevisionDoesNotExistException),
    /// <p>The revision ID was not specified.</p>
    RevisionRequiredException(crate::error::RevisionRequiredException),
    /// <p>The role ID was not specified.</p>
    RoleRequiredException(crate::error::RoleRequiredException),
    /// <p>The maximum allowed number of tags was exceeded.</p>
    TagLimitExceededException(crate::error::TagLimitExceededException),
    /// <p>A tag was not specified.</p>
    TagRequiredException(crate::error::TagRequiredException),
    /// <p>The number of tag groups included in the tag set list exceeded the maximum allowed limit of 3.</p>
    TagSetListLimitExceededException(crate::error::TagSetListLimitExceededException),
    /// <p>An API function was called too frequently.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The maximum allowed number of triggers was exceeded.</p>
    TriggerTargetsLimitExceededException(crate::error::TriggerTargetsLimitExceededException),
    /// <p>A call was submitted that is not supported for the specified deployment type.</p>
    UnsupportedActionForDeploymentTypeException(
        crate::error::UnsupportedActionForDeploymentTypeException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::AlarmsLimitExceededException(inner) => inner.fmt(f),
            Error::ApplicationAlreadyExistsException(inner) => inner.fmt(f),
            Error::ApplicationDoesNotExistException(inner) => inner.fmt(f),
            Error::ApplicationLimitExceededException(inner) => inner.fmt(f),
            Error::ApplicationNameRequiredException(inner) => inner.fmt(f),
            Error::ArnNotSupportedException(inner) => inner.fmt(f),
            Error::BatchLimitExceededException(inner) => inner.fmt(f),
            Error::BucketNameFilterRequiredException(inner) => inner.fmt(f),
            Error::DeploymentAlreadyCompletedException(inner) => inner.fmt(f),
            Error::DeploymentConfigAlreadyExistsException(inner) => inner.fmt(f),
            Error::DeploymentConfigDoesNotExistException(inner) => inner.fmt(f),
            Error::DeploymentConfigInUseException(inner) => inner.fmt(f),
            Error::DeploymentConfigLimitExceededException(inner) => inner.fmt(f),
            Error::DeploymentConfigNameRequiredException(inner) => inner.fmt(f),
            Error::DeploymentDoesNotExistException(inner) => inner.fmt(f),
            Error::DeploymentGroupAlreadyExistsException(inner) => inner.fmt(f),
            Error::DeploymentGroupDoesNotExistException(inner) => inner.fmt(f),
            Error::DeploymentGroupLimitExceededException(inner) => inner.fmt(f),
            Error::DeploymentGroupNameRequiredException(inner) => inner.fmt(f),
            Error::DeploymentIdRequiredException(inner) => inner.fmt(f),
            Error::DeploymentIsNotInReadyStateException(inner) => inner.fmt(f),
            Error::DeploymentLimitExceededException(inner) => inner.fmt(f),
            Error::DeploymentNotStartedException(inner) => inner.fmt(f),
            Error::DeploymentTargetDoesNotExistException(inner) => inner.fmt(f),
            Error::DeploymentTargetIdRequiredException(inner) => inner.fmt(f),
            Error::DeploymentTargetListSizeExceededException(inner) => inner.fmt(f),
            Error::DescriptionTooLongException(inner) => inner.fmt(f),
            Error::EcsServiceMappingLimitExceededException(inner) => inner.fmt(f),
            Error::GitHubAccountTokenDoesNotExistException(inner) => inner.fmt(f),
            Error::GitHubAccountTokenNameRequiredException(inner) => inner.fmt(f),
            Error::IamArnRequiredException(inner) => inner.fmt(f),
            Error::IamSessionArnAlreadyRegisteredException(inner) => inner.fmt(f),
            Error::IamUserArnAlreadyRegisteredException(inner) => inner.fmt(f),
            Error::IamUserArnRequiredException(inner) => inner.fmt(f),
            Error::InstanceDoesNotExistException(inner) => inner.fmt(f),
            Error::InstanceIdRequiredException(inner) => inner.fmt(f),
            Error::InstanceLimitExceededException(inner) => inner.fmt(f),
            Error::InstanceNameAlreadyRegisteredException(inner) => inner.fmt(f),
            Error::InstanceNameRequiredException(inner) => inner.fmt(f),
            Error::InstanceNotRegisteredException(inner) => inner.fmt(f),
            Error::InvalidAlarmConfigException(inner) => inner.fmt(f),
            Error::InvalidApplicationNameException(inner) => inner.fmt(f),
            Error::InvalidArnException(inner) => inner.fmt(f),
            Error::InvalidAutoRollbackConfigException(inner) => inner.fmt(f),
            Error::InvalidAutoScalingGroupException(inner) => inner.fmt(f),
            Error::InvalidBlueGreenDeploymentConfigurationException(inner) => inner.fmt(f),
            Error::InvalidBucketNameFilterException(inner) => inner.fmt(f),
            Error::InvalidComputePlatformException(inner) => inner.fmt(f),
            Error::InvalidDeployedStateFilterException(inner) => inner.fmt(f),
            Error::InvalidDeploymentConfigNameException(inner) => inner.fmt(f),
            Error::InvalidDeploymentGroupNameException(inner) => inner.fmt(f),
            Error::InvalidDeploymentIdException(inner) => inner.fmt(f),
            Error::InvalidDeploymentInstanceTypeException(inner) => inner.fmt(f),
            Error::InvalidDeploymentStatusException(inner) => inner.fmt(f),
            Error::InvalidDeploymentStyleException(inner) => inner.fmt(f),
            Error::InvalidDeploymentTargetIdException(inner) => inner.fmt(f),
            Error::InvalidDeploymentWaitTypeException(inner) => inner.fmt(f),
            Error::InvalidEc2TagCombinationException(inner) => inner.fmt(f),
            Error::InvalidEc2TagException(inner) => inner.fmt(f),
            Error::InvalidEcsServiceException(inner) => inner.fmt(f),
            Error::InvalidExternalIdException(inner) => inner.fmt(f),
            Error::InvalidFileExistsBehaviorException(inner) => inner.fmt(f),
            Error::InvalidGitHubAccountTokenException(inner) => inner.fmt(f),
            Error::InvalidGitHubAccountTokenNameException(inner) => inner.fmt(f),
            Error::InvalidIamSessionArnException(inner) => inner.fmt(f),
            Error::InvalidIamUserArnException(inner) => inner.fmt(f),
            Error::InvalidIgnoreApplicationStopFailuresValueException(inner) => inner.fmt(f),
            Error::InvalidInputException(inner) => inner.fmt(f),
            Error::InvalidInstanceNameException(inner) => inner.fmt(f),
            Error::InvalidInstanceStatusException(inner) => inner.fmt(f),
            Error::InvalidInstanceTypeException(inner) => inner.fmt(f),
            Error::InvalidKeyPrefixFilterException(inner) => inner.fmt(f),
            Error::InvalidLifecycleEventHookExecutionIdException(inner) => inner.fmt(f),
            Error::InvalidLifecycleEventHookExecutionStatusException(inner) => inner.fmt(f),
            Error::InvalidLoadBalancerInfoException(inner) => inner.fmt(f),
            Error::InvalidMinimumHealthyHostValueException(inner) => inner.fmt(f),
            Error::InvalidNextTokenException(inner) => inner.fmt(f),
            Error::InvalidOnPremisesTagCombinationException(inner) => inner.fmt(f),
            Error::InvalidOperationException(inner) => inner.fmt(f),
            Error::InvalidRegistrationStatusException(inner) => inner.fmt(f),
            Error::InvalidRevisionException(inner) => inner.fmt(f),
            Error::InvalidRoleException(inner) => inner.fmt(f),
            Error::InvalidSortByException(inner) => inner.fmt(f),
            Error::InvalidSortOrderException(inner) => inner.fmt(f),
            Error::InvalidTagException(inner) => inner.fmt(f),
            Error::InvalidTagFilterException(inner) => inner.fmt(f),
            Error::InvalidTagsToAddException(inner) => inner.fmt(f),
            Error::InvalidTargetFilterNameException(inner) => inner.fmt(f),
            Error::InvalidTargetGroupPairException(inner) => inner.fmt(f),
            Error::InvalidTargetInstancesException(inner) => inner.fmt(f),
            Error::InvalidTimeRangeException(inner) => inner.fmt(f),
            Error::InvalidTrafficRoutingConfigurationException(inner) => inner.fmt(f),
            Error::InvalidTriggerConfigException(inner) => inner.fmt(f),
            Error::InvalidUpdateOutdatedInstancesOnlyValueException(inner) => inner.fmt(f),
            Error::LifecycleEventAlreadyCompletedException(inner) => inner.fmt(f),
            Error::LifecycleHookLimitExceededException(inner) => inner.fmt(f),
            Error::MultipleIamArnsProvidedException(inner) => inner.fmt(f),
            Error::OperationNotSupportedException(inner) => inner.fmt(f),
            Error::ResourceArnRequiredException(inner) => inner.fmt(f),
            Error::ResourceValidationException(inner) => inner.fmt(f),
            Error::RevisionDoesNotExistException(inner) => inner.fmt(f),
            Error::RevisionRequiredException(inner) => inner.fmt(f),
            Error::RoleRequiredException(inner) => inner.fmt(f),
            Error::TagLimitExceededException(inner) => inner.fmt(f),
            Error::TagRequiredException(inner) => inner.fmt(f),
            Error::TagSetListLimitExceededException(inner) => inner.fmt(f),
            Error::ThrottlingException(inner) => inner.fmt(f),
            Error::TriggerTargetsLimitExceededException(inner) => inner.fmt(f),
            Error::UnsupportedActionForDeploymentTypeException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AddTagsToOnPremisesInstancesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::AddTagsToOnPremisesInstancesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::AddTagsToOnPremisesInstancesError> for Error {
    fn from(err: crate::error::AddTagsToOnPremisesInstancesError) -> Self {
        match err {
            crate::error::AddTagsToOnPremisesInstancesError::InstanceLimitExceededException(
                inner,
            ) => Error::InstanceLimitExceededException(inner),
            crate::error::AddTagsToOnPremisesInstancesError::InstanceNameRequiredException(
                inner,
            ) => Error::InstanceNameRequiredException(inner),
            crate::error::AddTagsToOnPremisesInstancesError::InstanceNotRegisteredException(
                inner,
            ) => Error::InstanceNotRegisteredException(inner),
            crate::error::AddTagsToOnPremisesInstancesError::InvalidInstanceNameException(
                inner,
            ) => Error::InvalidInstanceNameException(inner),
            crate::error::AddTagsToOnPremisesInstancesError::InvalidTagException(inner) => {
                Error::InvalidTagException(inner)
            }
            crate::error::AddTagsToOnPremisesInstancesError::TagLimitExceededException(inner) => {
                Error::TagLimitExceededException(inner)
            }
            crate::error::AddTagsToOnPremisesInstancesError::TagRequiredException(inner) => {
                Error::TagRequiredException(inner)
            }
            crate::error::AddTagsToOnPremisesInstancesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetApplicationRevisionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::BatchGetApplicationRevisionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchGetApplicationRevisionsError> for Error {
    fn from(err: crate::error::BatchGetApplicationRevisionsError) -> Self {
        match err {
            crate::error::BatchGetApplicationRevisionsError::ApplicationDoesNotExistException(
                inner,
            ) => Error::ApplicationDoesNotExistException(inner),
            crate::error::BatchGetApplicationRevisionsError::ApplicationNameRequiredException(
                inner,
            ) => Error::ApplicationNameRequiredException(inner),
            crate::error::BatchGetApplicationRevisionsError::BatchLimitExceededException(inner) => {
                Error::BatchLimitExceededException(inner)
            }
            crate::error::BatchGetApplicationRevisionsError::InvalidApplicationNameException(
                inner,
            ) => Error::InvalidApplicationNameException(inner),
            crate::error::BatchGetApplicationRevisionsError::InvalidRevisionException(inner) => {
                Error::InvalidRevisionException(inner)
            }
            crate::error::BatchGetApplicationRevisionsError::RevisionRequiredException(inner) => {
                Error::RevisionRequiredException(inner)
            }
            crate::error::BatchGetApplicationRevisionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetApplicationsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::BatchGetApplicationsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchGetApplicationsError> for Error {
    fn from(err: crate::error::BatchGetApplicationsError) -> Self {
        match err {
            crate::error::BatchGetApplicationsError::ApplicationDoesNotExistException(inner) => {
                Error::ApplicationDoesNotExistException(inner)
            }
            crate::error::BatchGetApplicationsError::ApplicationNameRequiredException(inner) => {
                Error::ApplicationNameRequiredException(inner)
            }
            crate::error::BatchGetApplicationsError::BatchLimitExceededException(inner) => {
                Error::BatchLimitExceededException(inner)
            }
            crate::error::BatchGetApplicationsError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::BatchGetApplicationsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentGroupsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentGroupsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchGetDeploymentGroupsError> for Error {
    fn from(err: crate::error::BatchGetDeploymentGroupsError) -> Self {
        match err {
            crate::error::BatchGetDeploymentGroupsError::ApplicationDoesNotExistException(
                inner,
            ) => Error::ApplicationDoesNotExistException(inner),
            crate::error::BatchGetDeploymentGroupsError::ApplicationNameRequiredException(
                inner,
            ) => Error::ApplicationNameRequiredException(inner),
            crate::error::BatchGetDeploymentGroupsError::BatchLimitExceededException(inner) => {
                Error::BatchLimitExceededException(inner)
            }
            crate::error::BatchGetDeploymentGroupsError::DeploymentConfigDoesNotExistException(
                inner,
            ) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::BatchGetDeploymentGroupsError::DeploymentGroupNameRequiredException(
                inner,
            ) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::BatchGetDeploymentGroupsError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::BatchGetDeploymentGroupsError::InvalidDeploymentGroupNameException(
                inner,
            ) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::BatchGetDeploymentGroupsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentInstancesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentInstancesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchGetDeploymentInstancesError> for Error {
    fn from(err: crate::error::BatchGetDeploymentInstancesError) -> Self {
        match err {
            crate::error::BatchGetDeploymentInstancesError::BatchLimitExceededException(inner) => {
                Error::BatchLimitExceededException(inner)
            }
            crate::error::BatchGetDeploymentInstancesError::DeploymentDoesNotExistException(
                inner,
            ) => Error::DeploymentDoesNotExistException(inner),
            crate::error::BatchGetDeploymentInstancesError::DeploymentIdRequiredException(
                inner,
            ) => Error::DeploymentIdRequiredException(inner),
            crate::error::BatchGetDeploymentInstancesError::InstanceIdRequiredException(inner) => {
                Error::InstanceIdRequiredException(inner)
            }
            crate::error::BatchGetDeploymentInstancesError::InvalidComputePlatformException(
                inner,
            ) => Error::InvalidComputePlatformException(inner),
            crate::error::BatchGetDeploymentInstancesError::InvalidDeploymentIdException(inner) => {
                Error::InvalidDeploymentIdException(inner)
            }
            crate::error::BatchGetDeploymentInstancesError::InvalidInstanceNameException(inner) => {
                Error::InvalidInstanceNameException(inner)
            }
            crate::error::BatchGetDeploymentInstancesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchGetDeploymentsError> for Error {
    fn from(err: crate::error::BatchGetDeploymentsError) -> Self {
        match err {
            crate::error::BatchGetDeploymentsError::BatchLimitExceededException(inner) => {
                Error::BatchLimitExceededException(inner)
            }
            crate::error::BatchGetDeploymentsError::DeploymentIdRequiredException(inner) => {
                Error::DeploymentIdRequiredException(inner)
            }
            crate::error::BatchGetDeploymentsError::InvalidDeploymentIdException(inner) => {
                Error::InvalidDeploymentIdException(inner)
            }
            crate::error::BatchGetDeploymentsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentTargetsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::BatchGetDeploymentTargetsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchGetDeploymentTargetsError> for Error {
    fn from(err: crate::error::BatchGetDeploymentTargetsError) -> Self {
        match err {
            crate::error::BatchGetDeploymentTargetsError::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::BatchGetDeploymentTargetsError::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::BatchGetDeploymentTargetsError::DeploymentNotStartedException(inner) => Error::DeploymentNotStartedException(inner),
            crate::error::BatchGetDeploymentTargetsError::DeploymentTargetDoesNotExistException(inner) => Error::DeploymentTargetDoesNotExistException(inner),
            crate::error::BatchGetDeploymentTargetsError::DeploymentTargetIdRequiredException(inner) => Error::DeploymentTargetIdRequiredException(inner),
            crate::error::BatchGetDeploymentTargetsError::DeploymentTargetListSizeExceededException(inner) => Error::DeploymentTargetListSizeExceededException(inner),
            crate::error::BatchGetDeploymentTargetsError::InstanceDoesNotExistException(inner) => Error::InstanceDoesNotExistException(inner),
            crate::error::BatchGetDeploymentTargetsError::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::BatchGetDeploymentTargetsError::InvalidDeploymentTargetIdException(inner) => Error::InvalidDeploymentTargetIdException(inner),
            crate::error::BatchGetDeploymentTargetsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetOnPremisesInstancesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::BatchGetOnPremisesInstancesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::BatchGetOnPremisesInstancesError> for Error {
    fn from(err: crate::error::BatchGetOnPremisesInstancesError) -> Self {
        match err {
            crate::error::BatchGetOnPremisesInstancesError::BatchLimitExceededException(inner) => {
                Error::BatchLimitExceededException(inner)
            }
            crate::error::BatchGetOnPremisesInstancesError::InstanceNameRequiredException(
                inner,
            ) => Error::InstanceNameRequiredException(inner),
            crate::error::BatchGetOnPremisesInstancesError::InvalidInstanceNameException(inner) => {
                Error::InvalidInstanceNameException(inner)
            }
            crate::error::BatchGetOnPremisesInstancesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ContinueDeploymentError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ContinueDeploymentError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ContinueDeploymentError> for Error {
    fn from(err: crate::error::ContinueDeploymentError) -> Self {
        match err {
            crate::error::ContinueDeploymentError::DeploymentAlreadyCompletedException(inner) => {
                Error::DeploymentAlreadyCompletedException(inner)
            }
            crate::error::ContinueDeploymentError::DeploymentDoesNotExistException(inner) => {
                Error::DeploymentDoesNotExistException(inner)
            }
            crate::error::ContinueDeploymentError::DeploymentIdRequiredException(inner) => {
                Error::DeploymentIdRequiredException(inner)
            }
            crate::error::ContinueDeploymentError::DeploymentIsNotInReadyStateException(inner) => {
                Error::DeploymentIsNotInReadyStateException(inner)
            }
            crate::error::ContinueDeploymentError::InvalidDeploymentIdException(inner) => {
                Error::InvalidDeploymentIdException(inner)
            }
            crate::error::ContinueDeploymentError::InvalidDeploymentStatusException(inner) => {
                Error::InvalidDeploymentStatusException(inner)
            }
            crate::error::ContinueDeploymentError::InvalidDeploymentWaitTypeException(inner) => {
                Error::InvalidDeploymentWaitTypeException(inner)
            }
            crate::error::ContinueDeploymentError::UnsupportedActionForDeploymentTypeException(
                inner,
            ) => Error::UnsupportedActionForDeploymentTypeException(inner),
            crate::error::ContinueDeploymentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateApplicationError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateApplicationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateApplicationError> for Error {
    fn from(err: crate::error::CreateApplicationError) -> Self {
        match err {
            crate::error::CreateApplicationError::ApplicationAlreadyExistsException(inner) => {
                Error::ApplicationAlreadyExistsException(inner)
            }
            crate::error::CreateApplicationError::ApplicationLimitExceededException(inner) => {
                Error::ApplicationLimitExceededException(inner)
            }
            crate::error::CreateApplicationError::ApplicationNameRequiredException(inner) => {
                Error::ApplicationNameRequiredException(inner)
            }
            crate::error::CreateApplicationError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::CreateApplicationError::InvalidComputePlatformException(inner) => {
                Error::InvalidComputePlatformException(inner)
            }
            crate::error::CreateApplicationError::InvalidTagsToAddException(inner) => {
                Error::InvalidTagsToAddException(inner)
            }
            crate::error::CreateApplicationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateDeploymentError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateDeploymentError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateDeploymentError> for Error {
    fn from(err: crate::error::CreateDeploymentError) -> Self {
        match err {
            crate::error::CreateDeploymentError::AlarmsLimitExceededException(inner) => Error::AlarmsLimitExceededException(inner),
            crate::error::CreateDeploymentError::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::CreateDeploymentError::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::CreateDeploymentError::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::CreateDeploymentError::DeploymentGroupDoesNotExistException(inner) => Error::DeploymentGroupDoesNotExistException(inner),
            crate::error::CreateDeploymentError::DeploymentGroupNameRequiredException(inner) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::CreateDeploymentError::DeploymentLimitExceededException(inner) => Error::DeploymentLimitExceededException(inner),
            crate::error::CreateDeploymentError::DescriptionTooLongException(inner) => Error::DescriptionTooLongException(inner),
            crate::error::CreateDeploymentError::InvalidAlarmConfigException(inner) => Error::InvalidAlarmConfigException(inner),
            crate::error::CreateDeploymentError::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::CreateDeploymentError::InvalidAutoRollbackConfigException(inner) => Error::InvalidAutoRollbackConfigException(inner),
            crate::error::CreateDeploymentError::InvalidAutoScalingGroupException(inner) => Error::InvalidAutoScalingGroupException(inner),
            crate::error::CreateDeploymentError::InvalidDeploymentConfigNameException(inner) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::CreateDeploymentError::InvalidDeploymentGroupNameException(inner) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::CreateDeploymentError::InvalidFileExistsBehaviorException(inner) => Error::InvalidFileExistsBehaviorException(inner),
            crate::error::CreateDeploymentError::InvalidGitHubAccountTokenException(inner) => Error::InvalidGitHubAccountTokenException(inner),
            crate::error::CreateDeploymentError::InvalidIgnoreApplicationStopFailuresValueException(inner) => Error::InvalidIgnoreApplicationStopFailuresValueException(inner),
            crate::error::CreateDeploymentError::InvalidLoadBalancerInfoException(inner) => Error::InvalidLoadBalancerInfoException(inner),
            crate::error::CreateDeploymentError::InvalidRevisionException(inner) => Error::InvalidRevisionException(inner),
            crate::error::CreateDeploymentError::InvalidRoleException(inner) => Error::InvalidRoleException(inner),
            crate::error::CreateDeploymentError::InvalidTargetInstancesException(inner) => Error::InvalidTargetInstancesException(inner),
            crate::error::CreateDeploymentError::InvalidTrafficRoutingConfigurationException(inner) => Error::InvalidTrafficRoutingConfigurationException(inner),
            crate::error::CreateDeploymentError::InvalidUpdateOutdatedInstancesOnlyValueException(inner) => Error::InvalidUpdateOutdatedInstancesOnlyValueException(inner),
            crate::error::CreateDeploymentError::RevisionDoesNotExistException(inner) => Error::RevisionDoesNotExistException(inner),
            crate::error::CreateDeploymentError::RevisionRequiredException(inner) => Error::RevisionRequiredException(inner),
            crate::error::CreateDeploymentError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::error::CreateDeploymentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateDeploymentConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateDeploymentConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateDeploymentConfigError> for Error {
    fn from(err: crate::error::CreateDeploymentConfigError) -> Self {
        match err {
            crate::error::CreateDeploymentConfigError::DeploymentConfigAlreadyExistsException(inner) => Error::DeploymentConfigAlreadyExistsException(inner),
            crate::error::CreateDeploymentConfigError::DeploymentConfigLimitExceededException(inner) => Error::DeploymentConfigLimitExceededException(inner),
            crate::error::CreateDeploymentConfigError::DeploymentConfigNameRequiredException(inner) => Error::DeploymentConfigNameRequiredException(inner),
            crate::error::CreateDeploymentConfigError::InvalidComputePlatformException(inner) => Error::InvalidComputePlatformException(inner),
            crate::error::CreateDeploymentConfigError::InvalidDeploymentConfigNameException(inner) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::CreateDeploymentConfigError::InvalidMinimumHealthyHostValueException(inner) => Error::InvalidMinimumHealthyHostValueException(inner),
            crate::error::CreateDeploymentConfigError::InvalidTrafficRoutingConfigurationException(inner) => Error::InvalidTrafficRoutingConfigurationException(inner),
            crate::error::CreateDeploymentConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateDeploymentGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::CreateDeploymentGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::CreateDeploymentGroupError> for Error {
    fn from(err: crate::error::CreateDeploymentGroupError) -> Self {
        match err {
            crate::error::CreateDeploymentGroupError::AlarmsLimitExceededException(inner) => Error::AlarmsLimitExceededException(inner),
            crate::error::CreateDeploymentGroupError::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::CreateDeploymentGroupError::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::CreateDeploymentGroupError::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::CreateDeploymentGroupError::DeploymentGroupAlreadyExistsException(inner) => Error::DeploymentGroupAlreadyExistsException(inner),
            crate::error::CreateDeploymentGroupError::DeploymentGroupLimitExceededException(inner) => Error::DeploymentGroupLimitExceededException(inner),
            crate::error::CreateDeploymentGroupError::DeploymentGroupNameRequiredException(inner) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::CreateDeploymentGroupError::EcsServiceMappingLimitExceededException(inner) => Error::EcsServiceMappingLimitExceededException(inner),
            crate::error::CreateDeploymentGroupError::InvalidAlarmConfigException(inner) => Error::InvalidAlarmConfigException(inner),
            crate::error::CreateDeploymentGroupError::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::CreateDeploymentGroupError::InvalidAutoRollbackConfigException(inner) => Error::InvalidAutoRollbackConfigException(inner),
            crate::error::CreateDeploymentGroupError::InvalidAutoScalingGroupException(inner) => Error::InvalidAutoScalingGroupException(inner),
            crate::error::CreateDeploymentGroupError::InvalidBlueGreenDeploymentConfigurationException(inner) => Error::InvalidBlueGreenDeploymentConfigurationException(inner),
            crate::error::CreateDeploymentGroupError::InvalidDeploymentConfigNameException(inner) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::CreateDeploymentGroupError::InvalidDeploymentGroupNameException(inner) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::CreateDeploymentGroupError::InvalidDeploymentStyleException(inner) => Error::InvalidDeploymentStyleException(inner),
            crate::error::CreateDeploymentGroupError::InvalidEc2TagCombinationException(inner) => Error::InvalidEc2TagCombinationException(inner),
            crate::error::CreateDeploymentGroupError::InvalidEc2TagException(inner) => Error::InvalidEc2TagException(inner),
            crate::error::CreateDeploymentGroupError::InvalidEcsServiceException(inner) => Error::InvalidEcsServiceException(inner),
            crate::error::CreateDeploymentGroupError::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::error::CreateDeploymentGroupError::InvalidLoadBalancerInfoException(inner) => Error::InvalidLoadBalancerInfoException(inner),
            crate::error::CreateDeploymentGroupError::InvalidOnPremisesTagCombinationException(inner) => Error::InvalidOnPremisesTagCombinationException(inner),
            crate::error::CreateDeploymentGroupError::InvalidRoleException(inner) => Error::InvalidRoleException(inner),
            crate::error::CreateDeploymentGroupError::InvalidTagException(inner) => Error::InvalidTagException(inner),
            crate::error::CreateDeploymentGroupError::InvalidTagsToAddException(inner) => Error::InvalidTagsToAddException(inner),
            crate::error::CreateDeploymentGroupError::InvalidTargetGroupPairException(inner) => Error::InvalidTargetGroupPairException(inner),
            crate::error::CreateDeploymentGroupError::InvalidTrafficRoutingConfigurationException(inner) => Error::InvalidTrafficRoutingConfigurationException(inner),
            crate::error::CreateDeploymentGroupError::InvalidTriggerConfigException(inner) => Error::InvalidTriggerConfigException(inner),
            crate::error::CreateDeploymentGroupError::LifecycleHookLimitExceededException(inner) => Error::LifecycleHookLimitExceededException(inner),
            crate::error::CreateDeploymentGroupError::RoleRequiredException(inner) => Error::RoleRequiredException(inner),
            crate::error::CreateDeploymentGroupError::TagSetListLimitExceededException(inner) => Error::TagSetListLimitExceededException(inner),
            crate::error::CreateDeploymentGroupError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::error::CreateDeploymentGroupError::TriggerTargetsLimitExceededException(inner) => Error::TriggerTargetsLimitExceededException(inner),
            crate::error::CreateDeploymentGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteApplicationError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteApplicationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteApplicationError> for Error {
    fn from(err: crate::error::DeleteApplicationError) -> Self {
        match err {
            crate::error::DeleteApplicationError::ApplicationNameRequiredException(inner) => {
                Error::ApplicationNameRequiredException(inner)
            }
            crate::error::DeleteApplicationError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::DeleteApplicationError::InvalidRoleException(inner) => {
                Error::InvalidRoleException(inner)
            }
            crate::error::DeleteApplicationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteDeploymentConfigError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteDeploymentConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteDeploymentConfigError> for Error {
    fn from(err: crate::error::DeleteDeploymentConfigError) -> Self {
        match err {
            crate::error::DeleteDeploymentConfigError::DeploymentConfigInUseException(inner) => {
                Error::DeploymentConfigInUseException(inner)
            }
            crate::error::DeleteDeploymentConfigError::DeploymentConfigNameRequiredException(
                inner,
            ) => Error::DeploymentConfigNameRequiredException(inner),
            crate::error::DeleteDeploymentConfigError::InvalidDeploymentConfigNameException(
                inner,
            ) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::DeleteDeploymentConfigError::InvalidOperationException(inner) => {
                Error::InvalidOperationException(inner)
            }
            crate::error::DeleteDeploymentConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteDeploymentGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteDeploymentGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteDeploymentGroupError> for Error {
    fn from(err: crate::error::DeleteDeploymentGroupError) -> Self {
        match err {
            crate::error::DeleteDeploymentGroupError::ApplicationNameRequiredException(inner) => {
                Error::ApplicationNameRequiredException(inner)
            }
            crate::error::DeleteDeploymentGroupError::DeploymentGroupNameRequiredException(
                inner,
            ) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::DeleteDeploymentGroupError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::DeleteDeploymentGroupError::InvalidDeploymentGroupNameException(
                inner,
            ) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::DeleteDeploymentGroupError::InvalidRoleException(inner) => {
                Error::InvalidRoleException(inner)
            }
            crate::error::DeleteDeploymentGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteGitHubAccountTokenError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteGitHubAccountTokenError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteGitHubAccountTokenError> for Error {
    fn from(err: crate::error::DeleteGitHubAccountTokenError) -> Self {
        match err {
            crate::error::DeleteGitHubAccountTokenError::GitHubAccountTokenDoesNotExistException(inner) => Error::GitHubAccountTokenDoesNotExistException(inner),
            crate::error::DeleteGitHubAccountTokenError::GitHubAccountTokenNameRequiredException(inner) => Error::GitHubAccountTokenNameRequiredException(inner),
            crate::error::DeleteGitHubAccountTokenError::InvalidGitHubAccountTokenNameException(inner) => Error::InvalidGitHubAccountTokenNameException(inner),
            crate::error::DeleteGitHubAccountTokenError::OperationNotSupportedException(inner) => Error::OperationNotSupportedException(inner),
            crate::error::DeleteGitHubAccountTokenError::ResourceValidationException(inner) => Error::ResourceValidationException(inner),
            crate::error::DeleteGitHubAccountTokenError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteResourcesByExternalIdError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeleteResourcesByExternalIdError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeleteResourcesByExternalIdError> for Error {
    fn from(err: crate::error::DeleteResourcesByExternalIdError) -> Self {
        match err {
            crate::error::DeleteResourcesByExternalIdError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeregisterOnPremisesInstanceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::DeregisterOnPremisesInstanceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::DeregisterOnPremisesInstanceError> for Error {
    fn from(err: crate::error::DeregisterOnPremisesInstanceError) -> Self {
        match err {
            crate::error::DeregisterOnPremisesInstanceError::InstanceNameRequiredException(
                inner,
            ) => Error::InstanceNameRequiredException(inner),
            crate::error::DeregisterOnPremisesInstanceError::InvalidInstanceNameException(
                inner,
            ) => Error::InvalidInstanceNameException(inner),
            crate::error::DeregisterOnPremisesInstanceError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetApplicationError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetApplicationError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetApplicationError> for Error {
    fn from(err: crate::error::GetApplicationError) -> Self {
        match err {
            crate::error::GetApplicationError::ApplicationDoesNotExistException(inner) => {
                Error::ApplicationDoesNotExistException(inner)
            }
            crate::error::GetApplicationError::ApplicationNameRequiredException(inner) => {
                Error::ApplicationNameRequiredException(inner)
            }
            crate::error::GetApplicationError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::GetApplicationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetApplicationRevisionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetApplicationRevisionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetApplicationRevisionError> for Error {
    fn from(err: crate::error::GetApplicationRevisionError) -> Self {
        match err {
            crate::error::GetApplicationRevisionError::ApplicationDoesNotExistException(inner) => {
                Error::ApplicationDoesNotExistException(inner)
            }
            crate::error::GetApplicationRevisionError::ApplicationNameRequiredException(inner) => {
                Error::ApplicationNameRequiredException(inner)
            }
            crate::error::GetApplicationRevisionError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::GetApplicationRevisionError::InvalidRevisionException(inner) => {
                Error::InvalidRevisionException(inner)
            }
            crate::error::GetApplicationRevisionError::RevisionDoesNotExistException(inner) => {
                Error::RevisionDoesNotExistException(inner)
            }
            crate::error::GetApplicationRevisionError::RevisionRequiredException(inner) => {
                Error::RevisionRequiredException(inner)
            }
            crate::error::GetApplicationRevisionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDeploymentError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDeploymentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDeploymentError> for Error {
    fn from(err: crate::error::GetDeploymentError) -> Self {
        match err {
            crate::error::GetDeploymentError::DeploymentDoesNotExistException(inner) => {
                Error::DeploymentDoesNotExistException(inner)
            }
            crate::error::GetDeploymentError::DeploymentIdRequiredException(inner) => {
                Error::DeploymentIdRequiredException(inner)
            }
            crate::error::GetDeploymentError::InvalidDeploymentIdException(inner) => {
                Error::InvalidDeploymentIdException(inner)
            }
            crate::error::GetDeploymentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDeploymentConfigError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetDeploymentConfigError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDeploymentConfigError> for Error {
    fn from(err: crate::error::GetDeploymentConfigError) -> Self {
        match err {
            crate::error::GetDeploymentConfigError::DeploymentConfigDoesNotExistException(
                inner,
            ) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::GetDeploymentConfigError::DeploymentConfigNameRequiredException(
                inner,
            ) => Error::DeploymentConfigNameRequiredException(inner),
            crate::error::GetDeploymentConfigError::InvalidComputePlatformException(inner) => {
                Error::InvalidComputePlatformException(inner)
            }
            crate::error::GetDeploymentConfigError::InvalidDeploymentConfigNameException(inner) => {
                Error::InvalidDeploymentConfigNameException(inner)
            }
            crate::error::GetDeploymentConfigError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDeploymentGroupError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetDeploymentGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDeploymentGroupError> for Error {
    fn from(err: crate::error::GetDeploymentGroupError) -> Self {
        match err {
            crate::error::GetDeploymentGroupError::ApplicationDoesNotExistException(inner) => {
                Error::ApplicationDoesNotExistException(inner)
            }
            crate::error::GetDeploymentGroupError::ApplicationNameRequiredException(inner) => {
                Error::ApplicationNameRequiredException(inner)
            }
            crate::error::GetDeploymentGroupError::DeploymentConfigDoesNotExistException(inner) => {
                Error::DeploymentConfigDoesNotExistException(inner)
            }
            crate::error::GetDeploymentGroupError::DeploymentGroupDoesNotExistException(inner) => {
                Error::DeploymentGroupDoesNotExistException(inner)
            }
            crate::error::GetDeploymentGroupError::DeploymentGroupNameRequiredException(inner) => {
                Error::DeploymentGroupNameRequiredException(inner)
            }
            crate::error::GetDeploymentGroupError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::GetDeploymentGroupError::InvalidDeploymentGroupNameException(inner) => {
                Error::InvalidDeploymentGroupNameException(inner)
            }
            crate::error::GetDeploymentGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDeploymentInstanceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetDeploymentInstanceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDeploymentInstanceError> for Error {
    fn from(err: crate::error::GetDeploymentInstanceError) -> Self {
        match err {
            crate::error::GetDeploymentInstanceError::DeploymentDoesNotExistException(inner) => {
                Error::DeploymentDoesNotExistException(inner)
            }
            crate::error::GetDeploymentInstanceError::DeploymentIdRequiredException(inner) => {
                Error::DeploymentIdRequiredException(inner)
            }
            crate::error::GetDeploymentInstanceError::InstanceDoesNotExistException(inner) => {
                Error::InstanceDoesNotExistException(inner)
            }
            crate::error::GetDeploymentInstanceError::InstanceIdRequiredException(inner) => {
                Error::InstanceIdRequiredException(inner)
            }
            crate::error::GetDeploymentInstanceError::InvalidComputePlatformException(inner) => {
                Error::InvalidComputePlatformException(inner)
            }
            crate::error::GetDeploymentInstanceError::InvalidDeploymentIdException(inner) => {
                Error::InvalidDeploymentIdException(inner)
            }
            crate::error::GetDeploymentInstanceError::InvalidInstanceNameException(inner) => {
                Error::InvalidInstanceNameException(inner)
            }
            crate::error::GetDeploymentInstanceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDeploymentTargetError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetDeploymentTargetError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetDeploymentTargetError> for Error {
    fn from(err: crate::error::GetDeploymentTargetError) -> Self {
        match err {
            crate::error::GetDeploymentTargetError::DeploymentDoesNotExistException(inner) => {
                Error::DeploymentDoesNotExistException(inner)
            }
            crate::error::GetDeploymentTargetError::DeploymentIdRequiredException(inner) => {
                Error::DeploymentIdRequiredException(inner)
            }
            crate::error::GetDeploymentTargetError::DeploymentNotStartedException(inner) => {
                Error::DeploymentNotStartedException(inner)
            }
            crate::error::GetDeploymentTargetError::DeploymentTargetDoesNotExistException(
                inner,
            ) => Error::DeploymentTargetDoesNotExistException(inner),
            crate::error::GetDeploymentTargetError::DeploymentTargetIdRequiredException(inner) => {
                Error::DeploymentTargetIdRequiredException(inner)
            }
            crate::error::GetDeploymentTargetError::InvalidDeploymentIdException(inner) => {
                Error::InvalidDeploymentIdException(inner)
            }
            crate::error::GetDeploymentTargetError::InvalidDeploymentTargetIdException(inner) => {
                Error::InvalidDeploymentTargetIdException(inner)
            }
            crate::error::GetDeploymentTargetError::InvalidInstanceNameException(inner) => {
                Error::InvalidInstanceNameException(inner)
            }
            crate::error::GetDeploymentTargetError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetOnPremisesInstanceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::GetOnPremisesInstanceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::GetOnPremisesInstanceError> for Error {
    fn from(err: crate::error::GetOnPremisesInstanceError) -> Self {
        match err {
            crate::error::GetOnPremisesInstanceError::InstanceNameRequiredException(inner) => {
                Error::InstanceNameRequiredException(inner)
            }
            crate::error::GetOnPremisesInstanceError::InstanceNotRegisteredException(inner) => {
                Error::InstanceNotRegisteredException(inner)
            }
            crate::error::GetOnPremisesInstanceError::InvalidInstanceNameException(inner) => {
                Error::InvalidInstanceNameException(inner)
            }
            crate::error::GetOnPremisesInstanceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListApplicationRevisionsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListApplicationRevisionsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListApplicationRevisionsError> for Error {
    fn from(err: crate::error::ListApplicationRevisionsError) -> Self {
        match err {
            crate::error::ListApplicationRevisionsError::ApplicationDoesNotExistException(
                inner,
            ) => Error::ApplicationDoesNotExistException(inner),
            crate::error::ListApplicationRevisionsError::ApplicationNameRequiredException(
                inner,
            ) => Error::ApplicationNameRequiredException(inner),
            crate::error::ListApplicationRevisionsError::BucketNameFilterRequiredException(
                inner,
            ) => Error::BucketNameFilterRequiredException(inner),
            crate::error::ListApplicationRevisionsError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::ListApplicationRevisionsError::InvalidBucketNameFilterException(
                inner,
            ) => Error::InvalidBucketNameFilterException(inner),
            crate::error::ListApplicationRevisionsError::InvalidDeployedStateFilterException(
                inner,
            ) => Error::InvalidDeployedStateFilterException(inner),
            crate::error::ListApplicationRevisionsError::InvalidKeyPrefixFilterException(inner) => {
                Error::InvalidKeyPrefixFilterException(inner)
            }
            crate::error::ListApplicationRevisionsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::ListApplicationRevisionsError::InvalidSortByException(inner) => {
                Error::InvalidSortByException(inner)
            }
            crate::error::ListApplicationRevisionsError::InvalidSortOrderException(inner) => {
                Error::InvalidSortOrderException(inner)
            }
            crate::error::ListApplicationRevisionsError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListApplicationsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListApplicationsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListApplicationsError> for Error {
    fn from(err: crate::error::ListApplicationsError) -> Self {
        match err {
            crate::error::ListApplicationsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::ListApplicationsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDeploymentConfigsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListDeploymentConfigsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDeploymentConfigsError> for Error {
    fn from(err: crate::error::ListDeploymentConfigsError) -> Self {
        match err {
            crate::error::ListDeploymentConfigsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::ListDeploymentConfigsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDeploymentGroupsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListDeploymentGroupsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDeploymentGroupsError> for Error {
    fn from(err: crate::error::ListDeploymentGroupsError) -> Self {
        match err {
            crate::error::ListDeploymentGroupsError::ApplicationDoesNotExistException(inner) => {
                Error::ApplicationDoesNotExistException(inner)
            }
            crate::error::ListDeploymentGroupsError::ApplicationNameRequiredException(inner) => {
                Error::ApplicationNameRequiredException(inner)
            }
            crate::error::ListDeploymentGroupsError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::ListDeploymentGroupsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::ListDeploymentGroupsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDeploymentInstancesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListDeploymentInstancesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDeploymentInstancesError> for Error {
    fn from(err: crate::error::ListDeploymentInstancesError) -> Self {
        match err {
            crate::error::ListDeploymentInstancesError::DeploymentDoesNotExistException(inner) => {
                Error::DeploymentDoesNotExistException(inner)
            }
            crate::error::ListDeploymentInstancesError::DeploymentIdRequiredException(inner) => {
                Error::DeploymentIdRequiredException(inner)
            }
            crate::error::ListDeploymentInstancesError::DeploymentNotStartedException(inner) => {
                Error::DeploymentNotStartedException(inner)
            }
            crate::error::ListDeploymentInstancesError::InvalidComputePlatformException(inner) => {
                Error::InvalidComputePlatformException(inner)
            }
            crate::error::ListDeploymentInstancesError::InvalidDeploymentIdException(inner) => {
                Error::InvalidDeploymentIdException(inner)
            }
            crate::error::ListDeploymentInstancesError::InvalidDeploymentInstanceTypeException(
                inner,
            ) => Error::InvalidDeploymentInstanceTypeException(inner),
            crate::error::ListDeploymentInstancesError::InvalidInstanceStatusException(inner) => {
                Error::InvalidInstanceStatusException(inner)
            }
            crate::error::ListDeploymentInstancesError::InvalidInstanceTypeException(inner) => {
                Error::InvalidInstanceTypeException(inner)
            }
            crate::error::ListDeploymentInstancesError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::ListDeploymentInstancesError::InvalidTargetFilterNameException(inner) => {
                Error::InvalidTargetFilterNameException(inner)
            }
            crate::error::ListDeploymentInstancesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDeploymentsError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListDeploymentsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDeploymentsError> for Error {
    fn from(err: crate::error::ListDeploymentsError) -> Self {
        match err {
            crate::error::ListDeploymentsError::ApplicationDoesNotExistException(inner) => {
                Error::ApplicationDoesNotExistException(inner)
            }
            crate::error::ListDeploymentsError::ApplicationNameRequiredException(inner) => {
                Error::ApplicationNameRequiredException(inner)
            }
            crate::error::ListDeploymentsError::DeploymentGroupDoesNotExistException(inner) => {
                Error::DeploymentGroupDoesNotExistException(inner)
            }
            crate::error::ListDeploymentsError::DeploymentGroupNameRequiredException(inner) => {
                Error::DeploymentGroupNameRequiredException(inner)
            }
            crate::error::ListDeploymentsError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::ListDeploymentsError::InvalidDeploymentGroupNameException(inner) => {
                Error::InvalidDeploymentGroupNameException(inner)
            }
            crate::error::ListDeploymentsError::InvalidDeploymentStatusException(inner) => {
                Error::InvalidDeploymentStatusException(inner)
            }
            crate::error::ListDeploymentsError::InvalidExternalIdException(inner) => {
                Error::InvalidExternalIdException(inner)
            }
            crate::error::ListDeploymentsError::InvalidInputException(inner) => {
                Error::InvalidInputException(inner)
            }
            crate::error::ListDeploymentsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::ListDeploymentsError::InvalidTimeRangeException(inner) => {
                Error::InvalidTimeRangeException(inner)
            }
            crate::error::ListDeploymentsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListDeploymentTargetsError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListDeploymentTargetsError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListDeploymentTargetsError> for Error {
    fn from(err: crate::error::ListDeploymentTargetsError) -> Self {
        match err {
            crate::error::ListDeploymentTargetsError::DeploymentDoesNotExistException(inner) => {
                Error::DeploymentDoesNotExistException(inner)
            }
            crate::error::ListDeploymentTargetsError::DeploymentIdRequiredException(inner) => {
                Error::DeploymentIdRequiredException(inner)
            }
            crate::error::ListDeploymentTargetsError::DeploymentNotStartedException(inner) => {
                Error::DeploymentNotStartedException(inner)
            }
            crate::error::ListDeploymentTargetsError::InvalidDeploymentIdException(inner) => {
                Error::InvalidDeploymentIdException(inner)
            }
            crate::error::ListDeploymentTargetsError::InvalidDeploymentInstanceTypeException(
                inner,
            ) => Error::InvalidDeploymentInstanceTypeException(inner),
            crate::error::ListDeploymentTargetsError::InvalidInstanceStatusException(inner) => {
                Error::InvalidInstanceStatusException(inner)
            }
            crate::error::ListDeploymentTargetsError::InvalidInstanceTypeException(inner) => {
                Error::InvalidInstanceTypeException(inner)
            }
            crate::error::ListDeploymentTargetsError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::ListDeploymentTargetsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListGitHubAccountTokenNamesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListGitHubAccountTokenNamesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListGitHubAccountTokenNamesError> for Error {
    fn from(err: crate::error::ListGitHubAccountTokenNamesError) -> Self {
        match err {
            crate::error::ListGitHubAccountTokenNamesError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::ListGitHubAccountTokenNamesError::OperationNotSupportedException(
                inner,
            ) => Error::OperationNotSupportedException(inner),
            crate::error::ListGitHubAccountTokenNamesError::ResourceValidationException(inner) => {
                Error::ResourceValidationException(inner)
            }
            crate::error::ListGitHubAccountTokenNamesError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListOnPremisesInstancesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListOnPremisesInstancesError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListOnPremisesInstancesError> for Error {
    fn from(err: crate::error::ListOnPremisesInstancesError) -> Self {
        match err {
            crate::error::ListOnPremisesInstancesError::InvalidNextTokenException(inner) => {
                Error::InvalidNextTokenException(inner)
            }
            crate::error::ListOnPremisesInstancesError::InvalidRegistrationStatusException(
                inner,
            ) => Error::InvalidRegistrationStatusException(inner),
            crate::error::ListOnPremisesInstancesError::InvalidTagFilterException(inner) => {
                Error::InvalidTagFilterException(inner)
            }
            crate::error::ListOnPremisesInstancesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err {
            crate::error::ListTagsForResourceError::ArnNotSupportedException(inner) => {
                Error::ArnNotSupportedException(inner)
            }
            crate::error::ListTagsForResourceError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::ListTagsForResourceError::ResourceArnRequiredException(inner) => {
                Error::ResourceArnRequiredException(inner)
            }
            crate::error::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::error::PutLifecycleEventHookExecutionStatusError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::PutLifecycleEventHookExecutionStatusError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::PutLifecycleEventHookExecutionStatusError> for Error {
    fn from(err: crate::error::PutLifecycleEventHookExecutionStatusError) -> Self {
        match err {
            crate::error::PutLifecycleEventHookExecutionStatusError::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusError::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusError::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusError::InvalidLifecycleEventHookExecutionIdException(inner) => Error::InvalidLifecycleEventHookExecutionIdException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusError::InvalidLifecycleEventHookExecutionStatusException(inner) => Error::InvalidLifecycleEventHookExecutionStatusException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusError::LifecycleEventAlreadyCompletedException(inner) => Error::LifecycleEventAlreadyCompletedException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusError::UnsupportedActionForDeploymentTypeException(inner) => Error::UnsupportedActionForDeploymentTypeException(inner),
            crate::error::PutLifecycleEventHookExecutionStatusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RegisterApplicationRevisionError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RegisterApplicationRevisionError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RegisterApplicationRevisionError> for Error {
    fn from(err: crate::error::RegisterApplicationRevisionError) -> Self {
        match err {
            crate::error::RegisterApplicationRevisionError::ApplicationDoesNotExistException(
                inner,
            ) => Error::ApplicationDoesNotExistException(inner),
            crate::error::RegisterApplicationRevisionError::ApplicationNameRequiredException(
                inner,
            ) => Error::ApplicationNameRequiredException(inner),
            crate::error::RegisterApplicationRevisionError::DescriptionTooLongException(inner) => {
                Error::DescriptionTooLongException(inner)
            }
            crate::error::RegisterApplicationRevisionError::InvalidApplicationNameException(
                inner,
            ) => Error::InvalidApplicationNameException(inner),
            crate::error::RegisterApplicationRevisionError::InvalidRevisionException(inner) => {
                Error::InvalidRevisionException(inner)
            }
            crate::error::RegisterApplicationRevisionError::RevisionRequiredException(inner) => {
                Error::RevisionRequiredException(inner)
            }
            crate::error::RegisterApplicationRevisionError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::RegisterOnPremisesInstanceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::RegisterOnPremisesInstanceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RegisterOnPremisesInstanceError> for Error {
    fn from(err: crate::error::RegisterOnPremisesInstanceError) -> Self {
        match err {
            crate::error::RegisterOnPremisesInstanceError::IamArnRequiredException(inner) => Error::IamArnRequiredException(inner),
            crate::error::RegisterOnPremisesInstanceError::IamSessionArnAlreadyRegisteredException(inner) => Error::IamSessionArnAlreadyRegisteredException(inner),
            crate::error::RegisterOnPremisesInstanceError::IamUserArnAlreadyRegisteredException(inner) => Error::IamUserArnAlreadyRegisteredException(inner),
            crate::error::RegisterOnPremisesInstanceError::IamUserArnRequiredException(inner) => Error::IamUserArnRequiredException(inner),
            crate::error::RegisterOnPremisesInstanceError::InstanceNameAlreadyRegisteredException(inner) => Error::InstanceNameAlreadyRegisteredException(inner),
            crate::error::RegisterOnPremisesInstanceError::InstanceNameRequiredException(inner) => Error::InstanceNameRequiredException(inner),
            crate::error::RegisterOnPremisesInstanceError::InvalidIamSessionArnException(inner) => Error::InvalidIamSessionArnException(inner),
            crate::error::RegisterOnPremisesInstanceError::InvalidIamUserArnException(inner) => Error::InvalidIamUserArnException(inner),
            crate::error::RegisterOnPremisesInstanceError::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::RegisterOnPremisesInstanceError::MultipleIamArnsProvidedException(inner) => Error::MultipleIamArnsProvidedException(inner),
            crate::error::RegisterOnPremisesInstanceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::error::RemoveTagsFromOnPremisesInstancesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::RemoveTagsFromOnPremisesInstancesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::RemoveTagsFromOnPremisesInstancesError> for Error {
    fn from(err: crate::error::RemoveTagsFromOnPremisesInstancesError) -> Self {
        match err {
            crate::error::RemoveTagsFromOnPremisesInstancesError::InstanceLimitExceededException(inner) => Error::InstanceLimitExceededException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesError::InstanceNameRequiredException(inner) => Error::InstanceNameRequiredException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesError::InstanceNotRegisteredException(inner) => Error::InstanceNotRegisteredException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesError::InvalidInstanceNameException(inner) => Error::InvalidInstanceNameException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesError::InvalidTagException(inner) => Error::InvalidTagException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesError::TagLimitExceededException(inner) => Error::TagLimitExceededException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesError::TagRequiredException(inner) => Error::TagRequiredException(inner),
            crate::error::RemoveTagsFromOnPremisesInstancesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<crate::error::SkipWaitTimeForInstanceTerminationError, R>,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::error::SkipWaitTimeForInstanceTerminationError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::SkipWaitTimeForInstanceTerminationError> for Error {
    fn from(err: crate::error::SkipWaitTimeForInstanceTerminationError) -> Self {
        match err {
            crate::error::SkipWaitTimeForInstanceTerminationError::DeploymentAlreadyCompletedException(inner) => Error::DeploymentAlreadyCompletedException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationError::DeploymentDoesNotExistException(inner) => Error::DeploymentDoesNotExistException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationError::DeploymentIdRequiredException(inner) => Error::DeploymentIdRequiredException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationError::DeploymentNotStartedException(inner) => Error::DeploymentNotStartedException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationError::InvalidDeploymentIdException(inner) => Error::InvalidDeploymentIdException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationError::UnsupportedActionForDeploymentTypeException(inner) => Error::UnsupportedActionForDeploymentTypeException(inner),
            crate::error::SkipWaitTimeForInstanceTerminationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::StopDeploymentError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::StopDeploymentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::StopDeploymentError> for Error {
    fn from(err: crate::error::StopDeploymentError) -> Self {
        match err {
            crate::error::StopDeploymentError::DeploymentAlreadyCompletedException(inner) => {
                Error::DeploymentAlreadyCompletedException(inner)
            }
            crate::error::StopDeploymentError::DeploymentDoesNotExistException(inner) => {
                Error::DeploymentDoesNotExistException(inner)
            }
            crate::error::StopDeploymentError::DeploymentGroupDoesNotExistException(inner) => {
                Error::DeploymentGroupDoesNotExistException(inner)
            }
            crate::error::StopDeploymentError::DeploymentIdRequiredException(inner) => {
                Error::DeploymentIdRequiredException(inner)
            }
            crate::error::StopDeploymentError::InvalidDeploymentIdException(inner) => {
                Error::InvalidDeploymentIdException(inner)
            }
            crate::error::StopDeploymentError::UnsupportedActionForDeploymentTypeException(
                inner,
            ) => Error::UnsupportedActionForDeploymentTypeException(inner),
            crate::error::StopDeploymentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err {
            crate::error::TagResourceError::ApplicationDoesNotExistException(inner) => {
                Error::ApplicationDoesNotExistException(inner)
            }
            crate::error::TagResourceError::ArnNotSupportedException(inner) => {
                Error::ArnNotSupportedException(inner)
            }
            crate::error::TagResourceError::DeploymentConfigDoesNotExistException(inner) => {
                Error::DeploymentConfigDoesNotExistException(inner)
            }
            crate::error::TagResourceError::DeploymentGroupDoesNotExistException(inner) => {
                Error::DeploymentGroupDoesNotExistException(inner)
            }
            crate::error::TagResourceError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::TagResourceError::InvalidTagsToAddException(inner) => {
                Error::InvalidTagsToAddException(inner)
            }
            crate::error::TagResourceError::ResourceArnRequiredException(inner) => {
                Error::ResourceArnRequiredException(inner)
            }
            crate::error::TagResourceError::TagRequiredException(inner) => {
                Error::TagRequiredException(inner)
            }
            crate::error::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err {
            crate::error::UntagResourceError::ApplicationDoesNotExistException(inner) => {
                Error::ApplicationDoesNotExistException(inner)
            }
            crate::error::UntagResourceError::ArnNotSupportedException(inner) => {
                Error::ArnNotSupportedException(inner)
            }
            crate::error::UntagResourceError::DeploymentConfigDoesNotExistException(inner) => {
                Error::DeploymentConfigDoesNotExistException(inner)
            }
            crate::error::UntagResourceError::DeploymentGroupDoesNotExistException(inner) => {
                Error::DeploymentGroupDoesNotExistException(inner)
            }
            crate::error::UntagResourceError::InvalidArnException(inner) => {
                Error::InvalidArnException(inner)
            }
            crate::error::UntagResourceError::InvalidTagsToAddException(inner) => {
                Error::InvalidTagsToAddException(inner)
            }
            crate::error::UntagResourceError::ResourceArnRequiredException(inner) => {
                Error::ResourceArnRequiredException(inner)
            }
            crate::error::UntagResourceError::TagRequiredException(inner) => {
                Error::TagRequiredException(inner)
            }
            crate::error::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateApplicationError, R>> for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateApplicationError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateApplicationError> for Error {
    fn from(err: crate::error::UpdateApplicationError) -> Self {
        match err {
            crate::error::UpdateApplicationError::ApplicationAlreadyExistsException(inner) => {
                Error::ApplicationAlreadyExistsException(inner)
            }
            crate::error::UpdateApplicationError::ApplicationDoesNotExistException(inner) => {
                Error::ApplicationDoesNotExistException(inner)
            }
            crate::error::UpdateApplicationError::ApplicationNameRequiredException(inner) => {
                Error::ApplicationNameRequiredException(inner)
            }
            crate::error::UpdateApplicationError::InvalidApplicationNameException(inner) => {
                Error::InvalidApplicationNameException(inner)
            }
            crate::error::UpdateApplicationError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDeploymentGroupError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::error::UpdateDeploymentGroupError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::error::UpdateDeploymentGroupError> for Error {
    fn from(err: crate::error::UpdateDeploymentGroupError) -> Self {
        match err {
            crate::error::UpdateDeploymentGroupError::AlarmsLimitExceededException(inner) => Error::AlarmsLimitExceededException(inner),
            crate::error::UpdateDeploymentGroupError::ApplicationDoesNotExistException(inner) => Error::ApplicationDoesNotExistException(inner),
            crate::error::UpdateDeploymentGroupError::ApplicationNameRequiredException(inner) => Error::ApplicationNameRequiredException(inner),
            crate::error::UpdateDeploymentGroupError::DeploymentConfigDoesNotExistException(inner) => Error::DeploymentConfigDoesNotExistException(inner),
            crate::error::UpdateDeploymentGroupError::DeploymentGroupAlreadyExistsException(inner) => Error::DeploymentGroupAlreadyExistsException(inner),
            crate::error::UpdateDeploymentGroupError::DeploymentGroupDoesNotExistException(inner) => Error::DeploymentGroupDoesNotExistException(inner),
            crate::error::UpdateDeploymentGroupError::DeploymentGroupNameRequiredException(inner) => Error::DeploymentGroupNameRequiredException(inner),
            crate::error::UpdateDeploymentGroupError::EcsServiceMappingLimitExceededException(inner) => Error::EcsServiceMappingLimitExceededException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidAlarmConfigException(inner) => Error::InvalidAlarmConfigException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidApplicationNameException(inner) => Error::InvalidApplicationNameException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidAutoRollbackConfigException(inner) => Error::InvalidAutoRollbackConfigException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidAutoScalingGroupException(inner) => Error::InvalidAutoScalingGroupException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidBlueGreenDeploymentConfigurationException(inner) => Error::InvalidBlueGreenDeploymentConfigurationException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidDeploymentConfigNameException(inner) => Error::InvalidDeploymentConfigNameException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidDeploymentGroupNameException(inner) => Error::InvalidDeploymentGroupNameException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidDeploymentStyleException(inner) => Error::InvalidDeploymentStyleException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidEc2TagCombinationException(inner) => Error::InvalidEc2TagCombinationException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidEc2TagException(inner) => Error::InvalidEc2TagException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidEcsServiceException(inner) => Error::InvalidEcsServiceException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidInputException(inner) => Error::InvalidInputException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidLoadBalancerInfoException(inner) => Error::InvalidLoadBalancerInfoException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidOnPremisesTagCombinationException(inner) => Error::InvalidOnPremisesTagCombinationException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidRoleException(inner) => Error::InvalidRoleException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidTagException(inner) => Error::InvalidTagException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidTargetGroupPairException(inner) => Error::InvalidTargetGroupPairException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidTrafficRoutingConfigurationException(inner) => Error::InvalidTrafficRoutingConfigurationException(inner),
            crate::error::UpdateDeploymentGroupError::InvalidTriggerConfigException(inner) => Error::InvalidTriggerConfigException(inner),
            crate::error::UpdateDeploymentGroupError::LifecycleHookLimitExceededException(inner) => Error::LifecycleHookLimitExceededException(inner),
            crate::error::UpdateDeploymentGroupError::TagSetListLimitExceededException(inner) => Error::TagSetListLimitExceededException(inner),
            crate::error::UpdateDeploymentGroupError::ThrottlingException(inner) => Error::ThrottlingException(inner),
            crate::error::UpdateDeploymentGroupError::TriggerTargetsLimitExceededException(inner) => Error::TriggerTargetsLimitExceededException(inner),
            crate::error::UpdateDeploymentGroupError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::AlarmsLimitExceededException(e) => e.request_id(),
            Self::ApplicationAlreadyExistsException(e) => e.request_id(),
            Self::ApplicationDoesNotExistException(e) => e.request_id(),
            Self::ApplicationLimitExceededException(e) => e.request_id(),
            Self::ApplicationNameRequiredException(e) => e.request_id(),
            Self::ArnNotSupportedException(e) => e.request_id(),
            Self::BatchLimitExceededException(e) => e.request_id(),
            Self::BucketNameFilterRequiredException(e) => e.request_id(),
            Self::DeploymentAlreadyCompletedException(e) => e.request_id(),
            Self::DeploymentConfigAlreadyExistsException(e) => e.request_id(),
            Self::DeploymentConfigDoesNotExistException(e) => e.request_id(),
            Self::DeploymentConfigInUseException(e) => e.request_id(),
            Self::DeploymentConfigLimitExceededException(e) => e.request_id(),
            Self::DeploymentConfigNameRequiredException(e) => e.request_id(),
            Self::DeploymentDoesNotExistException(e) => e.request_id(),
            Self::DeploymentGroupAlreadyExistsException(e) => e.request_id(),
            Self::DeploymentGroupDoesNotExistException(e) => e.request_id(),
            Self::DeploymentGroupLimitExceededException(e) => e.request_id(),
            Self::DeploymentGroupNameRequiredException(e) => e.request_id(),
            Self::DeploymentIdRequiredException(e) => e.request_id(),
            Self::DeploymentIsNotInReadyStateException(e) => e.request_id(),
            Self::DeploymentLimitExceededException(e) => e.request_id(),
            Self::DeploymentNotStartedException(e) => e.request_id(),
            Self::DeploymentTargetDoesNotExistException(e) => e.request_id(),
            Self::DeploymentTargetIdRequiredException(e) => e.request_id(),
            Self::DeploymentTargetListSizeExceededException(e) => e.request_id(),
            Self::DescriptionTooLongException(e) => e.request_id(),
            Self::EcsServiceMappingLimitExceededException(e) => e.request_id(),
            Self::GitHubAccountTokenDoesNotExistException(e) => e.request_id(),
            Self::GitHubAccountTokenNameRequiredException(e) => e.request_id(),
            Self::IamArnRequiredException(e) => e.request_id(),
            Self::IamSessionArnAlreadyRegisteredException(e) => e.request_id(),
            Self::IamUserArnAlreadyRegisteredException(e) => e.request_id(),
            Self::IamUserArnRequiredException(e) => e.request_id(),
            Self::InstanceDoesNotExistException(e) => e.request_id(),
            Self::InstanceIdRequiredException(e) => e.request_id(),
            Self::InstanceLimitExceededException(e) => e.request_id(),
            Self::InstanceNameAlreadyRegisteredException(e) => e.request_id(),
            Self::InstanceNameRequiredException(e) => e.request_id(),
            Self::InstanceNotRegisteredException(e) => e.request_id(),
            Self::InvalidAlarmConfigException(e) => e.request_id(),
            Self::InvalidApplicationNameException(e) => e.request_id(),
            Self::InvalidArnException(e) => e.request_id(),
            Self::InvalidAutoRollbackConfigException(e) => e.request_id(),
            Self::InvalidAutoScalingGroupException(e) => e.request_id(),
            Self::InvalidBlueGreenDeploymentConfigurationException(e) => e.request_id(),
            Self::InvalidBucketNameFilterException(e) => e.request_id(),
            Self::InvalidComputePlatformException(e) => e.request_id(),
            Self::InvalidDeployedStateFilterException(e) => e.request_id(),
            Self::InvalidDeploymentConfigNameException(e) => e.request_id(),
            Self::InvalidDeploymentGroupNameException(e) => e.request_id(),
            Self::InvalidDeploymentIdException(e) => e.request_id(),
            Self::InvalidDeploymentInstanceTypeException(e) => e.request_id(),
            Self::InvalidDeploymentStatusException(e) => e.request_id(),
            Self::InvalidDeploymentStyleException(e) => e.request_id(),
            Self::InvalidDeploymentTargetIdException(e) => e.request_id(),
            Self::InvalidDeploymentWaitTypeException(e) => e.request_id(),
            Self::InvalidEc2TagCombinationException(e) => e.request_id(),
            Self::InvalidEc2TagException(e) => e.request_id(),
            Self::InvalidEcsServiceException(e) => e.request_id(),
            Self::InvalidExternalIdException(e) => e.request_id(),
            Self::InvalidFileExistsBehaviorException(e) => e.request_id(),
            Self::InvalidGitHubAccountTokenException(e) => e.request_id(),
            Self::InvalidGitHubAccountTokenNameException(e) => e.request_id(),
            Self::InvalidIamSessionArnException(e) => e.request_id(),
            Self::InvalidIamUserArnException(e) => e.request_id(),
            Self::InvalidIgnoreApplicationStopFailuresValueException(e) => e.request_id(),
            Self::InvalidInputException(e) => e.request_id(),
            Self::InvalidInstanceNameException(e) => e.request_id(),
            Self::InvalidInstanceStatusException(e) => e.request_id(),
            Self::InvalidInstanceTypeException(e) => e.request_id(),
            Self::InvalidKeyPrefixFilterException(e) => e.request_id(),
            Self::InvalidLifecycleEventHookExecutionIdException(e) => e.request_id(),
            Self::InvalidLifecycleEventHookExecutionStatusException(e) => e.request_id(),
            Self::InvalidLoadBalancerInfoException(e) => e.request_id(),
            Self::InvalidMinimumHealthyHostValueException(e) => e.request_id(),
            Self::InvalidNextTokenException(e) => e.request_id(),
            Self::InvalidOnPremisesTagCombinationException(e) => e.request_id(),
            Self::InvalidOperationException(e) => e.request_id(),
            Self::InvalidRegistrationStatusException(e) => e.request_id(),
            Self::InvalidRevisionException(e) => e.request_id(),
            Self::InvalidRoleException(e) => e.request_id(),
            Self::InvalidSortByException(e) => e.request_id(),
            Self::InvalidSortOrderException(e) => e.request_id(),
            Self::InvalidTagException(e) => e.request_id(),
            Self::InvalidTagFilterException(e) => e.request_id(),
            Self::InvalidTagsToAddException(e) => e.request_id(),
            Self::InvalidTargetFilterNameException(e) => e.request_id(),
            Self::InvalidTargetGroupPairException(e) => e.request_id(),
            Self::InvalidTargetInstancesException(e) => e.request_id(),
            Self::InvalidTimeRangeException(e) => e.request_id(),
            Self::InvalidTrafficRoutingConfigurationException(e) => e.request_id(),
            Self::InvalidTriggerConfigException(e) => e.request_id(),
            Self::InvalidUpdateOutdatedInstancesOnlyValueException(e) => e.request_id(),
            Self::LifecycleEventAlreadyCompletedException(e) => e.request_id(),
            Self::LifecycleHookLimitExceededException(e) => e.request_id(),
            Self::MultipleIamArnsProvidedException(e) => e.request_id(),
            Self::OperationNotSupportedException(e) => e.request_id(),
            Self::ResourceArnRequiredException(e) => e.request_id(),
            Self::ResourceValidationException(e) => e.request_id(),
            Self::RevisionDoesNotExistException(e) => e.request_id(),
            Self::RevisionRequiredException(e) => e.request_id(),
            Self::RoleRequiredException(e) => e.request_id(),
            Self::TagLimitExceededException(e) => e.request_id(),
            Self::TagRequiredException(e) => e.request_id(),
            Self::TagSetListLimitExceededException(e) => e.request_id(),
            Self::ThrottlingException(e) => e.request_id(),
            Self::TriggerTargetsLimitExceededException(e) => e.request_id(),
            Self::UnsupportedActionForDeploymentTypeException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
