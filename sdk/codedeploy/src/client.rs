// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn add_tags_to_on_premises_instances(
        &self,
    ) -> fluent_builders::AddTagsToOnPremisesInstances<C> {
        fluent_builders::AddTagsToOnPremisesInstances::new(self.handle.clone())
    }
    pub fn batch_get_application_revisions(
        &self,
    ) -> fluent_builders::BatchGetApplicationRevisions<C> {
        fluent_builders::BatchGetApplicationRevisions::new(self.handle.clone())
    }
    pub fn batch_get_applications(&self) -> fluent_builders::BatchGetApplications<C> {
        fluent_builders::BatchGetApplications::new(self.handle.clone())
    }
    pub fn batch_get_deployment_groups(&self) -> fluent_builders::BatchGetDeploymentGroups<C> {
        fluent_builders::BatchGetDeploymentGroups::new(self.handle.clone())
    }
    pub fn batch_get_deployment_instances(
        &self,
    ) -> fluent_builders::BatchGetDeploymentInstances<C> {
        fluent_builders::BatchGetDeploymentInstances::new(self.handle.clone())
    }
    pub fn batch_get_deployments(&self) -> fluent_builders::BatchGetDeployments<C> {
        fluent_builders::BatchGetDeployments::new(self.handle.clone())
    }
    pub fn batch_get_deployment_targets(&self) -> fluent_builders::BatchGetDeploymentTargets<C> {
        fluent_builders::BatchGetDeploymentTargets::new(self.handle.clone())
    }
    pub fn batch_get_on_premises_instances(
        &self,
    ) -> fluent_builders::BatchGetOnPremisesInstances<C> {
        fluent_builders::BatchGetOnPremisesInstances::new(self.handle.clone())
    }
    pub fn continue_deployment(&self) -> fluent_builders::ContinueDeployment<C> {
        fluent_builders::ContinueDeployment::new(self.handle.clone())
    }
    pub fn create_application(&self) -> fluent_builders::CreateApplication<C> {
        fluent_builders::CreateApplication::new(self.handle.clone())
    }
    pub fn create_deployment(&self) -> fluent_builders::CreateDeployment<C> {
        fluent_builders::CreateDeployment::new(self.handle.clone())
    }
    pub fn create_deployment_config(&self) -> fluent_builders::CreateDeploymentConfig<C> {
        fluent_builders::CreateDeploymentConfig::new(self.handle.clone())
    }
    pub fn create_deployment_group(&self) -> fluent_builders::CreateDeploymentGroup<C> {
        fluent_builders::CreateDeploymentGroup::new(self.handle.clone())
    }
    pub fn delete_application(&self) -> fluent_builders::DeleteApplication<C> {
        fluent_builders::DeleteApplication::new(self.handle.clone())
    }
    pub fn delete_deployment_config(&self) -> fluent_builders::DeleteDeploymentConfig<C> {
        fluent_builders::DeleteDeploymentConfig::new(self.handle.clone())
    }
    pub fn delete_deployment_group(&self) -> fluent_builders::DeleteDeploymentGroup<C> {
        fluent_builders::DeleteDeploymentGroup::new(self.handle.clone())
    }
    pub fn delete_git_hub_account_token(&self) -> fluent_builders::DeleteGitHubAccountToken<C> {
        fluent_builders::DeleteGitHubAccountToken::new(self.handle.clone())
    }
    pub fn delete_resources_by_external_id(
        &self,
    ) -> fluent_builders::DeleteResourcesByExternalId<C> {
        fluent_builders::DeleteResourcesByExternalId::new(self.handle.clone())
    }
    pub fn deregister_on_premises_instance(
        &self,
    ) -> fluent_builders::DeregisterOnPremisesInstance<C> {
        fluent_builders::DeregisterOnPremisesInstance::new(self.handle.clone())
    }
    pub fn get_application(&self) -> fluent_builders::GetApplication<C> {
        fluent_builders::GetApplication::new(self.handle.clone())
    }
    pub fn get_application_revision(&self) -> fluent_builders::GetApplicationRevision<C> {
        fluent_builders::GetApplicationRevision::new(self.handle.clone())
    }
    pub fn get_deployment(&self) -> fluent_builders::GetDeployment<C> {
        fluent_builders::GetDeployment::new(self.handle.clone())
    }
    pub fn get_deployment_config(&self) -> fluent_builders::GetDeploymentConfig<C> {
        fluent_builders::GetDeploymentConfig::new(self.handle.clone())
    }
    pub fn get_deployment_group(&self) -> fluent_builders::GetDeploymentGroup<C> {
        fluent_builders::GetDeploymentGroup::new(self.handle.clone())
    }
    pub fn get_deployment_instance(&self) -> fluent_builders::GetDeploymentInstance<C> {
        fluent_builders::GetDeploymentInstance::new(self.handle.clone())
    }
    pub fn get_deployment_target(&self) -> fluent_builders::GetDeploymentTarget<C> {
        fluent_builders::GetDeploymentTarget::new(self.handle.clone())
    }
    pub fn get_on_premises_instance(&self) -> fluent_builders::GetOnPremisesInstance<C> {
        fluent_builders::GetOnPremisesInstance::new(self.handle.clone())
    }
    pub fn list_application_revisions(&self) -> fluent_builders::ListApplicationRevisions<C> {
        fluent_builders::ListApplicationRevisions::new(self.handle.clone())
    }
    pub fn list_applications(&self) -> fluent_builders::ListApplications<C> {
        fluent_builders::ListApplications::new(self.handle.clone())
    }
    pub fn list_deployment_configs(&self) -> fluent_builders::ListDeploymentConfigs<C> {
        fluent_builders::ListDeploymentConfigs::new(self.handle.clone())
    }
    pub fn list_deployment_groups(&self) -> fluent_builders::ListDeploymentGroups<C> {
        fluent_builders::ListDeploymentGroups::new(self.handle.clone())
    }
    pub fn list_deployment_instances(&self) -> fluent_builders::ListDeploymentInstances<C> {
        fluent_builders::ListDeploymentInstances::new(self.handle.clone())
    }
    pub fn list_deployments(&self) -> fluent_builders::ListDeployments<C> {
        fluent_builders::ListDeployments::new(self.handle.clone())
    }
    pub fn list_deployment_targets(&self) -> fluent_builders::ListDeploymentTargets<C> {
        fluent_builders::ListDeploymentTargets::new(self.handle.clone())
    }
    pub fn list_git_hub_account_token_names(
        &self,
    ) -> fluent_builders::ListGitHubAccountTokenNames<C> {
        fluent_builders::ListGitHubAccountTokenNames::new(self.handle.clone())
    }
    pub fn list_on_premises_instances(&self) -> fluent_builders::ListOnPremisesInstances<C> {
        fluent_builders::ListOnPremisesInstances::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn put_lifecycle_event_hook_execution_status(
        &self,
    ) -> fluent_builders::PutLifecycleEventHookExecutionStatus<C> {
        fluent_builders::PutLifecycleEventHookExecutionStatus::new(self.handle.clone())
    }
    pub fn register_application_revision(&self) -> fluent_builders::RegisterApplicationRevision<C> {
        fluent_builders::RegisterApplicationRevision::new(self.handle.clone())
    }
    pub fn register_on_premises_instance(&self) -> fluent_builders::RegisterOnPremisesInstance<C> {
        fluent_builders::RegisterOnPremisesInstance::new(self.handle.clone())
    }
    pub fn remove_tags_from_on_premises_instances(
        &self,
    ) -> fluent_builders::RemoveTagsFromOnPremisesInstances<C> {
        fluent_builders::RemoveTagsFromOnPremisesInstances::new(self.handle.clone())
    }
    pub fn skip_wait_time_for_instance_termination(
        &self,
    ) -> fluent_builders::SkipWaitTimeForInstanceTermination<C> {
        fluent_builders::SkipWaitTimeForInstanceTermination::new(self.handle.clone())
    }
    pub fn stop_deployment(&self) -> fluent_builders::StopDeployment<C> {
        fluent_builders::StopDeployment::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_application(&self) -> fluent_builders::UpdateApplication<C> {
        fluent_builders::UpdateApplication::new(self.handle.clone())
    }
    pub fn update_deployment_group(&self) -> fluent_builders::UpdateDeploymentGroup<C> {
        fluent_builders::UpdateDeploymentGroup::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AddTagsToOnPremisesInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::add_tags_to_on_premises_instances_input::Builder,
    }
    impl<C> AddTagsToOnPremisesInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AddTagsToOnPremisesInstancesOutput,
            smithy_http::result::SdkError<crate::error::AddTagsToOnPremisesInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tag key-value pairs to add to the on-premises instances.</p>
        /// <p>Keys and values are both required. Keys cannot be null or empty strings. Value-only
        /// tags are not allowed.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The names of the on-premises instances to which to add tags.</p>
        pub fn instance_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_names(inp);
            self
        }
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetApplicationRevisions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_application_revisions_input::Builder,
    }
    impl<C> BatchGetApplicationRevisions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetApplicationRevisionsOutput,
            smithy_http::result::SdkError<crate::error::BatchGetApplicationRevisionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application about which to get revision
        /// information.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>An array of <code>RevisionLocation</code> objects that specify information to get
        /// about the application revisions, including type and location. The maximum number of
        /// <code>RevisionLocation</code> objects you can specify is 25.</p>
        pub fn revisions(mut self, inp: impl Into<crate::model::RevisionLocation>) -> Self {
            self.inner = self.inner.revisions(inp);
            self
        }
        pub fn set_revisions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RevisionLocation>>,
        ) -> Self {
            self.inner = self.inner.set_revisions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetApplications<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_applications_input::Builder,
    }
    impl<C> BatchGetApplications<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetApplicationsOutput,
            smithy_http::result::SdkError<crate::error::BatchGetApplicationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A list of application names separated by spaces. The maximum number of application
        /// names you can specify is 100.</p>
        pub fn application_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_names(inp);
            self
        }
        pub fn set_application_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_application_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetDeploymentGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_deployment_groups_input::Builder,
    }
    impl<C> BatchGetDeploymentGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetDeploymentGroupsOutput,
            smithy_http::result::SdkError<crate::error::BatchGetDeploymentGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application associated with the applicable IAM user or
        /// AWS account.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The names of the deployment groups.</p>
        pub fn deployment_group_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_group_names(inp);
            self
        }
        pub fn set_deployment_group_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_deployment_group_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetDeploymentInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_deployment_instances_input::Builder,
    }
    impl<C> BatchGetDeploymentInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetDeploymentInstancesOutput,
            smithy_http::result::SdkError<crate::error::BatchGetDeploymentInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a deployment. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
        /// <p>The unique IDs of instances used in the deployment. The maximum number of instance IDs
        /// you can specify is 25.</p>
        pub fn instance_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_ids(inp);
            self
        }
        pub fn set_instance_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetDeployments<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_deployments_input::Builder,
    }
    impl<C> BatchGetDeployments<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetDeploymentsOutput,
            smithy_http::result::SdkError<crate::error::BatchGetDeploymentsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> A list of deployment IDs, separated by spaces. The maximum number of deployment IDs
        /// you can specify is 25.</p>
        pub fn deployment_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_ids(inp);
            self
        }
        pub fn set_deployment_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_deployment_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetDeploymentTargets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_deployment_targets_input::Builder,
    }
    impl<C> BatchGetDeploymentTargets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetDeploymentTargetsOutput,
            smithy_http::result::SdkError<crate::error::BatchGetDeploymentTargetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a deployment. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
        /// <p> The unique IDs of the deployment targets. The compute platform of the deployment
        /// determines the type of the targets and their formats. The maximum number of deployment
        /// target IDs you can specify is 25.</p>
        /// <ul>
        /// <li>
        /// <p> For deployments that use the EC2/On-premises compute platform, the target IDs
        /// are EC2 or on-premises instances IDs, and their target type is
        /// <code>instanceTarget</code>. </p>
        /// </li>
        /// <li>
        /// <p> For deployments that use the AWS Lambda compute platform, the target IDs are
        /// the names of Lambda functions, and their target type is
        /// <code>instanceTarget</code>. </p>
        /// </li>
        /// <li>
        /// <p> For deployments that use the Amazon ECS compute platform, the target IDs are
        /// pairs of Amazon ECS clusters and services specified using the format
        /// <code><clustername>:<servicename></code>. Their target type is
        /// <code>ecsTarget</code>. </p>
        /// </li>
        /// <li>
        /// <p> For deployments that are deployed with AWS CloudFormation, the target IDs are
        /// CloudFormation stack IDs. Their target type is
        /// <code>cloudFormationTarget</code>. </p>
        /// </li>
        /// </ul>
        pub fn target_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_ids(inp);
            self
        }
        pub fn set_target_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_target_ids(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetOnPremisesInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_on_premises_instances_input::Builder,
    }
    impl<C> BatchGetOnPremisesInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetOnPremisesInstancesOutput,
            smithy_http::result::SdkError<crate::error::BatchGetOnPremisesInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the on-premises instances about which to get information. The maximum
        /// number of instance names you can specify is 25.</p>
        pub fn instance_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_names(inp);
            self
        }
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ContinueDeployment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::continue_deployment_input::Builder,
    }
    impl<C> ContinueDeployment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ContinueDeploymentOutput,
            smithy_http::result::SdkError<crate::error::ContinueDeploymentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a blue/green deployment for which you want to start rerouting
        /// traffic to the replacement environment. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
        /// <p> The status of the deployment's waiting period. <code>READY_WAIT</code> indicates that
        /// the deployment is ready to start shifting traffic. <code>TERMINATION_WAIT</code>
        /// indicates that the traffic is shifted, but the original target is not terminated.
        /// </p>
        pub fn deployment_wait_type(mut self, input: crate::model::DeploymentWaitType) -> Self {
            self.inner = self.inner.deployment_wait_type(input);
            self
        }
        pub fn set_deployment_wait_type(
            mut self,
            input: std::option::Option<crate::model::DeploymentWaitType>,
        ) -> Self {
            self.inner = self.inner.set_deployment_wait_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_application_input::Builder,
    }
    impl<C> CreateApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateApplicationOutput,
            smithy_http::result::SdkError<crate::error::CreateApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application. This name must be unique with the applicable IAM user or
        /// AWS account.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p> The destination platform type for the deployment (<code>Lambda</code>,
        /// <code>Server</code>, or <code>ECS</code>).</p>
        pub fn compute_platform(mut self, input: crate::model::ComputePlatform) -> Self {
            self.inner = self.inner.compute_platform(input);
            self
        }
        pub fn set_compute_platform(
            mut self,
            input: std::option::Option<crate::model::ComputePlatform>,
        ) -> Self {
            self.inner = self.inner.set_compute_platform(input);
            self
        }
        /// <p> The metadata that you apply to CodeDeploy applications to help you organize and
        /// categorize them. Each tag consists of a key and an optional value, both of which you
        /// define. </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDeployment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_deployment_input::Builder,
    }
    impl<C> CreateDeployment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDeploymentOutput,
            smithy_http::result::SdkError<crate::error::CreateDeploymentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
        /// account.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The name of the deployment group.</p>
        pub fn deployment_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_group_name(input);
            self
        }
        pub fn set_deployment_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_group_name(input);
            self
        }
        /// <p> The type and location of the revision to deploy. </p>
        pub fn revision(mut self, input: crate::model::RevisionLocation) -> Self {
            self.inner = self.inner.revision(input);
            self
        }
        pub fn set_revision(
            mut self,
            input: std::option::Option<crate::model::RevisionLocation>,
        ) -> Self {
            self.inner = self.inner.set_revision(input);
            self
        }
        /// <p>The name of a deployment configuration associated with the IAM user or AWS
        /// account.</p>
        /// <p>If not specified, the value configured in the deployment group is used as the default.
        /// If the deployment group does not have a deployment configuration associated with it,
        /// <code>CodeDeployDefault</code>.<code>OneAtATime</code> is used by default.</p>
        pub fn deployment_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_config_name(input);
            self
        }
        pub fn set_deployment_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_config_name(input);
            self
        }
        /// <p>A comment about the deployment.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p> If true, then if an <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, or
        /// <code>AfterBlockTraffic</code> deployment lifecycle event to an instance fails, then
        /// the deployment continues to the next deployment lifecycle event. For example, if
        /// <code>ApplicationStop</code> fails, the deployment continues with
        /// <code>DownloadBundle</code>. If <code>BeforeBlockTraffic</code> fails, the
        /// deployment continues with <code>BlockTraffic</code>. If <code>AfterBlockTraffic</code>
        /// fails, the deployment continues with <code>ApplicationStop</code>. </p>
        /// <p> If false or not specified, then if a lifecycle event fails during a deployment to an
        /// instance, that deployment fails. If deployment to that instance is part of an overall
        /// deployment and the number of healthy hosts is not less than the minimum number of
        /// healthy hosts, then a deployment to the next instance is attempted. </p>
        /// <p> During a deployment, the AWS CodeDeploy agent runs the scripts specified for
        /// <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and
        /// <code>AfterBlockTraffic</code> in the AppSpec file from the previous successful
        /// deployment. (All other scripts are run from the AppSpec file in the current deployment.)
        /// If one of these scripts contains an error and does not run successfully, the deployment
        /// can fail. </p>
        /// <p> If the cause of the failure is a script from the last successful deployment that will
        /// never run successfully, create a new deployment and use
        /// <code>ignoreApplicationStopFailures</code> to specify that the
        /// <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and
        /// <code>AfterBlockTraffic</code> failures should be ignored. </p>
        pub fn ignore_application_stop_failures(mut self, input: bool) -> Self {
            self.inner = self.inner.ignore_application_stop_failures(input);
            self
        }
        pub fn set_ignore_application_stop_failures(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_ignore_application_stop_failures(input);
            self
        }
        /// <p> Information about the instances that belong to the replacement environment in a
        /// blue/green deployment. </p>
        pub fn target_instances(mut self, input: crate::model::TargetInstances) -> Self {
            self.inner = self.inner.target_instances(input);
            self
        }
        pub fn set_target_instances(
            mut self,
            input: std::option::Option<crate::model::TargetInstances>,
        ) -> Self {
            self.inner = self.inner.set_target_instances(input);
            self
        }
        /// <p>Configuration information for an automatic rollback that is added when a deployment is
        /// created.</p>
        pub fn auto_rollback_configuration(
            mut self,
            input: crate::model::AutoRollbackConfiguration,
        ) -> Self {
            self.inner = self.inner.auto_rollback_configuration(input);
            self
        }
        pub fn set_auto_rollback_configuration(
            mut self,
            input: std::option::Option<crate::model::AutoRollbackConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_auto_rollback_configuration(input);
            self
        }
        /// <p> Indicates whether to deploy to all instances or only to instances that are not
        /// running the latest application revision. </p>
        pub fn update_outdated_instances_only(mut self, input: bool) -> Self {
            self.inner = self.inner.update_outdated_instances_only(input);
            self
        }
        pub fn set_update_outdated_instances_only(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_update_outdated_instances_only(input);
            self
        }
        /// <p>Information about how AWS CodeDeploy handles files that already exist in a deployment
        /// target location but weren't part of the previous successful deployment.</p>
        /// <p>The <code>fileExistsBehavior</code> parameter takes any of the following
        /// values:</p>
        /// <ul>
        /// <li>
        /// <p>DISALLOW: The deployment fails. This is also the default behavior if no option
        /// is specified.</p>
        /// </li>
        /// <li>
        /// <p>OVERWRITE: The version of the file from the application revision currently
        /// being deployed replaces the version already on the instance.</p>
        /// </li>
        /// <li>
        /// <p>RETAIN: The version of the file already on the instance is kept and used as
        /// part of the new deployment.</p>
        /// </li>
        /// </ul>
        pub fn file_exists_behavior(mut self, input: crate::model::FileExistsBehavior) -> Self {
            self.inner = self.inner.file_exists_behavior(input);
            self
        }
        pub fn set_file_exists_behavior(
            mut self,
            input: std::option::Option<crate::model::FileExistsBehavior>,
        ) -> Self {
            self.inner = self.inner.set_file_exists_behavior(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDeploymentConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_deployment_config_input::Builder,
    }
    impl<C> CreateDeploymentConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDeploymentConfigOutput,
            smithy_http::result::SdkError<crate::error::CreateDeploymentConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the deployment configuration to create.</p>
        pub fn deployment_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_config_name(input);
            self
        }
        pub fn set_deployment_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_config_name(input);
            self
        }
        /// <p>The minimum number of healthy instances that should be available at any time during
        /// the deployment. There are two parameters expected in the input: type and value.</p>
        /// <p>The type parameter takes either of the following values:</p>
        /// <ul>
        /// <li>
        /// <p>HOST_COUNT: The value parameter represents the minimum number of healthy
        /// instances as an absolute value.</p>
        /// </li>
        /// <li>
        /// <p>FLEET_PERCENT: The value parameter represents the minimum number of healthy
        /// instances as a percentage of the total number of instances in the deployment. If
        /// you specify FLEET_PERCENT, at the start of the deployment, AWS CodeDeploy
        /// converts the percentage to the equivalent number of instances and rounds up
        /// fractional instances.</p>
        /// </li>
        /// </ul>
        /// <p>The value parameter takes an integer.</p>
        /// <p>For example, to set a minimum of 95% healthy instance, specify a type of FLEET_PERCENT
        /// and a value of 95.</p>
        pub fn minimum_healthy_hosts(mut self, input: crate::model::MinimumHealthyHosts) -> Self {
            self.inner = self.inner.minimum_healthy_hosts(input);
            self
        }
        pub fn set_minimum_healthy_hosts(
            mut self,
            input: std::option::Option<crate::model::MinimumHealthyHosts>,
        ) -> Self {
            self.inner = self.inner.set_minimum_healthy_hosts(input);
            self
        }
        /// <p>The configuration that specifies how the deployment traffic is routed.</p>
        pub fn traffic_routing_config(mut self, input: crate::model::TrafficRoutingConfig) -> Self {
            self.inner = self.inner.traffic_routing_config(input);
            self
        }
        pub fn set_traffic_routing_config(
            mut self,
            input: std::option::Option<crate::model::TrafficRoutingConfig>,
        ) -> Self {
            self.inner = self.inner.set_traffic_routing_config(input);
            self
        }
        /// <p>The destination platform type for the deployment (<code>Lambda</code>,
        /// <code>Server</code>, or <code>ECS</code>).</p>
        pub fn compute_platform(mut self, input: crate::model::ComputePlatform) -> Self {
            self.inner = self.inner.compute_platform(input);
            self
        }
        pub fn set_compute_platform(
            mut self,
            input: std::option::Option<crate::model::ComputePlatform>,
        ) -> Self {
            self.inner = self.inner.set_compute_platform(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateDeploymentGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_deployment_group_input::Builder,
    }
    impl<C> CreateDeploymentGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateDeploymentGroupOutput,
            smithy_http::result::SdkError<crate::error::CreateDeploymentGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
        /// account.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The name of a new deployment group for the specified application.</p>
        pub fn deployment_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_group_name(input);
            self
        }
        pub fn set_deployment_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_group_name(input);
            self
        }
        /// <p>If specified, the deployment configuration name can be either one of the predefined
        /// configurations provided with AWS CodeDeploy or a custom deployment configuration that
        /// you create by calling the create deployment configuration operation.</p>
        /// <p>
        /// <code>CodeDeployDefault.OneAtATime</code> is the default deployment configuration. It
        /// is used if a configuration isn't specified for the deployment or deployment
        /// group.</p>
        /// <p>For more information about the predefined deployment configurations in AWS CodeDeploy,
        /// see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/deployment-configurations.html">Working with
        /// Deployment Configurations in CodeDeploy</a> in the <i>AWS CodeDeploy User
        /// Guide</i>.</p>
        pub fn deployment_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_config_name(input);
            self
        }
        pub fn set_deployment_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_config_name(input);
            self
        }
        /// <p>The Amazon EC2 tags on which to filter. The deployment group includes EC2 instances
        /// with any of the specified tags. Cannot be used in the same call as ec2TagSet.</p>
        pub fn ec2_tag_filters(mut self, inp: impl Into<crate::model::Ec2TagFilter>) -> Self {
            self.inner = self.inner.ec2_tag_filters(inp);
            self
        }
        pub fn set_ec2_tag_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ec2TagFilter>>,
        ) -> Self {
            self.inner = self.inner.set_ec2_tag_filters(input);
            self
        }
        /// <p>The on-premises instance tags on which to filter. The deployment group includes
        /// on-premises instances with any of the specified tags. Cannot be used in the same call as
        /// <code>OnPremisesTagSet</code>.</p>
        pub fn on_premises_instance_tag_filters(
            mut self,
            inp: impl Into<crate::model::TagFilter>,
        ) -> Self {
            self.inner = self.inner.on_premises_instance_tag_filters(inp);
            self
        }
        pub fn set_on_premises_instance_tag_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagFilter>>,
        ) -> Self {
            self.inner = self.inner.set_on_premises_instance_tag_filters(input);
            self
        }
        /// <p>A list of associated Amazon EC2 Auto Scaling groups.</p>
        pub fn auto_scaling_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_groups(inp);
            self
        }
        pub fn set_auto_scaling_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_groups(input);
            self
        }
        /// <p>A service role Amazon Resource Name (ARN) that allows AWS CodeDeploy to act on the
        /// user's behalf when interacting with AWS services.</p>
        pub fn service_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_role_arn(input);
            self
        }
        pub fn set_service_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_role_arn(input);
            self
        }
        /// <p>Information about triggers to create when the deployment group is created. For
        /// examples, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/how-to-notify-sns.html">Create a Trigger for an
        /// AWS CodeDeploy Event</a> in the <i>AWS CodeDeploy User
        /// Guide</i>.</p>
        pub fn trigger_configurations(
            mut self,
            inp: impl Into<crate::model::TriggerConfig>,
        ) -> Self {
            self.inner = self.inner.trigger_configurations(inp);
            self
        }
        pub fn set_trigger_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TriggerConfig>>,
        ) -> Self {
            self.inner = self.inner.set_trigger_configurations(input);
            self
        }
        /// <p>Information to add about Amazon CloudWatch alarms when the deployment group is
        /// created.</p>
        pub fn alarm_configuration(mut self, input: crate::model::AlarmConfiguration) -> Self {
            self.inner = self.inner.alarm_configuration(input);
            self
        }
        pub fn set_alarm_configuration(
            mut self,
            input: std::option::Option<crate::model::AlarmConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_alarm_configuration(input);
            self
        }
        /// <p>Configuration information for an automatic rollback that is added when a deployment
        /// group is created.</p>
        pub fn auto_rollback_configuration(
            mut self,
            input: crate::model::AutoRollbackConfiguration,
        ) -> Self {
            self.inner = self.inner.auto_rollback_configuration(input);
            self
        }
        pub fn set_auto_rollback_configuration(
            mut self,
            input: std::option::Option<crate::model::AutoRollbackConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_auto_rollback_configuration(input);
            self
        }
        /// <p>Indicates what happens when new EC2 instances are launched mid-deployment and do not
        /// receive the deployed application revision.</p>
        /// <p>If this option is set to <code>UPDATE</code> or is unspecified, CodeDeploy initiates
        /// one or more 'auto-update outdated instances' deployments to apply the deployed
        /// application revision to the new EC2 instances.</p>
        /// <p>If this option is set to <code>IGNORE</code>, CodeDeploy does not initiate a
        /// deployment to update the new EC2 instances. This may result in instances having
        /// different revisions.</p>
        pub fn outdated_instances_strategy(
            mut self,
            input: crate::model::OutdatedInstancesStrategy,
        ) -> Self {
            self.inner = self.inner.outdated_instances_strategy(input);
            self
        }
        pub fn set_outdated_instances_strategy(
            mut self,
            input: std::option::Option<crate::model::OutdatedInstancesStrategy>,
        ) -> Self {
            self.inner = self.inner.set_outdated_instances_strategy(input);
            self
        }
        /// <p>Information about the type of deployment, in-place or blue/green, that you want to run
        /// and whether to route deployment traffic behind a load balancer.</p>
        pub fn deployment_style(mut self, input: crate::model::DeploymentStyle) -> Self {
            self.inner = self.inner.deployment_style(input);
            self
        }
        pub fn set_deployment_style(
            mut self,
            input: std::option::Option<crate::model::DeploymentStyle>,
        ) -> Self {
            self.inner = self.inner.set_deployment_style(input);
            self
        }
        /// <p>Information about blue/green deployment options for a deployment group.</p>
        pub fn blue_green_deployment_configuration(
            mut self,
            input: crate::model::BlueGreenDeploymentConfiguration,
        ) -> Self {
            self.inner = self.inner.blue_green_deployment_configuration(input);
            self
        }
        pub fn set_blue_green_deployment_configuration(
            mut self,
            input: std::option::Option<crate::model::BlueGreenDeploymentConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_blue_green_deployment_configuration(input);
            self
        }
        /// <p>Information about the load balancer used in a deployment.</p>
        pub fn load_balancer_info(mut self, input: crate::model::LoadBalancerInfo) -> Self {
            self.inner = self.inner.load_balancer_info(input);
            self
        }
        pub fn set_load_balancer_info(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerInfo>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_info(input);
            self
        }
        /// <p>Information about groups of tags applied to EC2 instances. The deployment group
        /// includes only EC2 instances identified by all the tag groups. Cannot be used in the same
        /// call as <code>ec2TagFilters</code>.</p>
        pub fn ec2_tag_set(mut self, input: crate::model::Ec2TagSet) -> Self {
            self.inner = self.inner.ec2_tag_set(input);
            self
        }
        pub fn set_ec2_tag_set(
            mut self,
            input: std::option::Option<crate::model::Ec2TagSet>,
        ) -> Self {
            self.inner = self.inner.set_ec2_tag_set(input);
            self
        }
        /// <p> The target Amazon ECS services in the deployment group. This applies only to
        /// deployment groups that use the Amazon ECS compute platform. A target Amazon ECS service
        /// is specified as an Amazon ECS cluster and service name pair using the format
        /// <code><clustername>:<servicename></code>. </p>
        pub fn ecs_services(mut self, inp: impl Into<crate::model::EcsService>) -> Self {
            self.inner = self.inner.ecs_services(inp);
            self
        }
        pub fn set_ecs_services(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EcsService>>,
        ) -> Self {
            self.inner = self.inner.set_ecs_services(input);
            self
        }
        /// <p>Information about groups of tags applied to on-premises instances. The deployment
        /// group includes only on-premises instances identified by all of the tag groups. Cannot be
        /// used in the same call as <code>onPremisesInstanceTagFilters</code>.</p>
        pub fn on_premises_tag_set(mut self, input: crate::model::OnPremisesTagSet) -> Self {
            self.inner = self.inner.on_premises_tag_set(input);
            self
        }
        pub fn set_on_premises_tag_set(
            mut self,
            input: std::option::Option<crate::model::OnPremisesTagSet>,
        ) -> Self {
            self.inner = self.inner.set_on_premises_tag_set(input);
            self
        }
        /// <p> The metadata that you apply to CodeDeploy deployment groups to help you organize and
        /// categorize them. Each tag consists of a key and an optional value, both of which you
        /// define. </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_application_input::Builder,
    }
    impl<C> DeleteApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteApplicationOutput,
            smithy_http::result::SdkError<crate::error::DeleteApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
        /// account.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDeploymentConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_deployment_config_input::Builder,
    }
    impl<C> DeleteDeploymentConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDeploymentConfigOutput,
            smithy_http::result::SdkError<crate::error::DeleteDeploymentConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a deployment configuration associated with the IAM user or AWS
        /// account.</p>
        pub fn deployment_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_config_name(input);
            self
        }
        pub fn set_deployment_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_config_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteDeploymentGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_deployment_group_input::Builder,
    }
    impl<C> DeleteDeploymentGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteDeploymentGroupOutput,
            smithy_http::result::SdkError<crate::error::DeleteDeploymentGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
        /// account.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The name of a deployment group for the specified application.</p>
        pub fn deployment_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_group_name(input);
            self
        }
        pub fn set_deployment_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteGitHubAccountToken<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_git_hub_account_token_input::Builder,
    }
    impl<C> DeleteGitHubAccountToken<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteGitHubAccountTokenOutput,
            smithy_http::result::SdkError<crate::error::DeleteGitHubAccountTokenError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the GitHub account connection to delete.</p>
        pub fn token_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.token_name(input);
            self
        }
        pub fn set_token_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_token_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResourcesByExternalId<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_resources_by_external_id_input::Builder,
    }
    impl<C> DeleteResourcesByExternalId<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResourcesByExternalIdOutput,
            smithy_http::result::SdkError<crate::error::DeleteResourcesByExternalIdError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique ID of an external resource (for example, a CloudFormation stack ID) that is
        /// linked to one or more CodeDeploy resources.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(input);
            self
        }
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeregisterOnPremisesInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::deregister_on_premises_instance_input::Builder,
    }
    impl<C> DeregisterOnPremisesInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeregisterOnPremisesInstanceOutput,
            smithy_http::result::SdkError<crate::error::DeregisterOnPremisesInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the on-premises instance to deregister.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_application_input::Builder,
    }
    impl<C> GetApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetApplicationOutput,
            smithy_http::result::SdkError<crate::error::GetApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
        /// account.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetApplicationRevision<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_application_revision_input::Builder,
    }
    impl<C> GetApplicationRevision<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetApplicationRevisionOutput,
            smithy_http::result::SdkError<crate::error::GetApplicationRevisionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the application that corresponds to the revision.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>Information about the application revision to get, including type and location.</p>
        pub fn revision(mut self, input: crate::model::RevisionLocation) -> Self {
            self.inner = self.inner.revision(input);
            self
        }
        pub fn set_revision(
            mut self,
            input: std::option::Option<crate::model::RevisionLocation>,
        ) -> Self {
            self.inner = self.inner.set_revision(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDeployment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_deployment_input::Builder,
    }
    impl<C> GetDeployment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDeploymentOutput,
            smithy_http::result::SdkError<crate::error::GetDeploymentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a deployment associated with the IAM user or AWS account. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDeploymentConfig<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_deployment_config_input::Builder,
    }
    impl<C> GetDeploymentConfig<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDeploymentConfigOutput,
            smithy_http::result::SdkError<crate::error::GetDeploymentConfigError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of a deployment configuration associated with the IAM user or AWS
        /// account.</p>
        pub fn deployment_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_config_name(input);
            self
        }
        pub fn set_deployment_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_config_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDeploymentGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_deployment_group_input::Builder,
    }
    impl<C> GetDeploymentGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDeploymentGroupOutput,
            smithy_http::result::SdkError<crate::error::GetDeploymentGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
        /// account.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The name of a deployment group for the specified application.</p>
        pub fn deployment_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_group_name(input);
            self
        }
        pub fn set_deployment_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_group_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDeploymentInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_deployment_instance_input::Builder,
    }
    impl<C> GetDeploymentInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDeploymentInstanceOutput,
            smithy_http::result::SdkError<crate::error::GetDeploymentInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a deployment. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
        /// <p> The unique ID of an instance in the deployment group. </p>
        pub fn instance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_id(input);
            self
        }
        pub fn set_instance_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_instance_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDeploymentTarget<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_deployment_target_input::Builder,
    }
    impl<C> GetDeploymentTarget<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDeploymentTargetOutput,
            smithy_http::result::SdkError<crate::error::GetDeploymentTargetError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a deployment. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
        /// <p> The unique ID of a deployment target. </p>
        pub fn target_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_id(input);
            self
        }
        pub fn set_target_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_target_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetOnPremisesInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_on_premises_instance_input::Builder,
    }
    impl<C> GetOnPremisesInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetOnPremisesInstanceOutput,
            smithy_http::result::SdkError<crate::error::GetOnPremisesInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name of the on-premises instance about which to get information. </p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListApplicationRevisions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_application_revisions_input::Builder,
    }
    impl<C> ListApplicationRevisions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListApplicationRevisionsOutput,
            smithy_http::result::SdkError<crate::error::ListApplicationRevisionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The name of an AWS CodeDeploy application associated with the IAM user or AWS
        /// account. </p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The column name to use to sort the list results:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>registerTime</code>: Sort by the time the revisions were registered with
        /// AWS CodeDeploy.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>firstUsedTime</code>: Sort by the time the revisions were first used in
        /// a deployment.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>lastUsedTime</code>: Sort by the time the revisions were last used in a
        /// deployment.</p>
        /// </li>
        /// </ul>
        /// <p> If not specified or set to null, the results are returned in an arbitrary order.
        /// </p>
        pub fn sort_by(mut self, input: crate::model::ApplicationRevisionSortBy) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(
            mut self,
            input: std::option::Option<crate::model::ApplicationRevisionSortBy>,
        ) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p> The order in which to sort the list results: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>ascending</code>: ascending order.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>descending</code>: descending order.</p>
        /// </li>
        /// </ul>
        /// <p>If not specified, the results are sorted in ascending order.</p>
        /// <p>If set to null, the results are sorted in an arbitrary order.</p>
        pub fn sort_order(mut self, input: crate::model::SortOrder) -> Self {
            self.inner = self.inner.sort_order(input);
            self
        }
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrder>,
        ) -> Self {
            self.inner = self.inner.set_sort_order(input);
            self
        }
        /// <p> An Amazon S3 bucket name to limit the search for revisions. </p>
        /// <p> If set to null, all of the user's buckets are searched. </p>
        pub fn s3_bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.s3_bucket(input);
            self
        }
        pub fn set_s3_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_s3_bucket(input);
            self
        }
        /// <p> A key prefix for the set of Amazon S3 objects to limit the search for revisions.
        /// </p>
        pub fn s3_key_prefix(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.s3_key_prefix(input);
            self
        }
        pub fn set_s3_key_prefix(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_s3_key_prefix(input);
            self
        }
        /// <p> Whether to list revisions based on whether the revision is the target revision of a
        /// deployment group: </p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>include</code>: List revisions that are target revisions of a deployment
        /// group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>exclude</code>: Do not list revisions that are target revisions of a
        /// deployment group.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ignore</code>: List all revisions.</p>
        /// </li>
        /// </ul>
        pub fn deployed(mut self, input: crate::model::ListStateFilterAction) -> Self {
            self.inner = self.inner.deployed(input);
            self
        }
        pub fn set_deployed(
            mut self,
            input: std::option::Option<crate::model::ListStateFilterAction>,
        ) -> Self {
            self.inner = self.inner.set_deployed(input);
            self
        }
        /// <p>An identifier returned from the previous <code>ListApplicationRevisions</code> call.
        /// It can be used to return the next set of applications in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListApplications<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_applications_input::Builder,
    }
    impl<C> ListApplications<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListApplicationsOutput,
            smithy_http::result::SdkError<crate::error::ListApplicationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier returned from the previous list applications call. It can be used to
        /// return the next set of applications in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDeploymentConfigs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_deployment_configs_input::Builder,
    }
    impl<C> ListDeploymentConfigs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDeploymentConfigsOutput,
            smithy_http::result::SdkError<crate::error::ListDeploymentConfigsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier returned from the previous <code>ListDeploymentConfigs</code> call. It
        /// can be used to return the next set of deployment configurations in the list. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDeploymentGroups<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_deployment_groups_input::Builder,
    }
    impl<C> ListDeploymentGroups<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDeploymentGroupsOutput,
            smithy_http::result::SdkError<crate::error::ListDeploymentGroupsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
        /// account.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>An identifier returned from the previous list deployment groups call. It can be used
        /// to return the next set of deployment groups in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDeploymentInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_deployment_instances_input::Builder,
    }
    impl<C> ListDeploymentInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDeploymentInstancesOutput,
            smithy_http::result::SdkError<crate::error::ListDeploymentInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a deployment. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
        /// <p>An identifier returned from the previous list deployment instances call. It can be
        /// used to return the next set of deployment instances in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A subset of instances to list by status:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Pending</code>: Include those instances with pending deployments.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>InProgress</code>: Include those instances where deployments are still
        /// in progress.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Succeeded</code>: Include those instances with successful
        /// deployments.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Failed</code>: Include those instances with failed deployments.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Skipped</code>: Include those instances with skipped deployments.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Unknown</code>: Include those instances with deployments in an unknown
        /// state.</p>
        /// </li>
        /// </ul>
        pub fn instance_status_filter(
            mut self,
            inp: impl Into<crate::model::InstanceStatus>,
        ) -> Self {
            self.inner = self.inner.instance_status_filter(inp);
            self
        }
        pub fn set_instance_status_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceStatus>>,
        ) -> Self {
            self.inner = self.inner.set_instance_status_filter(input);
            self
        }
        /// <p>The set of instances in a blue/green deployment, either those in the original
        /// environment ("BLUE") or those in the replacement environment ("GREEN"), for which you
        /// want to view instance information.</p>
        pub fn instance_type_filter(mut self, inp: impl Into<crate::model::InstanceType>) -> Self {
            self.inner = self.inner.instance_type_filter(inp);
            self
        }
        pub fn set_instance_type_filter(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::InstanceType>>,
        ) -> Self {
            self.inner = self.inner.set_instance_type_filter(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDeployments<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_deployments_input::Builder,
    }
    impl<C> ListDeployments<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDeploymentsOutput,
            smithy_http::result::SdkError<crate::error::ListDeploymentsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
        /// account.</p>
        /// <note>
        /// <p>If <code>applicationName</code> is specified, then
        /// <code>deploymentGroupName</code> must be specified. If it is not specified, then
        /// <code>deploymentGroupName</code> must not be specified. </p>
        /// </note>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The name of a deployment group for the specified application.</p>
        /// <note>
        /// <p>If <code>deploymentGroupName</code> is specified, then
        /// <code>applicationName</code> must be specified. If it is not specified, then
        /// <code>applicationName</code> must not be specified. </p>
        /// </note>
        pub fn deployment_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_group_name(input);
            self
        }
        pub fn set_deployment_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_group_name(input);
            self
        }
        /// <p>The unique ID of an external resource for returning deployments linked to the external
        /// resource.</p>
        pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.external_id(input);
            self
        }
        pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_external_id(input);
            self
        }
        /// <p>A subset of deployments to list by status:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Created</code>: Include created deployments in the resulting
        /// list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Queued</code>: Include queued deployments in the resulting list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>In Progress</code>: Include in-progress deployments in the resulting
        /// list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Succeeded</code>: Include successful deployments in the resulting
        /// list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Failed</code>: Include failed deployments in the resulting list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Stopped</code>: Include stopped deployments in the resulting
        /// list.</p>
        /// </li>
        /// </ul>
        pub fn include_only_statuses(
            mut self,
            inp: impl Into<crate::model::DeploymentStatus>,
        ) -> Self {
            self.inner = self.inner.include_only_statuses(inp);
            self
        }
        pub fn set_include_only_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeploymentStatus>>,
        ) -> Self {
            self.inner = self.inner.set_include_only_statuses(input);
            self
        }
        /// <p>A time range (start and end) for returning a subset of the list of deployments.</p>
        pub fn create_time_range(mut self, input: crate::model::TimeRange) -> Self {
            self.inner = self.inner.create_time_range(input);
            self
        }
        pub fn set_create_time_range(
            mut self,
            input: std::option::Option<crate::model::TimeRange>,
        ) -> Self {
            self.inner = self.inner.set_create_time_range(input);
            self
        }
        /// <p>An identifier returned from the previous list deployments call. It can be used to
        /// return the next set of deployments in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListDeploymentTargets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_deployment_targets_input::Builder,
    }
    impl<C> ListDeploymentTargets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListDeploymentTargetsOutput,
            smithy_http::result::SdkError<crate::error::ListDeploymentTargetsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a deployment. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
        /// <p> A token identifier returned from the previous <code>ListDeploymentTargets</code>
        /// call. It can be used to return the next set of deployment targets in the list. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p> A key used to filter the returned targets. The two valid values are:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>TargetStatus</code> - A <code>TargetStatus</code> filter string can be
        /// <code>Failed</code>, <code>InProgress</code>, <code>Pending</code>,
        /// <code>Ready</code>, <code>Skipped</code>, <code>Succeeded</code>, or
        /// <code>Unknown</code>. </p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>ServerInstanceLabel</code> - A <code>ServerInstanceLabel</code> filter
        /// string can be <code>Blue</code> or <code>Green</code>. </p>
        /// </li>
        /// </ul>
        pub fn target_filters(
            mut self,
            k: impl Into<crate::model::TargetFilterName>,
            v: impl Into<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.target_filters(k, v);
            self
        }
        pub fn set_target_filters(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    crate::model::TargetFilterName,
                    std::vec::Vec<std::string::String>,
                >,
            >,
        ) -> Self {
            self.inner = self.inner.set_target_filters(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListGitHubAccountTokenNames<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_git_hub_account_token_names_input::Builder,
    }
    impl<C> ListGitHubAccountTokenNames<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListGitHubAccountTokenNamesOutput,
            smithy_http::result::SdkError<crate::error::ListGitHubAccountTokenNamesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An identifier returned from the previous <code>ListGitHubAccountTokenNames</code>
        /// call. It can be used to return the next set of names in the list. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListOnPremisesInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_on_premises_instances_input::Builder,
    }
    impl<C> ListOnPremisesInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListOnPremisesInstancesOutput,
            smithy_http::result::SdkError<crate::error::ListOnPremisesInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The registration status of the on-premises instances:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <code>Deregistered</code>: Include deregistered on-premises instances in the
        /// resulting list.</p>
        /// </li>
        /// <li>
        /// <p>
        /// <code>Registered</code>: Include registered on-premises instances in the
        /// resulting list.</p>
        /// </li>
        /// </ul>
        pub fn registration_status(mut self, input: crate::model::RegistrationStatus) -> Self {
            self.inner = self.inner.registration_status(input);
            self
        }
        pub fn set_registration_status(
            mut self,
            input: std::option::Option<crate::model::RegistrationStatus>,
        ) -> Self {
            self.inner = self.inner.set_registration_status(input);
            self
        }
        /// <p>The on-premises instance tags that are used to restrict the on-premises instance names
        /// returned.</p>
        pub fn tag_filters(mut self, inp: impl Into<crate::model::TagFilter>) -> Self {
            self.inner = self.inner.tag_filters(inp);
            self
        }
        pub fn set_tag_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagFilter>>,
        ) -> Self {
            self.inner = self.inner.set_tag_filters(input);
            self
        }
        /// <p>An identifier returned from the previous list on-premises instances call. It can be
        /// used to return the next set of on-premises instances in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The ARN of a CodeDeploy resource. <code>ListTagsForResource</code> returns all the
        /// tags associated with the resource that is identified by the <code>ResourceArn</code>.
        /// </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>An identifier returned from the previous <code>ListTagsForResource</code> call. It can
        /// be used to return the next set of applications in the list.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutLifecycleEventHookExecutionStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_lifecycle_event_hook_execution_status_input::Builder,
    }
    impl<C> PutLifecycleEventHookExecutionStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutLifecycleEventHookExecutionStatusOutput,
            smithy_http::result::SdkError<crate::error::PutLifecycleEventHookExecutionStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a deployment. Pass this ID to a Lambda function that validates a
        /// deployment lifecycle event. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
        /// <p> The execution ID of a deployment's lifecycle hook. A deployment lifecycle hook is
        /// specified in the <code>hooks</code> section of the AppSpec file. </p>
        pub fn lifecycle_event_hook_execution_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.lifecycle_event_hook_execution_id(input);
            self
        }
        pub fn set_lifecycle_event_hook_execution_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_event_hook_execution_id(input);
            self
        }
        /// <p>The result of a Lambda function that validates a deployment lifecycle event.
        /// <code>Succeeded</code> and <code>Failed</code> are the only valid values for
        /// <code>status</code>.</p>
        pub fn status(mut self, input: crate::model::LifecycleEventStatus) -> Self {
            self.inner = self.inner.status(input);
            self
        }
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::LifecycleEventStatus>,
        ) -> Self {
            self.inner = self.inner.set_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterApplicationRevision<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_application_revision_input::Builder,
    }
    impl<C> RegisterApplicationRevision<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterApplicationRevisionOutput,
            smithy_http::result::SdkError<crate::error::RegisterApplicationRevisionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of an AWS CodeDeploy application associated with the IAM user or AWS
        /// account.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>A comment about the revision.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>Information about the application revision to register, including type and
        /// location.</p>
        pub fn revision(mut self, input: crate::model::RevisionLocation) -> Self {
            self.inner = self.inner.revision(input);
            self
        }
        pub fn set_revision(
            mut self,
            input: std::option::Option<crate::model::RevisionLocation>,
        ) -> Self {
            self.inner = self.inner.set_revision(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RegisterOnPremisesInstance<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::register_on_premises_instance_input::Builder,
    }
    impl<C> RegisterOnPremisesInstance<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RegisterOnPremisesInstanceOutput,
            smithy_http::result::SdkError<crate::error::RegisterOnPremisesInstanceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the on-premises instance to register.</p>
        pub fn instance_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_name(input);
            self
        }
        pub fn set_instance_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_instance_name(input);
            self
        }
        /// <p>The ARN of the IAM session to associate with the on-premises instance.</p>
        pub fn iam_session_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.iam_session_arn(input);
            self
        }
        pub fn set_iam_session_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_iam_session_arn(input);
            self
        }
        /// <p>The ARN of the IAM user to associate with the on-premises instance.</p>
        pub fn iam_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.iam_user_arn(input);
            self
        }
        pub fn set_iam_user_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_iam_user_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveTagsFromOnPremisesInstances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::remove_tags_from_on_premises_instances_input::Builder,
    }
    impl<C> RemoveTagsFromOnPremisesInstances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveTagsFromOnPremisesInstancesOutput,
            smithy_http::result::SdkError<crate::error::RemoveTagsFromOnPremisesInstancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The tag key-value pairs to remove from the on-premises instances.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The names of the on-premises instances from which to remove tags.</p>
        pub fn instance_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.instance_names(inp);
            self
        }
        pub fn set_instance_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_instance_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct SkipWaitTimeForInstanceTermination<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::skip_wait_time_for_instance_termination_input::Builder,
    }
    impl<C> SkipWaitTimeForInstanceTermination<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::SkipWaitTimeForInstanceTerminationOutput,
            smithy_http::result::SdkError<crate::error::SkipWaitTimeForInstanceTerminationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a blue/green deployment for which you want to skip the instance
        /// termination wait time. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopDeployment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::stop_deployment_input::Builder,
    }
    impl<C> StopDeployment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopDeploymentOutput,
            smithy_http::result::SdkError<crate::error::StopDeploymentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The unique ID of a deployment. </p>
        pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_id(input);
            self
        }
        pub fn set_deployment_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_id(input);
            self
        }
        /// <p> Indicates, when a deployment is stopped, whether instances that have been updated
        /// should be rolled back to the previous version of the application revision. </p>
        pub fn auto_rollback_enabled(mut self, input: bool) -> Self {
            self.inner = self.inner.auto_rollback_enabled(input);
            self
        }
        pub fn set_auto_rollback_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_auto_rollback_enabled(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The ARN of a resource, such as a CodeDeploy application or deployment group. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p> A list of tags that <code>TagResource</code> associates with a resource. The resource
        /// is identified by the <code>ResourceArn</code> input parameter. </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> The Amazon Resource Name (ARN) that specifies from which resource to disassociate the
        /// tags with the keys in the <code>TagKeys</code> input parameter. </p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p> A list of keys of <code>Tag</code> objects. The <code>Tag</code> objects identified
        /// by the keys are disassociated from the resource specified by the
        /// <code>ResourceArn</code> input parameter. </p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateApplication<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_application_input::Builder,
    }
    impl<C> UpdateApplication<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateApplicationOutput,
            smithy_http::result::SdkError<crate::error::UpdateApplicationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The current name of the application you want to change.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The new name to give the application.</p>
        pub fn new_application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_application_name(input);
            self
        }
        pub fn set_new_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_new_application_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDeploymentGroup<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_deployment_group_input::Builder,
    }
    impl<C> UpdateDeploymentGroup<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDeploymentGroupOutput,
            smithy_http::result::SdkError<crate::error::UpdateDeploymentGroupError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The application name that corresponds to the deployment group to update.</p>
        pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.application_name(input);
            self
        }
        pub fn set_application_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_application_name(input);
            self
        }
        /// <p>The current name of the deployment group.</p>
        pub fn current_deployment_group_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.current_deployment_group_name(input);
            self
        }
        pub fn set_current_deployment_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_current_deployment_group_name(input);
            self
        }
        /// <p>The new name of the deployment group, if you want to change it.</p>
        pub fn new_deployment_group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_deployment_group_name(input);
            self
        }
        pub fn set_new_deployment_group_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_new_deployment_group_name(input);
            self
        }
        /// <p>The replacement deployment configuration name to use, if you want to change it.</p>
        pub fn deployment_config_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.deployment_config_name(input);
            self
        }
        pub fn set_deployment_config_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_deployment_config_name(input);
            self
        }
        /// <p>The replacement set of Amazon EC2 tags on which to filter, if you want to change them.
        /// To keep the existing tags, enter their names. To remove tags, do not enter any tag
        /// names.</p>
        pub fn ec2_tag_filters(mut self, inp: impl Into<crate::model::Ec2TagFilter>) -> Self {
            self.inner = self.inner.ec2_tag_filters(inp);
            self
        }
        pub fn set_ec2_tag_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Ec2TagFilter>>,
        ) -> Self {
            self.inner = self.inner.set_ec2_tag_filters(input);
            self
        }
        /// <p>The replacement set of on-premises instance tags on which to filter, if you want to
        /// change them. To keep the existing tags, enter their names. To remove tags, do not enter
        /// any tag names.</p>
        pub fn on_premises_instance_tag_filters(
            mut self,
            inp: impl Into<crate::model::TagFilter>,
        ) -> Self {
            self.inner = self.inner.on_premises_instance_tag_filters(inp);
            self
        }
        pub fn set_on_premises_instance_tag_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TagFilter>>,
        ) -> Self {
            self.inner = self.inner.set_on_premises_instance_tag_filters(input);
            self
        }
        /// <p>The replacement list of Auto Scaling groups to be included in the deployment group, if
        /// you want to change them. To keep the Auto Scaling groups, enter their names. To remove
        /// Auto Scaling groups, do not enter any Auto Scaling group names.</p>
        pub fn auto_scaling_groups(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.auto_scaling_groups(inp);
            self
        }
        pub fn set_auto_scaling_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_auto_scaling_groups(input);
            self
        }
        /// <p>A replacement ARN for the service role, if you want to change it.</p>
        pub fn service_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.service_role_arn(input);
            self
        }
        pub fn set_service_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_service_role_arn(input);
            self
        }
        /// <p>Information about triggers to change when the deployment group is updated. For
        /// examples, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/how-to-notify-edit.html">Edit a Trigger in a
        /// CodeDeploy Deployment Group</a> in the <i>AWS CodeDeploy User
        /// Guide</i>.</p>
        pub fn trigger_configurations(
            mut self,
            inp: impl Into<crate::model::TriggerConfig>,
        ) -> Self {
            self.inner = self.inner.trigger_configurations(inp);
            self
        }
        pub fn set_trigger_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TriggerConfig>>,
        ) -> Self {
            self.inner = self.inner.set_trigger_configurations(input);
            self
        }
        /// <p>Information to add or change about Amazon CloudWatch alarms when the deployment group
        /// is updated.</p>
        pub fn alarm_configuration(mut self, input: crate::model::AlarmConfiguration) -> Self {
            self.inner = self.inner.alarm_configuration(input);
            self
        }
        pub fn set_alarm_configuration(
            mut self,
            input: std::option::Option<crate::model::AlarmConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_alarm_configuration(input);
            self
        }
        /// <p>Information for an automatic rollback configuration that is added or changed when a
        /// deployment group is updated.</p>
        pub fn auto_rollback_configuration(
            mut self,
            input: crate::model::AutoRollbackConfiguration,
        ) -> Self {
            self.inner = self.inner.auto_rollback_configuration(input);
            self
        }
        pub fn set_auto_rollback_configuration(
            mut self,
            input: std::option::Option<crate::model::AutoRollbackConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_auto_rollback_configuration(input);
            self
        }
        /// <p>Indicates what happens when new EC2 instances are launched mid-deployment and do not
        /// receive the deployed application revision.</p>
        /// <p>If this option is set to <code>UPDATE</code> or is unspecified, CodeDeploy initiates
        /// one or more 'auto-update outdated instances' deployments to apply the deployed
        /// application revision to the new EC2 instances.</p>
        /// <p>If this option is set to <code>IGNORE</code>, CodeDeploy does not initiate a
        /// deployment to update the new EC2 instances. This may result in instances having
        /// different revisions.</p>
        pub fn outdated_instances_strategy(
            mut self,
            input: crate::model::OutdatedInstancesStrategy,
        ) -> Self {
            self.inner = self.inner.outdated_instances_strategy(input);
            self
        }
        pub fn set_outdated_instances_strategy(
            mut self,
            input: std::option::Option<crate::model::OutdatedInstancesStrategy>,
        ) -> Self {
            self.inner = self.inner.set_outdated_instances_strategy(input);
            self
        }
        /// <p>Information about the type of deployment, either in-place or blue/green, you want to
        /// run and whether to route deployment traffic behind a load balancer.</p>
        pub fn deployment_style(mut self, input: crate::model::DeploymentStyle) -> Self {
            self.inner = self.inner.deployment_style(input);
            self
        }
        pub fn set_deployment_style(
            mut self,
            input: std::option::Option<crate::model::DeploymentStyle>,
        ) -> Self {
            self.inner = self.inner.set_deployment_style(input);
            self
        }
        /// <p>Information about blue/green deployment options for a deployment group.</p>
        pub fn blue_green_deployment_configuration(
            mut self,
            input: crate::model::BlueGreenDeploymentConfiguration,
        ) -> Self {
            self.inner = self.inner.blue_green_deployment_configuration(input);
            self
        }
        pub fn set_blue_green_deployment_configuration(
            mut self,
            input: std::option::Option<crate::model::BlueGreenDeploymentConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_blue_green_deployment_configuration(input);
            self
        }
        /// <p>Information about the load balancer used in a deployment.</p>
        pub fn load_balancer_info(mut self, input: crate::model::LoadBalancerInfo) -> Self {
            self.inner = self.inner.load_balancer_info(input);
            self
        }
        pub fn set_load_balancer_info(
            mut self,
            input: std::option::Option<crate::model::LoadBalancerInfo>,
        ) -> Self {
            self.inner = self.inner.set_load_balancer_info(input);
            self
        }
        /// <p>Information about groups of tags applied to on-premises instances. The deployment
        /// group includes only EC2 instances identified by all the tag groups.</p>
        pub fn ec2_tag_set(mut self, input: crate::model::Ec2TagSet) -> Self {
            self.inner = self.inner.ec2_tag_set(input);
            self
        }
        pub fn set_ec2_tag_set(
            mut self,
            input: std::option::Option<crate::model::Ec2TagSet>,
        ) -> Self {
            self.inner = self.inner.set_ec2_tag_set(input);
            self
        }
        /// <p> The target Amazon ECS services in the deployment group. This applies only to
        /// deployment groups that use the Amazon ECS compute platform. A target Amazon ECS service
        /// is specified as an Amazon ECS cluster and service name pair using the format
        /// <code><clustername>:<servicename></code>. </p>
        pub fn ecs_services(mut self, inp: impl Into<crate::model::EcsService>) -> Self {
            self.inner = self.inner.ecs_services(inp);
            self
        }
        pub fn set_ecs_services(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::EcsService>>,
        ) -> Self {
            self.inner = self.inner.set_ecs_services(input);
            self
        }
        /// <p>Information about an on-premises instance tag set. The deployment group includes only
        /// on-premises instances identified by all the tag groups.</p>
        pub fn on_premises_tag_set(mut self, input: crate::model::OnPremisesTagSet) -> Self {
            self.inner = self.inner.on_premises_tag_set(input);
            self
        }
        pub fn set_on_premises_tag_set(
            mut self,
            input: std::option::Option<crate::model::OnPremisesTagSet>,
        ) -> Self {
            self.inner = self.inner.set_on_premises_tag_set(input);
            self
        }
    }
}
