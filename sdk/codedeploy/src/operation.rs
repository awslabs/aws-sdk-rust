// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Adds tags to on-premises instances.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AddTagsToOnPremisesInstances {
    _private: (),
}
impl AddTagsToOnPremisesInstances {
    /// Creates a new builder-style object to manufacture [`AddTagsToOnPremisesInstancesInput`](crate::input::AddTagsToOnPremisesInstancesInput)
    pub fn builder() -> crate::input::add_tags_to_on_premises_instances_input::Builder {
        crate::input::add_tags_to_on_premises_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AddTagsToOnPremisesInstances {
    type Output = std::result::Result<
        crate::output::AddTagsToOnPremisesInstancesOutput,
        crate::error::AddTagsToOnPremisesInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_add_tags_to_on_premises_instances_error(response)
        } else {
            crate::operation_deser::parse_add_tags_to_on_premises_instances_response(response)
        }
    }
}

/// <p>Gets information about one or more application revisions. The maximum number of
/// application revisions that can be returned is 25.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetApplicationRevisions {
    _private: (),
}
impl BatchGetApplicationRevisions {
    /// Creates a new builder-style object to manufacture [`BatchGetApplicationRevisionsInput`](crate::input::BatchGetApplicationRevisionsInput)
    pub fn builder() -> crate::input::batch_get_application_revisions_input::Builder {
        crate::input::batch_get_application_revisions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetApplicationRevisions {
    type Output = std::result::Result<
        crate::output::BatchGetApplicationRevisionsOutput,
        crate::error::BatchGetApplicationRevisionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_application_revisions_error(response)
        } else {
            crate::operation_deser::parse_batch_get_application_revisions_response(response)
        }
    }
}

/// <p>Gets information about one or more applications. The maximum number of applications
/// that can be returned is 100.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetApplications {
    _private: (),
}
impl BatchGetApplications {
    /// Creates a new builder-style object to manufacture [`BatchGetApplicationsInput`](crate::input::BatchGetApplicationsInput)
    pub fn builder() -> crate::input::batch_get_applications_input::Builder {
        crate::input::batch_get_applications_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetApplications {
    type Output = std::result::Result<
        crate::output::BatchGetApplicationsOutput,
        crate::error::BatchGetApplicationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_applications_error(response)
        } else {
            crate::operation_deser::parse_batch_get_applications_response(response)
        }
    }
}

/// <p>Gets information about one or more deployment groups.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetDeploymentGroups {
    _private: (),
}
impl BatchGetDeploymentGroups {
    /// Creates a new builder-style object to manufacture [`BatchGetDeploymentGroupsInput`](crate::input::BatchGetDeploymentGroupsInput)
    pub fn builder() -> crate::input::batch_get_deployment_groups_input::Builder {
        crate::input::batch_get_deployment_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetDeploymentGroups {
    type Output = std::result::Result<
        crate::output::BatchGetDeploymentGroupsOutput,
        crate::error::BatchGetDeploymentGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_deployment_groups_error(response)
        } else {
            crate::operation_deser::parse_batch_get_deployment_groups_response(response)
        }
    }
}

/// <note>
/// <p> This method works, but is deprecated. Use <code>BatchGetDeploymentTargets</code>
/// instead. </p>
/// </note>
/// <p> Returns an array of one or more instances associated with a deployment. This method
/// works with EC2/On-premises and AWS Lambda compute platforms. The newer
/// <code>BatchGetDeploymentTargets</code> works with all compute platforms. The maximum
/// number of instances that can be returned is 25.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetDeploymentInstances {
    _private: (),
}
impl BatchGetDeploymentInstances {
    /// Creates a new builder-style object to manufacture [`BatchGetDeploymentInstancesInput`](crate::input::BatchGetDeploymentInstancesInput)
    pub fn builder() -> crate::input::batch_get_deployment_instances_input::Builder {
        crate::input::batch_get_deployment_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetDeploymentInstances {
    type Output = std::result::Result<
        crate::output::BatchGetDeploymentInstancesOutput,
        crate::error::BatchGetDeploymentInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_deployment_instances_error(response)
        } else {
            crate::operation_deser::parse_batch_get_deployment_instances_response(response)
        }
    }
}

/// <p>Gets information about one or more deployments. The maximum number of deployments that
/// can be returned is 25.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetDeployments {
    _private: (),
}
impl BatchGetDeployments {
    /// Creates a new builder-style object to manufacture [`BatchGetDeploymentsInput`](crate::input::BatchGetDeploymentsInput)
    pub fn builder() -> crate::input::batch_get_deployments_input::Builder {
        crate::input::batch_get_deployments_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetDeployments {
    type Output = std::result::Result<
        crate::output::BatchGetDeploymentsOutput,
        crate::error::BatchGetDeploymentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_deployments_error(response)
        } else {
            crate::operation_deser::parse_batch_get_deployments_response(response)
        }
    }
}

/// <p> Returns an array of one or more targets associated with a deployment. This method
/// works with all compute types and should be used instead of the deprecated
/// <code>BatchGetDeploymentInstances</code>. The maximum number of targets that can be
/// returned is 25.</p>
/// <p> The type of targets returned depends on the deployment's compute platform or
/// deployment method: </p>
/// <ul>
/// <li>
/// <p>
/// <b>EC2/On-premises</b>: Information about EC2 instance
/// targets. </p>
/// </li>
/// <li>
/// <p>
/// <b>AWS Lambda</b>: Information about Lambda functions
/// targets. </p>
/// </li>
/// <li>
/// <p>
/// <b>Amazon ECS</b>: Information about Amazon ECS
/// service targets. </p>
/// </li>
/// <li>
/// <p>
/// <b>CloudFormation</b>: Information about targets of
/// blue/green deployments initiated by a CloudFormation stack update.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetDeploymentTargets {
    _private: (),
}
impl BatchGetDeploymentTargets {
    /// Creates a new builder-style object to manufacture [`BatchGetDeploymentTargetsInput`](crate::input::BatchGetDeploymentTargetsInput)
    pub fn builder() -> crate::input::batch_get_deployment_targets_input::Builder {
        crate::input::batch_get_deployment_targets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetDeploymentTargets {
    type Output = std::result::Result<
        crate::output::BatchGetDeploymentTargetsOutput,
        crate::error::BatchGetDeploymentTargetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_deployment_targets_error(response)
        } else {
            crate::operation_deser::parse_batch_get_deployment_targets_response(response)
        }
    }
}

/// <p>Gets information about one or more on-premises instances. The maximum number of
/// on-premises instances that can be returned is 25.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetOnPremisesInstances {
    _private: (),
}
impl BatchGetOnPremisesInstances {
    /// Creates a new builder-style object to manufacture [`BatchGetOnPremisesInstancesInput`](crate::input::BatchGetOnPremisesInstancesInput)
    pub fn builder() -> crate::input::batch_get_on_premises_instances_input::Builder {
        crate::input::batch_get_on_premises_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetOnPremisesInstances {
    type Output = std::result::Result<
        crate::output::BatchGetOnPremisesInstancesOutput,
        crate::error::BatchGetOnPremisesInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_on_premises_instances_error(response)
        } else {
            crate::operation_deser::parse_batch_get_on_premises_instances_response(response)
        }
    }
}

/// <p>For a blue/green deployment, starts the process of rerouting traffic from instances in
/// the original environment to instances in the replacement environment without waiting for
/// a specified wait time to elapse. (Traffic rerouting, which is achieved by registering
/// instances in the replacement environment with the load balancer, can start as soon as
/// all instances have a status of Ready.) </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ContinueDeployment {
    _private: (),
}
impl ContinueDeployment {
    /// Creates a new builder-style object to manufacture [`ContinueDeploymentInput`](crate::input::ContinueDeploymentInput)
    pub fn builder() -> crate::input::continue_deployment_input::Builder {
        crate::input::continue_deployment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ContinueDeployment {
    type Output = std::result::Result<
        crate::output::ContinueDeploymentOutput,
        crate::error::ContinueDeploymentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_continue_deployment_error(response)
        } else {
            crate::operation_deser::parse_continue_deployment_response(response)
        }
    }
}

/// <p>Creates an application.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateApplication {
    _private: (),
}
impl CreateApplication {
    /// Creates a new builder-style object to manufacture [`CreateApplicationInput`](crate::input::CreateApplicationInput)
    pub fn builder() -> crate::input::create_application_input::Builder {
        crate::input::create_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateApplication {
    type Output = std::result::Result<
        crate::output::CreateApplicationOutput,
        crate::error::CreateApplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_application_error(response)
        } else {
            crate::operation_deser::parse_create_application_response(response)
        }
    }
}

/// <p>Deploys an application revision through the specified deployment group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDeployment {
    _private: (),
}
impl CreateDeployment {
    /// Creates a new builder-style object to manufacture [`CreateDeploymentInput`](crate::input::CreateDeploymentInput)
    pub fn builder() -> crate::input::create_deployment_input::Builder {
        crate::input::create_deployment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDeployment {
    type Output = std::result::Result<
        crate::output::CreateDeploymentOutput,
        crate::error::CreateDeploymentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_deployment_error(response)
        } else {
            crate::operation_deser::parse_create_deployment_response(response)
        }
    }
}

/// <p> Creates a deployment configuration. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDeploymentConfig {
    _private: (),
}
impl CreateDeploymentConfig {
    /// Creates a new builder-style object to manufacture [`CreateDeploymentConfigInput`](crate::input::CreateDeploymentConfigInput)
    pub fn builder() -> crate::input::create_deployment_config_input::Builder {
        crate::input::create_deployment_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDeploymentConfig {
    type Output = std::result::Result<
        crate::output::CreateDeploymentConfigOutput,
        crate::error::CreateDeploymentConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_deployment_config_error(response)
        } else {
            crate::operation_deser::parse_create_deployment_config_response(response)
        }
    }
}

/// <p>Creates a deployment group to which application revisions are deployed.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateDeploymentGroup {
    _private: (),
}
impl CreateDeploymentGroup {
    /// Creates a new builder-style object to manufacture [`CreateDeploymentGroupInput`](crate::input::CreateDeploymentGroupInput)
    pub fn builder() -> crate::input::create_deployment_group_input::Builder {
        crate::input::create_deployment_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateDeploymentGroup {
    type Output = std::result::Result<
        crate::output::CreateDeploymentGroupOutput,
        crate::error::CreateDeploymentGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_deployment_group_error(response)
        } else {
            crate::operation_deser::parse_create_deployment_group_response(response)
        }
    }
}

/// <p>Deletes an application.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteApplication {
    _private: (),
}
impl DeleteApplication {
    /// Creates a new builder-style object to manufacture [`DeleteApplicationInput`](crate::input::DeleteApplicationInput)
    pub fn builder() -> crate::input::delete_application_input::Builder {
        crate::input::delete_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteApplication {
    type Output = std::result::Result<
        crate::output::DeleteApplicationOutput,
        crate::error::DeleteApplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_application_error(response)
        } else {
            crate::operation_deser::parse_delete_application_response(response)
        }
    }
}

/// <p>Deletes a deployment configuration.</p>
/// <note>
/// <p>A deployment configuration cannot be deleted if it is currently in use. Predefined
/// configurations cannot be deleted.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDeploymentConfig {
    _private: (),
}
impl DeleteDeploymentConfig {
    /// Creates a new builder-style object to manufacture [`DeleteDeploymentConfigInput`](crate::input::DeleteDeploymentConfigInput)
    pub fn builder() -> crate::input::delete_deployment_config_input::Builder {
        crate::input::delete_deployment_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDeploymentConfig {
    type Output = std::result::Result<
        crate::output::DeleteDeploymentConfigOutput,
        crate::error::DeleteDeploymentConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_deployment_config_error(response)
        } else {
            crate::operation_deser::parse_delete_deployment_config_response(response)
        }
    }
}

/// <p>Deletes a deployment group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteDeploymentGroup {
    _private: (),
}
impl DeleteDeploymentGroup {
    /// Creates a new builder-style object to manufacture [`DeleteDeploymentGroupInput`](crate::input::DeleteDeploymentGroupInput)
    pub fn builder() -> crate::input::delete_deployment_group_input::Builder {
        crate::input::delete_deployment_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteDeploymentGroup {
    type Output = std::result::Result<
        crate::output::DeleteDeploymentGroupOutput,
        crate::error::DeleteDeploymentGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_deployment_group_error(response)
        } else {
            crate::operation_deser::parse_delete_deployment_group_response(response)
        }
    }
}

/// <p>Deletes a GitHub account connection.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteGitHubAccountToken {
    _private: (),
}
impl DeleteGitHubAccountToken {
    /// Creates a new builder-style object to manufacture [`DeleteGitHubAccountTokenInput`](crate::input::DeleteGitHubAccountTokenInput)
    pub fn builder() -> crate::input::delete_git_hub_account_token_input::Builder {
        crate::input::delete_git_hub_account_token_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteGitHubAccountToken {
    type Output = std::result::Result<
        crate::output::DeleteGitHubAccountTokenOutput,
        crate::error::DeleteGitHubAccountTokenError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_git_hub_account_token_error(response)
        } else {
            crate::operation_deser::parse_delete_git_hub_account_token_response(response)
        }
    }
}

/// <p>Deletes resources linked to an external ID.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResourcesByExternalId {
    _private: (),
}
impl DeleteResourcesByExternalId {
    /// Creates a new builder-style object to manufacture [`DeleteResourcesByExternalIdInput`](crate::input::DeleteResourcesByExternalIdInput)
    pub fn builder() -> crate::input::delete_resources_by_external_id_input::Builder {
        crate::input::delete_resources_by_external_id_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResourcesByExternalId {
    type Output = std::result::Result<
        crate::output::DeleteResourcesByExternalIdOutput,
        crate::error::DeleteResourcesByExternalIdError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_resources_by_external_id_error(response)
        } else {
            crate::operation_deser::parse_delete_resources_by_external_id_response(response)
        }
    }
}

/// <p>Deregisters an on-premises instance.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeregisterOnPremisesInstance {
    _private: (),
}
impl DeregisterOnPremisesInstance {
    /// Creates a new builder-style object to manufacture [`DeregisterOnPremisesInstanceInput`](crate::input::DeregisterOnPremisesInstanceInput)
    pub fn builder() -> crate::input::deregister_on_premises_instance_input::Builder {
        crate::input::deregister_on_premises_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeregisterOnPremisesInstance {
    type Output = std::result::Result<
        crate::output::DeregisterOnPremisesInstanceOutput,
        crate::error::DeregisterOnPremisesInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deregister_on_premises_instance_error(response)
        } else {
            crate::operation_deser::parse_deregister_on_premises_instance_response(response)
        }
    }
}

/// <p>Gets information about an application.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetApplication {
    _private: (),
}
impl GetApplication {
    /// Creates a new builder-style object to manufacture [`GetApplicationInput`](crate::input::GetApplicationInput)
    pub fn builder() -> crate::input::get_application_input::Builder {
        crate::input::get_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetApplication {
    type Output =
        std::result::Result<crate::output::GetApplicationOutput, crate::error::GetApplicationError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_application_error(response)
        } else {
            crate::operation_deser::parse_get_application_response(response)
        }
    }
}

/// <p>Gets information about an application revision.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetApplicationRevision {
    _private: (),
}
impl GetApplicationRevision {
    /// Creates a new builder-style object to manufacture [`GetApplicationRevisionInput`](crate::input::GetApplicationRevisionInput)
    pub fn builder() -> crate::input::get_application_revision_input::Builder {
        crate::input::get_application_revision_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetApplicationRevision {
    type Output = std::result::Result<
        crate::output::GetApplicationRevisionOutput,
        crate::error::GetApplicationRevisionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_application_revision_error(response)
        } else {
            crate::operation_deser::parse_get_application_revision_response(response)
        }
    }
}

/// <p>Gets information about a deployment.</p>
/// <note>
/// <p> The <code>content</code> property of the <code>appSpecContent</code> object in
/// the returned revision is always null. Use <code>GetApplicationRevision</code> and
/// the <code>sha256</code> property of the returned <code>appSpecContent</code> object
/// to get the content of the deploymentâ€™s AppSpec file. </p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDeployment {
    _private: (),
}
impl GetDeployment {
    /// Creates a new builder-style object to manufacture [`GetDeploymentInput`](crate::input::GetDeploymentInput)
    pub fn builder() -> crate::input::get_deployment_input::Builder {
        crate::input::get_deployment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDeployment {
    type Output =
        std::result::Result<crate::output::GetDeploymentOutput, crate::error::GetDeploymentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_deployment_error(response)
        } else {
            crate::operation_deser::parse_get_deployment_response(response)
        }
    }
}

/// <p>Gets information about a deployment configuration.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDeploymentConfig {
    _private: (),
}
impl GetDeploymentConfig {
    /// Creates a new builder-style object to manufacture [`GetDeploymentConfigInput`](crate::input::GetDeploymentConfigInput)
    pub fn builder() -> crate::input::get_deployment_config_input::Builder {
        crate::input::get_deployment_config_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDeploymentConfig {
    type Output = std::result::Result<
        crate::output::GetDeploymentConfigOutput,
        crate::error::GetDeploymentConfigError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_deployment_config_error(response)
        } else {
            crate::operation_deser::parse_get_deployment_config_response(response)
        }
    }
}

/// <p>Gets information about a deployment group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDeploymentGroup {
    _private: (),
}
impl GetDeploymentGroup {
    /// Creates a new builder-style object to manufacture [`GetDeploymentGroupInput`](crate::input::GetDeploymentGroupInput)
    pub fn builder() -> crate::input::get_deployment_group_input::Builder {
        crate::input::get_deployment_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDeploymentGroup {
    type Output = std::result::Result<
        crate::output::GetDeploymentGroupOutput,
        crate::error::GetDeploymentGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_deployment_group_error(response)
        } else {
            crate::operation_deser::parse_get_deployment_group_response(response)
        }
    }
}

/// <p>Gets information about an instance as part of a deployment.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDeploymentInstance {
    _private: (),
}
impl GetDeploymentInstance {
    /// Creates a new builder-style object to manufacture [`GetDeploymentInstanceInput`](crate::input::GetDeploymentInstanceInput)
    pub fn builder() -> crate::input::get_deployment_instance_input::Builder {
        crate::input::get_deployment_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDeploymentInstance {
    type Output = std::result::Result<
        crate::output::GetDeploymentInstanceOutput,
        crate::error::GetDeploymentInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_deployment_instance_error(response)
        } else {
            crate::operation_deser::parse_get_deployment_instance_response(response)
        }
    }
}

/// <p> Returns information about a deployment target. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDeploymentTarget {
    _private: (),
}
impl GetDeploymentTarget {
    /// Creates a new builder-style object to manufacture [`GetDeploymentTargetInput`](crate::input::GetDeploymentTargetInput)
    pub fn builder() -> crate::input::get_deployment_target_input::Builder {
        crate::input::get_deployment_target_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDeploymentTarget {
    type Output = std::result::Result<
        crate::output::GetDeploymentTargetOutput,
        crate::error::GetDeploymentTargetError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_deployment_target_error(response)
        } else {
            crate::operation_deser::parse_get_deployment_target_response(response)
        }
    }
}

/// <p> Gets information about an on-premises instance. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetOnPremisesInstance {
    _private: (),
}
impl GetOnPremisesInstance {
    /// Creates a new builder-style object to manufacture [`GetOnPremisesInstanceInput`](crate::input::GetOnPremisesInstanceInput)
    pub fn builder() -> crate::input::get_on_premises_instance_input::Builder {
        crate::input::get_on_premises_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetOnPremisesInstance {
    type Output = std::result::Result<
        crate::output::GetOnPremisesInstanceOutput,
        crate::error::GetOnPremisesInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_on_premises_instance_error(response)
        } else {
            crate::operation_deser::parse_get_on_premises_instance_response(response)
        }
    }
}

/// <p>Lists information about revisions for an application.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListApplicationRevisions {
    _private: (),
}
impl ListApplicationRevisions {
    /// Creates a new builder-style object to manufacture [`ListApplicationRevisionsInput`](crate::input::ListApplicationRevisionsInput)
    pub fn builder() -> crate::input::list_application_revisions_input::Builder {
        crate::input::list_application_revisions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListApplicationRevisions {
    type Output = std::result::Result<
        crate::output::ListApplicationRevisionsOutput,
        crate::error::ListApplicationRevisionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_application_revisions_error(response)
        } else {
            crate::operation_deser::parse_list_application_revisions_response(response)
        }
    }
}

/// <p>Lists the applications registered with the IAM user or AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListApplications {
    _private: (),
}
impl ListApplications {
    /// Creates a new builder-style object to manufacture [`ListApplicationsInput`](crate::input::ListApplicationsInput)
    pub fn builder() -> crate::input::list_applications_input::Builder {
        crate::input::list_applications_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListApplications {
    type Output = std::result::Result<
        crate::output::ListApplicationsOutput,
        crate::error::ListApplicationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_applications_error(response)
        } else {
            crate::operation_deser::parse_list_applications_response(response)
        }
    }
}

/// <p>Lists the deployment configurations with the IAM user or AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDeploymentConfigs {
    _private: (),
}
impl ListDeploymentConfigs {
    /// Creates a new builder-style object to manufacture [`ListDeploymentConfigsInput`](crate::input::ListDeploymentConfigsInput)
    pub fn builder() -> crate::input::list_deployment_configs_input::Builder {
        crate::input::list_deployment_configs_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDeploymentConfigs {
    type Output = std::result::Result<
        crate::output::ListDeploymentConfigsOutput,
        crate::error::ListDeploymentConfigsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_deployment_configs_error(response)
        } else {
            crate::operation_deser::parse_list_deployment_configs_response(response)
        }
    }
}

/// <p>Lists the deployment groups for an application registered with the IAM user or AWS
/// account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDeploymentGroups {
    _private: (),
}
impl ListDeploymentGroups {
    /// Creates a new builder-style object to manufacture [`ListDeploymentGroupsInput`](crate::input::ListDeploymentGroupsInput)
    pub fn builder() -> crate::input::list_deployment_groups_input::Builder {
        crate::input::list_deployment_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDeploymentGroups {
    type Output = std::result::Result<
        crate::output::ListDeploymentGroupsOutput,
        crate::error::ListDeploymentGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_deployment_groups_error(response)
        } else {
            crate::operation_deser::parse_list_deployment_groups_response(response)
        }
    }
}

/// <note>
/// <p> The newer <code>BatchGetDeploymentTargets</code> should be used instead because
/// it works with all compute types. <code>ListDeploymentInstances</code> throws an
/// exception if it is used with a compute platform other than EC2/On-premises or AWS
/// Lambda. </p>
/// </note>
/// <p> Lists the instance for a deployment associated with the IAM user or AWS account. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDeploymentInstances {
    _private: (),
}
impl ListDeploymentInstances {
    /// Creates a new builder-style object to manufacture [`ListDeploymentInstancesInput`](crate::input::ListDeploymentInstancesInput)
    pub fn builder() -> crate::input::list_deployment_instances_input::Builder {
        crate::input::list_deployment_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDeploymentInstances {
    type Output = std::result::Result<
        crate::output::ListDeploymentInstancesOutput,
        crate::error::ListDeploymentInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_deployment_instances_error(response)
        } else {
            crate::operation_deser::parse_list_deployment_instances_response(response)
        }
    }
}

/// <p>Lists the deployments in a deployment group for an application registered with the IAM
/// user or AWS account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDeployments {
    _private: (),
}
impl ListDeployments {
    /// Creates a new builder-style object to manufacture [`ListDeploymentsInput`](crate::input::ListDeploymentsInput)
    pub fn builder() -> crate::input::list_deployments_input::Builder {
        crate::input::list_deployments_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDeployments {
    type Output = std::result::Result<
        crate::output::ListDeploymentsOutput,
        crate::error::ListDeploymentsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_deployments_error(response)
        } else {
            crate::operation_deser::parse_list_deployments_response(response)
        }
    }
}

/// <p> Returns an array of target IDs that are associated a deployment. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListDeploymentTargets {
    _private: (),
}
impl ListDeploymentTargets {
    /// Creates a new builder-style object to manufacture [`ListDeploymentTargetsInput`](crate::input::ListDeploymentTargetsInput)
    pub fn builder() -> crate::input::list_deployment_targets_input::Builder {
        crate::input::list_deployment_targets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListDeploymentTargets {
    type Output = std::result::Result<
        crate::output::ListDeploymentTargetsOutput,
        crate::error::ListDeploymentTargetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_deployment_targets_error(response)
        } else {
            crate::operation_deser::parse_list_deployment_targets_response(response)
        }
    }
}

/// <p>Lists the names of stored connections to GitHub accounts.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListGitHubAccountTokenNames {
    _private: (),
}
impl ListGitHubAccountTokenNames {
    /// Creates a new builder-style object to manufacture [`ListGitHubAccountTokenNamesInput`](crate::input::ListGitHubAccountTokenNamesInput)
    pub fn builder() -> crate::input::list_git_hub_account_token_names_input::Builder {
        crate::input::list_git_hub_account_token_names_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListGitHubAccountTokenNames {
    type Output = std::result::Result<
        crate::output::ListGitHubAccountTokenNamesOutput,
        crate::error::ListGitHubAccountTokenNamesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_git_hub_account_token_names_error(response)
        } else {
            crate::operation_deser::parse_list_git_hub_account_token_names_response(response)
        }
    }
}

/// <p>Gets a list of names for one or more on-premises instances.</p>
/// <p>Unless otherwise specified, both registered and deregistered on-premises instance
/// names are listed. To list only registered or deregistered on-premises instance names,
/// use the registration status parameter.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListOnPremisesInstances {
    _private: (),
}
impl ListOnPremisesInstances {
    /// Creates a new builder-style object to manufacture [`ListOnPremisesInstancesInput`](crate::input::ListOnPremisesInstancesInput)
    pub fn builder() -> crate::input::list_on_premises_instances_input::Builder {
        crate::input::list_on_premises_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListOnPremisesInstances {
    type Output = std::result::Result<
        crate::output::ListOnPremisesInstancesOutput,
        crate::error::ListOnPremisesInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_on_premises_instances_error(response)
        } else {
            crate::operation_deser::parse_list_on_premises_instances_response(response)
        }
    }
}

/// <p> Returns a list of tags for the resource identified by a specified Amazon Resource
/// Name (ARN). Tags are used to organize and categorize your CodeDeploy resources. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p> Sets the result of a Lambda validation function. The function validates lifecycle
/// hooks during a deployment that uses the AWS Lambda or Amazon ECS compute platform. For
/// AWS Lambda deployments, the available lifecycle hooks are
/// <code>BeforeAllowTraffic</code> and <code>AfterAllowTraffic</code>. For Amazon ECS
/// deployments, the available lifecycle hooks are <code>BeforeInstall</code>,
/// <code>AfterInstall</code>, <code>AfterAllowTestTraffic</code>,
/// <code>BeforeAllowTraffic</code>, and <code>AfterAllowTraffic</code>. Lambda
/// validation functions return <code>Succeeded</code> or <code>Failed</code>. For more
/// information, see <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html#appspec-hooks-lambda">AppSpec 'hooks' Section for an AWS Lambda Deployment </a> and <a href="https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html#appspec-hooks-ecs">AppSpec 'hooks' Section for an Amazon ECS Deployment</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutLifecycleEventHookExecutionStatus {
    _private: (),
}
impl PutLifecycleEventHookExecutionStatus {
    /// Creates a new builder-style object to manufacture [`PutLifecycleEventHookExecutionStatusInput`](crate::input::PutLifecycleEventHookExecutionStatusInput)
    pub fn builder() -> crate::input::put_lifecycle_event_hook_execution_status_input::Builder {
        crate::input::put_lifecycle_event_hook_execution_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutLifecycleEventHookExecutionStatus {
    type Output = std::result::Result<
        crate::output::PutLifecycleEventHookExecutionStatusOutput,
        crate::error::PutLifecycleEventHookExecutionStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_lifecycle_event_hook_execution_status_error(response)
        } else {
            crate::operation_deser::parse_put_lifecycle_event_hook_execution_status_response(
                response,
            )
        }
    }
}

/// <p>Registers with AWS CodeDeploy a revision for the specified application.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterApplicationRevision {
    _private: (),
}
impl RegisterApplicationRevision {
    /// Creates a new builder-style object to manufacture [`RegisterApplicationRevisionInput`](crate::input::RegisterApplicationRevisionInput)
    pub fn builder() -> crate::input::register_application_revision_input::Builder {
        crate::input::register_application_revision_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterApplicationRevision {
    type Output = std::result::Result<
        crate::output::RegisterApplicationRevisionOutput,
        crate::error::RegisterApplicationRevisionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_application_revision_error(response)
        } else {
            crate::operation_deser::parse_register_application_revision_response(response)
        }
    }
}

/// <p>Registers an on-premises instance.</p>
/// <note>
/// <p>Only one IAM ARN (an IAM session ARN or IAM user ARN) is supported in the request.
/// You cannot use both.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterOnPremisesInstance {
    _private: (),
}
impl RegisterOnPremisesInstance {
    /// Creates a new builder-style object to manufacture [`RegisterOnPremisesInstanceInput`](crate::input::RegisterOnPremisesInstanceInput)
    pub fn builder() -> crate::input::register_on_premises_instance_input::Builder {
        crate::input::register_on_premises_instance_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterOnPremisesInstance {
    type Output = std::result::Result<
        crate::output::RegisterOnPremisesInstanceOutput,
        crate::error::RegisterOnPremisesInstanceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_on_premises_instance_error(response)
        } else {
            crate::operation_deser::parse_register_on_premises_instance_response(response)
        }
    }
}

/// <p>Removes one or more tags from one or more on-premises instances.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveTagsFromOnPremisesInstances {
    _private: (),
}
impl RemoveTagsFromOnPremisesInstances {
    /// Creates a new builder-style object to manufacture [`RemoveTagsFromOnPremisesInstancesInput`](crate::input::RemoveTagsFromOnPremisesInstancesInput)
    pub fn builder() -> crate::input::remove_tags_from_on_premises_instances_input::Builder {
        crate::input::remove_tags_from_on_premises_instances_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveTagsFromOnPremisesInstances {
    type Output = std::result::Result<
        crate::output::RemoveTagsFromOnPremisesInstancesOutput,
        crate::error::RemoveTagsFromOnPremisesInstancesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_tags_from_on_premises_instances_error(response)
        } else {
            crate::operation_deser::parse_remove_tags_from_on_premises_instances_response(response)
        }
    }
}

/// <p>In a blue/green deployment, overrides any specified wait time and starts terminating
/// instances immediately after the traffic routing is complete.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct SkipWaitTimeForInstanceTermination {
    _private: (),
}
impl SkipWaitTimeForInstanceTermination {
    /// Creates a new builder-style object to manufacture [`SkipWaitTimeForInstanceTerminationInput`](crate::input::SkipWaitTimeForInstanceTerminationInput)
    pub fn builder() -> crate::input::skip_wait_time_for_instance_termination_input::Builder {
        crate::input::skip_wait_time_for_instance_termination_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for SkipWaitTimeForInstanceTermination {
    type Output = std::result::Result<
        crate::output::SkipWaitTimeForInstanceTerminationOutput,
        crate::error::SkipWaitTimeForInstanceTerminationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_skip_wait_time_for_instance_termination_error(response)
        } else {
            crate::operation_deser::parse_skip_wait_time_for_instance_termination_response(response)
        }
    }
}

/// <p>Attempts to stop an ongoing deployment.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopDeployment {
    _private: (),
}
impl StopDeployment {
    /// Creates a new builder-style object to manufacture [`StopDeploymentInput`](crate::input::StopDeploymentInput)
    pub fn builder() -> crate::input::stop_deployment_input::Builder {
        crate::input::stop_deployment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopDeployment {
    type Output =
        std::result::Result<crate::output::StopDeploymentOutput, crate::error::StopDeploymentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_deployment_error(response)
        } else {
            crate::operation_deser::parse_stop_deployment_response(response)
        }
    }
}

/// <p> Associates the list of tags in the input <code>Tags</code> parameter with the
/// resource identified by the <code>ResourceArn</code> input parameter. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p> Disassociates a resource from a list of tags. The resource is identified by the
/// <code>ResourceArn</code> input parameter. The tags are identified by the list of
/// keys in the <code>TagKeys</code> input parameter. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Changes the name of an application.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateApplication {
    _private: (),
}
impl UpdateApplication {
    /// Creates a new builder-style object to manufacture [`UpdateApplicationInput`](crate::input::UpdateApplicationInput)
    pub fn builder() -> crate::input::update_application_input::Builder {
        crate::input::update_application_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateApplication {
    type Output = std::result::Result<
        crate::output::UpdateApplicationOutput,
        crate::error::UpdateApplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_application_error(response)
        } else {
            crate::operation_deser::parse_update_application_response(response)
        }
    }
}

/// <p>Changes information about a deployment group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDeploymentGroup {
    _private: (),
}
impl UpdateDeploymentGroup {
    /// Creates a new builder-style object to manufacture [`UpdateDeploymentGroupInput`](crate::input::UpdateDeploymentGroupInput)
    pub fn builder() -> crate::input::update_deployment_group_input::Builder {
        crate::input::update_deployment_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDeploymentGroup {
    type Output = std::result::Result<
        crate::output::UpdateDeploymentGroupOutput,
        crate::error::UpdateDeploymentGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_deployment_group_error(response)
        } else {
            crate::operation_deser::parse_update_deployment_group_response(response)
        }
    }
}
