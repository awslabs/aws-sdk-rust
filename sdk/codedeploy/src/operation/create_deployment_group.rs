// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `CreateDeploymentGroup`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct CreateDeploymentGroup;
impl CreateDeploymentGroup {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::create_deployment_group::CreateDeploymentGroupInput,
    ) -> ::std::result::Result<
        crate::operation::create_deployment_group::CreateDeploymentGroupOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_deployment_group::CreateDeploymentGroupError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let map_err = |err: ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >| {
            err.map_service_error(|err| {
                err.downcast::<crate::operation::create_deployment_group::CreateDeploymentGroupError>()
                    .expect("correct error type")
            })
        };
        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
            .await
            .map_err(map_err)?;
        let output = context.finalize().map_err(map_err)?;
        ::std::result::Result::Ok(
            output
                .downcast::<crate::operation::create_deployment_group::CreateDeploymentGroupOutput>()
                .expect("correct output type"),
        )
    }

    pub(crate) async fn orchestrate_with_stop_point(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::create_deployment_group::CreateDeploymentGroupInput,
        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
    ) -> ::std::result::Result<
        ::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext,
        ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point("codedeploy", "CreateDeploymentGroup", input, runtime_plugins, stop_point)
            .await
    }

    pub(crate) fn operation_runtime_plugins(
        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        client_config: &crate::config::Config,
        config_override: ::std::option::Option<crate::config::Builder>,
    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());
        runtime_plugins = runtime_plugins.with_client_plugin(crate::auth_plugin::DefaultAuthOptionsPlugin::new(vec![
            ::aws_runtime::auth::sigv4::SCHEME_ID,
        ]));
        if let ::std::option::Option::Some(config_override) = config_override {
            for plugin in config_override.runtime_plugins.iter().cloned() {
                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
            }
            runtime_plugins = runtime_plugins.with_operation_plugin(crate::config::ConfigOverrideRuntimePlugin::new(
                config_override,
                client_config.config.clone(),
                &client_config.runtime_components,
            ));
        }
        runtime_plugins
    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for CreateDeploymentGroup {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        let mut cfg = ::aws_smithy_types::config_bag::Layer::new("CreateDeploymentGroup");

        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(
            CreateDeploymentGroupRequestSerializer,
        ));
        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(
            CreateDeploymentGroupResponseDeserializer,
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(
            ::aws_smithy_runtime_api::client::auth::static_resolver::StaticAuthSchemeOptionResolverParams::new(),
        ));

        cfg.store_put(::aws_smithy_http::operation::Metadata::new("CreateDeploymentGroup", "codedeploy"));
        let mut signing_options = ::aws_runtime::auth::SigningOptions::default();
        signing_options.double_uri_encode = true;
        signing_options.content_sha256_header = false;
        signing_options.normalize_uri_path = true;
        signing_options.payload_override = None;

        cfg.store_put(::aws_runtime::auth::SigV4OperationSigningConfig {
            signing_options,
            ..::std::default::Default::default()
        });

        ::std::option::Option::Some(cfg.freeze())
    }

    fn runtime_components(
        &self,
        _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        ::std::borrow::Cow::Owned(
            ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("CreateDeploymentGroup")
                .with_interceptor(CreateDeploymentGroupEndpointParamsInterceptor)
                .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<
                    crate::operation::create_deployment_group::CreateDeploymentGroupError,
                >::new())
                .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<
                    crate::operation::create_deployment_group::CreateDeploymentGroupError,
                >::new())
                .with_retry_classifier(::aws_runtime::retries::classifiers::AwsErrorCodeClassifier::<
                    crate::operation::create_deployment_group::CreateDeploymentGroupError,
                >::new()),
        )
    }
}

#[derive(Debug)]
struct CreateDeploymentGroupResponseDeserializer;
impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for CreateDeploymentGroupResponseDeserializer {
    fn deserialize_nonstreaming(
        &self,
        response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
    ) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
        let (success, status) = (response.status().is_success(), response.status().as_u16());
        let headers = response.headers();
        let body = response.body().bytes().expect("body loaded");
        #[allow(unused_mut)]
        let mut force_error = false;
        ::tracing::debug!(request_id = ?::aws_http::request_id::RequestId::request_id(response));
        let parse_result = if !success && status != 200 || force_error {
            crate::protocol_serde::shape_create_deployment_group::de_create_deployment_group_http_error(status, headers, body)
        } else {
            crate::protocol_serde::shape_create_deployment_group::de_create_deployment_group_http_response(status, headers, body)
        };
        crate::protocol_serde::type_erase_result(parse_result)
    }
}
#[derive(Debug)]
struct CreateDeploymentGroupRequestSerializer;
impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for CreateDeploymentGroupRequestSerializer {
    #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
    fn serialize_input(
        &self,
        input: ::aws_smithy_runtime_api::client::interceptors::context::Input,
        _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
        let input = input
            .downcast::<crate::operation::create_deployment_group::CreateDeploymentGroupInput>()
            .expect("correct type");
        let _header_serialization_settings = _cfg
            .load::<crate::serialization_settings::HeaderSerializationSettings>()
            .cloned()
            .unwrap_or_default();
        let mut request_builder = {
            fn uri_base(
                _input: &crate::operation::create_deployment_group::CreateDeploymentGroupInput,
                output: &mut ::std::string::String,
            ) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
                use ::std::fmt::Write as _;
                ::std::write!(output, "/").expect("formatting should succeed");
                ::std::result::Result::Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::create_deployment_group::CreateDeploymentGroupInput,
                builder: ::http::request::Builder,
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
                let mut uri = ::std::string::String::new();
                uri_base(input, &mut uri)?;
                ::std::result::Result::Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
            builder = _header_serialization_settings.set_default_header(builder, ::http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = _header_serialization_settings.set_default_header(
                builder,
                ::http::header::HeaderName::from_static("x-amz-target"),
                "CodeDeploy_20141006.CreateDeploymentGroup",
            );
            builder
        };
        let body = ::aws_smithy_types::body::SdkBody::from(crate::protocol_serde::shape_create_deployment_group::ser_create_deployment_group_input(
            &input,
        )?);
        if let Some(content_length) = body.content_length() {
            let content_length = content_length.to_string();
            request_builder = _header_serialization_settings.set_default_header(request_builder, ::http::header::CONTENT_LENGTH, &content_length);
        }
        ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
    }
}
#[derive(Debug)]
struct CreateDeploymentGroupEndpointParamsInterceptor;

impl ::aws_smithy_runtime_api::client::interceptors::Intercept for CreateDeploymentGroupEndpointParamsInterceptor {
    fn name(&self) -> &'static str {
        "CreateDeploymentGroupEndpointParamsInterceptor"
    }

    fn read_before_execution(
        &self,
        context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<
            '_,
            ::aws_smithy_runtime_api::client::interceptors::context::Input,
            ::aws_smithy_runtime_api::client::interceptors::context::Output,
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
        >,
        cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
        let _input = context
            .input()
            .downcast_ref::<CreateDeploymentGroupInput>()
            .ok_or("failed to downcast to CreateDeploymentGroupInput")?;

        let params = crate::config::endpoint::Params::builder()
            .set_region(cfg.load::<::aws_types::region::Region>().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(cfg.load::<::aws_types::endpoint_config::UseDualStack>().map(|ty| ty.0))
            .set_use_fips(cfg.load::<::aws_types::endpoint_config::UseFips>().map(|ty| ty.0))
            .set_endpoint(cfg.load::<::aws_types::endpoint_config::EndpointUrl>().map(|ty| ty.0.clone()))
            .build()
            .map_err(|err| {
                ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err)
            })?;
        cfg.interceptor_state()
            .store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
        ::std::result::Result::Ok(())
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDeploymentGroupErrorKind = CreateDeploymentGroupError;
/// Error type for the `CreateDeploymentGroupError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateDeploymentGroupError {
    /// <p>The maximum number of alarms for a deployment group (10) was exceeded.</p>
    AlarmsLimitExceededException(crate::types::error::AlarmsLimitExceededException),
    /// <p>The application does not exist with the user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::types::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::types::error::ApplicationNameRequiredException),
    /// <p>The deployment configuration does not exist with the user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::types::error::DeploymentConfigDoesNotExistException),
    /// <p>A deployment group with the specified name with the user or Amazon Web Services account already exists.</p>
    DeploymentGroupAlreadyExistsException(crate::types::error::DeploymentGroupAlreadyExistsException),
    /// <p> The deployment groups limit was exceeded.</p>
    DeploymentGroupLimitExceededException(crate::types::error::DeploymentGroupLimitExceededException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::types::error::DeploymentGroupNameRequiredException),
    /// <p> The Amazon ECS service is associated with more than one deployment groups. An Amazon ECS service can be associated with only one deployment group. </p>
    EcsServiceMappingLimitExceededException(crate::types::error::EcsServiceMappingLimitExceededException),
    /// <p>The format of the alarm configuration is invalid. Possible causes include:</p>
    /// <ul>
    /// <li> <p>The alarm list is null.</p> </li>
    /// <li> <p>The alarm object is null.</p> </li>
    /// <li> <p>The alarm name is empty or null or exceeds the limit of 255 characters.</p> </li>
    /// <li> <p>Two alarms with the same name have been specified.</p> </li>
    /// <li> <p>The alarm configuration is enabled, but the alarm list is empty.</p> </li>
    /// </ul>
    InvalidAlarmConfigException(crate::types::error::InvalidAlarmConfigException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::types::error::InvalidApplicationNameException),
    /// <p>The automatic rollback configuration was specified in an invalid format. For example, automatic rollback is enabled, but an invalid triggering event type or no event types were listed.</p>
    InvalidAutoRollbackConfigException(crate::types::error::InvalidAutoRollbackConfigException),
    /// <p>The Auto Scaling group was specified in an invalid format or does not exist.</p>
    InvalidAutoScalingGroupException(crate::types::error::InvalidAutoScalingGroupException),
    /// <p>The configuration for the blue/green deployment group was provided in an invalid format. For information about deployment configuration format, see <code>CreateDeploymentConfig</code>.</p>
    InvalidBlueGreenDeploymentConfigurationException(crate::types::error::InvalidBlueGreenDeploymentConfigurationException),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::types::error::InvalidDeploymentConfigNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::types::error::InvalidDeploymentGroupNameException),
    /// <p>An invalid deployment style was specified. Valid deployment types include "IN_PLACE" and "BLUE_GREEN." Valid deployment options include "WITH_TRAFFIC_CONTROL" and "WITHOUT_TRAFFIC_CONTROL."</p>
    InvalidDeploymentStyleException(crate::types::error::InvalidDeploymentStyleException),
    /// <p>A call was submitted that specified both Ec2TagFilters and Ec2TagSet, but only one of these data types can be used in a single call.</p>
    InvalidEc2TagCombinationException(crate::types::error::InvalidEc2TagCombinationException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidEc2TagException(crate::types::error::InvalidEc2TagException),
    /// <p> The Amazon ECS service identifier is not valid. </p>
    InvalidEcsServiceException(crate::types::error::InvalidEcsServiceException),
    /// <p>The input was specified in an invalid format.</p>
    InvalidInputException(crate::types::error::InvalidInputException),
    /// <p>An invalid load balancer name, or no load balancer name, was specified.</p>
    InvalidLoadBalancerInfoException(crate::types::error::InvalidLoadBalancerInfoException),
    /// <p>A call was submitted that specified both OnPremisesTagFilters and OnPremisesTagSet, but only one of these data types can be used in a single call.</p>
    InvalidOnPremisesTagCombinationException(crate::types::error::InvalidOnPremisesTagCombinationException),
    /// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
    InvalidRoleException(crate::types::error::InvalidRoleException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidTagException(crate::types::error::InvalidTagException),
    /// <p> The specified tags are not valid. </p>
    InvalidTagsToAddException(crate::types::error::InvalidTagsToAddException),
    /// <p> A target group pair associated with this deployment is not valid. </p>
    InvalidTargetGroupPairException(crate::types::error::InvalidTargetGroupPairException),
    /// <p> The configuration that specifies how traffic is routed during a deployment is invalid.</p>
    InvalidTrafficRoutingConfigurationException(crate::types::error::InvalidTrafficRoutingConfigurationException),
    /// <p>The trigger was specified in an invalid format.</p>
    InvalidTriggerConfigException(crate::types::error::InvalidTriggerConfigException),
    /// <p>The limit for lifecycle hooks was exceeded.</p>
    LifecycleHookLimitExceededException(crate::types::error::LifecycleHookLimitExceededException),
    /// <p>The role ID was not specified.</p>
    RoleRequiredException(crate::types::error::RoleRequiredException),
    /// <p>The number of tag groups included in the tag set list exceeded the maximum allowed limit of 3.</p>
    TagSetListLimitExceededException(crate::types::error::TagSetListLimitExceededException),
    /// <p>An API function was called too frequently.</p>
    ThrottlingException(crate::types::error::ThrottlingException),
    /// <p>The maximum allowed number of triggers was exceeded.</p>
    TriggerTargetsLimitExceededException(crate::types::error::TriggerTargetsLimitExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(::aws_smithy_types::error::Unhandled),
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for CreateDeploymentGroupError {
    fn create_unhandled_error(
        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = ::aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl ::std::fmt::Display for CreateDeploymentGroupError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::AlarmsLimitExceededException(_inner) => _inner.fmt(f),
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupLimitExceededException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupNameRequiredException(_inner) => _inner.fmt(f),
            Self::EcsServiceMappingLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidAlarmConfigException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidAutoRollbackConfigException(_inner) => _inner.fmt(f),
            Self::InvalidAutoScalingGroupException(_inner) => _inner.fmt(f),
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentConfigNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentGroupNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentStyleException(_inner) => _inner.fmt(f),
            Self::InvalidEc2TagCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidEc2TagException(_inner) => _inner.fmt(f),
            Self::InvalidEcsServiceException(_inner) => _inner.fmt(f),
            Self::InvalidInputException(_inner) => _inner.fmt(f),
            Self::InvalidLoadBalancerInfoException(_inner) => _inner.fmt(f),
            Self::InvalidOnPremisesTagCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidRoleException(_inner) => _inner.fmt(f),
            Self::InvalidTagException(_inner) => _inner.fmt(f),
            Self::InvalidTagsToAddException(_inner) => _inner.fmt(f),
            Self::InvalidTargetGroupPairException(_inner) => _inner.fmt(f),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => _inner.fmt(f),
            Self::InvalidTriggerConfigException(_inner) => _inner.fmt(f),
            Self::LifecycleHookLimitExceededException(_inner) => _inner.fmt(f),
            Self::RoleRequiredException(_inner) => _inner.fmt(f),
            Self::TagSetListLimitExceededException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::TriggerTargetsLimitExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDeploymentGroupError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AlarmsLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ApplicationDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ApplicationNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DeploymentGroupAlreadyExistsException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DeploymentGroupLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EcsServiceMappingLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidAlarmConfigException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidApplicationNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidAutoRollbackConfigException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidAutoScalingGroupException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidDeploymentStyleException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidEc2TagCombinationException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidEc2TagException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidEcsServiceException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidInputException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidLoadBalancerInfoException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidOnPremisesTagCombinationException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRoleException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidTagException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidTagsToAddException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidTargetGroupPairException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidTriggerConfigException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::LifecycleHookLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RoleRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::TagSetListLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ThrottlingException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::TriggerTargetsLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::Unhandled(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
        }
    }
}
impl ::aws_http::request_id::RequestId for crate::operation::create_deployment_group::CreateDeploymentGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for CreateDeploymentGroupError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl CreateDeploymentGroupError {
    /// Creates the `CreateDeploymentGroupError::Unhandled` variant from any error type.
    pub fn unhandled(
        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
    ) -> Self {
        Self::Unhandled(::aws_smithy_types::error::Unhandled::builder().source(err).build())
    }

    /// Creates the `CreateDeploymentGroupError::Unhandled` variant from a `::aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(::aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        use ::aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AlarmsLimitExceededException(e) => e.meta(),
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::DeploymentConfigDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupAlreadyExistsException(e) => e.meta(),
            Self::DeploymentGroupLimitExceededException(e) => e.meta(),
            Self::DeploymentGroupNameRequiredException(e) => e.meta(),
            Self::EcsServiceMappingLimitExceededException(e) => e.meta(),
            Self::InvalidAlarmConfigException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidAutoRollbackConfigException(e) => e.meta(),
            Self::InvalidAutoScalingGroupException(e) => e.meta(),
            Self::InvalidBlueGreenDeploymentConfigurationException(e) => e.meta(),
            Self::InvalidDeploymentConfigNameException(e) => e.meta(),
            Self::InvalidDeploymentGroupNameException(e) => e.meta(),
            Self::InvalidDeploymentStyleException(e) => e.meta(),
            Self::InvalidEc2TagCombinationException(e) => e.meta(),
            Self::InvalidEc2TagException(e) => e.meta(),
            Self::InvalidEcsServiceException(e) => e.meta(),
            Self::InvalidInputException(e) => e.meta(),
            Self::InvalidLoadBalancerInfoException(e) => e.meta(),
            Self::InvalidOnPremisesTagCombinationException(e) => e.meta(),
            Self::InvalidRoleException(e) => e.meta(),
            Self::InvalidTagException(e) => e.meta(),
            Self::InvalidTagsToAddException(e) => e.meta(),
            Self::InvalidTargetGroupPairException(e) => e.meta(),
            Self::InvalidTrafficRoutingConfigurationException(e) => e.meta(),
            Self::InvalidTriggerConfigException(e) => e.meta(),
            Self::LifecycleHookLimitExceededException(e) => e.meta(),
            Self::RoleRequiredException(e) => e.meta(),
            Self::TagSetListLimitExceededException(e) => e.meta(),
            Self::ThrottlingException(e) => e.meta(),
            Self::TriggerTargetsLimitExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::AlarmsLimitExceededException`.
    pub fn is_alarms_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::AlarmsLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentGroupAlreadyExistsException`.
    pub fn is_deployment_group_already_exists_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentGroupLimitExceededException`.
    pub fn is_deployment_group_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentGroupNameRequiredException`.
    pub fn is_deployment_group_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::EcsServiceMappingLimitExceededException`.
    pub fn is_ecs_service_mapping_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::EcsServiceMappingLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidAlarmConfigException`.
    pub fn is_invalid_alarm_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAlarmConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidAutoRollbackConfigException`.
    pub fn is_invalid_auto_rollback_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoRollbackConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidAutoScalingGroupException`.
    pub fn is_invalid_auto_scaling_group_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoScalingGroupException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidBlueGreenDeploymentConfigurationException`.
    pub fn is_invalid_blue_green_deployment_configuration_exception(&self) -> bool {
        matches!(self, Self::InvalidBlueGreenDeploymentConfigurationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidDeploymentConfigNameException`.
    pub fn is_invalid_deployment_config_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentConfigNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidDeploymentGroupNameException`.
    pub fn is_invalid_deployment_group_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentGroupNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidDeploymentStyleException`.
    pub fn is_invalid_deployment_style_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentStyleException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidEc2TagCombinationException`.
    pub fn is_invalid_ec2_tag_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidEc2TagCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidEc2TagException`.
    pub fn is_invalid_ec2_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidEc2TagException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidEcsServiceException`.
    pub fn is_invalid_ecs_service_exception(&self) -> bool {
        matches!(self, Self::InvalidEcsServiceException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidInputException`.
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(self, Self::InvalidInputException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidLoadBalancerInfoException`.
    pub fn is_invalid_load_balancer_info_exception(&self) -> bool {
        matches!(self, Self::InvalidLoadBalancerInfoException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidOnPremisesTagCombinationException`.
    pub fn is_invalid_on_premises_tag_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidOnPremisesTagCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidRoleException`.
    pub fn is_invalid_role_exception(&self) -> bool {
        matches!(self, Self::InvalidRoleException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidTagException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTagsToAddException`.
    pub fn is_invalid_tags_to_add_exception(&self) -> bool {
        matches!(self, Self::InvalidTagsToAddException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTargetGroupPairException`.
    pub fn is_invalid_target_group_pair_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetGroupPairException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTrafficRoutingConfigurationException`.
    pub fn is_invalid_traffic_routing_configuration_exception(&self) -> bool {
        matches!(self, Self::InvalidTrafficRoutingConfigurationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTriggerConfigException`.
    pub fn is_invalid_trigger_config_exception(&self) -> bool {
        matches!(self, Self::InvalidTriggerConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::LifecycleHookLimitExceededException`.
    pub fn is_lifecycle_hook_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LifecycleHookLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::RoleRequiredException`.
    pub fn is_role_required_exception(&self) -> bool {
        matches!(self, Self::RoleRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::TagSetListLimitExceededException`.
    pub fn is_tag_set_list_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TagSetListLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::TriggerTargetsLimitExceededException`.
    pub fn is_trigger_targets_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TriggerTargetsLimitExceededException(_))
    }
}
impl ::std::error::Error for CreateDeploymentGroupError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::AlarmsLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::ApplicationDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::DeploymentGroupAlreadyExistsException(_inner) => ::std::option::Option::Some(_inner),
            Self::DeploymentGroupLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::EcsServiceMappingLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidAlarmConfigException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidApplicationNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidAutoRollbackConfigException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidAutoScalingGroupException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidDeploymentStyleException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidEc2TagCombinationException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidEc2TagException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidEcsServiceException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidInputException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidLoadBalancerInfoException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidOnPremisesTagCombinationException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRoleException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidTagException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidTagsToAddException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidTargetGroupPairException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidTriggerConfigException(_inner) => ::std::option::Option::Some(_inner),
            Self::LifecycleHookLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::RoleRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::TagSetListLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::ThrottlingException(_inner) => ::std::option::Option::Some(_inner),
            Self::TriggerTargetsLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::Unhandled(_inner) => ::std::option::Option::Some(_inner),
        }
    }
}

pub use crate::operation::create_deployment_group::_create_deployment_group_output::CreateDeploymentGroupOutput;

pub use crate::operation::create_deployment_group::_create_deployment_group_input::CreateDeploymentGroupInput;

mod _create_deployment_group_input;

mod _create_deployment_group_output;

/// Builders
pub mod builders;
