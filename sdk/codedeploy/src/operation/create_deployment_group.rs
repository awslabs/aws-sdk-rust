// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl CreateDeploymentGroupInput {
    /// Consumes the builder and constructs an Operation<[`CreateDeploymentGroup`](crate::operation::create_deployment_group::CreateDeploymentGroup)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::create_deployment_group::CreateDeploymentGroup,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::operation::create_deployment_group::CreateDeploymentGroupInput,
                output: &mut String,
            ) -> std::result::Result<(), aws_smithy_http::operation::error::BuildError>
            {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::create_deployment_group::CreateDeploymentGroupInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "CodeDeploy_20141006.CreateDeploymentGroup",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_deployment_group::ser_create_deployment_group_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::meta::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::create_deployment_group::CreateDeploymentGroup::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "CreateDeploymentGroup",
            "codedeploy",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `CreateDeploymentGroup`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct CreateDeploymentGroup;
impl CreateDeploymentGroup {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateDeploymentGroup {
    type Output = std::result::Result<
        crate::operation::create_deployment_group::CreateDeploymentGroupOutput,
        crate::operation::create_deployment_group::CreateDeploymentGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::protocol_serde::shape_create_deployment_group::de_create_deployment_group_http_error(response)
        } else {
            crate::protocol_serde::shape_create_deployment_group::de_create_deployment_group_http_response(response)
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDeploymentGroupErrorKind = CreateDeploymentGroupError;
/// Error type for the `CreateDeploymentGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDeploymentGroupError {
    /// <p>The maximum number of alarms for a deployment group (10) was exceeded.</p>
    AlarmsLimitExceededException(crate::types::error::AlarmsLimitExceededException),
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::types::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::types::error::ApplicationNameRequiredException),
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(
        crate::types::error::DeploymentConfigDoesNotExistException,
    ),
    /// <p>A deployment group with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    DeploymentGroupAlreadyExistsException(
        crate::types::error::DeploymentGroupAlreadyExistsException,
    ),
    /// <p> The deployment groups limit was exceeded.</p>
    DeploymentGroupLimitExceededException(
        crate::types::error::DeploymentGroupLimitExceededException,
    ),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::types::error::DeploymentGroupNameRequiredException),
    /// <p> The Amazon ECS service is associated with more than one deployment groups. An Amazon ECS service can be associated with only one deployment group. </p>
    EcsServiceMappingLimitExceededException(
        crate::types::error::EcsServiceMappingLimitExceededException,
    ),
    /// <p>The format of the alarm configuration is invalid. Possible causes include:</p>
    /// <ul>
    /// <li> <p>The alarm list is null.</p> </li>
    /// <li> <p>The alarm object is null.</p> </li>
    /// <li> <p>The alarm name is empty or null or exceeds the limit of 255 characters.</p> </li>
    /// <li> <p>Two alarms with the same name have been specified.</p> </li>
    /// <li> <p>The alarm configuration is enabled, but the alarm list is empty.</p> </li>
    /// </ul>
    InvalidAlarmConfigException(crate::types::error::InvalidAlarmConfigException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::types::error::InvalidApplicationNameException),
    /// <p>The automatic rollback configuration was specified in an invalid format. For example, automatic rollback is enabled, but an invalid triggering event type or no event types were listed.</p>
    InvalidAutoRollbackConfigException(crate::types::error::InvalidAutoRollbackConfigException),
    /// <p>The Auto Scaling group was specified in an invalid format or does not exist.</p>
    InvalidAutoScalingGroupException(crate::types::error::InvalidAutoScalingGroupException),
    /// <p>The configuration for the blue/green deployment group was provided in an invalid format. For information about deployment configuration format, see <code>CreateDeploymentConfig</code>.</p>
    InvalidBlueGreenDeploymentConfigurationException(
        crate::types::error::InvalidBlueGreenDeploymentConfigurationException,
    ),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::types::error::InvalidDeploymentConfigNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::types::error::InvalidDeploymentGroupNameException),
    /// <p>An invalid deployment style was specified. Valid deployment types include "IN_PLACE" and "BLUE_GREEN." Valid deployment options include "WITH_TRAFFIC_CONTROL" and "WITHOUT_TRAFFIC_CONTROL."</p>
    InvalidDeploymentStyleException(crate::types::error::InvalidDeploymentStyleException),
    /// <p>A call was submitted that specified both Ec2TagFilters and Ec2TagSet, but only one of these data types can be used in a single call.</p>
    InvalidEc2TagCombinationException(crate::types::error::InvalidEc2TagCombinationException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidEc2TagException(crate::types::error::InvalidEc2TagException),
    /// <p> The Amazon ECS service identifier is not valid. </p>
    InvalidEcsServiceException(crate::types::error::InvalidEcsServiceException),
    /// <p>The input was specified in an invalid format.</p>
    InvalidInputException(crate::types::error::InvalidInputException),
    /// <p>An invalid load balancer name, or no load balancer name, was specified.</p>
    InvalidLoadBalancerInfoException(crate::types::error::InvalidLoadBalancerInfoException),
    /// <p>A call was submitted that specified both OnPremisesTagFilters and OnPremisesTagSet, but only one of these data types can be used in a single call.</p>
    InvalidOnPremisesTagCombinationException(
        crate::types::error::InvalidOnPremisesTagCombinationException,
    ),
    /// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
    InvalidRoleException(crate::types::error::InvalidRoleException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidTagException(crate::types::error::InvalidTagException),
    /// <p> The specified tags are not valid. </p>
    InvalidTagsToAddException(crate::types::error::InvalidTagsToAddException),
    /// <p> A target group pair associated with this deployment is not valid. </p>
    InvalidTargetGroupPairException(crate::types::error::InvalidTargetGroupPairException),
    /// <p> The configuration that specifies how traffic is routed during a deployment is invalid.</p>
    InvalidTrafficRoutingConfigurationException(
        crate::types::error::InvalidTrafficRoutingConfigurationException,
    ),
    /// <p>The trigger was specified in an invalid format.</p>
    InvalidTriggerConfigException(crate::types::error::InvalidTriggerConfigException),
    /// <p>The limit for lifecycle hooks was exceeded.</p>
    LifecycleHookLimitExceededException(crate::types::error::LifecycleHookLimitExceededException),
    /// <p>The role ID was not specified.</p>
    RoleRequiredException(crate::types::error::RoleRequiredException),
    /// <p>The number of tag groups included in the tag set list exceeded the maximum allowed limit of 3.</p>
    TagSetListLimitExceededException(crate::types::error::TagSetListLimitExceededException),
    /// <p>An API function was called too frequently.</p>
    ThrottlingException(crate::types::error::ThrottlingException),
    /// <p>The maximum allowed number of triggers was exceeded.</p>
    TriggerTargetsLimitExceededException(crate::types::error::TriggerTargetsLimitExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDeploymentGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: std::option::Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDeploymentGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AlarmsLimitExceededException(_inner) => _inner.fmt(f),
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupLimitExceededException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupNameRequiredException(_inner) => _inner.fmt(f),
            Self::EcsServiceMappingLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidAlarmConfigException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidAutoRollbackConfigException(_inner) => _inner.fmt(f),
            Self::InvalidAutoScalingGroupException(_inner) => _inner.fmt(f),
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentConfigNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentGroupNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentStyleException(_inner) => _inner.fmt(f),
            Self::InvalidEc2TagCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidEc2TagException(_inner) => _inner.fmt(f),
            Self::InvalidEcsServiceException(_inner) => _inner.fmt(f),
            Self::InvalidInputException(_inner) => _inner.fmt(f),
            Self::InvalidLoadBalancerInfoException(_inner) => _inner.fmt(f),
            Self::InvalidOnPremisesTagCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidRoleException(_inner) => _inner.fmt(f),
            Self::InvalidTagException(_inner) => _inner.fmt(f),
            Self::InvalidTagsToAddException(_inner) => _inner.fmt(f),
            Self::InvalidTargetGroupPairException(_inner) => _inner.fmt(f),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => _inner.fmt(f),
            Self::InvalidTriggerConfigException(_inner) => _inner.fmt(f),
            Self::LifecycleHookLimitExceededException(_inner) => _inner.fmt(f),
            Self::RoleRequiredException(_inner) => _inner.fmt(f),
            Self::TagSetListLimitExceededException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::TriggerTargetsLimitExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDeploymentGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AlarmsLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EcsServiceMappingLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAlarmConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAutoRollbackConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAutoScalingGroupException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentConfigNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentGroupNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentStyleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEc2TagCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEc2TagException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEcsServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInputException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLoadBalancerInfoException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOnPremisesTagCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRoleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagsToAddException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetGroupPairException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTrafficRoutingConfigurationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTriggerConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LifecycleHookLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RoleRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagSetListLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ThrottlingException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TriggerTargetsLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::operation::create_deployment_group::CreateDeploymentGroupError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDeploymentGroupError {
    fn code(&self) -> std::option::Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> std::option::Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDeploymentGroupError {
    /// Creates the `CreateDeploymentGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDeploymentGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AlarmsLimitExceededException(e) => e.meta(),
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::DeploymentConfigDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupAlreadyExistsException(e) => e.meta(),
            Self::DeploymentGroupLimitExceededException(e) => e.meta(),
            Self::DeploymentGroupNameRequiredException(e) => e.meta(),
            Self::EcsServiceMappingLimitExceededException(e) => e.meta(),
            Self::InvalidAlarmConfigException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidAutoRollbackConfigException(e) => e.meta(),
            Self::InvalidAutoScalingGroupException(e) => e.meta(),
            Self::InvalidBlueGreenDeploymentConfigurationException(e) => e.meta(),
            Self::InvalidDeploymentConfigNameException(e) => e.meta(),
            Self::InvalidDeploymentGroupNameException(e) => e.meta(),
            Self::InvalidDeploymentStyleException(e) => e.meta(),
            Self::InvalidEc2TagCombinationException(e) => e.meta(),
            Self::InvalidEc2TagException(e) => e.meta(),
            Self::InvalidEcsServiceException(e) => e.meta(),
            Self::InvalidInputException(e) => e.meta(),
            Self::InvalidLoadBalancerInfoException(e) => e.meta(),
            Self::InvalidOnPremisesTagCombinationException(e) => e.meta(),
            Self::InvalidRoleException(e) => e.meta(),
            Self::InvalidTagException(e) => e.meta(),
            Self::InvalidTagsToAddException(e) => e.meta(),
            Self::InvalidTargetGroupPairException(e) => e.meta(),
            Self::InvalidTrafficRoutingConfigurationException(e) => e.meta(),
            Self::InvalidTriggerConfigException(e) => e.meta(),
            Self::LifecycleHookLimitExceededException(e) => e.meta(),
            Self::RoleRequiredException(e) => e.meta(),
            Self::TagSetListLimitExceededException(e) => e.meta(),
            Self::ThrottlingException(e) => e.meta(),
            Self::TriggerTargetsLimitExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::AlarmsLimitExceededException`.
    pub fn is_alarms_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::AlarmsLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentGroupAlreadyExistsException`.
    pub fn is_deployment_group_already_exists_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentGroupLimitExceededException`.
    pub fn is_deployment_group_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentGroupNameRequiredException`.
    pub fn is_deployment_group_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::EcsServiceMappingLimitExceededException`.
    pub fn is_ecs_service_mapping_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::EcsServiceMappingLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidAlarmConfigException`.
    pub fn is_invalid_alarm_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAlarmConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidAutoRollbackConfigException`.
    pub fn is_invalid_auto_rollback_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoRollbackConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidAutoScalingGroupException`.
    pub fn is_invalid_auto_scaling_group_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoScalingGroupException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidBlueGreenDeploymentConfigurationException`.
    pub fn is_invalid_blue_green_deployment_configuration_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidBlueGreenDeploymentConfigurationException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidDeploymentConfigNameException`.
    pub fn is_invalid_deployment_config_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentConfigNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidDeploymentGroupNameException`.
    pub fn is_invalid_deployment_group_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentGroupNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidDeploymentStyleException`.
    pub fn is_invalid_deployment_style_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentStyleException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidEc2TagCombinationException`.
    pub fn is_invalid_ec2_tag_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidEc2TagCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidEc2TagException`.
    pub fn is_invalid_ec2_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidEc2TagException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidEcsServiceException`.
    pub fn is_invalid_ecs_service_exception(&self) -> bool {
        matches!(self, Self::InvalidEcsServiceException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidInputException`.
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(self, Self::InvalidInputException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidLoadBalancerInfoException`.
    pub fn is_invalid_load_balancer_info_exception(&self) -> bool {
        matches!(self, Self::InvalidLoadBalancerInfoException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidOnPremisesTagCombinationException`.
    pub fn is_invalid_on_premises_tag_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidOnPremisesTagCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidRoleException`.
    pub fn is_invalid_role_exception(&self) -> bool {
        matches!(self, Self::InvalidRoleException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidTagException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTagsToAddException`.
    pub fn is_invalid_tags_to_add_exception(&self) -> bool {
        matches!(self, Self::InvalidTagsToAddException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTargetGroupPairException`.
    pub fn is_invalid_target_group_pair_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetGroupPairException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTrafficRoutingConfigurationException`.
    pub fn is_invalid_traffic_routing_configuration_exception(&self) -> bool {
        matches!(self, Self::InvalidTrafficRoutingConfigurationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTriggerConfigException`.
    pub fn is_invalid_trigger_config_exception(&self) -> bool {
        matches!(self, Self::InvalidTriggerConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::LifecycleHookLimitExceededException`.
    pub fn is_lifecycle_hook_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LifecycleHookLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::RoleRequiredException`.
    pub fn is_role_required_exception(&self) -> bool {
        matches!(self, Self::RoleRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::TagSetListLimitExceededException`.
    pub fn is_tag_set_list_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TagSetListLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::TriggerTargetsLimitExceededException`.
    pub fn is_trigger_targets_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TriggerTargetsLimitExceededException(_))
    }
}
impl std::error::Error for CreateDeploymentGroupError {
    fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AlarmsLimitExceededException(_inner) => Some(_inner),
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupAlreadyExistsException(_inner) => Some(_inner),
            Self::DeploymentGroupLimitExceededException(_inner) => Some(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => Some(_inner),
            Self::EcsServiceMappingLimitExceededException(_inner) => Some(_inner),
            Self::InvalidAlarmConfigException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidAutoRollbackConfigException(_inner) => Some(_inner),
            Self::InvalidAutoScalingGroupException(_inner) => Some(_inner),
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => Some(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentStyleException(_inner) => Some(_inner),
            Self::InvalidEc2TagCombinationException(_inner) => Some(_inner),
            Self::InvalidEc2TagException(_inner) => Some(_inner),
            Self::InvalidEcsServiceException(_inner) => Some(_inner),
            Self::InvalidInputException(_inner) => Some(_inner),
            Self::InvalidLoadBalancerInfoException(_inner) => Some(_inner),
            Self::InvalidOnPremisesTagCombinationException(_inner) => Some(_inner),
            Self::InvalidRoleException(_inner) => Some(_inner),
            Self::InvalidTagException(_inner) => Some(_inner),
            Self::InvalidTagsToAddException(_inner) => Some(_inner),
            Self::InvalidTargetGroupPairException(_inner) => Some(_inner),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => Some(_inner),
            Self::InvalidTriggerConfigException(_inner) => Some(_inner),
            Self::LifecycleHookLimitExceededException(_inner) => Some(_inner),
            Self::RoleRequiredException(_inner) => Some(_inner),
            Self::TagSetListLimitExceededException(_inner) => Some(_inner),
            Self::ThrottlingException(_inner) => Some(_inner),
            Self::TriggerTargetsLimitExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

pub use crate::operation::create_deployment_group::_create_deployment_group_output::CreateDeploymentGroupOutput;

pub use crate::operation::create_deployment_group::_create_deployment_group_input::CreateDeploymentGroupInput;

mod _create_deployment_group_input;

mod _create_deployment_group_output;

/// Builders
pub mod builders;
