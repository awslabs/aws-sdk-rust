// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl BatchGetDeploymentTargetsInput {
    /// Consumes the builder and constructs an Operation<[`BatchGetDeploymentTargets`](crate::operation::batch_get_deployment_targets::BatchGetDeploymentTargets)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::batch_get_deployment_targets::BatchGetDeploymentTargets,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::operation::batch_get_deployment_targets::BatchGetDeploymentTargetsInput,
                output: &mut String,
            ) -> std::result::Result<(), aws_smithy_http::operation::error::BuildError>
            {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::batch_get_deployment_targets::BatchGetDeploymentTargetsInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "CodeDeploy_20141006.BatchGetDeploymentTargets",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_batch_get_deployment_targets::ser_batch_get_deployment_targets_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::meta::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::batch_get_deployment_targets::BatchGetDeploymentTargets::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "BatchGetDeploymentTargets",
            "codedeploy",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `BatchGetDeploymentTargets`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct BatchGetDeploymentTargets;
impl BatchGetDeploymentTargets {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for BatchGetDeploymentTargets {
    type Output = std::result::Result<
        crate::operation::batch_get_deployment_targets::BatchGetDeploymentTargetsOutput,
        crate::operation::batch_get_deployment_targets::BatchGetDeploymentTargetsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::protocol_serde::shape_batch_get_deployment_targets::de_batch_get_deployment_targets_http_error(response)
        } else {
            crate::protocol_serde::shape_batch_get_deployment_targets::de_batch_get_deployment_targets_http_response(response)
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchGetDeploymentTargetsErrorKind = BatchGetDeploymentTargetsError;
/// Error type for the `BatchGetDeploymentTargetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetDeploymentTargetsError {
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::types::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::types::error::DeploymentIdRequiredException),
    /// <p>The specified deployment has not started.</p>
    DeploymentNotStartedException(crate::types::error::DeploymentNotStartedException),
    /// <p> The provided target ID does not belong to the attempted deployment. </p>
    DeploymentTargetDoesNotExistException(
        crate::types::error::DeploymentTargetDoesNotExistException,
    ),
    /// <p> A deployment target ID was not provided. </p>
    DeploymentTargetIdRequiredException(crate::types::error::DeploymentTargetIdRequiredException),
    /// <p> The maximum number of targets that can be associated with an Amazon ECS or Lambda deployment was exceeded. The target list of both types of deployments must have exactly one item. This exception does not apply to EC2/On-premises deployments. </p>
    DeploymentTargetListSizeExceededException(
        crate::types::error::DeploymentTargetListSizeExceededException,
    ),
    /// <p>The specified instance does not exist in the deployment group.</p>
    #[deprecated(
        note = "This exception is deprecated, use DeploymentTargetDoesNotExistException instead."
    )]
    InstanceDoesNotExistException(crate::types::error::InstanceDoesNotExistException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::types::error::InvalidDeploymentIdException),
    /// <p> The target ID provided was not valid. </p>
    InvalidDeploymentTargetIdException(crate::types::error::InvalidDeploymentTargetIdException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetDeploymentTargetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: std::option::Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchGetDeploymentTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentNotStartedException(_inner) => _inner.fmt(f),
            Self::DeploymentTargetDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentTargetIdRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentTargetListSizeExceededException(_inner) => _inner.fmt(f),
            Self::InstanceDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentTargetIdException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchGetDeploymentTargetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentNotStartedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentTargetDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentTargetIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentTargetListSizeExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentTargetIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::operation::batch_get_deployment_targets::BatchGetDeploymentTargetsError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetDeploymentTargetsError {
    fn code(&self) -> std::option::Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> std::option::Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetDeploymentTargetsError {
    /// Creates the `BatchGetDeploymentTargetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchGetDeploymentTargetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::DeploymentNotStartedException(e) => e.meta(),
            Self::DeploymentTargetDoesNotExistException(e) => e.meta(),
            Self::DeploymentTargetIdRequiredException(e) => e.meta(),
            Self::DeploymentTargetListSizeExceededException(e) => e.meta(),
            Self::InstanceDoesNotExistException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::InvalidDeploymentTargetIdException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentNotStartedException`.
    pub fn is_deployment_not_started_exception(&self) -> bool {
        matches!(self, Self::DeploymentNotStartedException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentTargetDoesNotExistException`.
    pub fn is_deployment_target_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentTargetDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentTargetIdRequiredException`.
    pub fn is_deployment_target_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentTargetIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentTargetListSizeExceededException`.
    pub fn is_deployment_target_list_size_exceeded_exception(&self) -> bool {
        matches!(self, Self::DeploymentTargetListSizeExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::InstanceDoesNotExistException`.
    pub fn is_instance_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::InstanceDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::InvalidDeploymentTargetIdException`.
    pub fn is_invalid_deployment_target_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentTargetIdException(_))
    }
}
impl std::error::Error for BatchGetDeploymentTargetsError {
    fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::DeploymentNotStartedException(_inner) => Some(_inner),
            Self::DeploymentTargetDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentTargetIdRequiredException(_inner) => Some(_inner),
            Self::DeploymentTargetListSizeExceededException(_inner) => Some(_inner),
            Self::InstanceDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::InvalidDeploymentTargetIdException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

pub use crate::operation::batch_get_deployment_targets::_batch_get_deployment_targets_output::BatchGetDeploymentTargetsOutput;

pub use crate::operation::batch_get_deployment_targets::_batch_get_deployment_targets_input::BatchGetDeploymentTargetsInput;

mod _batch_get_deployment_targets_input;

mod _batch_get_deployment_targets_output;

/// Builders
pub mod builders;
