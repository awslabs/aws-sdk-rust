// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `CreateDeployment`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct CreateDeployment;
impl CreateDeployment {
    /// Creates a new `CreateDeployment`
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::create_deployment::CreateDeploymentInput,
    ) -> ::std::result::Result<
        crate::operation::create_deployment::CreateDeploymentOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_deployment::CreateDeploymentError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let map_err = |err: ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >| {
            err.map_service_error(|err| {
                err.downcast::<crate::operation::create_deployment::CreateDeploymentError>()
                    .expect("correct error type")
            })
        };
        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
            .await
            .map_err(map_err)?;
        let output = context.finalize().map_err(map_err)?;
        ::std::result::Result::Ok(
            output
                .downcast::<crate::operation::create_deployment::CreateDeploymentOutput>()
                .expect("correct output type"),
        )
    }

    pub(crate) async fn orchestrate_with_stop_point(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::create_deployment::CreateDeploymentInput,
        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
    ) -> ::std::result::Result<
        ::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext,
        ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
        use ::tracing::Instrument;
        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point("CodeDeploy", "CreateDeployment", input, runtime_plugins, stop_point)
            // Create a parent span for the entire operation. Includes a random, internal-only,
            // seven-digit ID for the operation orchestration so that it can be correlated in the logs.
            .instrument(::tracing::debug_span!(
                "CodeDeploy.CreateDeployment",
                "rpc.service" = "CodeDeploy",
                "rpc.method" = "CreateDeployment",
                "sdk_invocation_id" = ::fastrand::u32(1_000_000..10_000_000),
                "rpc.system" = "aws-api",
            ))
            .await
    }

    pub(crate) fn operation_runtime_plugins(
        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        client_config: &crate::config::Config,
        config_override: ::std::option::Option<crate::config::Builder>,
    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());

        if let ::std::option::Option::Some(config_override) = config_override {
            for plugin in config_override.runtime_plugins.iter().cloned() {
                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
            }
            runtime_plugins = runtime_plugins.with_operation_plugin(crate::config::ConfigOverrideRuntimePlugin::new(
                config_override,
                client_config.config.clone(),
                &client_config.runtime_components,
            ));
        }
        runtime_plugins
    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for CreateDeployment {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        let mut cfg = ::aws_smithy_types::config_bag::Layer::new("CreateDeployment");

        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(
            CreateDeploymentRequestSerializer,
        ));
        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(
            CreateDeploymentResponseDeserializer,
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(
            crate::config::auth::Params::builder()
                .operation_name("CreateDeployment")
                .build()
                .expect("required fields set"),
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::orchestrator::Metadata::new(
            "CreateDeployment",
            "CodeDeploy",
        ));
        let mut signing_options = ::aws_runtime::auth::SigningOptions::default();
        signing_options.double_uri_encode = true;
        signing_options.content_sha256_header = false;
        signing_options.normalize_uri_path = true;
        signing_options.payload_override = None;

        cfg.store_put(::aws_runtime::auth::SigV4OperationSigningConfig {
            signing_options,
            ..::std::default::Default::default()
        });

        ::std::option::Option::Some(cfg.freeze())
    }

    fn runtime_components(
        &self,
        _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        #[allow(unused_mut)]
        let mut rcb = ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("CreateDeployment")
            .with_interceptor(::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptor::default())
            .with_interceptor(CreateDeploymentEndpointParamsInterceptor)
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<
                crate::operation::create_deployment::CreateDeploymentError,
            >::new())
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<
                crate::operation::create_deployment::CreateDeploymentError,
            >::new())
            .with_retry_classifier(::aws_runtime::retries::classifiers::AwsErrorCodeClassifier::<
                crate::operation::create_deployment::CreateDeploymentError,
            >::new());

        ::std::borrow::Cow::Owned(rcb)
    }
}

#[derive(Debug)]
struct CreateDeploymentResponseDeserializer;
impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for CreateDeploymentResponseDeserializer {
    fn deserialize_nonstreaming(
        &self,
        response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
    ) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
        let (success, status) = (response.status().is_success(), response.status().as_u16());
        let headers = response.headers();
        let body = response.body().bytes().expect("body loaded");
        #[allow(unused_mut)]
        let mut force_error = false;
        ::tracing::debug!(request_id = ?::aws_types::request_id::RequestId::request_id(response));
        let parse_result = if !success && status != 200 || force_error {
            crate::protocol_serde::shape_create_deployment::de_create_deployment_http_error(status, headers, body)
        } else {
            crate::protocol_serde::shape_create_deployment::de_create_deployment_http_response(status, headers, body)
        };
        crate::protocol_serde::type_erase_result(parse_result)
    }
}
#[derive(Debug)]
struct CreateDeploymentRequestSerializer;
impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for CreateDeploymentRequestSerializer {
    #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
    fn serialize_input(
        &self,
        input: ::aws_smithy_runtime_api::client::interceptors::context::Input,
        _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
        let input = input
            .downcast::<crate::operation::create_deployment::CreateDeploymentInput>()
            .expect("correct type");
        let _header_serialization_settings = _cfg
            .load::<crate::serialization_settings::HeaderSerializationSettings>()
            .cloned()
            .unwrap_or_default();
        let mut request_builder = {
            #[allow(clippy::uninlined_format_args)]
            fn uri_base(
                _input: &crate::operation::create_deployment::CreateDeploymentInput,
                output: &mut ::std::string::String,
            ) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
                use ::std::fmt::Write as _;
                ::std::write!(output, "/").expect("formatting should succeed");
                ::std::result::Result::Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::create_deployment::CreateDeploymentInput,
                builder: ::http::request::Builder,
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
                let mut uri = ::std::string::String::new();
                uri_base(input, &mut uri)?;
                ::std::result::Result::Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
            builder = _header_serialization_settings.set_default_header(builder, ::http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = _header_serialization_settings.set_default_header(
                builder,
                ::http::header::HeaderName::from_static("x-amz-target"),
                "CodeDeploy_20141006.CreateDeployment",
            );
            builder
        };
        let body = ::aws_smithy_types::body::SdkBody::from(crate::protocol_serde::shape_create_deployment::ser_create_deployment_input(&input)?);
        if let Some(content_length) = body.content_length() {
            let content_length = content_length.to_string();
            request_builder = _header_serialization_settings.set_default_header(request_builder, ::http::header::CONTENT_LENGTH, &content_length);
        }
        ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
    }
}
#[derive(Debug)]
struct CreateDeploymentEndpointParamsInterceptor;

impl ::aws_smithy_runtime_api::client::interceptors::Intercept for CreateDeploymentEndpointParamsInterceptor {
    fn name(&self) -> &'static str {
        "CreateDeploymentEndpointParamsInterceptor"
    }

    fn read_before_execution(
        &self,
        context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<
            '_,
            ::aws_smithy_runtime_api::client::interceptors::context::Input,
            ::aws_smithy_runtime_api::client::interceptors::context::Output,
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
        >,
        cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
        let _input = context
            .input()
            .downcast_ref::<CreateDeploymentInput>()
            .ok_or("failed to downcast to CreateDeploymentInput")?;

        let params = crate::config::endpoint::Params::builder()
            .set_region(cfg.load::<::aws_types::region::Region>().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(cfg.load::<::aws_types::endpoint_config::UseDualStack>().map(|ty| ty.0))
            .set_use_fips(cfg.load::<::aws_types::endpoint_config::UseFips>().map(|ty| ty.0))
            .set_endpoint(cfg.load::<::aws_types::endpoint_config::EndpointUrl>().map(|ty| ty.0.clone()))
            .build()
            .map_err(|err| {
                ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err)
            })?;
        cfg.interceptor_state()
            .store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
        ::std::result::Result::Ok(())
    }
}

// The get_* functions below are generated from JMESPath expressions in the
// operationContextParams trait. They target the operation's input shape.

/// Error type for the `CreateDeploymentError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateDeploymentError {
    /// <p>The maximum number of alarms for a deployment group (10) was exceeded.</p>
    AlarmsLimitExceededException(crate::types::error::AlarmsLimitExceededException),
    /// <p>The application does not exist with the user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::types::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::types::error::ApplicationNameRequiredException),
    /// <p>The deployment configuration does not exist with the user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::types::error::DeploymentConfigDoesNotExistException),
    /// <p>The named deployment group with the user or Amazon Web Services account does not exist.</p>
    DeploymentGroupDoesNotExistException(crate::types::error::DeploymentGroupDoesNotExistException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::types::error::DeploymentGroupNameRequiredException),
    /// <p>The number of allowed deployments was exceeded.</p>
    DeploymentLimitExceededException(crate::types::error::DeploymentLimitExceededException),
    /// <p>The description is too long.</p>
    DescriptionTooLongException(crate::types::error::DescriptionTooLongException),
    /// <p>The format of the alarm configuration is invalid. Possible causes include:</p>
    /// <ul>
    /// <li>
    /// <p>The alarm list is null.</p></li>
    /// <li>
    /// <p>The alarm object is null.</p></li>
    /// <li>
    /// <p>The alarm name is empty or null or exceeds the limit of 255 characters.</p></li>
    /// <li>
    /// <p>Two alarms with the same name have been specified.</p></li>
    /// <li>
    /// <p>The alarm configuration is enabled, but the alarm list is empty.</p></li>
    /// </ul>
    InvalidAlarmConfigException(crate::types::error::InvalidAlarmConfigException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::types::error::InvalidApplicationNameException),
    /// <p>The automatic rollback configuration was specified in an invalid format. For example, automatic rollback is enabled, but an invalid triggering event type or no event types were listed.</p>
    InvalidAutoRollbackConfigException(crate::types::error::InvalidAutoRollbackConfigException),
    /// <p>The Auto Scaling group was specified in an invalid format or does not exist.</p>
    InvalidAutoScalingGroupException(crate::types::error::InvalidAutoScalingGroupException),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::types::error::InvalidDeploymentConfigNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::types::error::InvalidDeploymentGroupNameException),
    /// <p>An invalid fileExistsBehavior option was specified to determine how CodeDeploy handles files or directories that already exist in a deployment target location, but weren't part of the previous successful deployment. Valid values include "DISALLOW," "OVERWRITE," and "RETAIN."</p>
    InvalidFileExistsBehaviorException(crate::types::error::InvalidFileExistsBehaviorException),
    /// <p>The GitHub token is not valid.</p>
    InvalidGitHubAccountTokenException(crate::types::error::InvalidGitHubAccountTokenException),
    /// <p>The IgnoreApplicationStopFailures value is invalid. For Lambda deployments, <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code> or <code>false</code> is expected.</p>
    InvalidIgnoreApplicationStopFailuresValueException(crate::types::error::InvalidIgnoreApplicationStopFailuresValueException),
    /// <p>An invalid load balancer name, or no load balancer name, was specified.</p>
    InvalidLoadBalancerInfoException(crate::types::error::InvalidLoadBalancerInfoException),
    /// <p>The revision was specified in an invalid format.</p>
    InvalidRevisionException(crate::types::error::InvalidRevisionException),
    /// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
    InvalidRoleException(crate::types::error::InvalidRoleException),
    /// <p>The target instance configuration is invalid. Possible causes include:</p>
    /// <ul>
    /// <li>
    /// <p>Configuration data for target instances was entered for an in-place deployment.</p></li>
    /// <li>
    /// <p>The limit of 10 tags for a tag type was exceeded.</p></li>
    /// <li>
    /// <p>The combined length of the tag names exceeded the limit.</p></li>
    /// <li>
    /// <p>A specified tag is not currently applied to any instances.</p></li>
    /// </ul>
    InvalidTargetInstancesException(crate::types::error::InvalidTargetInstancesException),
    /// <p>The configuration that specifies how traffic is routed during a deployment is invalid.</p>
    InvalidTrafficRoutingConfigurationException(crate::types::error::InvalidTrafficRoutingConfigurationException),
    /// <p>The UpdateOutdatedInstancesOnly value is invalid. For Lambda deployments, <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code> or <code>false</code> is expected.</p>
    InvalidUpdateOutdatedInstancesOnlyValueException(crate::types::error::InvalidUpdateOutdatedInstancesOnlyValueException),
    /// <p>The named revision does not exist with the user or Amazon Web Services account.</p>
    RevisionDoesNotExistException(crate::types::error::RevisionDoesNotExistException),
    /// <p>The revision ID was not specified.</p>
    RevisionRequiredException(crate::types::error::RevisionRequiredException),
    /// <p>An API function was called too frequently.</p>
    ThrottlingException(crate::types::error::ThrottlingException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-CreateDeploymentError) for what information is available for the error.")]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl CreateDeploymentError {
    /// Creates the `CreateDeploymentError::Unhandled` variant from any error type.
    pub fn unhandled(
        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.into(),
            meta: ::std::default::Default::default(),
        })
    }

    /// Creates the `CreateDeploymentError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.clone().into(),
            meta: err,
        })
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AlarmsLimitExceededException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::ApplicationDoesNotExistException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::ApplicationNameRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::DeploymentConfigDoesNotExistException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::DeploymentGroupDoesNotExistException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::DeploymentGroupNameRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::DeploymentLimitExceededException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::DescriptionTooLongException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidAlarmConfigException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidApplicationNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidAutoRollbackConfigException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidAutoScalingGroupException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidDeploymentConfigNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidDeploymentGroupNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidFileExistsBehaviorException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidGitHubAccountTokenException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidIgnoreApplicationStopFailuresValueException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidLoadBalancerInfoException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRevisionException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRoleException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidTargetInstancesException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidTrafficRoutingConfigurationException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidUpdateOutdatedInstancesOnlyValueException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RevisionDoesNotExistException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RevisionRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::ThrottlingException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::Unhandled(e) => &e.meta,
        }
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::AlarmsLimitExceededException`.
    pub fn is_alarms_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::AlarmsLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::DeploymentGroupDoesNotExistException`.
    pub fn is_deployment_group_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::DeploymentGroupNameRequiredException`.
    pub fn is_deployment_group_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::DeploymentLimitExceededException`.
    pub fn is_deployment_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::DeploymentLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::DescriptionTooLongException`.
    pub fn is_description_too_long_exception(&self) -> bool {
        matches!(self, Self::DescriptionTooLongException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidAlarmConfigException`.
    pub fn is_invalid_alarm_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAlarmConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidAutoRollbackConfigException`.
    pub fn is_invalid_auto_rollback_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoRollbackConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidAutoScalingGroupException`.
    pub fn is_invalid_auto_scaling_group_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoScalingGroupException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidDeploymentConfigNameException`.
    pub fn is_invalid_deployment_config_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentConfigNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidDeploymentGroupNameException`.
    pub fn is_invalid_deployment_group_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentGroupNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidFileExistsBehaviorException`.
    pub fn is_invalid_file_exists_behavior_exception(&self) -> bool {
        matches!(self, Self::InvalidFileExistsBehaviorException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidGitHubAccountTokenException`.
    pub fn is_invalid_git_hub_account_token_exception(&self) -> bool {
        matches!(self, Self::InvalidGitHubAccountTokenException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidIgnoreApplicationStopFailuresValueException`.
    pub fn is_invalid_ignore_application_stop_failures_value_exception(&self) -> bool {
        matches!(self, Self::InvalidIgnoreApplicationStopFailuresValueException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidLoadBalancerInfoException`.
    pub fn is_invalid_load_balancer_info_exception(&self) -> bool {
        matches!(self, Self::InvalidLoadBalancerInfoException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidRevisionException`.
    pub fn is_invalid_revision_exception(&self) -> bool {
        matches!(self, Self::InvalidRevisionException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidRoleException`.
    pub fn is_invalid_role_exception(&self) -> bool {
        matches!(self, Self::InvalidRoleException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidTargetInstancesException`.
    pub fn is_invalid_target_instances_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetInstancesException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidTrafficRoutingConfigurationException`.
    pub fn is_invalid_traffic_routing_configuration_exception(&self) -> bool {
        matches!(self, Self::InvalidTrafficRoutingConfigurationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidUpdateOutdatedInstancesOnlyValueException`.
    pub fn is_invalid_update_outdated_instances_only_value_exception(&self) -> bool {
        matches!(self, Self::InvalidUpdateOutdatedInstancesOnlyValueException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::RevisionDoesNotExistException`.
    pub fn is_revision_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RevisionDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::RevisionRequiredException`.
    pub fn is_revision_required_exception(&self) -> bool {
        matches!(self, Self::RevisionRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
}
impl ::std::error::Error for CreateDeploymentError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::AlarmsLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::ApplicationDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::DeploymentGroupDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::DeploymentLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::DescriptionTooLongException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidAlarmConfigException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidApplicationNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidAutoRollbackConfigException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidAutoScalingGroupException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidFileExistsBehaviorException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidGitHubAccountTokenException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidIgnoreApplicationStopFailuresValueException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidLoadBalancerInfoException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRevisionException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRoleException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidTargetInstancesException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidUpdateOutdatedInstancesOnlyValueException(_inner) => ::std::option::Option::Some(_inner),
            Self::RevisionDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::RevisionRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::ThrottlingException(_inner) => ::std::option::Option::Some(_inner),
            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
        }
    }
}
impl ::std::fmt::Display for CreateDeploymentError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::AlarmsLimitExceededException(_inner) => _inner.fmt(f),
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentLimitExceededException(_inner) => _inner.fmt(f),
            Self::DescriptionTooLongException(_inner) => _inner.fmt(f),
            Self::InvalidAlarmConfigException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidAutoRollbackConfigException(_inner) => _inner.fmt(f),
            Self::InvalidAutoScalingGroupException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentConfigNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentGroupNameException(_inner) => _inner.fmt(f),
            Self::InvalidFileExistsBehaviorException(_inner) => _inner.fmt(f),
            Self::InvalidGitHubAccountTokenException(_inner) => _inner.fmt(f),
            Self::InvalidIgnoreApplicationStopFailuresValueException(_inner) => _inner.fmt(f),
            Self::InvalidLoadBalancerInfoException(_inner) => _inner.fmt(f),
            Self::InvalidRevisionException(_inner) => _inner.fmt(f),
            Self::InvalidRoleException(_inner) => _inner.fmt(f),
            Self::InvalidTargetInstancesException(_inner) => _inner.fmt(f),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => _inner.fmt(f),
            Self::InvalidUpdateOutdatedInstancesOnlyValueException(_inner) => _inner.fmt(f),
            Self::RevisionDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RevisionRequiredException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => {
                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for CreateDeploymentError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDeploymentError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AlarmsLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ApplicationDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ApplicationNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DeploymentGroupDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DeploymentLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DescriptionTooLongException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidAlarmConfigException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidApplicationNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidAutoRollbackConfigException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidAutoScalingGroupException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidFileExistsBehaviorException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidGitHubAccountTokenException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidIgnoreApplicationStopFailuresValueException(_inner) => {
                ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLoadBalancerInfoException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRevisionException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRoleException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidTargetInstancesException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidUpdateOutdatedInstancesOnlyValueException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RevisionDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RevisionRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ThrottlingException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::Unhandled(_inner) => &_inner.meta,
        }
    }
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for CreateDeploymentError {
    fn create_unhandled_error(
        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source,
            meta: meta.unwrap_or_default(),
        })
    }
}
impl ::aws_types::request_id::RequestId for crate::operation::create_deployment::CreateDeploymentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}

pub use crate::operation::create_deployment::_create_deployment_output::CreateDeploymentOutput;

pub use crate::operation::create_deployment::_create_deployment_input::CreateDeploymentInput;

mod _create_deployment_input;

mod _create_deployment_output;

/// Builders
pub mod builders;
