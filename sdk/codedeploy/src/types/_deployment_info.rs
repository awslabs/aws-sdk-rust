// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about a deployment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentInfo  {
    /// <p>The application name.</p>
    #[doc(hidden)]
    pub application_name: std::option::Option<std::string::String>,
    /// <p> The deployment group name. </p>
    #[doc(hidden)]
    pub deployment_group_name: std::option::Option<std::string::String>,
    /// <p> The deployment configuration name. </p>
    #[doc(hidden)]
    pub deployment_config_name: std::option::Option<std::string::String>,
    /// <p> The unique ID of a deployment. </p>
    #[doc(hidden)]
    pub deployment_id: std::option::Option<std::string::String>,
    /// <p>Information about the application revision that was deployed to the deployment group before the most recent successful deployment.</p>
    #[doc(hidden)]
    pub previous_revision: std::option::Option<crate::types::RevisionLocation>,
    /// <p>Information about the location of stored application artifacts and the service from which to retrieve them.</p>
    #[doc(hidden)]
    pub revision: std::option::Option<crate::types::RevisionLocation>,
    /// <p>The current state of the deployment as a whole.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::types::DeploymentStatus>,
    /// <p>Information about any error associated with this deployment.</p>
    #[doc(hidden)]
    pub error_information: std::option::Option<crate::types::ErrorInformation>,
    /// <p>A timestamp that indicates when the deployment was created.</p>
    #[doc(hidden)]
    pub create_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that indicates when the deployment was deployed to the deployment group.</p> 
    /// <p>In some cases, the reported value of the start time might be later than the complete time. This is due to differences in the clock settings of backend servers that participate in the deployment process.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A timestamp that indicates when the deployment was complete.</p>
    #[doc(hidden)]
    pub complete_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A summary of the deployment status of the instances in the deployment.</p>
    #[doc(hidden)]
    pub deployment_overview: std::option::Option<crate::types::DeploymentOverview>,
    /// <p>A comment about the deployment.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The means by which the deployment was created:</p> 
    /// <ul> 
    /// <li> <p> <code>user</code>: A user created the deployment.</p> </li> 
    /// <li> <p> <code>autoscaling</code>: Amazon EC2 Auto Scaling created the deployment.</p> </li> 
    /// <li> <p> <code>codeDeployRollback</code>: A rollback process created the deployment.</p> </li> 
    /// <li> <p> <code>CodeDeployAutoUpdate</code>: An auto-update process created the deployment when it detected outdated Amazon EC2 instances.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub creator: std::option::Option<crate::types::DeploymentCreator>,
    /// <p> If true, then if an <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, or <code>AfterBlockTraffic</code> deployment lifecycle event to an instance fails, then the deployment continues to the next deployment lifecycle event. For example, if <code>ApplicationStop</code> fails, the deployment continues with DownloadBundle. If <code>BeforeBlockTraffic</code> fails, the deployment continues with <code>BlockTraffic</code>. If <code>AfterBlockTraffic</code> fails, the deployment continues with <code>ApplicationStop</code>. </p> 
    /// <p> If false or not specified, then if a lifecycle event fails during a deployment to an instance, that deployment fails. If deployment to that instance is part of an overall deployment and the number of healthy hosts is not less than the minimum number of healthy hosts, then a deployment to the next instance is attempted. </p> 
    /// <p> During a deployment, the CodeDeploy agent runs the scripts specified for <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and <code>AfterBlockTraffic</code> in the AppSpec file from the previous successful deployment. (All other scripts are run from the AppSpec file in the current deployment.) If one of these scripts contains an error and does not run successfully, the deployment can fail. </p> 
    /// <p> If the cause of the failure is a script from the last successful deployment that will never run successfully, create a new deployment and use <code>ignoreApplicationStopFailures</code> to specify that the <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and <code>AfterBlockTraffic</code> failures should be ignored. </p>
    #[doc(hidden)]
    pub ignore_application_stop_failures: bool,
    /// <p>Information about the automatic rollback configuration associated with the deployment.</p>
    #[doc(hidden)]
    pub auto_rollback_configuration: std::option::Option<crate::types::AutoRollbackConfiguration>,
    /// <p>Indicates whether only instances that are not running the latest application revision are to be deployed to.</p>
    #[doc(hidden)]
    pub update_outdated_instances_only: bool,
    /// <p>Information about a deployment rollback.</p>
    #[doc(hidden)]
    pub rollback_info: std::option::Option<crate::types::RollbackInfo>,
    /// <p>Information about the type of deployment, either in-place or blue/green, you want to run and whether to route deployment traffic behind a load balancer.</p>
    #[doc(hidden)]
    pub deployment_style: std::option::Option<crate::types::DeploymentStyle>,
    /// <p>Information about the instances that belong to the replacement environment in a blue/green deployment.</p>
    #[doc(hidden)]
    pub target_instances: std::option::Option<crate::types::TargetInstances>,
    /// <p>Indicates whether the wait period set for the termination of instances in the original environment has started. Status is 'false' if the KEEP_ALIVE option is specified. Otherwise, 'true' as soon as the termination wait period starts.</p>
    #[doc(hidden)]
    pub instance_termination_wait_time_started: bool,
    /// <p>Information about blue/green deployment options for this deployment.</p>
    #[doc(hidden)]
    pub blue_green_deployment_configuration: std::option::Option<crate::types::BlueGreenDeploymentConfiguration>,
    /// <p>Information about the load balancer used in the deployment.</p>
    #[doc(hidden)]
    pub load_balancer_info: std::option::Option<crate::types::LoadBalancerInfo>,
    /// <p>Provides information about the results of a deployment, such as whether instances in the original environment in a blue/green deployment were not terminated.</p>
    #[doc(hidden)]
    pub additional_deployment_status_info: std::option::Option<std::string::String>,
    /// <p>Information about how CodeDeploy handles files that already exist in a deployment target location but weren't part of the previous successful deployment.</p> 
    /// <ul> 
    /// <li> <p> <code>DISALLOW</code>: The deployment fails. This is also the default behavior if no option is specified.</p> </li> 
    /// <li> <p> <code>OVERWRITE</code>: The version of the file from the application revision currently being deployed replaces the version already on the instance.</p> </li> 
    /// <li> <p> <code>RETAIN</code>: The version of the file already on the instance is kept and used as part of the new deployment.</p> </li> 
    /// </ul>
    #[doc(hidden)]
    pub file_exists_behavior: std::option::Option<crate::types::FileExistsBehavior>,
    /// <p>Messages that contain information about the status of a deployment.</p>
    #[doc(hidden)]
    pub deployment_status_messages: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The destination platform type for the deployment (<code>Lambda</code>, <code>Server</code>, or <code>ECS</code>).</p>
    #[doc(hidden)]
    pub compute_platform: std::option::Option<crate::types::ComputePlatform>,
    /// <p>The unique ID for an external resource (for example, a CloudFormation stack ID) that is linked to this deployment.</p>
    #[doc(hidden)]
    pub external_id: std::option::Option<std::string::String>,
    /// <p>Information about deployments related to the specified deployment.</p>
    #[doc(hidden)]
    pub related_deployments: std::option::Option<crate::types::RelatedDeployments>,
    /// <p>Information about alarms associated with a deployment or deployment group.</p>
    #[doc(hidden)]
    pub override_alarm_configuration: std::option::Option<crate::types::AlarmConfiguration>,
}
impl DeploymentInfo {
    /// <p>The application name.</p>
    pub fn application_name(&self) -> std::option::Option<& str> {
        self.application_name.as_deref()
    }
    /// <p> The deployment group name. </p>
    pub fn deployment_group_name(&self) -> std::option::Option<& str> {
        self.deployment_group_name.as_deref()
    }
    /// <p> The deployment configuration name. </p>
    pub fn deployment_config_name(&self) -> std::option::Option<& str> {
        self.deployment_config_name.as_deref()
    }
    /// <p> The unique ID of a deployment. </p>
    pub fn deployment_id(&self) -> std::option::Option<& str> {
        self.deployment_id.as_deref()
    }
    /// <p>Information about the application revision that was deployed to the deployment group before the most recent successful deployment.</p>
    pub fn previous_revision(&self) -> std::option::Option<& crate::types::RevisionLocation> {
        self.previous_revision.as_ref()
    }
    /// <p>Information about the location of stored application artifacts and the service from which to retrieve them.</p>
    pub fn revision(&self) -> std::option::Option<& crate::types::RevisionLocation> {
        self.revision.as_ref()
    }
    /// <p>The current state of the deployment as a whole.</p>
    pub fn status(&self) -> std::option::Option<& crate::types::DeploymentStatus> {
        self.status.as_ref()
    }
    /// <p>Information about any error associated with this deployment.</p>
    pub fn error_information(&self) -> std::option::Option<& crate::types::ErrorInformation> {
        self.error_information.as_ref()
    }
    /// <p>A timestamp that indicates when the deployment was created.</p>
    pub fn create_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.create_time.as_ref()
    }
    /// <p>A timestamp that indicates when the deployment was deployed to the deployment group.</p> 
    /// <p>In some cases, the reported value of the start time might be later than the complete time. This is due to differences in the clock settings of backend servers that participate in the deployment process.</p>
    pub fn start_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>A timestamp that indicates when the deployment was complete.</p>
    pub fn complete_time(&self) -> std::option::Option<& aws_smithy_types::DateTime> {
        self.complete_time.as_ref()
    }
    /// <p>A summary of the deployment status of the instances in the deployment.</p>
    pub fn deployment_overview(&self) -> std::option::Option<& crate::types::DeploymentOverview> {
        self.deployment_overview.as_ref()
    }
    /// <p>A comment about the deployment.</p>
    pub fn description(&self) -> std::option::Option<& str> {
        self.description.as_deref()
    }
    /// <p>The means by which the deployment was created:</p> 
    /// <ul> 
    /// <li> <p> <code>user</code>: A user created the deployment.</p> </li> 
    /// <li> <p> <code>autoscaling</code>: Amazon EC2 Auto Scaling created the deployment.</p> </li> 
    /// <li> <p> <code>codeDeployRollback</code>: A rollback process created the deployment.</p> </li> 
    /// <li> <p> <code>CodeDeployAutoUpdate</code>: An auto-update process created the deployment when it detected outdated Amazon EC2 instances.</p> </li> 
    /// </ul>
    pub fn creator(&self) -> std::option::Option<& crate::types::DeploymentCreator> {
        self.creator.as_ref()
    }
    /// <p> If true, then if an <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, or <code>AfterBlockTraffic</code> deployment lifecycle event to an instance fails, then the deployment continues to the next deployment lifecycle event. For example, if <code>ApplicationStop</code> fails, the deployment continues with DownloadBundle. If <code>BeforeBlockTraffic</code> fails, the deployment continues with <code>BlockTraffic</code>. If <code>AfterBlockTraffic</code> fails, the deployment continues with <code>ApplicationStop</code>. </p> 
    /// <p> If false or not specified, then if a lifecycle event fails during a deployment to an instance, that deployment fails. If deployment to that instance is part of an overall deployment and the number of healthy hosts is not less than the minimum number of healthy hosts, then a deployment to the next instance is attempted. </p> 
    /// <p> During a deployment, the CodeDeploy agent runs the scripts specified for <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and <code>AfterBlockTraffic</code> in the AppSpec file from the previous successful deployment. (All other scripts are run from the AppSpec file in the current deployment.) If one of these scripts contains an error and does not run successfully, the deployment can fail. </p> 
    /// <p> If the cause of the failure is a script from the last successful deployment that will never run successfully, create a new deployment and use <code>ignoreApplicationStopFailures</code> to specify that the <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and <code>AfterBlockTraffic</code> failures should be ignored. </p>
    pub fn ignore_application_stop_failures(&self) -> bool {
        self.ignore_application_stop_failures
    }
    /// <p>Information about the automatic rollback configuration associated with the deployment.</p>
    pub fn auto_rollback_configuration(&self) -> std::option::Option<& crate::types::AutoRollbackConfiguration> {
        self.auto_rollback_configuration.as_ref()
    }
    /// <p>Indicates whether only instances that are not running the latest application revision are to be deployed to.</p>
    pub fn update_outdated_instances_only(&self) -> bool {
        self.update_outdated_instances_only
    }
    /// <p>Information about a deployment rollback.</p>
    pub fn rollback_info(&self) -> std::option::Option<& crate::types::RollbackInfo> {
        self.rollback_info.as_ref()
    }
    /// <p>Information about the type of deployment, either in-place or blue/green, you want to run and whether to route deployment traffic behind a load balancer.</p>
    pub fn deployment_style(&self) -> std::option::Option<& crate::types::DeploymentStyle> {
        self.deployment_style.as_ref()
    }
    /// <p>Information about the instances that belong to the replacement environment in a blue/green deployment.</p>
    pub fn target_instances(&self) -> std::option::Option<& crate::types::TargetInstances> {
        self.target_instances.as_ref()
    }
    /// <p>Indicates whether the wait period set for the termination of instances in the original environment has started. Status is 'false' if the KEEP_ALIVE option is specified. Otherwise, 'true' as soon as the termination wait period starts.</p>
    pub fn instance_termination_wait_time_started(&self) -> bool {
        self.instance_termination_wait_time_started
    }
    /// <p>Information about blue/green deployment options for this deployment.</p>
    pub fn blue_green_deployment_configuration(&self) -> std::option::Option<& crate::types::BlueGreenDeploymentConfiguration> {
        self.blue_green_deployment_configuration.as_ref()
    }
    /// <p>Information about the load balancer used in the deployment.</p>
    pub fn load_balancer_info(&self) -> std::option::Option<& crate::types::LoadBalancerInfo> {
        self.load_balancer_info.as_ref()
    }
    /// <p>Provides information about the results of a deployment, such as whether instances in the original environment in a blue/green deployment were not terminated.</p>
    pub fn additional_deployment_status_info(&self) -> std::option::Option<& str> {
        self.additional_deployment_status_info.as_deref()
    }
    /// <p>Information about how CodeDeploy handles files that already exist in a deployment target location but weren't part of the previous successful deployment.</p> 
    /// <ul> 
    /// <li> <p> <code>DISALLOW</code>: The deployment fails. This is also the default behavior if no option is specified.</p> </li> 
    /// <li> <p> <code>OVERWRITE</code>: The version of the file from the application revision currently being deployed replaces the version already on the instance.</p> </li> 
    /// <li> <p> <code>RETAIN</code>: The version of the file already on the instance is kept and used as part of the new deployment.</p> </li> 
    /// </ul>
    pub fn file_exists_behavior(&self) -> std::option::Option<& crate::types::FileExistsBehavior> {
        self.file_exists_behavior.as_ref()
    }
    /// <p>Messages that contain information about the status of a deployment.</p>
    pub fn deployment_status_messages(&self) -> std::option::Option<& [std::string::String]> {
        self.deployment_status_messages.as_deref()
    }
    /// <p>The destination platform type for the deployment (<code>Lambda</code>, <code>Server</code>, or <code>ECS</code>).</p>
    pub fn compute_platform(&self) -> std::option::Option<& crate::types::ComputePlatform> {
        self.compute_platform.as_ref()
    }
    /// <p>The unique ID for an external resource (for example, a CloudFormation stack ID) that is linked to this deployment.</p>
    pub fn external_id(&self) -> std::option::Option<& str> {
        self.external_id.as_deref()
    }
    /// <p>Information about deployments related to the specified deployment.</p>
    pub fn related_deployments(&self) -> std::option::Option<& crate::types::RelatedDeployments> {
        self.related_deployments.as_ref()
    }
    /// <p>Information about alarms associated with a deployment or deployment group.</p>
    pub fn override_alarm_configuration(&self) -> std::option::Option<& crate::types::AlarmConfiguration> {
        self.override_alarm_configuration.as_ref()
    }
}
impl DeploymentInfo {
    /// Creates a new builder-style object to manufacture [`DeploymentInfo`](crate::types::DeploymentInfo).
    pub fn builder() -> crate::types::builders::DeploymentInfoBuilder {
        crate::types::builders::DeploymentInfoBuilder::default()
    }
}

/// A builder for [`DeploymentInfo`](crate::types::DeploymentInfo).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct DeploymentInfoBuilder {
    pub(crate) application_name: std::option::Option<std::string::String>,
    pub(crate) deployment_group_name: std::option::Option<std::string::String>,
    pub(crate) deployment_config_name: std::option::Option<std::string::String>,
    pub(crate) deployment_id: std::option::Option<std::string::String>,
    pub(crate) previous_revision: std::option::Option<crate::types::RevisionLocation>,
    pub(crate) revision: std::option::Option<crate::types::RevisionLocation>,
    pub(crate) status: std::option::Option<crate::types::DeploymentStatus>,
    pub(crate) error_information: std::option::Option<crate::types::ErrorInformation>,
    pub(crate) create_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) complete_time: std::option::Option<aws_smithy_types::DateTime>,
    pub(crate) deployment_overview: std::option::Option<crate::types::DeploymentOverview>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) creator: std::option::Option<crate::types::DeploymentCreator>,
    pub(crate) ignore_application_stop_failures: std::option::Option<bool>,
    pub(crate) auto_rollback_configuration: std::option::Option<crate::types::AutoRollbackConfiguration>,
    pub(crate) update_outdated_instances_only: std::option::Option<bool>,
    pub(crate) rollback_info: std::option::Option<crate::types::RollbackInfo>,
    pub(crate) deployment_style: std::option::Option<crate::types::DeploymentStyle>,
    pub(crate) target_instances: std::option::Option<crate::types::TargetInstances>,
    pub(crate) instance_termination_wait_time_started: std::option::Option<bool>,
    pub(crate) blue_green_deployment_configuration: std::option::Option<crate::types::BlueGreenDeploymentConfiguration>,
    pub(crate) load_balancer_info: std::option::Option<crate::types::LoadBalancerInfo>,
    pub(crate) additional_deployment_status_info: std::option::Option<std::string::String>,
    pub(crate) file_exists_behavior: std::option::Option<crate::types::FileExistsBehavior>,
    pub(crate) deployment_status_messages: std::option::Option<std::vec::Vec<std::string::String>>,
    pub(crate) compute_platform: std::option::Option<crate::types::ComputePlatform>,
    pub(crate) external_id: std::option::Option<std::string::String>,
    pub(crate) related_deployments: std::option::Option<crate::types::RelatedDeployments>,
    pub(crate) override_alarm_configuration: std::option::Option<crate::types::AlarmConfiguration>,
}
impl DeploymentInfoBuilder {
    /// <p>The application name.</p>
    pub fn application_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.application_name = Some(input.into());
        self
    }
    /// <p>The application name.</p>
    pub fn set_application_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.application_name = input; self
    }
    /// <p> The deployment group name. </p>
    pub fn deployment_group_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.deployment_group_name = Some(input.into());
        self
    }
    /// <p> The deployment group name. </p>
    pub fn set_deployment_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.deployment_group_name = input; self
    }
    /// <p> The deployment configuration name. </p>
    pub fn deployment_config_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.deployment_config_name = Some(input.into());
        self
    }
    /// <p> The deployment configuration name. </p>
    pub fn set_deployment_config_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.deployment_config_name = input; self
    }
    /// <p> The unique ID of a deployment. </p>
    pub fn deployment_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.deployment_id = Some(input.into());
        self
    }
    /// <p> The unique ID of a deployment. </p>
    pub fn set_deployment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.deployment_id = input; self
    }
    /// <p>Information about the application revision that was deployed to the deployment group before the most recent successful deployment.</p>
    pub fn previous_revision(mut self, input: crate::types::RevisionLocation) -> Self {
        self.previous_revision = Some(input);
        self
    }
    /// <p>Information about the application revision that was deployed to the deployment group before the most recent successful deployment.</p>
    pub fn set_previous_revision(mut self, input: std::option::Option<crate::types::RevisionLocation>) -> Self {
        self.previous_revision = input; self
    }
    /// <p>Information about the location of stored application artifacts and the service from which to retrieve them.</p>
    pub fn revision(mut self, input: crate::types::RevisionLocation) -> Self {
        self.revision = Some(input);
        self
    }
    /// <p>Information about the location of stored application artifacts and the service from which to retrieve them.</p>
    pub fn set_revision(mut self, input: std::option::Option<crate::types::RevisionLocation>) -> Self {
        self.revision = input; self
    }
    /// <p>The current state of the deployment as a whole.</p>
    pub fn status(mut self, input: crate::types::DeploymentStatus) -> Self {
        self.status = Some(input);
        self
    }
    /// <p>The current state of the deployment as a whole.</p>
    pub fn set_status(mut self, input: std::option::Option<crate::types::DeploymentStatus>) -> Self {
        self.status = input; self
    }
    /// <p>Information about any error associated with this deployment.</p>
    pub fn error_information(mut self, input: crate::types::ErrorInformation) -> Self {
        self.error_information = Some(input);
        self
    }
    /// <p>Information about any error associated with this deployment.</p>
    pub fn set_error_information(mut self, input: std::option::Option<crate::types::ErrorInformation>) -> Self {
        self.error_information = input; self
    }
    /// <p>A timestamp that indicates when the deployment was created.</p>
    pub fn create_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.create_time = Some(input);
        self
    }
    /// <p>A timestamp that indicates when the deployment was created.</p>
    pub fn set_create_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.create_time = input; self
    }
    /// <p>A timestamp that indicates when the deployment was deployed to the deployment group.</p> 
    /// <p>In some cases, the reported value of the start time might be later than the complete time. This is due to differences in the clock settings of backend servers that participate in the deployment process.</p>
    pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.start_time = Some(input);
        self
    }
    /// <p>A timestamp that indicates when the deployment was deployed to the deployment group.</p> 
    /// <p>In some cases, the reported value of the start time might be later than the complete time. This is due to differences in the clock settings of backend servers that participate in the deployment process.</p>
    pub fn set_start_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.start_time = input; self
    }
    /// <p>A timestamp that indicates when the deployment was complete.</p>
    pub fn complete_time(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.complete_time = Some(input);
        self
    }
    /// <p>A timestamp that indicates when the deployment was complete.</p>
    pub fn set_complete_time(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.complete_time = input; self
    }
    /// <p>A summary of the deployment status of the instances in the deployment.</p>
    pub fn deployment_overview(mut self, input: crate::types::DeploymentOverview) -> Self {
        self.deployment_overview = Some(input);
        self
    }
    /// <p>A summary of the deployment status of the instances in the deployment.</p>
    pub fn set_deployment_overview(mut self, input: std::option::Option<crate::types::DeploymentOverview>) -> Self {
        self.deployment_overview = input; self
    }
    /// <p>A comment about the deployment.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>A comment about the deployment.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input; self
    }
    /// <p>The means by which the deployment was created:</p> 
    /// <ul> 
    /// <li> <p> <code>user</code>: A user created the deployment.</p> </li> 
    /// <li> <p> <code>autoscaling</code>: Amazon EC2 Auto Scaling created the deployment.</p> </li> 
    /// <li> <p> <code>codeDeployRollback</code>: A rollback process created the deployment.</p> </li> 
    /// <li> <p> <code>CodeDeployAutoUpdate</code>: An auto-update process created the deployment when it detected outdated Amazon EC2 instances.</p> </li> 
    /// </ul>
    pub fn creator(mut self, input: crate::types::DeploymentCreator) -> Self {
        self.creator = Some(input);
        self
    }
    /// <p>The means by which the deployment was created:</p> 
    /// <ul> 
    /// <li> <p> <code>user</code>: A user created the deployment.</p> </li> 
    /// <li> <p> <code>autoscaling</code>: Amazon EC2 Auto Scaling created the deployment.</p> </li> 
    /// <li> <p> <code>codeDeployRollback</code>: A rollback process created the deployment.</p> </li> 
    /// <li> <p> <code>CodeDeployAutoUpdate</code>: An auto-update process created the deployment when it detected outdated Amazon EC2 instances.</p> </li> 
    /// </ul>
    pub fn set_creator(mut self, input: std::option::Option<crate::types::DeploymentCreator>) -> Self {
        self.creator = input; self
    }
    /// <p> If true, then if an <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, or <code>AfterBlockTraffic</code> deployment lifecycle event to an instance fails, then the deployment continues to the next deployment lifecycle event. For example, if <code>ApplicationStop</code> fails, the deployment continues with DownloadBundle. If <code>BeforeBlockTraffic</code> fails, the deployment continues with <code>BlockTraffic</code>. If <code>AfterBlockTraffic</code> fails, the deployment continues with <code>ApplicationStop</code>. </p> 
    /// <p> If false or not specified, then if a lifecycle event fails during a deployment to an instance, that deployment fails. If deployment to that instance is part of an overall deployment and the number of healthy hosts is not less than the minimum number of healthy hosts, then a deployment to the next instance is attempted. </p> 
    /// <p> During a deployment, the CodeDeploy agent runs the scripts specified for <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and <code>AfterBlockTraffic</code> in the AppSpec file from the previous successful deployment. (All other scripts are run from the AppSpec file in the current deployment.) If one of these scripts contains an error and does not run successfully, the deployment can fail. </p> 
    /// <p> If the cause of the failure is a script from the last successful deployment that will never run successfully, create a new deployment and use <code>ignoreApplicationStopFailures</code> to specify that the <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and <code>AfterBlockTraffic</code> failures should be ignored. </p>
    pub fn ignore_application_stop_failures(mut self, input: bool) -> Self {
        self.ignore_application_stop_failures = Some(input);
        self
    }
    /// <p> If true, then if an <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, or <code>AfterBlockTraffic</code> deployment lifecycle event to an instance fails, then the deployment continues to the next deployment lifecycle event. For example, if <code>ApplicationStop</code> fails, the deployment continues with DownloadBundle. If <code>BeforeBlockTraffic</code> fails, the deployment continues with <code>BlockTraffic</code>. If <code>AfterBlockTraffic</code> fails, the deployment continues with <code>ApplicationStop</code>. </p> 
    /// <p> If false or not specified, then if a lifecycle event fails during a deployment to an instance, that deployment fails. If deployment to that instance is part of an overall deployment and the number of healthy hosts is not less than the minimum number of healthy hosts, then a deployment to the next instance is attempted. </p> 
    /// <p> During a deployment, the CodeDeploy agent runs the scripts specified for <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and <code>AfterBlockTraffic</code> in the AppSpec file from the previous successful deployment. (All other scripts are run from the AppSpec file in the current deployment.) If one of these scripts contains an error and does not run successfully, the deployment can fail. </p> 
    /// <p> If the cause of the failure is a script from the last successful deployment that will never run successfully, create a new deployment and use <code>ignoreApplicationStopFailures</code> to specify that the <code>ApplicationStop</code>, <code>BeforeBlockTraffic</code>, and <code>AfterBlockTraffic</code> failures should be ignored. </p>
    pub fn set_ignore_application_stop_failures(mut self, input: std::option::Option<bool>) -> Self {
        self.ignore_application_stop_failures = input; self
    }
    /// <p>Information about the automatic rollback configuration associated with the deployment.</p>
    pub fn auto_rollback_configuration(mut self, input: crate::types::AutoRollbackConfiguration) -> Self {
        self.auto_rollback_configuration = Some(input);
        self
    }
    /// <p>Information about the automatic rollback configuration associated with the deployment.</p>
    pub fn set_auto_rollback_configuration(mut self, input: std::option::Option<crate::types::AutoRollbackConfiguration>) -> Self {
        self.auto_rollback_configuration = input; self
    }
    /// <p>Indicates whether only instances that are not running the latest application revision are to be deployed to.</p>
    pub fn update_outdated_instances_only(mut self, input: bool) -> Self {
        self.update_outdated_instances_only = Some(input);
        self
    }
    /// <p>Indicates whether only instances that are not running the latest application revision are to be deployed to.</p>
    pub fn set_update_outdated_instances_only(mut self, input: std::option::Option<bool>) -> Self {
        self.update_outdated_instances_only = input; self
    }
    /// <p>Information about a deployment rollback.</p>
    pub fn rollback_info(mut self, input: crate::types::RollbackInfo) -> Self {
        self.rollback_info = Some(input);
        self
    }
    /// <p>Information about a deployment rollback.</p>
    pub fn set_rollback_info(mut self, input: std::option::Option<crate::types::RollbackInfo>) -> Self {
        self.rollback_info = input; self
    }
    /// <p>Information about the type of deployment, either in-place or blue/green, you want to run and whether to route deployment traffic behind a load balancer.</p>
    pub fn deployment_style(mut self, input: crate::types::DeploymentStyle) -> Self {
        self.deployment_style = Some(input);
        self
    }
    /// <p>Information about the type of deployment, either in-place or blue/green, you want to run and whether to route deployment traffic behind a load balancer.</p>
    pub fn set_deployment_style(mut self, input: std::option::Option<crate::types::DeploymentStyle>) -> Self {
        self.deployment_style = input; self
    }
    /// <p>Information about the instances that belong to the replacement environment in a blue/green deployment.</p>
    pub fn target_instances(mut self, input: crate::types::TargetInstances) -> Self {
        self.target_instances = Some(input);
        self
    }
    /// <p>Information about the instances that belong to the replacement environment in a blue/green deployment.</p>
    pub fn set_target_instances(mut self, input: std::option::Option<crate::types::TargetInstances>) -> Self {
        self.target_instances = input; self
    }
    /// <p>Indicates whether the wait period set for the termination of instances in the original environment has started. Status is 'false' if the KEEP_ALIVE option is specified. Otherwise, 'true' as soon as the termination wait period starts.</p>
    pub fn instance_termination_wait_time_started(mut self, input: bool) -> Self {
        self.instance_termination_wait_time_started = Some(input);
        self
    }
    /// <p>Indicates whether the wait period set for the termination of instances in the original environment has started. Status is 'false' if the KEEP_ALIVE option is specified. Otherwise, 'true' as soon as the termination wait period starts.</p>
    pub fn set_instance_termination_wait_time_started(mut self, input: std::option::Option<bool>) -> Self {
        self.instance_termination_wait_time_started = input; self
    }
    /// <p>Information about blue/green deployment options for this deployment.</p>
    pub fn blue_green_deployment_configuration(mut self, input: crate::types::BlueGreenDeploymentConfiguration) -> Self {
        self.blue_green_deployment_configuration = Some(input);
        self
    }
    /// <p>Information about blue/green deployment options for this deployment.</p>
    pub fn set_blue_green_deployment_configuration(mut self, input: std::option::Option<crate::types::BlueGreenDeploymentConfiguration>) -> Self {
        self.blue_green_deployment_configuration = input; self
    }
    /// <p>Information about the load balancer used in the deployment.</p>
    pub fn load_balancer_info(mut self, input: crate::types::LoadBalancerInfo) -> Self {
        self.load_balancer_info = Some(input);
        self
    }
    /// <p>Information about the load balancer used in the deployment.</p>
    pub fn set_load_balancer_info(mut self, input: std::option::Option<crate::types::LoadBalancerInfo>) -> Self {
        self.load_balancer_info = input; self
    }
    /// <p>Provides information about the results of a deployment, such as whether instances in the original environment in a blue/green deployment were not terminated.</p>
    pub fn additional_deployment_status_info(mut self, input: impl Into<std::string::String>) -> Self {
        self.additional_deployment_status_info = Some(input.into());
        self
    }
    /// <p>Provides information about the results of a deployment, such as whether instances in the original environment in a blue/green deployment were not terminated.</p>
    pub fn set_additional_deployment_status_info(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.additional_deployment_status_info = input; self
    }
    /// <p>Information about how CodeDeploy handles files that already exist in a deployment target location but weren't part of the previous successful deployment.</p> 
    /// <ul> 
    /// <li> <p> <code>DISALLOW</code>: The deployment fails. This is also the default behavior if no option is specified.</p> </li> 
    /// <li> <p> <code>OVERWRITE</code>: The version of the file from the application revision currently being deployed replaces the version already on the instance.</p> </li> 
    /// <li> <p> <code>RETAIN</code>: The version of the file already on the instance is kept and used as part of the new deployment.</p> </li> 
    /// </ul>
    pub fn file_exists_behavior(mut self, input: crate::types::FileExistsBehavior) -> Self {
        self.file_exists_behavior = Some(input);
        self
    }
    /// <p>Information about how CodeDeploy handles files that already exist in a deployment target location but weren't part of the previous successful deployment.</p> 
    /// <ul> 
    /// <li> <p> <code>DISALLOW</code>: The deployment fails. This is also the default behavior if no option is specified.</p> </li> 
    /// <li> <p> <code>OVERWRITE</code>: The version of the file from the application revision currently being deployed replaces the version already on the instance.</p> </li> 
    /// <li> <p> <code>RETAIN</code>: The version of the file already on the instance is kept and used as part of the new deployment.</p> </li> 
    /// </ul>
    pub fn set_file_exists_behavior(mut self, input: std::option::Option<crate::types::FileExistsBehavior>) -> Self {
        self.file_exists_behavior = input; self
    }
    /// Appends an item to `deployment_status_messages`.
    ///
    /// To override the contents of this collection use [`set_deployment_status_messages`](Self::set_deployment_status_messages).
    ///
    /// <p>Messages that contain information about the status of a deployment.</p>
    pub fn deployment_status_messages(mut self, input: impl Into<std::string::String>) -> Self {
        let mut v = self.deployment_status_messages.unwrap_or_default();
                        v.push(input.into());
                        self.deployment_status_messages = Some(v);
                        self
    }
    /// <p>Messages that contain information about the status of a deployment.</p>
    pub fn set_deployment_status_messages(mut self, input: std::option::Option<std::vec::Vec<std::string::String>>) -> Self {
        self.deployment_status_messages = input; self
    }
    /// <p>The destination platform type for the deployment (<code>Lambda</code>, <code>Server</code>, or <code>ECS</code>).</p>
    pub fn compute_platform(mut self, input: crate::types::ComputePlatform) -> Self {
        self.compute_platform = Some(input);
        self
    }
    /// <p>The destination platform type for the deployment (<code>Lambda</code>, <code>Server</code>, or <code>ECS</code>).</p>
    pub fn set_compute_platform(mut self, input: std::option::Option<crate::types::ComputePlatform>) -> Self {
        self.compute_platform = input; self
    }
    /// <p>The unique ID for an external resource (for example, a CloudFormation stack ID) that is linked to this deployment.</p>
    pub fn external_id(mut self, input: impl Into<std::string::String>) -> Self {
        self.external_id = Some(input.into());
        self
    }
    /// <p>The unique ID for an external resource (for example, a CloudFormation stack ID) that is linked to this deployment.</p>
    pub fn set_external_id(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.external_id = input; self
    }
    /// <p>Information about deployments related to the specified deployment.</p>
    pub fn related_deployments(mut self, input: crate::types::RelatedDeployments) -> Self {
        self.related_deployments = Some(input);
        self
    }
    /// <p>Information about deployments related to the specified deployment.</p>
    pub fn set_related_deployments(mut self, input: std::option::Option<crate::types::RelatedDeployments>) -> Self {
        self.related_deployments = input; self
    }
    /// <p>Information about alarms associated with a deployment or deployment group.</p>
    pub fn override_alarm_configuration(mut self, input: crate::types::AlarmConfiguration) -> Self {
        self.override_alarm_configuration = Some(input);
        self
    }
    /// <p>Information about alarms associated with a deployment or deployment group.</p>
    pub fn set_override_alarm_configuration(mut self, input: std::option::Option<crate::types::AlarmConfiguration>) -> Self {
        self.override_alarm_configuration = input; self
    }
    /// Consumes the builder and constructs a [`DeploymentInfo`](crate::types::DeploymentInfo).
    pub fn build(self) -> crate::types::DeploymentInfo {
        crate::types::DeploymentInfo {
            application_name: self.application_name
            ,
            deployment_group_name: self.deployment_group_name
            ,
            deployment_config_name: self.deployment_config_name
            ,
            deployment_id: self.deployment_id
            ,
            previous_revision: self.previous_revision
            ,
            revision: self.revision
            ,
            status: self.status
            ,
            error_information: self.error_information
            ,
            create_time: self.create_time
            ,
            start_time: self.start_time
            ,
            complete_time: self.complete_time
            ,
            deployment_overview: self.deployment_overview
            ,
            description: self.description
            ,
            creator: self.creator
            ,
            ignore_application_stop_failures: self.ignore_application_stop_failures
                .unwrap_or_default()
            ,
            auto_rollback_configuration: self.auto_rollback_configuration
            ,
            update_outdated_instances_only: self.update_outdated_instances_only
                .unwrap_or_default()
            ,
            rollback_info: self.rollback_info
            ,
            deployment_style: self.deployment_style
            ,
            target_instances: self.target_instances
            ,
            instance_termination_wait_time_started: self.instance_termination_wait_time_started
                .unwrap_or_default()
            ,
            blue_green_deployment_configuration: self.blue_green_deployment_configuration
            ,
            load_balancer_info: self.load_balancer_info
            ,
            additional_deployment_status_info: self.additional_deployment_status_info
            ,
            file_exists_behavior: self.file_exists_behavior
            ,
            deployment_status_messages: self.deployment_status_messages
            ,
            compute_platform: self.compute_platform
            ,
            external_id: self.external_id
            ,
            related_deployments: self.related_deployments
            ,
            override_alarm_configuration: self.override_alarm_configuration
            ,
        }
    }
}

