// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateDeploymentGroupErrorKind = UpdateDeploymentGroupError;
/// Error type for the `UpdateDeploymentGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDeploymentGroupError {
    /// <p>The maximum number of alarms for a deployment group (10) was exceeded.</p>
    AlarmsLimitExceededException(crate::error::AlarmsLimitExceededException),
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::error::DeploymentConfigDoesNotExistException),
    /// <p>A deployment group with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    DeploymentGroupAlreadyExistsException(crate::error::DeploymentGroupAlreadyExistsException),
    /// <p>The named deployment group with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentGroupDoesNotExistException(crate::error::DeploymentGroupDoesNotExistException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::error::DeploymentGroupNameRequiredException),
    /// <p> The Amazon ECS service is associated with more than one deployment groups. An Amazon ECS service can be associated with only one deployment group. </p>
    EcsServiceMappingLimitExceededException(crate::error::EcsServiceMappingLimitExceededException),
    /// <p>The format of the alarm configuration is invalid. Possible causes include:</p>
    /// <ul>
    /// <li> <p>The alarm list is null.</p> </li>
    /// <li> <p>The alarm object is null.</p> </li>
    /// <li> <p>The alarm name is empty or null or exceeds the limit of 255 characters.</p> </li>
    /// <li> <p>Two alarms with the same name have been specified.</p> </li>
    /// <li> <p>The alarm configuration is enabled, but the alarm list is empty.</p> </li>
    /// </ul>
    InvalidAlarmConfigException(crate::error::InvalidAlarmConfigException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The automatic rollback configuration was specified in an invalid format. For example, automatic rollback is enabled, but an invalid triggering event type or no event types were listed.</p>
    InvalidAutoRollbackConfigException(crate::error::InvalidAutoRollbackConfigException),
    /// <p>The Auto Scaling group was specified in an invalid format or does not exist.</p>
    InvalidAutoScalingGroupException(crate::error::InvalidAutoScalingGroupException),
    /// <p>The configuration for the blue/green deployment group was provided in an invalid format. For information about deployment configuration format, see <code>CreateDeploymentConfig</code>.</p>
    InvalidBlueGreenDeploymentConfigurationException(
        crate::error::InvalidBlueGreenDeploymentConfigurationException,
    ),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::error::InvalidDeploymentConfigNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::error::InvalidDeploymentGroupNameException),
    /// <p>An invalid deployment style was specified. Valid deployment types include "IN_PLACE" and "BLUE_GREEN." Valid deployment options include "WITH_TRAFFIC_CONTROL" and "WITHOUT_TRAFFIC_CONTROL."</p>
    InvalidDeploymentStyleException(crate::error::InvalidDeploymentStyleException),
    /// <p>A call was submitted that specified both Ec2TagFilters and Ec2TagSet, but only one of these data types can be used in a single call.</p>
    InvalidEc2TagCombinationException(crate::error::InvalidEc2TagCombinationException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidEc2TagException(crate::error::InvalidEc2TagException),
    /// <p> The Amazon ECS service identifier is not valid. </p>
    InvalidEcsServiceException(crate::error::InvalidEcsServiceException),
    /// <p>The input was specified in an invalid format.</p>
    InvalidInputException(crate::error::InvalidInputException),
    /// <p>An invalid load balancer name, or no load balancer name, was specified.</p>
    InvalidLoadBalancerInfoException(crate::error::InvalidLoadBalancerInfoException),
    /// <p>A call was submitted that specified both OnPremisesTagFilters and OnPremisesTagSet, but only one of these data types can be used in a single call.</p>
    InvalidOnPremisesTagCombinationException(
        crate::error::InvalidOnPremisesTagCombinationException,
    ),
    /// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
    InvalidRoleException(crate::error::InvalidRoleException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p> A target group pair associated with this deployment is not valid. </p>
    InvalidTargetGroupPairException(crate::error::InvalidTargetGroupPairException),
    /// <p> The configuration that specifies how traffic is routed during a deployment is invalid.</p>
    InvalidTrafficRoutingConfigurationException(
        crate::error::InvalidTrafficRoutingConfigurationException,
    ),
    /// <p>The trigger was specified in an invalid format.</p>
    InvalidTriggerConfigException(crate::error::InvalidTriggerConfigException),
    /// <p>The limit for lifecycle hooks was exceeded.</p>
    LifecycleHookLimitExceededException(crate::error::LifecycleHookLimitExceededException),
    /// <p>The number of tag groups included in the tag set list exceeded the maximum allowed limit of 3.</p>
    TagSetListLimitExceededException(crate::error::TagSetListLimitExceededException),
    /// <p>An API function was called too frequently.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The maximum allowed number of triggers was exceeded.</p>
    TriggerTargetsLimitExceededException(crate::error::TriggerTargetsLimitExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateDeploymentGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateDeploymentGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AlarmsLimitExceededException(_inner) => _inner.fmt(f),
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupNameRequiredException(_inner) => _inner.fmt(f),
            Self::EcsServiceMappingLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidAlarmConfigException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidAutoRollbackConfigException(_inner) => _inner.fmt(f),
            Self::InvalidAutoScalingGroupException(_inner) => _inner.fmt(f),
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentConfigNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentGroupNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentStyleException(_inner) => _inner.fmt(f),
            Self::InvalidEc2TagCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidEc2TagException(_inner) => _inner.fmt(f),
            Self::InvalidEcsServiceException(_inner) => _inner.fmt(f),
            Self::InvalidInputException(_inner) => _inner.fmt(f),
            Self::InvalidLoadBalancerInfoException(_inner) => _inner.fmt(f),
            Self::InvalidOnPremisesTagCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidRoleException(_inner) => _inner.fmt(f),
            Self::InvalidTagException(_inner) => _inner.fmt(f),
            Self::InvalidTargetGroupPairException(_inner) => _inner.fmt(f),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => _inner.fmt(f),
            Self::InvalidTriggerConfigException(_inner) => _inner.fmt(f),
            Self::LifecycleHookLimitExceededException(_inner) => _inner.fmt(f),
            Self::TagSetListLimitExceededException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::TriggerTargetsLimitExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateDeploymentGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AlarmsLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EcsServiceMappingLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAlarmConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAutoRollbackConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAutoScalingGroupException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentConfigNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentGroupNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentStyleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEc2TagCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEc2TagException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEcsServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInputException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLoadBalancerInfoException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOnPremisesTagCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRoleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetGroupPairException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTrafficRoutingConfigurationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTriggerConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LifecycleHookLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagSetListLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ThrottlingException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TriggerTargetsLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateDeploymentGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDeploymentGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDeploymentGroupError {
    /// Creates the `UpdateDeploymentGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateDeploymentGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AlarmsLimitExceededException(e) => e.meta(),
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::DeploymentConfigDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupAlreadyExistsException(e) => e.meta(),
            Self::DeploymentGroupDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupNameRequiredException(e) => e.meta(),
            Self::EcsServiceMappingLimitExceededException(e) => e.meta(),
            Self::InvalidAlarmConfigException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidAutoRollbackConfigException(e) => e.meta(),
            Self::InvalidAutoScalingGroupException(e) => e.meta(),
            Self::InvalidBlueGreenDeploymentConfigurationException(e) => e.meta(),
            Self::InvalidDeploymentConfigNameException(e) => e.meta(),
            Self::InvalidDeploymentGroupNameException(e) => e.meta(),
            Self::InvalidDeploymentStyleException(e) => e.meta(),
            Self::InvalidEc2TagCombinationException(e) => e.meta(),
            Self::InvalidEc2TagException(e) => e.meta(),
            Self::InvalidEcsServiceException(e) => e.meta(),
            Self::InvalidInputException(e) => e.meta(),
            Self::InvalidLoadBalancerInfoException(e) => e.meta(),
            Self::InvalidOnPremisesTagCombinationException(e) => e.meta(),
            Self::InvalidRoleException(e) => e.meta(),
            Self::InvalidTagException(e) => e.meta(),
            Self::InvalidTargetGroupPairException(e) => e.meta(),
            Self::InvalidTrafficRoutingConfigurationException(e) => e.meta(),
            Self::InvalidTriggerConfigException(e) => e.meta(),
            Self::LifecycleHookLimitExceededException(e) => e.meta(),
            Self::TagSetListLimitExceededException(e) => e.meta(),
            Self::ThrottlingException(e) => e.meta(),
            Self::TriggerTargetsLimitExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::AlarmsLimitExceededException`.
    pub fn is_alarms_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::AlarmsLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::DeploymentGroupAlreadyExistsException`.
    pub fn is_deployment_group_already_exists_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::DeploymentGroupDoesNotExistException`.
    pub fn is_deployment_group_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::DeploymentGroupNameRequiredException`.
    pub fn is_deployment_group_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::EcsServiceMappingLimitExceededException`.
    pub fn is_ecs_service_mapping_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::EcsServiceMappingLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidAlarmConfigException`.
    pub fn is_invalid_alarm_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAlarmConfigException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidAutoRollbackConfigException`.
    pub fn is_invalid_auto_rollback_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoRollbackConfigException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidAutoScalingGroupException`.
    pub fn is_invalid_auto_scaling_group_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoScalingGroupException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidBlueGreenDeploymentConfigurationException`.
    pub fn is_invalid_blue_green_deployment_configuration_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidBlueGreenDeploymentConfigurationException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidDeploymentConfigNameException`.
    pub fn is_invalid_deployment_config_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentConfigNameException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidDeploymentGroupNameException`.
    pub fn is_invalid_deployment_group_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentGroupNameException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidDeploymentStyleException`.
    pub fn is_invalid_deployment_style_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentStyleException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidEc2TagCombinationException`.
    pub fn is_invalid_ec2_tag_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidEc2TagCombinationException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidEc2TagException`.
    pub fn is_invalid_ec2_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidEc2TagException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidEcsServiceException`.
    pub fn is_invalid_ecs_service_exception(&self) -> bool {
        matches!(self, Self::InvalidEcsServiceException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidInputException`.
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(self, Self::InvalidInputException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidLoadBalancerInfoException`.
    pub fn is_invalid_load_balancer_info_exception(&self) -> bool {
        matches!(self, Self::InvalidLoadBalancerInfoException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidOnPremisesTagCombinationException`.
    pub fn is_invalid_on_premises_tag_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidOnPremisesTagCombinationException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidRoleException`.
    pub fn is_invalid_role_exception(&self) -> bool {
        matches!(self, Self::InvalidRoleException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidTagException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidTargetGroupPairException`.
    pub fn is_invalid_target_group_pair_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetGroupPairException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidTrafficRoutingConfigurationException`.
    pub fn is_invalid_traffic_routing_configuration_exception(&self) -> bool {
        matches!(self, Self::InvalidTrafficRoutingConfigurationException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::InvalidTriggerConfigException`.
    pub fn is_invalid_trigger_config_exception(&self) -> bool {
        matches!(self, Self::InvalidTriggerConfigException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::LifecycleHookLimitExceededException`.
    pub fn is_lifecycle_hook_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LifecycleHookLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::TagSetListLimitExceededException`.
    pub fn is_tag_set_list_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TagSetListLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `UpdateDeploymentGroupError::TriggerTargetsLimitExceededException`.
    pub fn is_trigger_targets_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TriggerTargetsLimitExceededException(_))
    }
}
impl std::error::Error for UpdateDeploymentGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AlarmsLimitExceededException(_inner) => Some(_inner),
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupAlreadyExistsException(_inner) => Some(_inner),
            Self::DeploymentGroupDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => Some(_inner),
            Self::EcsServiceMappingLimitExceededException(_inner) => Some(_inner),
            Self::InvalidAlarmConfigException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidAutoRollbackConfigException(_inner) => Some(_inner),
            Self::InvalidAutoScalingGroupException(_inner) => Some(_inner),
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => Some(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentStyleException(_inner) => Some(_inner),
            Self::InvalidEc2TagCombinationException(_inner) => Some(_inner),
            Self::InvalidEc2TagException(_inner) => Some(_inner),
            Self::InvalidEcsServiceException(_inner) => Some(_inner),
            Self::InvalidInputException(_inner) => Some(_inner),
            Self::InvalidLoadBalancerInfoException(_inner) => Some(_inner),
            Self::InvalidOnPremisesTagCombinationException(_inner) => Some(_inner),
            Self::InvalidRoleException(_inner) => Some(_inner),
            Self::InvalidTagException(_inner) => Some(_inner),
            Self::InvalidTargetGroupPairException(_inner) => Some(_inner),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => Some(_inner),
            Self::InvalidTriggerConfigException(_inner) => Some(_inner),
            Self::LifecycleHookLimitExceededException(_inner) => Some(_inner),
            Self::TagSetListLimitExceededException(_inner) => Some(_inner),
            Self::ThrottlingException(_inner) => Some(_inner),
            Self::TriggerTargetsLimitExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum allowed number of triggers was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TriggerTargetsLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TriggerTargetsLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TriggerTargetsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TriggerTargetsLimitExceededException")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TriggerTargetsLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::TriggerTargetsLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TriggerTargetsLimitExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TriggerTargetsLimitExceededException {
    /// Creates a new builder-style object to manufacture [`TriggerTargetsLimitExceededException`](crate::error::TriggerTargetsLimitExceededException).
    pub fn builder() -> crate::error::trigger_targets_limit_exceeded_exception::Builder {
        crate::error::trigger_targets_limit_exceeded_exception::Builder::default()
    }
}

/// See [`TriggerTargetsLimitExceededException`](crate::error::TriggerTargetsLimitExceededException).
pub mod trigger_targets_limit_exceeded_exception {

    /// A builder for [`TriggerTargetsLimitExceededException`](crate::error::TriggerTargetsLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TriggerTargetsLimitExceededException`](crate::error::TriggerTargetsLimitExceededException).
        pub fn build(self) -> crate::error::TriggerTargetsLimitExceededException {
            crate::error::TriggerTargetsLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An API function was called too frequently.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ThrottlingException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ThrottlingException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
impl aws_http::request_id::RequestId for crate::error::ThrottlingException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ThrottlingException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException).
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// See [`ThrottlingException`](crate::error::ThrottlingException).
pub mod throttling_exception {

    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException).
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The number of tag groups included in the tag set list exceeded the maximum allowed limit of 3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagSetListLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagSetListLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagSetListLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagSetListLimitExceededException")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagSetListLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::TagSetListLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagSetListLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TagSetListLimitExceededException {
    /// Creates a new builder-style object to manufacture [`TagSetListLimitExceededException`](crate::error::TagSetListLimitExceededException).
    pub fn builder() -> crate::error::tag_set_list_limit_exceeded_exception::Builder {
        crate::error::tag_set_list_limit_exceeded_exception::Builder::default()
    }
}

/// See [`TagSetListLimitExceededException`](crate::error::TagSetListLimitExceededException).
pub mod tag_set_list_limit_exceeded_exception {

    /// A builder for [`TagSetListLimitExceededException`](crate::error::TagSetListLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TagSetListLimitExceededException`](crate::error::TagSetListLimitExceededException).
        pub fn build(self) -> crate::error::TagSetListLimitExceededException {
            crate::error::TagSetListLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The limit for lifecycle hooks was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LifecycleHookLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl LifecycleHookLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LifecycleHookLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LifecycleHookLimitExceededException")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for LifecycleHookLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::LifecycleHookLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for LifecycleHookLimitExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl LifecycleHookLimitExceededException {
    /// Creates a new builder-style object to manufacture [`LifecycleHookLimitExceededException`](crate::error::LifecycleHookLimitExceededException).
    pub fn builder() -> crate::error::lifecycle_hook_limit_exceeded_exception::Builder {
        crate::error::lifecycle_hook_limit_exceeded_exception::Builder::default()
    }
}

/// See [`LifecycleHookLimitExceededException`](crate::error::LifecycleHookLimitExceededException).
pub mod lifecycle_hook_limit_exceeded_exception {

    /// A builder for [`LifecycleHookLimitExceededException`](crate::error::LifecycleHookLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`LifecycleHookLimitExceededException`](crate::error::LifecycleHookLimitExceededException).
        pub fn build(self) -> crate::error::LifecycleHookLimitExceededException {
            crate::error::LifecycleHookLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The trigger was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTriggerConfigException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTriggerConfigException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTriggerConfigException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTriggerConfigException")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTriggerConfigException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTriggerConfigException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTriggerConfigException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTriggerConfigException {
    /// Creates a new builder-style object to manufacture [`InvalidTriggerConfigException`](crate::error::InvalidTriggerConfigException).
    pub fn builder() -> crate::error::invalid_trigger_config_exception::Builder {
        crate::error::invalid_trigger_config_exception::Builder::default()
    }
}

/// See [`InvalidTriggerConfigException`](crate::error::InvalidTriggerConfigException).
pub mod invalid_trigger_config_exception {

    /// A builder for [`InvalidTriggerConfigException`](crate::error::InvalidTriggerConfigException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTriggerConfigException`](crate::error::InvalidTriggerConfigException).
        pub fn build(self) -> crate::error::InvalidTriggerConfigException {
            crate::error::InvalidTriggerConfigException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> The configuration that specifies how traffic is routed during a deployment is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTrafficRoutingConfigurationException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTrafficRoutingConfigurationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTrafficRoutingConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTrafficRoutingConfigurationException")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTrafficRoutingConfigurationException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTrafficRoutingConfigurationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidTrafficRoutingConfigurationException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTrafficRoutingConfigurationException {
    /// Creates a new builder-style object to manufacture [`InvalidTrafficRoutingConfigurationException`](crate::error::InvalidTrafficRoutingConfigurationException).
    pub fn builder() -> crate::error::invalid_traffic_routing_configuration_exception::Builder {
        crate::error::invalid_traffic_routing_configuration_exception::Builder::default()
    }
}

/// See [`InvalidTrafficRoutingConfigurationException`](crate::error::InvalidTrafficRoutingConfigurationException).
pub mod invalid_traffic_routing_configuration_exception {

    /// A builder for [`InvalidTrafficRoutingConfigurationException`](crate::error::InvalidTrafficRoutingConfigurationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTrafficRoutingConfigurationException`](crate::error::InvalidTrafficRoutingConfigurationException).
        pub fn build(self) -> crate::error::InvalidTrafficRoutingConfigurationException {
            crate::error::InvalidTrafficRoutingConfigurationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> A target group pair associated with this deployment is not valid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTargetGroupPairException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTargetGroupPairException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetGroupPairException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetGroupPairException")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetGroupPairException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTargetGroupPairException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTargetGroupPairException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTargetGroupPairException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetGroupPairException`](crate::error::InvalidTargetGroupPairException).
    pub fn builder() -> crate::error::invalid_target_group_pair_exception::Builder {
        crate::error::invalid_target_group_pair_exception::Builder::default()
    }
}

/// See [`InvalidTargetGroupPairException`](crate::error::InvalidTargetGroupPairException).
pub mod invalid_target_group_pair_exception {

    /// A builder for [`InvalidTargetGroupPairException`](crate::error::InvalidTargetGroupPairException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetGroupPairException`](crate::error::InvalidTargetGroupPairException).
        pub fn build(self) -> crate::error::InvalidTargetGroupPairException {
            crate::error::InvalidTargetGroupPairException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The tag was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTagException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTagException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagException")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTagException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTagException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTagException {
    /// Creates a new builder-style object to manufacture [`InvalidTagException`](crate::error::InvalidTagException).
    pub fn builder() -> crate::error::invalid_tag_exception::Builder {
        crate::error::invalid_tag_exception::Builder::default()
    }
}

/// See [`InvalidTagException`](crate::error::InvalidTagException).
pub mod invalid_tag_exception {

    /// A builder for [`InvalidTagException`](crate::error::InvalidTagException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagException`](crate::error::InvalidTagException).
        pub fn build(self) -> crate::error::InvalidTagException {
            crate::error::InvalidTagException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRoleException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRoleException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRoleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRoleException")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRoleException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRoleException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRoleException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidRoleException {
    /// Creates a new builder-style object to manufacture [`InvalidRoleException`](crate::error::InvalidRoleException).
    pub fn builder() -> crate::error::invalid_role_exception::Builder {
        crate::error::invalid_role_exception::Builder::default()
    }
}

/// See [`InvalidRoleException`](crate::error::InvalidRoleException).
pub mod invalid_role_exception {

    /// A builder for [`InvalidRoleException`](crate::error::InvalidRoleException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRoleException`](crate::error::InvalidRoleException).
        pub fn build(self) -> crate::error::InvalidRoleException {
            crate::error::InvalidRoleException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A call was submitted that specified both OnPremisesTagFilters and OnPremisesTagSet, but only one of these data types can be used in a single call.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidOnPremisesTagCombinationException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidOnPremisesTagCombinationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOnPremisesTagCombinationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOnPremisesTagCombinationException")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOnPremisesTagCombinationException {}
impl aws_http::request_id::RequestId for crate::error::InvalidOnPremisesTagCombinationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidOnPremisesTagCombinationException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidOnPremisesTagCombinationException {
    /// Creates a new builder-style object to manufacture [`InvalidOnPremisesTagCombinationException`](crate::error::InvalidOnPremisesTagCombinationException).
    pub fn builder() -> crate::error::invalid_on_premises_tag_combination_exception::Builder {
        crate::error::invalid_on_premises_tag_combination_exception::Builder::default()
    }
}

/// See [`InvalidOnPremisesTagCombinationException`](crate::error::InvalidOnPremisesTagCombinationException).
pub mod invalid_on_premises_tag_combination_exception {

    /// A builder for [`InvalidOnPremisesTagCombinationException`](crate::error::InvalidOnPremisesTagCombinationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOnPremisesTagCombinationException`](crate::error::InvalidOnPremisesTagCombinationException).
        pub fn build(self) -> crate::error::InvalidOnPremisesTagCombinationException {
            crate::error::InvalidOnPremisesTagCombinationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An invalid load balancer name, or no load balancer name, was specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidLoadBalancerInfoException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidLoadBalancerInfoException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidLoadBalancerInfoException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidLoadBalancerInfoException")?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidLoadBalancerInfoException {}
impl aws_http::request_id::RequestId for crate::error::InvalidLoadBalancerInfoException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidLoadBalancerInfoException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidLoadBalancerInfoException {
    /// Creates a new builder-style object to manufacture [`InvalidLoadBalancerInfoException`](crate::error::InvalidLoadBalancerInfoException).
    pub fn builder() -> crate::error::invalid_load_balancer_info_exception::Builder {
        crate::error::invalid_load_balancer_info_exception::Builder::default()
    }
}

/// See [`InvalidLoadBalancerInfoException`](crate::error::InvalidLoadBalancerInfoException).
pub mod invalid_load_balancer_info_exception {

    /// A builder for [`InvalidLoadBalancerInfoException`](crate::error::InvalidLoadBalancerInfoException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidLoadBalancerInfoException`](crate::error::InvalidLoadBalancerInfoException).
        pub fn build(self) -> crate::error::InvalidLoadBalancerInfoException {
            crate::error::InvalidLoadBalancerInfoException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The input was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidInputException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidInputException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInputException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInputException")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInputException {}
impl aws_http::request_id::RequestId for crate::error::InvalidInputException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidInputException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidInputException {
    /// Creates a new builder-style object to manufacture [`InvalidInputException`](crate::error::InvalidInputException).
    pub fn builder() -> crate::error::invalid_input_exception::Builder {
        crate::error::invalid_input_exception::Builder::default()
    }
}

/// See [`InvalidInputException`](crate::error::InvalidInputException).
pub mod invalid_input_exception {

    /// A builder for [`InvalidInputException`](crate::error::InvalidInputException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInputException`](crate::error::InvalidInputException).
        pub fn build(self) -> crate::error::InvalidInputException {
            crate::error::InvalidInputException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> The Amazon ECS service identifier is not valid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidEcsServiceException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidEcsServiceException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEcsServiceException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEcsServiceException [InvalidECSServiceException]")?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEcsServiceException {}
impl aws_http::request_id::RequestId for crate::error::InvalidEcsServiceException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidEcsServiceException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidEcsServiceException {
    /// Creates a new builder-style object to manufacture [`InvalidEcsServiceException`](crate::error::InvalidEcsServiceException).
    pub fn builder() -> crate::error::invalid_ecs_service_exception::Builder {
        crate::error::invalid_ecs_service_exception::Builder::default()
    }
}

/// See [`InvalidEcsServiceException`](crate::error::InvalidEcsServiceException).
pub mod invalid_ecs_service_exception {

    /// A builder for [`InvalidEcsServiceException`](crate::error::InvalidEcsServiceException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEcsServiceException`](crate::error::InvalidEcsServiceException).
        pub fn build(self) -> crate::error::InvalidEcsServiceException {
            crate::error::InvalidEcsServiceException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The tag was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidEc2TagException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidEc2TagException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEc2TagException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEc2TagException [InvalidEC2TagException]")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEc2TagException {}
impl aws_http::request_id::RequestId for crate::error::InvalidEc2TagException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidEc2TagException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidEc2TagException {
    /// Creates a new builder-style object to manufacture [`InvalidEc2TagException`](crate::error::InvalidEc2TagException).
    pub fn builder() -> crate::error::invalid_ec2_tag_exception::Builder {
        crate::error::invalid_ec2_tag_exception::Builder::default()
    }
}

/// See [`InvalidEc2TagException`](crate::error::InvalidEc2TagException).
pub mod invalid_ec2_tag_exception {

    /// A builder for [`InvalidEc2TagException`](crate::error::InvalidEc2TagException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEc2TagException`](crate::error::InvalidEc2TagException).
        pub fn build(self) -> crate::error::InvalidEc2TagException {
            crate::error::InvalidEc2TagException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A call was submitted that specified both Ec2TagFilters and Ec2TagSet, but only one of these data types can be used in a single call.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidEc2TagCombinationException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidEc2TagCombinationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEc2TagCombinationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InvalidEc2TagCombinationException [InvalidEC2TagCombinationException]"
        )?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEc2TagCombinationException {}
impl aws_http::request_id::RequestId for crate::error::InvalidEc2TagCombinationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidEc2TagCombinationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidEc2TagCombinationException {
    /// Creates a new builder-style object to manufacture [`InvalidEc2TagCombinationException`](crate::error::InvalidEc2TagCombinationException).
    pub fn builder() -> crate::error::invalid_ec2_tag_combination_exception::Builder {
        crate::error::invalid_ec2_tag_combination_exception::Builder::default()
    }
}

/// See [`InvalidEc2TagCombinationException`](crate::error::InvalidEc2TagCombinationException).
pub mod invalid_ec2_tag_combination_exception {

    /// A builder for [`InvalidEc2TagCombinationException`](crate::error::InvalidEc2TagCombinationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEc2TagCombinationException`](crate::error::InvalidEc2TagCombinationException).
        pub fn build(self) -> crate::error::InvalidEc2TagCombinationException {
            crate::error::InvalidEc2TagCombinationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An invalid deployment style was specified. Valid deployment types include "IN_PLACE" and "BLUE_GREEN." Valid deployment options include "WITH_TRAFFIC_CONTROL" and "WITHOUT_TRAFFIC_CONTROL."</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDeploymentStyleException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDeploymentStyleException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeploymentStyleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeploymentStyleException")?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeploymentStyleException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDeploymentStyleException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDeploymentStyleException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDeploymentStyleException {
    /// Creates a new builder-style object to manufacture [`InvalidDeploymentStyleException`](crate::error::InvalidDeploymentStyleException).
    pub fn builder() -> crate::error::invalid_deployment_style_exception::Builder {
        crate::error::invalid_deployment_style_exception::Builder::default()
    }
}

/// See [`InvalidDeploymentStyleException`](crate::error::InvalidDeploymentStyleException).
pub mod invalid_deployment_style_exception {

    /// A builder for [`InvalidDeploymentStyleException`](crate::error::InvalidDeploymentStyleException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeploymentStyleException`](crate::error::InvalidDeploymentStyleException).
        pub fn build(self) -> crate::error::InvalidDeploymentStyleException {
            crate::error::InvalidDeploymentStyleException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The deployment group name was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDeploymentGroupNameException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDeploymentGroupNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeploymentGroupNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeploymentGroupNameException")?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeploymentGroupNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDeploymentGroupNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidDeploymentGroupNameException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDeploymentGroupNameException {
    /// Creates a new builder-style object to manufacture [`InvalidDeploymentGroupNameException`](crate::error::InvalidDeploymentGroupNameException).
    pub fn builder() -> crate::error::invalid_deployment_group_name_exception::Builder {
        crate::error::invalid_deployment_group_name_exception::Builder::default()
    }
}

/// See [`InvalidDeploymentGroupNameException`](crate::error::InvalidDeploymentGroupNameException).
pub mod invalid_deployment_group_name_exception {

    /// A builder for [`InvalidDeploymentGroupNameException`](crate::error::InvalidDeploymentGroupNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeploymentGroupNameException`](crate::error::InvalidDeploymentGroupNameException).
        pub fn build(self) -> crate::error::InvalidDeploymentGroupNameException {
            crate::error::InvalidDeploymentGroupNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The deployment configuration name was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDeploymentConfigNameException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDeploymentConfigNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeploymentConfigNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeploymentConfigNameException")?;
        if let Some(inner_18) = &self.message {
            {
                write!(f, ": {}", inner_18)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeploymentConfigNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDeploymentConfigNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidDeploymentConfigNameException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDeploymentConfigNameException {
    /// Creates a new builder-style object to manufacture [`InvalidDeploymentConfigNameException`](crate::error::InvalidDeploymentConfigNameException).
    pub fn builder() -> crate::error::invalid_deployment_config_name_exception::Builder {
        crate::error::invalid_deployment_config_name_exception::Builder::default()
    }
}

/// See [`InvalidDeploymentConfigNameException`](crate::error::InvalidDeploymentConfigNameException).
pub mod invalid_deployment_config_name_exception {

    /// A builder for [`InvalidDeploymentConfigNameException`](crate::error::InvalidDeploymentConfigNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeploymentConfigNameException`](crate::error::InvalidDeploymentConfigNameException).
        pub fn build(self) -> crate::error::InvalidDeploymentConfigNameException {
            crate::error::InvalidDeploymentConfigNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The configuration for the blue/green deployment group was provided in an invalid format. For information about deployment configuration format, see <code>CreateDeploymentConfig</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidBlueGreenDeploymentConfigurationException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidBlueGreenDeploymentConfigurationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidBlueGreenDeploymentConfigurationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidBlueGreenDeploymentConfigurationException")?;
        if let Some(inner_19) = &self.message {
            {
                write!(f, ": {}", inner_19)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidBlueGreenDeploymentConfigurationException {}
impl aws_http::request_id::RequestId
    for crate::error::InvalidBlueGreenDeploymentConfigurationException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidBlueGreenDeploymentConfigurationException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidBlueGreenDeploymentConfigurationException {
    /// Creates a new builder-style object to manufacture [`InvalidBlueGreenDeploymentConfigurationException`](crate::error::InvalidBlueGreenDeploymentConfigurationException).
    pub fn builder() -> crate::error::invalid_blue_green_deployment_configuration_exception::Builder
    {
        crate::error::invalid_blue_green_deployment_configuration_exception::Builder::default()
    }
}

/// See [`InvalidBlueGreenDeploymentConfigurationException`](crate::error::InvalidBlueGreenDeploymentConfigurationException).
pub mod invalid_blue_green_deployment_configuration_exception {

    /// A builder for [`InvalidBlueGreenDeploymentConfigurationException`](crate::error::InvalidBlueGreenDeploymentConfigurationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidBlueGreenDeploymentConfigurationException`](crate::error::InvalidBlueGreenDeploymentConfigurationException).
        pub fn build(self) -> crate::error::InvalidBlueGreenDeploymentConfigurationException {
            crate::error::InvalidBlueGreenDeploymentConfigurationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The Auto Scaling group was specified in an invalid format or does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidAutoScalingGroupException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidAutoScalingGroupException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAutoScalingGroupException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAutoScalingGroupException")?;
        if let Some(inner_20) = &self.message {
            {
                write!(f, ": {}", inner_20)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAutoScalingGroupException {}
impl aws_http::request_id::RequestId for crate::error::InvalidAutoScalingGroupException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidAutoScalingGroupException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidAutoScalingGroupException {
    /// Creates a new builder-style object to manufacture [`InvalidAutoScalingGroupException`](crate::error::InvalidAutoScalingGroupException).
    pub fn builder() -> crate::error::invalid_auto_scaling_group_exception::Builder {
        crate::error::invalid_auto_scaling_group_exception::Builder::default()
    }
}

/// See [`InvalidAutoScalingGroupException`](crate::error::InvalidAutoScalingGroupException).
pub mod invalid_auto_scaling_group_exception {

    /// A builder for [`InvalidAutoScalingGroupException`](crate::error::InvalidAutoScalingGroupException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAutoScalingGroupException`](crate::error::InvalidAutoScalingGroupException).
        pub fn build(self) -> crate::error::InvalidAutoScalingGroupException {
            crate::error::InvalidAutoScalingGroupException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The automatic rollback configuration was specified in an invalid format. For example, automatic rollback is enabled, but an invalid triggering event type or no event types were listed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidAutoRollbackConfigException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidAutoRollbackConfigException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAutoRollbackConfigException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAutoRollbackConfigException")?;
        if let Some(inner_21) = &self.message {
            {
                write!(f, ": {}", inner_21)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAutoRollbackConfigException {}
impl aws_http::request_id::RequestId for crate::error::InvalidAutoRollbackConfigException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidAutoRollbackConfigException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidAutoRollbackConfigException {
    /// Creates a new builder-style object to manufacture [`InvalidAutoRollbackConfigException`](crate::error::InvalidAutoRollbackConfigException).
    pub fn builder() -> crate::error::invalid_auto_rollback_config_exception::Builder {
        crate::error::invalid_auto_rollback_config_exception::Builder::default()
    }
}

/// See [`InvalidAutoRollbackConfigException`](crate::error::InvalidAutoRollbackConfigException).
pub mod invalid_auto_rollback_config_exception {

    /// A builder for [`InvalidAutoRollbackConfigException`](crate::error::InvalidAutoRollbackConfigException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAutoRollbackConfigException`](crate::error::InvalidAutoRollbackConfigException).
        pub fn build(self) -> crate::error::InvalidAutoRollbackConfigException {
            crate::error::InvalidAutoRollbackConfigException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The application name was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidApplicationNameException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidApplicationNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApplicationNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApplicationNameException")?;
        if let Some(inner_22) = &self.message {
            {
                write!(f, ": {}", inner_22)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApplicationNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidApplicationNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidApplicationNameException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidApplicationNameException {
    /// Creates a new builder-style object to manufacture [`InvalidApplicationNameException`](crate::error::InvalidApplicationNameException).
    pub fn builder() -> crate::error::invalid_application_name_exception::Builder {
        crate::error::invalid_application_name_exception::Builder::default()
    }
}

/// See [`InvalidApplicationNameException`](crate::error::InvalidApplicationNameException).
pub mod invalid_application_name_exception {

    /// A builder for [`InvalidApplicationNameException`](crate::error::InvalidApplicationNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApplicationNameException`](crate::error::InvalidApplicationNameException).
        pub fn build(self) -> crate::error::InvalidApplicationNameException {
            crate::error::InvalidApplicationNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The format of the alarm configuration is invalid. Possible causes include:</p>
/// <ul>
/// <li> <p>The alarm list is null.</p> </li>
/// <li> <p>The alarm object is null.</p> </li>
/// <li> <p>The alarm name is empty or null or exceeds the limit of 255 characters.</p> </li>
/// <li> <p>Two alarms with the same name have been specified.</p> </li>
/// <li> <p>The alarm configuration is enabled, but the alarm list is empty.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidAlarmConfigException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidAlarmConfigException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAlarmConfigException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAlarmConfigException")?;
        if let Some(inner_23) = &self.message {
            {
                write!(f, ": {}", inner_23)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAlarmConfigException {}
impl aws_http::request_id::RequestId for crate::error::InvalidAlarmConfigException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidAlarmConfigException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidAlarmConfigException {
    /// Creates a new builder-style object to manufacture [`InvalidAlarmConfigException`](crate::error::InvalidAlarmConfigException).
    pub fn builder() -> crate::error::invalid_alarm_config_exception::Builder {
        crate::error::invalid_alarm_config_exception::Builder::default()
    }
}

/// See [`InvalidAlarmConfigException`](crate::error::InvalidAlarmConfigException).
pub mod invalid_alarm_config_exception {

    /// A builder for [`InvalidAlarmConfigException`](crate::error::InvalidAlarmConfigException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAlarmConfigException`](crate::error::InvalidAlarmConfigException).
        pub fn build(self) -> crate::error::InvalidAlarmConfigException {
            crate::error::InvalidAlarmConfigException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> The Amazon ECS service is associated with more than one deployment groups. An Amazon ECS service can be associated with only one deployment group. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EcsServiceMappingLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EcsServiceMappingLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EcsServiceMappingLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "EcsServiceMappingLimitExceededException [ECSServiceMappingLimitExceededException]"
        )?;
        if let Some(inner_24) = &self.message {
            {
                write!(f, ": {}", inner_24)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EcsServiceMappingLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::EcsServiceMappingLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EcsServiceMappingLimitExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl EcsServiceMappingLimitExceededException {
    /// Creates a new builder-style object to manufacture [`EcsServiceMappingLimitExceededException`](crate::error::EcsServiceMappingLimitExceededException).
    pub fn builder() -> crate::error::ecs_service_mapping_limit_exceeded_exception::Builder {
        crate::error::ecs_service_mapping_limit_exceeded_exception::Builder::default()
    }
}

/// See [`EcsServiceMappingLimitExceededException`](crate::error::EcsServiceMappingLimitExceededException).
pub mod ecs_service_mapping_limit_exceeded_exception {

    /// A builder for [`EcsServiceMappingLimitExceededException`](crate::error::EcsServiceMappingLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EcsServiceMappingLimitExceededException`](crate::error::EcsServiceMappingLimitExceededException).
        pub fn build(self) -> crate::error::EcsServiceMappingLimitExceededException {
            crate::error::EcsServiceMappingLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The deployment group name was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentGroupNameRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentGroupNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentGroupNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentGroupNameRequiredException")?;
        if let Some(inner_25) = &self.message {
            {
                write!(f, ": {}", inner_25)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentGroupNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentGroupNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentGroupNameRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentGroupNameRequiredException {
    /// Creates a new builder-style object to manufacture [`DeploymentGroupNameRequiredException`](crate::error::DeploymentGroupNameRequiredException).
    pub fn builder() -> crate::error::deployment_group_name_required_exception::Builder {
        crate::error::deployment_group_name_required_exception::Builder::default()
    }
}

/// See [`DeploymentGroupNameRequiredException`](crate::error::DeploymentGroupNameRequiredException).
pub mod deployment_group_name_required_exception {

    /// A builder for [`DeploymentGroupNameRequiredException`](crate::error::DeploymentGroupNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentGroupNameRequiredException`](crate::error::DeploymentGroupNameRequiredException).
        pub fn build(self) -> crate::error::DeploymentGroupNameRequiredException {
            crate::error::DeploymentGroupNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The named deployment group with the IAM user or Amazon Web Services account does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentGroupDoesNotExistException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentGroupDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentGroupDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentGroupDoesNotExistException")?;
        if let Some(inner_26) = &self.message {
            {
                write!(f, ": {}", inner_26)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentGroupDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentGroupDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentGroupDoesNotExistException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentGroupDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`DeploymentGroupDoesNotExistException`](crate::error::DeploymentGroupDoesNotExistException).
    pub fn builder() -> crate::error::deployment_group_does_not_exist_exception::Builder {
        crate::error::deployment_group_does_not_exist_exception::Builder::default()
    }
}

/// See [`DeploymentGroupDoesNotExistException`](crate::error::DeploymentGroupDoesNotExistException).
pub mod deployment_group_does_not_exist_exception {

    /// A builder for [`DeploymentGroupDoesNotExistException`](crate::error::DeploymentGroupDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentGroupDoesNotExistException`](crate::error::DeploymentGroupDoesNotExistException).
        pub fn build(self) -> crate::error::DeploymentGroupDoesNotExistException {
            crate::error::DeploymentGroupDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A deployment group with the specified name with the IAM user or Amazon Web Services account already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentGroupAlreadyExistsException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentGroupAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentGroupAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentGroupAlreadyExistsException")?;
        if let Some(inner_27) = &self.message {
            {
                write!(f, ": {}", inner_27)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentGroupAlreadyExistsException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentGroupAlreadyExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentGroupAlreadyExistsException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentGroupAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`DeploymentGroupAlreadyExistsException`](crate::error::DeploymentGroupAlreadyExistsException).
    pub fn builder() -> crate::error::deployment_group_already_exists_exception::Builder {
        crate::error::deployment_group_already_exists_exception::Builder::default()
    }
}

/// See [`DeploymentGroupAlreadyExistsException`](crate::error::DeploymentGroupAlreadyExistsException).
pub mod deployment_group_already_exists_exception {

    /// A builder for [`DeploymentGroupAlreadyExistsException`](crate::error::DeploymentGroupAlreadyExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentGroupAlreadyExistsException`](crate::error::DeploymentGroupAlreadyExistsException).
        pub fn build(self) -> crate::error::DeploymentGroupAlreadyExistsException {
            crate::error::DeploymentGroupAlreadyExistsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentConfigDoesNotExistException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentConfigDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentConfigDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentConfigDoesNotExistException")?;
        if let Some(inner_28) = &self.message {
            {
                write!(f, ": {}", inner_28)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentConfigDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentConfigDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentConfigDoesNotExistException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentConfigDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`DeploymentConfigDoesNotExistException`](crate::error::DeploymentConfigDoesNotExistException).
    pub fn builder() -> crate::error::deployment_config_does_not_exist_exception::Builder {
        crate::error::deployment_config_does_not_exist_exception::Builder::default()
    }
}

/// See [`DeploymentConfigDoesNotExistException`](crate::error::DeploymentConfigDoesNotExistException).
pub mod deployment_config_does_not_exist_exception {

    /// A builder for [`DeploymentConfigDoesNotExistException`](crate::error::DeploymentConfigDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentConfigDoesNotExistException`](crate::error::DeploymentConfigDoesNotExistException).
        pub fn build(self) -> crate::error::DeploymentConfigDoesNotExistException {
            crate::error::DeploymentConfigDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The minimum number of required application names was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationNameRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApplicationNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApplicationNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApplicationNameRequiredException")?;
        if let Some(inner_29) = &self.message {
            {
                write!(f, ": {}", inner_29)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApplicationNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ApplicationNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ApplicationNameRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ApplicationNameRequiredException {
    /// Creates a new builder-style object to manufacture [`ApplicationNameRequiredException`](crate::error::ApplicationNameRequiredException).
    pub fn builder() -> crate::error::application_name_required_exception::Builder {
        crate::error::application_name_required_exception::Builder::default()
    }
}

/// See [`ApplicationNameRequiredException`](crate::error::ApplicationNameRequiredException).
pub mod application_name_required_exception {

    /// A builder for [`ApplicationNameRequiredException`](crate::error::ApplicationNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationNameRequiredException`](crate::error::ApplicationNameRequiredException).
        pub fn build(self) -> crate::error::ApplicationNameRequiredException {
            crate::error::ApplicationNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationDoesNotExistException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApplicationDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApplicationDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApplicationDoesNotExistException")?;
        if let Some(inner_30) = &self.message {
            {
                write!(f, ": {}", inner_30)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApplicationDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::ApplicationDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ApplicationDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ApplicationDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ApplicationDoesNotExistException`](crate::error::ApplicationDoesNotExistException).
    pub fn builder() -> crate::error::application_does_not_exist_exception::Builder {
        crate::error::application_does_not_exist_exception::Builder::default()
    }
}

/// See [`ApplicationDoesNotExistException`](crate::error::ApplicationDoesNotExistException).
pub mod application_does_not_exist_exception {

    /// A builder for [`ApplicationDoesNotExistException`](crate::error::ApplicationDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationDoesNotExistException`](crate::error::ApplicationDoesNotExistException).
        pub fn build(self) -> crate::error::ApplicationDoesNotExistException {
            crate::error::ApplicationDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The maximum number of alarms for a deployment group (10) was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AlarmsLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AlarmsLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AlarmsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AlarmsLimitExceededException")?;
        if let Some(inner_31) = &self.message {
            {
                write!(f, ": {}", inner_31)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AlarmsLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::AlarmsLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AlarmsLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl AlarmsLimitExceededException {
    /// Creates a new builder-style object to manufacture [`AlarmsLimitExceededException`](crate::error::AlarmsLimitExceededException).
    pub fn builder() -> crate::error::alarms_limit_exceeded_exception::Builder {
        crate::error::alarms_limit_exceeded_exception::Builder::default()
    }
}

/// See [`AlarmsLimitExceededException`](crate::error::AlarmsLimitExceededException).
pub mod alarms_limit_exceeded_exception {

    /// A builder for [`AlarmsLimitExceededException`](crate::error::AlarmsLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AlarmsLimitExceededException`](crate::error::AlarmsLimitExceededException).
        pub fn build(self) -> crate::error::AlarmsLimitExceededException {
            crate::error::AlarmsLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateApplicationErrorKind = UpdateApplicationError;
/// Error type for the `UpdateApplicationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApplicationError {
    /// <p>An application with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    ApplicationAlreadyExistsException(crate::error::ApplicationAlreadyExistsException),
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateApplicationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateApplicationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateApplicationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateApplicationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApplicationError {
    /// Creates the `UpdateApplicationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateApplicationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationAlreadyExistsException(e) => e.meta(),
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateApplicationError::ApplicationAlreadyExistsException`.
    pub fn is_application_already_exists_exception(&self) -> bool {
        matches!(self, Self::ApplicationAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `UpdateApplicationError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateApplicationError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateApplicationError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
}
impl std::error::Error for UpdateApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationAlreadyExistsException(_inner) => Some(_inner),
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An application with the specified name with the IAM user or Amazon Web Services account already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationAlreadyExistsException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApplicationAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApplicationAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApplicationAlreadyExistsException")?;
        if let Some(inner_32) = &self.message {
            {
                write!(f, ": {}", inner_32)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApplicationAlreadyExistsException {}
impl aws_http::request_id::RequestId for crate::error::ApplicationAlreadyExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ApplicationAlreadyExistsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ApplicationAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ApplicationAlreadyExistsException`](crate::error::ApplicationAlreadyExistsException).
    pub fn builder() -> crate::error::application_already_exists_exception::Builder {
        crate::error::application_already_exists_exception::Builder::default()
    }
}

/// See [`ApplicationAlreadyExistsException`](crate::error::ApplicationAlreadyExistsException).
pub mod application_already_exists_exception {

    /// A builder for [`ApplicationAlreadyExistsException`](crate::error::ApplicationAlreadyExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationAlreadyExistsException`](crate::error::ApplicationAlreadyExistsException).
        pub fn build(self) -> crate::error::ApplicationAlreadyExistsException {
            crate::error::ApplicationAlreadyExistsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UntagResourceErrorKind = UntagResourceError;
/// Error type for the `UntagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p> The specified ARN is not supported. For example, it might be an ARN for a resource that is not expected. </p>
    ArnNotSupportedException(crate::error::ArnNotSupportedException),
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::error::DeploymentConfigDoesNotExistException),
    /// <p>The named deployment group with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentGroupDoesNotExistException(crate::error::DeploymentGroupDoesNotExistException),
    /// <p> The specified ARN is not in a valid format. </p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p> The specified tags are not valid. </p>
    InvalidTagsToAddException(crate::error::InvalidTagsToAddException),
    /// <p> The ARN of a resource is required, but was not found. </p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// <p>A tag was not specified.</p>
    TagRequiredException(crate::error::TagRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UntagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ArnNotSupportedException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidArnException(_inner) => _inner.fmt(f),
            Self::InvalidTagsToAddException(_inner) => _inner.fmt(f),
            Self::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            Self::TagRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UntagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ArnNotSupportedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagsToAddException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UntagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ArnNotSupportedException(e) => e.meta(),
            Self::DeploymentConfigDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupDoesNotExistException(e) => e.meta(),
            Self::InvalidArnException(e) => e.meta(),
            Self::InvalidTagsToAddException(e) => e.meta(),
            Self::ResourceArnRequiredException(e) => e.meta(),
            Self::TagRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UntagResourceError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::ArnNotSupportedException`.
    pub fn is_arn_not_supported_exception(&self) -> bool {
        matches!(self, Self::ArnNotSupportedException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::DeploymentGroupDoesNotExistException`.
    pub fn is_deployment_group_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidArnException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::InvalidTagsToAddException`.
    pub fn is_invalid_tags_to_add_exception(&self) -> bool {
        matches!(self, Self::InvalidTagsToAddException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::ResourceArnRequiredException`.
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(self, Self::ResourceArnRequiredException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::TagRequiredException`.
    pub fn is_tag_required_exception(&self) -> bool {
        matches!(self, Self::TagRequiredException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ArnNotSupportedException(_inner) => Some(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidArnException(_inner) => Some(_inner),
            Self::InvalidTagsToAddException(_inner) => Some(_inner),
            Self::ResourceArnRequiredException(_inner) => Some(_inner),
            Self::TagRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A tag was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagRequiredException")?;
        if let Some(inner_33) = &self.message {
            {
                write!(f, ": {}", inner_33)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagRequiredException {}
impl aws_http::request_id::RequestId for crate::error::TagRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TagRequiredException {
    /// Creates a new builder-style object to manufacture [`TagRequiredException`](crate::error::TagRequiredException).
    pub fn builder() -> crate::error::tag_required_exception::Builder {
        crate::error::tag_required_exception::Builder::default()
    }
}

/// See [`TagRequiredException`](crate::error::TagRequiredException).
pub mod tag_required_exception {

    /// A builder for [`TagRequiredException`](crate::error::TagRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TagRequiredException`](crate::error::TagRequiredException).
        pub fn build(self) -> crate::error::TagRequiredException {
            crate::error::TagRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> The ARN of a resource is required, but was not found. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceArnRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceArnRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceArnRequiredException")?;
        if let Some(inner_34) = &self.message {
            {
                write!(f, ": {}", inner_34)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceArnRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ResourceArnRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceArnRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ResourceArnRequiredException {
    /// Creates a new builder-style object to manufacture [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException).
    pub fn builder() -> crate::error::resource_arn_required_exception::Builder {
        crate::error::resource_arn_required_exception::Builder::default()
    }
}

/// See [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException).
pub mod resource_arn_required_exception {

    /// A builder for [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException).
        pub fn build(self) -> crate::error::ResourceArnRequiredException {
            crate::error::ResourceArnRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> The specified tags are not valid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTagsToAddException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTagsToAddException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagsToAddException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagsToAddException")?;
        if let Some(inner_35) = &self.message {
            {
                write!(f, ": {}", inner_35)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagsToAddException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTagsToAddException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTagsToAddException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTagsToAddException {
    /// Creates a new builder-style object to manufacture [`InvalidTagsToAddException`](crate::error::InvalidTagsToAddException).
    pub fn builder() -> crate::error::invalid_tags_to_add_exception::Builder {
        crate::error::invalid_tags_to_add_exception::Builder::default()
    }
}

/// See [`InvalidTagsToAddException`](crate::error::InvalidTagsToAddException).
pub mod invalid_tags_to_add_exception {

    /// A builder for [`InvalidTagsToAddException`](crate::error::InvalidTagsToAddException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagsToAddException`](crate::error::InvalidTagsToAddException).
        pub fn build(self) -> crate::error::InvalidTagsToAddException {
            crate::error::InvalidTagsToAddException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> The specified ARN is not in a valid format. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidArnException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidArnException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidArnException")?;
        if let Some(inner_36) = &self.message {
            {
                write!(f, ": {}", inner_36)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidArnException {}
impl aws_http::request_id::RequestId for crate::error::InvalidArnException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidArnException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidArnException {
    /// Creates a new builder-style object to manufacture [`InvalidArnException`](crate::error::InvalidArnException).
    pub fn builder() -> crate::error::invalid_arn_exception::Builder {
        crate::error::invalid_arn_exception::Builder::default()
    }
}

/// See [`InvalidArnException`](crate::error::InvalidArnException).
pub mod invalid_arn_exception {

    /// A builder for [`InvalidArnException`](crate::error::InvalidArnException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidArnException`](crate::error::InvalidArnException).
        pub fn build(self) -> crate::error::InvalidArnException {
            crate::error::InvalidArnException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> The specified ARN is not supported. For example, it might be an ARN for a resource that is not expected. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ArnNotSupportedException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ArnNotSupportedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ArnNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ArnNotSupportedException")?;
        if let Some(inner_37) = &self.message {
            {
                write!(f, ": {}", inner_37)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ArnNotSupportedException {}
impl aws_http::request_id::RequestId for crate::error::ArnNotSupportedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ArnNotSupportedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ArnNotSupportedException {
    /// Creates a new builder-style object to manufacture [`ArnNotSupportedException`](crate::error::ArnNotSupportedException).
    pub fn builder() -> crate::error::arn_not_supported_exception::Builder {
        crate::error::arn_not_supported_exception::Builder::default()
    }
}

/// See [`ArnNotSupportedException`](crate::error::ArnNotSupportedException).
pub mod arn_not_supported_exception {

    /// A builder for [`ArnNotSupportedException`](crate::error::ArnNotSupportedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ArnNotSupportedException`](crate::error::ArnNotSupportedException).
        pub fn build(self) -> crate::error::ArnNotSupportedException {
            crate::error::ArnNotSupportedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type TagResourceErrorKind = TagResourceError;
/// Error type for the `TagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p> The specified ARN is not supported. For example, it might be an ARN for a resource that is not expected. </p>
    ArnNotSupportedException(crate::error::ArnNotSupportedException),
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::error::DeploymentConfigDoesNotExistException),
    /// <p>The named deployment group with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentGroupDoesNotExistException(crate::error::DeploymentGroupDoesNotExistException),
    /// <p> The specified ARN is not in a valid format. </p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p> The specified tags are not valid. </p>
    InvalidTagsToAddException(crate::error::InvalidTagsToAddException),
    /// <p> The ARN of a resource is required, but was not found. </p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// <p>A tag was not specified.</p>
    TagRequiredException(crate::error::TagRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ArnNotSupportedException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidArnException(_inner) => _inner.fmt(f),
            Self::InvalidTagsToAddException(_inner) => _inner.fmt(f),
            Self::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            Self::TagRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ArnNotSupportedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagsToAddException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ArnNotSupportedException(e) => e.meta(),
            Self::DeploymentConfigDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupDoesNotExistException(e) => e.meta(),
            Self::InvalidArnException(e) => e.meta(),
            Self::InvalidTagsToAddException(e) => e.meta(),
            Self::ResourceArnRequiredException(e) => e.meta(),
            Self::TagRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TagResourceError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::ArnNotSupportedException`.
    pub fn is_arn_not_supported_exception(&self) -> bool {
        matches!(self, Self::ArnNotSupportedException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::DeploymentGroupDoesNotExistException`.
    pub fn is_deployment_group_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidArnException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::InvalidTagsToAddException`.
    pub fn is_invalid_tags_to_add_exception(&self) -> bool {
        matches!(self, Self::InvalidTagsToAddException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::ResourceArnRequiredException`.
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(self, Self::ResourceArnRequiredException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::TagRequiredException`.
    pub fn is_tag_required_exception(&self) -> bool {
        matches!(self, Self::TagRequiredException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ArnNotSupportedException(_inner) => Some(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidArnException(_inner) => Some(_inner),
            Self::InvalidTagsToAddException(_inner) => Some(_inner),
            Self::ResourceArnRequiredException(_inner) => Some(_inner),
            Self::TagRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type StopDeploymentErrorKind = StopDeploymentError;
/// Error type for the `StopDeploymentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopDeploymentError {
    /// <p>The deployment is already complete.</p>
    DeploymentAlreadyCompletedException(crate::error::DeploymentAlreadyCompletedException),
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>The named deployment group with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentGroupDoesNotExistException(crate::error::DeploymentGroupDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p>A call was submitted that is not supported for the specified deployment type.</p>
    UnsupportedActionForDeploymentTypeException(
        crate::error::UnsupportedActionForDeploymentTypeException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for StopDeploymentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for StopDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentAlreadyCompletedException(_inner) => _inner.fmt(f),
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::UnsupportedActionForDeploymentTypeException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for StopDeploymentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentAlreadyCompletedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedActionForDeploymentTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::StopDeploymentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for StopDeploymentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopDeploymentError {
    /// Creates the `StopDeploymentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `StopDeploymentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentAlreadyCompletedException(e) => e.meta(),
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::UnsupportedActionForDeploymentTypeException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `StopDeploymentError::DeploymentAlreadyCompletedException`.
    pub fn is_deployment_already_completed_exception(&self) -> bool {
        matches!(self, Self::DeploymentAlreadyCompletedException(_))
    }
    /// Returns `true` if the error kind is `StopDeploymentError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `StopDeploymentError::DeploymentGroupDoesNotExistException`.
    pub fn is_deployment_group_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `StopDeploymentError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `StopDeploymentError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `StopDeploymentError::UnsupportedActionForDeploymentTypeException`.
    pub fn is_unsupported_action_for_deployment_type_exception(&self) -> bool {
        matches!(self, Self::UnsupportedActionForDeploymentTypeException(_))
    }
}
impl std::error::Error for StopDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentAlreadyCompletedException(_inner) => Some(_inner),
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::UnsupportedActionForDeploymentTypeException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A call was submitted that is not supported for the specified deployment type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UnsupportedActionForDeploymentTypeException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl UnsupportedActionForDeploymentTypeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for UnsupportedActionForDeploymentTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedActionForDeploymentTypeException")?;
        if let Some(inner_38) = &self.message {
            {
                write!(f, ": {}", inner_38)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for UnsupportedActionForDeploymentTypeException {}
impl aws_http::request_id::RequestId for crate::error::UnsupportedActionForDeploymentTypeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UnsupportedActionForDeploymentTypeException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl UnsupportedActionForDeploymentTypeException {
    /// Creates a new builder-style object to manufacture [`UnsupportedActionForDeploymentTypeException`](crate::error::UnsupportedActionForDeploymentTypeException).
    pub fn builder() -> crate::error::unsupported_action_for_deployment_type_exception::Builder {
        crate::error::unsupported_action_for_deployment_type_exception::Builder::default()
    }
}

/// See [`UnsupportedActionForDeploymentTypeException`](crate::error::UnsupportedActionForDeploymentTypeException).
pub mod unsupported_action_for_deployment_type_exception {

    /// A builder for [`UnsupportedActionForDeploymentTypeException`](crate::error::UnsupportedActionForDeploymentTypeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedActionForDeploymentTypeException`](crate::error::UnsupportedActionForDeploymentTypeException).
        pub fn build(self) -> crate::error::UnsupportedActionForDeploymentTypeException {
            crate::error::UnsupportedActionForDeploymentTypeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>At least one of the deployment IDs was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDeploymentIdException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDeploymentIdException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeploymentIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeploymentIdException")?;
        if let Some(inner_39) = &self.message {
            {
                write!(f, ": {}", inner_39)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeploymentIdException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDeploymentIdException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDeploymentIdException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDeploymentIdException {
    /// Creates a new builder-style object to manufacture [`InvalidDeploymentIdException`](crate::error::InvalidDeploymentIdException).
    pub fn builder() -> crate::error::invalid_deployment_id_exception::Builder {
        crate::error::invalid_deployment_id_exception::Builder::default()
    }
}

/// See [`InvalidDeploymentIdException`](crate::error::InvalidDeploymentIdException).
pub mod invalid_deployment_id_exception {

    /// A builder for [`InvalidDeploymentIdException`](crate::error::InvalidDeploymentIdException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeploymentIdException`](crate::error::InvalidDeploymentIdException).
        pub fn build(self) -> crate::error::InvalidDeploymentIdException {
            crate::error::InvalidDeploymentIdException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>At least one deployment ID must be specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentIdRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentIdRequiredException")?;
        if let Some(inner_40) = &self.message {
            {
                write!(f, ": {}", inner_40)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentIdRequiredException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentIdRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeploymentIdRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentIdRequiredException {
    /// Creates a new builder-style object to manufacture [`DeploymentIdRequiredException`](crate::error::DeploymentIdRequiredException).
    pub fn builder() -> crate::error::deployment_id_required_exception::Builder {
        crate::error::deployment_id_required_exception::Builder::default()
    }
}

/// See [`DeploymentIdRequiredException`](crate::error::DeploymentIdRequiredException).
pub mod deployment_id_required_exception {

    /// A builder for [`DeploymentIdRequiredException`](crate::error::DeploymentIdRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentIdRequiredException`](crate::error::DeploymentIdRequiredException).
        pub fn build(self) -> crate::error::DeploymentIdRequiredException {
            crate::error::DeploymentIdRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentDoesNotExistException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentDoesNotExistException")?;
        if let Some(inner_41) = &self.message {
            {
                write!(f, ": {}", inner_41)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeploymentDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`DeploymentDoesNotExistException`](crate::error::DeploymentDoesNotExistException).
    pub fn builder() -> crate::error::deployment_does_not_exist_exception::Builder {
        crate::error::deployment_does_not_exist_exception::Builder::default()
    }
}

/// See [`DeploymentDoesNotExistException`](crate::error::DeploymentDoesNotExistException).
pub mod deployment_does_not_exist_exception {

    /// A builder for [`DeploymentDoesNotExistException`](crate::error::DeploymentDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentDoesNotExistException`](crate::error::DeploymentDoesNotExistException).
        pub fn build(self) -> crate::error::DeploymentDoesNotExistException {
            crate::error::DeploymentDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The deployment is already complete.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentAlreadyCompletedException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentAlreadyCompletedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentAlreadyCompletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentAlreadyCompletedException")?;
        if let Some(inner_42) = &self.message {
            {
                write!(f, ": {}", inner_42)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentAlreadyCompletedException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentAlreadyCompletedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentAlreadyCompletedException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentAlreadyCompletedException {
    /// Creates a new builder-style object to manufacture [`DeploymentAlreadyCompletedException`](crate::error::DeploymentAlreadyCompletedException).
    pub fn builder() -> crate::error::deployment_already_completed_exception::Builder {
        crate::error::deployment_already_completed_exception::Builder::default()
    }
}

/// See [`DeploymentAlreadyCompletedException`](crate::error::DeploymentAlreadyCompletedException).
pub mod deployment_already_completed_exception {

    /// A builder for [`DeploymentAlreadyCompletedException`](crate::error::DeploymentAlreadyCompletedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentAlreadyCompletedException`](crate::error::DeploymentAlreadyCompletedException).
        pub fn build(self) -> crate::error::DeploymentAlreadyCompletedException {
            crate::error::DeploymentAlreadyCompletedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type SkipWaitTimeForInstanceTerminationErrorKind = SkipWaitTimeForInstanceTerminationError;
/// Error type for the `SkipWaitTimeForInstanceTerminationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SkipWaitTimeForInstanceTerminationError {
    /// <p>The deployment is already complete.</p>
    DeploymentAlreadyCompletedException(crate::error::DeploymentAlreadyCompletedException),
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>The specified deployment has not started.</p>
    DeploymentNotStartedException(crate::error::DeploymentNotStartedException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p>A call was submitted that is not supported for the specified deployment type.</p>
    UnsupportedActionForDeploymentTypeException(
        crate::error::UnsupportedActionForDeploymentTypeException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for SkipWaitTimeForInstanceTerminationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for SkipWaitTimeForInstanceTerminationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentAlreadyCompletedException(_inner) => _inner.fmt(f),
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentNotStartedException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::UnsupportedActionForDeploymentTypeException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for SkipWaitTimeForInstanceTerminationError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentAlreadyCompletedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentNotStartedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedActionForDeploymentTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::SkipWaitTimeForInstanceTerminationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for SkipWaitTimeForInstanceTerminationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl SkipWaitTimeForInstanceTerminationError {
    /// Creates the `SkipWaitTimeForInstanceTerminationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `SkipWaitTimeForInstanceTerminationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentAlreadyCompletedException(e) => e.meta(),
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::DeploymentNotStartedException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::UnsupportedActionForDeploymentTypeException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `SkipWaitTimeForInstanceTerminationError::DeploymentAlreadyCompletedException`.
    pub fn is_deployment_already_completed_exception(&self) -> bool {
        matches!(self, Self::DeploymentAlreadyCompletedException(_))
    }
    /// Returns `true` if the error kind is `SkipWaitTimeForInstanceTerminationError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `SkipWaitTimeForInstanceTerminationError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `SkipWaitTimeForInstanceTerminationError::DeploymentNotStartedException`.
    pub fn is_deployment_not_started_exception(&self) -> bool {
        matches!(self, Self::DeploymentNotStartedException(_))
    }
    /// Returns `true` if the error kind is `SkipWaitTimeForInstanceTerminationError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `SkipWaitTimeForInstanceTerminationError::UnsupportedActionForDeploymentTypeException`.
    pub fn is_unsupported_action_for_deployment_type_exception(&self) -> bool {
        matches!(self, Self::UnsupportedActionForDeploymentTypeException(_))
    }
}
impl std::error::Error for SkipWaitTimeForInstanceTerminationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentAlreadyCompletedException(_inner) => Some(_inner),
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::DeploymentNotStartedException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::UnsupportedActionForDeploymentTypeException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified deployment has not started.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentNotStartedException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentNotStartedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentNotStartedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentNotStartedException")?;
        if let Some(inner_43) = &self.message {
            {
                write!(f, ": {}", inner_43)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentNotStartedException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentNotStartedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeploymentNotStartedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentNotStartedException {
    /// Creates a new builder-style object to manufacture [`DeploymentNotStartedException`](crate::error::DeploymentNotStartedException).
    pub fn builder() -> crate::error::deployment_not_started_exception::Builder {
        crate::error::deployment_not_started_exception::Builder::default()
    }
}

/// See [`DeploymentNotStartedException`](crate::error::DeploymentNotStartedException).
pub mod deployment_not_started_exception {

    /// A builder for [`DeploymentNotStartedException`](crate::error::DeploymentNotStartedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentNotStartedException`](crate::error::DeploymentNotStartedException).
        pub fn build(self) -> crate::error::DeploymentNotStartedException {
            crate::error::DeploymentNotStartedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RemoveTagsFromOnPremisesInstancesErrorKind = RemoveTagsFromOnPremisesInstancesError;
/// Error type for the `RemoveTagsFromOnPremisesInstancesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveTagsFromOnPremisesInstancesError {
    /// <p>The maximum number of allowed on-premises instances in a single call was exceeded.</p>
    InstanceLimitExceededException(crate::error::InstanceLimitExceededException),
    /// <p>An on-premises instance name was not specified.</p>
    InstanceNameRequiredException(crate::error::InstanceNameRequiredException),
    /// <p>The specified on-premises instance is not registered.</p>
    InstanceNotRegisteredException(crate::error::InstanceNotRegisteredException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p>The maximum allowed number of tags was exceeded.</p>
    TagLimitExceededException(crate::error::TagLimitExceededException),
    /// <p>A tag was not specified.</p>
    TagRequiredException(crate::error::TagRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RemoveTagsFromOnPremisesInstancesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RemoveTagsFromOnPremisesInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InstanceLimitExceededException(_inner) => _inner.fmt(f),
            Self::InstanceNameRequiredException(_inner) => _inner.fmt(f),
            Self::InstanceNotRegisteredException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceNameException(_inner) => _inner.fmt(f),
            Self::InvalidTagException(_inner) => _inner.fmt(f),
            Self::TagLimitExceededException(_inner) => _inner.fmt(f),
            Self::TagRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RemoveTagsFromOnPremisesInstancesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InstanceLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceNotRegisteredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RemoveTagsFromOnPremisesInstancesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RemoveTagsFromOnPremisesInstancesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveTagsFromOnPremisesInstancesError {
    /// Creates the `RemoveTagsFromOnPremisesInstancesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RemoveTagsFromOnPremisesInstancesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InstanceLimitExceededException(e) => e.meta(),
            Self::InstanceNameRequiredException(e) => e.meta(),
            Self::InstanceNotRegisteredException(e) => e.meta(),
            Self::InvalidInstanceNameException(e) => e.meta(),
            Self::InvalidTagException(e) => e.meta(),
            Self::TagLimitExceededException(e) => e.meta(),
            Self::TagRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RemoveTagsFromOnPremisesInstancesError::InstanceLimitExceededException`.
    pub fn is_instance_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::InstanceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromOnPremisesInstancesError::InstanceNameRequiredException`.
    pub fn is_instance_name_required_exception(&self) -> bool {
        matches!(self, Self::InstanceNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromOnPremisesInstancesError::InstanceNotRegisteredException`.
    pub fn is_instance_not_registered_exception(&self) -> bool {
        matches!(self, Self::InstanceNotRegisteredException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromOnPremisesInstancesError::InvalidInstanceNameException`.
    pub fn is_invalid_instance_name_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceNameException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromOnPremisesInstancesError::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidTagException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromOnPremisesInstancesError::TagLimitExceededException`.
    pub fn is_tag_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TagLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `RemoveTagsFromOnPremisesInstancesError::TagRequiredException`.
    pub fn is_tag_required_exception(&self) -> bool {
        matches!(self, Self::TagRequiredException(_))
    }
}
impl std::error::Error for RemoveTagsFromOnPremisesInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InstanceLimitExceededException(_inner) => Some(_inner),
            Self::InstanceNameRequiredException(_inner) => Some(_inner),
            Self::InstanceNotRegisteredException(_inner) => Some(_inner),
            Self::InvalidInstanceNameException(_inner) => Some(_inner),
            Self::InvalidTagException(_inner) => Some(_inner),
            Self::TagLimitExceededException(_inner) => Some(_inner),
            Self::TagRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum allowed number of tags was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagLimitExceededException")?;
        if let Some(inner_44) = &self.message {
            {
                write!(f, ": {}", inner_44)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::TagLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl TagLimitExceededException {
    /// Creates a new builder-style object to manufacture [`TagLimitExceededException`](crate::error::TagLimitExceededException).
    pub fn builder() -> crate::error::tag_limit_exceeded_exception::Builder {
        crate::error::tag_limit_exceeded_exception::Builder::default()
    }
}

/// See [`TagLimitExceededException`](crate::error::TagLimitExceededException).
pub mod tag_limit_exceeded_exception {

    /// A builder for [`TagLimitExceededException`](crate::error::TagLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TagLimitExceededException`](crate::error::TagLimitExceededException).
        pub fn build(self) -> crate::error::TagLimitExceededException {
            crate::error::TagLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The on-premises instance name was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidInstanceNameException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidInstanceNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInstanceNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInstanceNameException")?;
        if let Some(inner_45) = &self.message {
            {
                write!(f, ": {}", inner_45)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInstanceNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidInstanceNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidInstanceNameException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidInstanceNameException {
    /// Creates a new builder-style object to manufacture [`InvalidInstanceNameException`](crate::error::InvalidInstanceNameException).
    pub fn builder() -> crate::error::invalid_instance_name_exception::Builder {
        crate::error::invalid_instance_name_exception::Builder::default()
    }
}

/// See [`InvalidInstanceNameException`](crate::error::InvalidInstanceNameException).
pub mod invalid_instance_name_exception {

    /// A builder for [`InvalidInstanceNameException`](crate::error::InvalidInstanceNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInstanceNameException`](crate::error::InvalidInstanceNameException).
        pub fn build(self) -> crate::error::InvalidInstanceNameException {
            crate::error::InvalidInstanceNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified on-premises instance is not registered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceNotRegisteredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InstanceNotRegisteredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstanceNotRegisteredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstanceNotRegisteredException")?;
        if let Some(inner_46) = &self.message {
            {
                write!(f, ": {}", inner_46)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InstanceNotRegisteredException {}
impl aws_http::request_id::RequestId for crate::error::InstanceNotRegisteredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InstanceNotRegisteredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InstanceNotRegisteredException {
    /// Creates a new builder-style object to manufacture [`InstanceNotRegisteredException`](crate::error::InstanceNotRegisteredException).
    pub fn builder() -> crate::error::instance_not_registered_exception::Builder {
        crate::error::instance_not_registered_exception::Builder::default()
    }
}

/// See [`InstanceNotRegisteredException`](crate::error::InstanceNotRegisteredException).
pub mod instance_not_registered_exception {

    /// A builder for [`InstanceNotRegisteredException`](crate::error::InstanceNotRegisteredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InstanceNotRegisteredException`](crate::error::InstanceNotRegisteredException).
        pub fn build(self) -> crate::error::InstanceNotRegisteredException {
            crate::error::InstanceNotRegisteredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An on-premises instance name was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceNameRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InstanceNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstanceNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstanceNameRequiredException")?;
        if let Some(inner_47) = &self.message {
            {
                write!(f, ": {}", inner_47)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InstanceNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::InstanceNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InstanceNameRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InstanceNameRequiredException {
    /// Creates a new builder-style object to manufacture [`InstanceNameRequiredException`](crate::error::InstanceNameRequiredException).
    pub fn builder() -> crate::error::instance_name_required_exception::Builder {
        crate::error::instance_name_required_exception::Builder::default()
    }
}

/// See [`InstanceNameRequiredException`](crate::error::InstanceNameRequiredException).
pub mod instance_name_required_exception {

    /// A builder for [`InstanceNameRequiredException`](crate::error::InstanceNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InstanceNameRequiredException`](crate::error::InstanceNameRequiredException).
        pub fn build(self) -> crate::error::InstanceNameRequiredException {
            crate::error::InstanceNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The maximum number of allowed on-premises instances in a single call was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InstanceLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstanceLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstanceLimitExceededException")?;
        if let Some(inner_48) = &self.message {
            {
                write!(f, ": {}", inner_48)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InstanceLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::InstanceLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InstanceLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InstanceLimitExceededException {
    /// Creates a new builder-style object to manufacture [`InstanceLimitExceededException`](crate::error::InstanceLimitExceededException).
    pub fn builder() -> crate::error::instance_limit_exceeded_exception::Builder {
        crate::error::instance_limit_exceeded_exception::Builder::default()
    }
}

/// See [`InstanceLimitExceededException`](crate::error::InstanceLimitExceededException).
pub mod instance_limit_exceeded_exception {

    /// A builder for [`InstanceLimitExceededException`](crate::error::InstanceLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InstanceLimitExceededException`](crate::error::InstanceLimitExceededException).
        pub fn build(self) -> crate::error::InstanceLimitExceededException {
            crate::error::InstanceLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RegisterOnPremisesInstanceErrorKind = RegisterOnPremisesInstanceError;
/// Error type for the `RegisterOnPremisesInstanceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterOnPremisesInstanceError {
    /// <p>No IAM ARN was included in the request. You must use an IAM session ARN or IAM user ARN in the request.</p>
    IamArnRequiredException(crate::error::IamArnRequiredException),
    /// <p>The request included an IAM session ARN that has already been used to register a different instance.</p>
    IamSessionArnAlreadyRegisteredException(crate::error::IamSessionArnAlreadyRegisteredException),
    /// <p>The specified IAM user ARN is already registered with an on-premises instance.</p>
    IamUserArnAlreadyRegisteredException(crate::error::IamUserArnAlreadyRegisteredException),
    /// <p>An IAM user ARN was not specified.</p>
    IamUserArnRequiredException(crate::error::IamUserArnRequiredException),
    /// <p>The specified on-premises instance name is already registered.</p>
    InstanceNameAlreadyRegisteredException(crate::error::InstanceNameAlreadyRegisteredException),
    /// <p>An on-premises instance name was not specified.</p>
    InstanceNameRequiredException(crate::error::InstanceNameRequiredException),
    /// <p>The IAM session ARN was specified in an invalid format.</p>
    InvalidIamSessionArnException(crate::error::InvalidIamSessionArnException),
    /// <p>The IAM user ARN was specified in an invalid format.</p>
    InvalidIamUserArnException(crate::error::InvalidIamUserArnException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// <p>Both an IAM user ARN and an IAM session ARN were included in the request. Use only one ARN type.</p>
    MultipleIamArnsProvidedException(crate::error::MultipleIamArnsProvidedException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RegisterOnPremisesInstanceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RegisterOnPremisesInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::IamArnRequiredException(_inner) => _inner.fmt(f),
            Self::IamSessionArnAlreadyRegisteredException(_inner) => _inner.fmt(f),
            Self::IamUserArnAlreadyRegisteredException(_inner) => _inner.fmt(f),
            Self::IamUserArnRequiredException(_inner) => _inner.fmt(f),
            Self::InstanceNameAlreadyRegisteredException(_inner) => _inner.fmt(f),
            Self::InstanceNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidIamSessionArnException(_inner) => _inner.fmt(f),
            Self::InvalidIamUserArnException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceNameException(_inner) => _inner.fmt(f),
            Self::MultipleIamArnsProvidedException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RegisterOnPremisesInstanceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::IamArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IamSessionArnAlreadyRegisteredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IamUserArnAlreadyRegisteredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IamUserArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceNameAlreadyRegisteredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIamSessionArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIamUserArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MultipleIamArnsProvidedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RegisterOnPremisesInstanceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterOnPremisesInstanceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterOnPremisesInstanceError {
    /// Creates the `RegisterOnPremisesInstanceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RegisterOnPremisesInstanceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::IamArnRequiredException(e) => e.meta(),
            Self::IamSessionArnAlreadyRegisteredException(e) => e.meta(),
            Self::IamUserArnAlreadyRegisteredException(e) => e.meta(),
            Self::IamUserArnRequiredException(e) => e.meta(),
            Self::InstanceNameAlreadyRegisteredException(e) => e.meta(),
            Self::InstanceNameRequiredException(e) => e.meta(),
            Self::InvalidIamSessionArnException(e) => e.meta(),
            Self::InvalidIamUserArnException(e) => e.meta(),
            Self::InvalidInstanceNameException(e) => e.meta(),
            Self::MultipleIamArnsProvidedException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RegisterOnPremisesInstanceError::IamArnRequiredException`.
    pub fn is_iam_arn_required_exception(&self) -> bool {
        matches!(self, Self::IamArnRequiredException(_))
    }
    /// Returns `true` if the error kind is `RegisterOnPremisesInstanceError::IamSessionArnAlreadyRegisteredException`.
    pub fn is_iam_session_arn_already_registered_exception(&self) -> bool {
        matches!(self, Self::IamSessionArnAlreadyRegisteredException(_))
    }
    /// Returns `true` if the error kind is `RegisterOnPremisesInstanceError::IamUserArnAlreadyRegisteredException`.
    pub fn is_iam_user_arn_already_registered_exception(&self) -> bool {
        matches!(self, Self::IamUserArnAlreadyRegisteredException(_))
    }
    /// Returns `true` if the error kind is `RegisterOnPremisesInstanceError::IamUserArnRequiredException`.
    pub fn is_iam_user_arn_required_exception(&self) -> bool {
        matches!(self, Self::IamUserArnRequiredException(_))
    }
    /// Returns `true` if the error kind is `RegisterOnPremisesInstanceError::InstanceNameAlreadyRegisteredException`.
    pub fn is_instance_name_already_registered_exception(&self) -> bool {
        matches!(self, Self::InstanceNameAlreadyRegisteredException(_))
    }
    /// Returns `true` if the error kind is `RegisterOnPremisesInstanceError::InstanceNameRequiredException`.
    pub fn is_instance_name_required_exception(&self) -> bool {
        matches!(self, Self::InstanceNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `RegisterOnPremisesInstanceError::InvalidIamSessionArnException`.
    pub fn is_invalid_iam_session_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidIamSessionArnException(_))
    }
    /// Returns `true` if the error kind is `RegisterOnPremisesInstanceError::InvalidIamUserArnException`.
    pub fn is_invalid_iam_user_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidIamUserArnException(_))
    }
    /// Returns `true` if the error kind is `RegisterOnPremisesInstanceError::InvalidInstanceNameException`.
    pub fn is_invalid_instance_name_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceNameException(_))
    }
    /// Returns `true` if the error kind is `RegisterOnPremisesInstanceError::MultipleIamArnsProvidedException`.
    pub fn is_multiple_iam_arns_provided_exception(&self) -> bool {
        matches!(self, Self::MultipleIamArnsProvidedException(_))
    }
}
impl std::error::Error for RegisterOnPremisesInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::IamArnRequiredException(_inner) => Some(_inner),
            Self::IamSessionArnAlreadyRegisteredException(_inner) => Some(_inner),
            Self::IamUserArnAlreadyRegisteredException(_inner) => Some(_inner),
            Self::IamUserArnRequiredException(_inner) => Some(_inner),
            Self::InstanceNameAlreadyRegisteredException(_inner) => Some(_inner),
            Self::InstanceNameRequiredException(_inner) => Some(_inner),
            Self::InvalidIamSessionArnException(_inner) => Some(_inner),
            Self::InvalidIamUserArnException(_inner) => Some(_inner),
            Self::InvalidInstanceNameException(_inner) => Some(_inner),
            Self::MultipleIamArnsProvidedException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Both an IAM user ARN and an IAM session ARN were included in the request. Use only one ARN type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MultipleIamArnsProvidedException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MultipleIamArnsProvidedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MultipleIamArnsProvidedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MultipleIamArnsProvidedException")?;
        if let Some(inner_49) = &self.message {
            {
                write!(f, ": {}", inner_49)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MultipleIamArnsProvidedException {}
impl aws_http::request_id::RequestId for crate::error::MultipleIamArnsProvidedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MultipleIamArnsProvidedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl MultipleIamArnsProvidedException {
    /// Creates a new builder-style object to manufacture [`MultipleIamArnsProvidedException`](crate::error::MultipleIamArnsProvidedException).
    pub fn builder() -> crate::error::multiple_iam_arns_provided_exception::Builder {
        crate::error::multiple_iam_arns_provided_exception::Builder::default()
    }
}

/// See [`MultipleIamArnsProvidedException`](crate::error::MultipleIamArnsProvidedException).
pub mod multiple_iam_arns_provided_exception {

    /// A builder for [`MultipleIamArnsProvidedException`](crate::error::MultipleIamArnsProvidedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MultipleIamArnsProvidedException`](crate::error::MultipleIamArnsProvidedException).
        pub fn build(self) -> crate::error::MultipleIamArnsProvidedException {
            crate::error::MultipleIamArnsProvidedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The IAM user ARN was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidIamUserArnException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidIamUserArnException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidIamUserArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidIamUserArnException")?;
        if let Some(inner_50) = &self.message {
            {
                write!(f, ": {}", inner_50)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidIamUserArnException {}
impl aws_http::request_id::RequestId for crate::error::InvalidIamUserArnException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidIamUserArnException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidIamUserArnException {
    /// Creates a new builder-style object to manufacture [`InvalidIamUserArnException`](crate::error::InvalidIamUserArnException).
    pub fn builder() -> crate::error::invalid_iam_user_arn_exception::Builder {
        crate::error::invalid_iam_user_arn_exception::Builder::default()
    }
}

/// See [`InvalidIamUserArnException`](crate::error::InvalidIamUserArnException).
pub mod invalid_iam_user_arn_exception {

    /// A builder for [`InvalidIamUserArnException`](crate::error::InvalidIamUserArnException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidIamUserArnException`](crate::error::InvalidIamUserArnException).
        pub fn build(self) -> crate::error::InvalidIamUserArnException {
            crate::error::InvalidIamUserArnException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The IAM session ARN was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidIamSessionArnException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidIamSessionArnException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidIamSessionArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidIamSessionArnException")?;
        if let Some(inner_51) = &self.message {
            {
                write!(f, ": {}", inner_51)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidIamSessionArnException {}
impl aws_http::request_id::RequestId for crate::error::InvalidIamSessionArnException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidIamSessionArnException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidIamSessionArnException {
    /// Creates a new builder-style object to manufacture [`InvalidIamSessionArnException`](crate::error::InvalidIamSessionArnException).
    pub fn builder() -> crate::error::invalid_iam_session_arn_exception::Builder {
        crate::error::invalid_iam_session_arn_exception::Builder::default()
    }
}

/// See [`InvalidIamSessionArnException`](crate::error::InvalidIamSessionArnException).
pub mod invalid_iam_session_arn_exception {

    /// A builder for [`InvalidIamSessionArnException`](crate::error::InvalidIamSessionArnException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidIamSessionArnException`](crate::error::InvalidIamSessionArnException).
        pub fn build(self) -> crate::error::InvalidIamSessionArnException {
            crate::error::InvalidIamSessionArnException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified on-premises instance name is already registered.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceNameAlreadyRegisteredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InstanceNameAlreadyRegisteredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstanceNameAlreadyRegisteredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstanceNameAlreadyRegisteredException")?;
        if let Some(inner_52) = &self.message {
            {
                write!(f, ": {}", inner_52)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InstanceNameAlreadyRegisteredException {}
impl aws_http::request_id::RequestId for crate::error::InstanceNameAlreadyRegisteredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InstanceNameAlreadyRegisteredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InstanceNameAlreadyRegisteredException {
    /// Creates a new builder-style object to manufacture [`InstanceNameAlreadyRegisteredException`](crate::error::InstanceNameAlreadyRegisteredException).
    pub fn builder() -> crate::error::instance_name_already_registered_exception::Builder {
        crate::error::instance_name_already_registered_exception::Builder::default()
    }
}

/// See [`InstanceNameAlreadyRegisteredException`](crate::error::InstanceNameAlreadyRegisteredException).
pub mod instance_name_already_registered_exception {

    /// A builder for [`InstanceNameAlreadyRegisteredException`](crate::error::InstanceNameAlreadyRegisteredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InstanceNameAlreadyRegisteredException`](crate::error::InstanceNameAlreadyRegisteredException).
        pub fn build(self) -> crate::error::InstanceNameAlreadyRegisteredException {
            crate::error::InstanceNameAlreadyRegisteredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An IAM user ARN was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IamUserArnRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IamUserArnRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IamUserArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IamUserArnRequiredException")?;
        if let Some(inner_53) = &self.message {
            {
                write!(f, ": {}", inner_53)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IamUserArnRequiredException {}
impl aws_http::request_id::RequestId for crate::error::IamUserArnRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IamUserArnRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl IamUserArnRequiredException {
    /// Creates a new builder-style object to manufacture [`IamUserArnRequiredException`](crate::error::IamUserArnRequiredException).
    pub fn builder() -> crate::error::iam_user_arn_required_exception::Builder {
        crate::error::iam_user_arn_required_exception::Builder::default()
    }
}

/// See [`IamUserArnRequiredException`](crate::error::IamUserArnRequiredException).
pub mod iam_user_arn_required_exception {

    /// A builder for [`IamUserArnRequiredException`](crate::error::IamUserArnRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IamUserArnRequiredException`](crate::error::IamUserArnRequiredException).
        pub fn build(self) -> crate::error::IamUserArnRequiredException {
            crate::error::IamUserArnRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified IAM user ARN is already registered with an on-premises instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IamUserArnAlreadyRegisteredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IamUserArnAlreadyRegisteredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IamUserArnAlreadyRegisteredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IamUserArnAlreadyRegisteredException")?;
        if let Some(inner_54) = &self.message {
            {
                write!(f, ": {}", inner_54)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IamUserArnAlreadyRegisteredException {}
impl aws_http::request_id::RequestId for crate::error::IamUserArnAlreadyRegisteredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for IamUserArnAlreadyRegisteredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl IamUserArnAlreadyRegisteredException {
    /// Creates a new builder-style object to manufacture [`IamUserArnAlreadyRegisteredException`](crate::error::IamUserArnAlreadyRegisteredException).
    pub fn builder() -> crate::error::iam_user_arn_already_registered_exception::Builder {
        crate::error::iam_user_arn_already_registered_exception::Builder::default()
    }
}

/// See [`IamUserArnAlreadyRegisteredException`](crate::error::IamUserArnAlreadyRegisteredException).
pub mod iam_user_arn_already_registered_exception {

    /// A builder for [`IamUserArnAlreadyRegisteredException`](crate::error::IamUserArnAlreadyRegisteredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IamUserArnAlreadyRegisteredException`](crate::error::IamUserArnAlreadyRegisteredException).
        pub fn build(self) -> crate::error::IamUserArnAlreadyRegisteredException {
            crate::error::IamUserArnAlreadyRegisteredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The request included an IAM session ARN that has already been used to register a different instance.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IamSessionArnAlreadyRegisteredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IamSessionArnAlreadyRegisteredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IamSessionArnAlreadyRegisteredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IamSessionArnAlreadyRegisteredException")?;
        if let Some(inner_55) = &self.message {
            {
                write!(f, ": {}", inner_55)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IamSessionArnAlreadyRegisteredException {}
impl aws_http::request_id::RequestId for crate::error::IamSessionArnAlreadyRegisteredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for IamSessionArnAlreadyRegisteredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl IamSessionArnAlreadyRegisteredException {
    /// Creates a new builder-style object to manufacture [`IamSessionArnAlreadyRegisteredException`](crate::error::IamSessionArnAlreadyRegisteredException).
    pub fn builder() -> crate::error::iam_session_arn_already_registered_exception::Builder {
        crate::error::iam_session_arn_already_registered_exception::Builder::default()
    }
}

/// See [`IamSessionArnAlreadyRegisteredException`](crate::error::IamSessionArnAlreadyRegisteredException).
pub mod iam_session_arn_already_registered_exception {

    /// A builder for [`IamSessionArnAlreadyRegisteredException`](crate::error::IamSessionArnAlreadyRegisteredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IamSessionArnAlreadyRegisteredException`](crate::error::IamSessionArnAlreadyRegisteredException).
        pub fn build(self) -> crate::error::IamSessionArnAlreadyRegisteredException {
            crate::error::IamSessionArnAlreadyRegisteredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>No IAM ARN was included in the request. You must use an IAM session ARN or IAM user ARN in the request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IamArnRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IamArnRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IamArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IamArnRequiredException")?;
        if let Some(inner_56) = &self.message {
            {
                write!(f, ": {}", inner_56)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IamArnRequiredException {}
impl aws_http::request_id::RequestId for crate::error::IamArnRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for IamArnRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl IamArnRequiredException {
    /// Creates a new builder-style object to manufacture [`IamArnRequiredException`](crate::error::IamArnRequiredException).
    pub fn builder() -> crate::error::iam_arn_required_exception::Builder {
        crate::error::iam_arn_required_exception::Builder::default()
    }
}

/// See [`IamArnRequiredException`](crate::error::IamArnRequiredException).
pub mod iam_arn_required_exception {

    /// A builder for [`IamArnRequiredException`](crate::error::IamArnRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IamArnRequiredException`](crate::error::IamArnRequiredException).
        pub fn build(self) -> crate::error::IamArnRequiredException {
            crate::error::IamArnRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type RegisterApplicationRevisionErrorKind = RegisterApplicationRevisionError;
/// Error type for the `RegisterApplicationRevisionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RegisterApplicationRevisionError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The description is too long.</p>
    DescriptionTooLongException(crate::error::DescriptionTooLongException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The revision was specified in an invalid format.</p>
    InvalidRevisionException(crate::error::InvalidRevisionException),
    /// <p>The revision ID was not specified.</p>
    RevisionRequiredException(crate::error::RevisionRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for RegisterApplicationRevisionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for RegisterApplicationRevisionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::DescriptionTooLongException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidRevisionException(_inner) => _inner.fmt(f),
            Self::RevisionRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RegisterApplicationRevisionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DescriptionTooLongException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRevisionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::RegisterApplicationRevisionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for RegisterApplicationRevisionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl RegisterApplicationRevisionError {
    /// Creates the `RegisterApplicationRevisionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `RegisterApplicationRevisionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::DescriptionTooLongException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidRevisionException(e) => e.meta(),
            Self::RevisionRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `RegisterApplicationRevisionError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `RegisterApplicationRevisionError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `RegisterApplicationRevisionError::DescriptionTooLongException`.
    pub fn is_description_too_long_exception(&self) -> bool {
        matches!(self, Self::DescriptionTooLongException(_))
    }
    /// Returns `true` if the error kind is `RegisterApplicationRevisionError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `RegisterApplicationRevisionError::InvalidRevisionException`.
    pub fn is_invalid_revision_exception(&self) -> bool {
        matches!(self, Self::InvalidRevisionException(_))
    }
    /// Returns `true` if the error kind is `RegisterApplicationRevisionError::RevisionRequiredException`.
    pub fn is_revision_required_exception(&self) -> bool {
        matches!(self, Self::RevisionRequiredException(_))
    }
}
impl std::error::Error for RegisterApplicationRevisionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::DescriptionTooLongException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidRevisionException(_inner) => Some(_inner),
            Self::RevisionRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The revision ID was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RevisionRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RevisionRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RevisionRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RevisionRequiredException")?;
        if let Some(inner_57) = &self.message {
            {
                write!(f, ": {}", inner_57)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RevisionRequiredException {}
impl aws_http::request_id::RequestId for crate::error::RevisionRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RevisionRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl RevisionRequiredException {
    /// Creates a new builder-style object to manufacture [`RevisionRequiredException`](crate::error::RevisionRequiredException).
    pub fn builder() -> crate::error::revision_required_exception::Builder {
        crate::error::revision_required_exception::Builder::default()
    }
}

/// See [`RevisionRequiredException`](crate::error::RevisionRequiredException).
pub mod revision_required_exception {

    /// A builder for [`RevisionRequiredException`](crate::error::RevisionRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RevisionRequiredException`](crate::error::RevisionRequiredException).
        pub fn build(self) -> crate::error::RevisionRequiredException {
            crate::error::RevisionRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The revision was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRevisionException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRevisionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRevisionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRevisionException")?;
        if let Some(inner_58) = &self.message {
            {
                write!(f, ": {}", inner_58)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRevisionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRevisionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRevisionException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidRevisionException {
    /// Creates a new builder-style object to manufacture [`InvalidRevisionException`](crate::error::InvalidRevisionException).
    pub fn builder() -> crate::error::invalid_revision_exception::Builder {
        crate::error::invalid_revision_exception::Builder::default()
    }
}

/// See [`InvalidRevisionException`](crate::error::InvalidRevisionException).
pub mod invalid_revision_exception {

    /// A builder for [`InvalidRevisionException`](crate::error::InvalidRevisionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRevisionException`](crate::error::InvalidRevisionException).
        pub fn build(self) -> crate::error::InvalidRevisionException {
            crate::error::InvalidRevisionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The description is too long.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DescriptionTooLongException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DescriptionTooLongException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DescriptionTooLongException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DescriptionTooLongException")?;
        if let Some(inner_59) = &self.message {
            {
                write!(f, ": {}", inner_59)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DescriptionTooLongException {}
impl aws_http::request_id::RequestId for crate::error::DescriptionTooLongException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescriptionTooLongException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DescriptionTooLongException {
    /// Creates a new builder-style object to manufacture [`DescriptionTooLongException`](crate::error::DescriptionTooLongException).
    pub fn builder() -> crate::error::description_too_long_exception::Builder {
        crate::error::description_too_long_exception::Builder::default()
    }
}

/// See [`DescriptionTooLongException`](crate::error::DescriptionTooLongException).
pub mod description_too_long_exception {

    /// A builder for [`DescriptionTooLongException`](crate::error::DescriptionTooLongException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DescriptionTooLongException`](crate::error::DescriptionTooLongException).
        pub fn build(self) -> crate::error::DescriptionTooLongException {
            crate::error::DescriptionTooLongException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PutLifecycleEventHookExecutionStatusErrorKind = PutLifecycleEventHookExecutionStatusError;
/// Error type for the `PutLifecycleEventHookExecutionStatusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutLifecycleEventHookExecutionStatusError {
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p>A lifecycle event hook is invalid. Review the <code>hooks</code> section in your AppSpec file to ensure the lifecycle events and <code>hooks</code> functions are valid.</p>
    InvalidLifecycleEventHookExecutionIdException(
        crate::error::InvalidLifecycleEventHookExecutionIdException,
    ),
    /// <p>The result of a Lambda validation function that verifies a lifecycle event is invalid. It should return <code>Succeeded</code> or <code>Failed</code>.</p>
    InvalidLifecycleEventHookExecutionStatusException(
        crate::error::InvalidLifecycleEventHookExecutionStatusException,
    ),
    /// <p>An attempt to return the status of an already completed lifecycle event occurred.</p>
    LifecycleEventAlreadyCompletedException(crate::error::LifecycleEventAlreadyCompletedException),
    /// <p>A call was submitted that is not supported for the specified deployment type.</p>
    UnsupportedActionForDeploymentTypeException(
        crate::error::UnsupportedActionForDeploymentTypeException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PutLifecycleEventHookExecutionStatusError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PutLifecycleEventHookExecutionStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::InvalidLifecycleEventHookExecutionIdException(_inner) => _inner.fmt(f),
            Self::InvalidLifecycleEventHookExecutionStatusException(_inner) => _inner.fmt(f),
            Self::LifecycleEventAlreadyCompletedException(_inner) => _inner.fmt(f),
            Self::UnsupportedActionForDeploymentTypeException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for PutLifecycleEventHookExecutionStatusError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLifecycleEventHookExecutionIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLifecycleEventHookExecutionStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LifecycleEventAlreadyCompletedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedActionForDeploymentTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PutLifecycleEventHookExecutionStatusError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutLifecycleEventHookExecutionStatusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutLifecycleEventHookExecutionStatusError {
    /// Creates the `PutLifecycleEventHookExecutionStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PutLifecycleEventHookExecutionStatusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::InvalidLifecycleEventHookExecutionIdException(e) => e.meta(),
            Self::InvalidLifecycleEventHookExecutionStatusException(e) => e.meta(),
            Self::LifecycleEventAlreadyCompletedException(e) => e.meta(),
            Self::UnsupportedActionForDeploymentTypeException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PutLifecycleEventHookExecutionStatusError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutLifecycleEventHookExecutionStatusError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutLifecycleEventHookExecutionStatusError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `PutLifecycleEventHookExecutionStatusError::InvalidLifecycleEventHookExecutionIdException`.
    pub fn is_invalid_lifecycle_event_hook_execution_id_exception(&self) -> bool {
        matches!(self, Self::InvalidLifecycleEventHookExecutionIdException(_))
    }
    /// Returns `true` if the error kind is `PutLifecycleEventHookExecutionStatusError::InvalidLifecycleEventHookExecutionStatusException`.
    pub fn is_invalid_lifecycle_event_hook_execution_status_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidLifecycleEventHookExecutionStatusException(_)
        )
    }
    /// Returns `true` if the error kind is `PutLifecycleEventHookExecutionStatusError::LifecycleEventAlreadyCompletedException`.
    pub fn is_lifecycle_event_already_completed_exception(&self) -> bool {
        matches!(self, Self::LifecycleEventAlreadyCompletedException(_))
    }
    /// Returns `true` if the error kind is `PutLifecycleEventHookExecutionStatusError::UnsupportedActionForDeploymentTypeException`.
    pub fn is_unsupported_action_for_deployment_type_exception(&self) -> bool {
        matches!(self, Self::UnsupportedActionForDeploymentTypeException(_))
    }
}
impl std::error::Error for PutLifecycleEventHookExecutionStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::InvalidLifecycleEventHookExecutionIdException(_inner) => Some(_inner),
            Self::InvalidLifecycleEventHookExecutionStatusException(_inner) => Some(_inner),
            Self::LifecycleEventAlreadyCompletedException(_inner) => Some(_inner),
            Self::UnsupportedActionForDeploymentTypeException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An attempt to return the status of an already completed lifecycle event occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LifecycleEventAlreadyCompletedException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl LifecycleEventAlreadyCompletedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LifecycleEventAlreadyCompletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LifecycleEventAlreadyCompletedException")?;
        if let Some(inner_60) = &self.message {
            {
                write!(f, ": {}", inner_60)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for LifecycleEventAlreadyCompletedException {}
impl aws_http::request_id::RequestId for crate::error::LifecycleEventAlreadyCompletedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for LifecycleEventAlreadyCompletedException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl LifecycleEventAlreadyCompletedException {
    /// Creates a new builder-style object to manufacture [`LifecycleEventAlreadyCompletedException`](crate::error::LifecycleEventAlreadyCompletedException).
    pub fn builder() -> crate::error::lifecycle_event_already_completed_exception::Builder {
        crate::error::lifecycle_event_already_completed_exception::Builder::default()
    }
}

/// See [`LifecycleEventAlreadyCompletedException`](crate::error::LifecycleEventAlreadyCompletedException).
pub mod lifecycle_event_already_completed_exception {

    /// A builder for [`LifecycleEventAlreadyCompletedException`](crate::error::LifecycleEventAlreadyCompletedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`LifecycleEventAlreadyCompletedException`](crate::error::LifecycleEventAlreadyCompletedException).
        pub fn build(self) -> crate::error::LifecycleEventAlreadyCompletedException {
            crate::error::LifecycleEventAlreadyCompletedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The result of a Lambda validation function that verifies a lifecycle event is invalid. It should return <code>Succeeded</code> or <code>Failed</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidLifecycleEventHookExecutionStatusException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidLifecycleEventHookExecutionStatusException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidLifecycleEventHookExecutionStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidLifecycleEventHookExecutionStatusException")?;
        if let Some(inner_61) = &self.message {
            {
                write!(f, ": {}", inner_61)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidLifecycleEventHookExecutionStatusException {}
impl aws_http::request_id::RequestId
    for crate::error::InvalidLifecycleEventHookExecutionStatusException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidLifecycleEventHookExecutionStatusException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidLifecycleEventHookExecutionStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidLifecycleEventHookExecutionStatusException`](crate::error::InvalidLifecycleEventHookExecutionStatusException).
    pub fn builder(
    ) -> crate::error::invalid_lifecycle_event_hook_execution_status_exception::Builder {
        crate::error::invalid_lifecycle_event_hook_execution_status_exception::Builder::default()
    }
}

/// See [`InvalidLifecycleEventHookExecutionStatusException`](crate::error::InvalidLifecycleEventHookExecutionStatusException).
pub mod invalid_lifecycle_event_hook_execution_status_exception {

    /// A builder for [`InvalidLifecycleEventHookExecutionStatusException`](crate::error::InvalidLifecycleEventHookExecutionStatusException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidLifecycleEventHookExecutionStatusException`](crate::error::InvalidLifecycleEventHookExecutionStatusException).
        pub fn build(self) -> crate::error::InvalidLifecycleEventHookExecutionStatusException {
            crate::error::InvalidLifecycleEventHookExecutionStatusException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A lifecycle event hook is invalid. Review the <code>hooks</code> section in your AppSpec file to ensure the lifecycle events and <code>hooks</code> functions are valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidLifecycleEventHookExecutionIdException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidLifecycleEventHookExecutionIdException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidLifecycleEventHookExecutionIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidLifecycleEventHookExecutionIdException")?;
        if let Some(inner_62) = &self.message {
            {
                write!(f, ": {}", inner_62)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidLifecycleEventHookExecutionIdException {}
impl aws_http::request_id::RequestId
    for crate::error::InvalidLifecycleEventHookExecutionIdException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidLifecycleEventHookExecutionIdException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidLifecycleEventHookExecutionIdException {
    /// Creates a new builder-style object to manufacture [`InvalidLifecycleEventHookExecutionIdException`](crate::error::InvalidLifecycleEventHookExecutionIdException).
    pub fn builder() -> crate::error::invalid_lifecycle_event_hook_execution_id_exception::Builder {
        crate::error::invalid_lifecycle_event_hook_execution_id_exception::Builder::default()
    }
}

/// See [`InvalidLifecycleEventHookExecutionIdException`](crate::error::InvalidLifecycleEventHookExecutionIdException).
pub mod invalid_lifecycle_event_hook_execution_id_exception {

    /// A builder for [`InvalidLifecycleEventHookExecutionIdException`](crate::error::InvalidLifecycleEventHookExecutionIdException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidLifecycleEventHookExecutionIdException`](crate::error::InvalidLifecycleEventHookExecutionIdException).
        pub fn build(self) -> crate::error::InvalidLifecycleEventHookExecutionIdException {
            crate::error::InvalidLifecycleEventHookExecutionIdException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListTagsForResourceErrorKind = ListTagsForResourceError;
/// Error type for the `ListTagsForResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceError {
    /// <p> The specified ARN is not supported. For example, it might be an ARN for a resource that is not expected. </p>
    ArnNotSupportedException(crate::error::ArnNotSupportedException),
    /// <p> The specified ARN is not in a valid format. </p>
    InvalidArnException(crate::error::InvalidArnException),
    /// <p> The ARN of a resource is required, but was not found. </p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ArnNotSupportedException(_inner) => _inner.fmt(f),
            Self::InvalidArnException(_inner) => _inner.fmt(f),
            Self::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsForResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ArnNotSupportedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsForResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ArnNotSupportedException(e) => e.meta(),
            Self::InvalidArnException(e) => e.meta(),
            Self::ResourceArnRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::ArnNotSupportedException`.
    pub fn is_arn_not_supported_exception(&self) -> bool {
        matches!(self, Self::ArnNotSupportedException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::InvalidArnException`.
    pub fn is_invalid_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidArnException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::ResourceArnRequiredException`.
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(self, Self::ResourceArnRequiredException(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ArnNotSupportedException(_inner) => Some(_inner),
            Self::InvalidArnException(_inner) => Some(_inner),
            Self::ResourceArnRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListOnPremisesInstancesErrorKind = ListOnPremisesInstancesError;
/// Error type for the `ListOnPremisesInstancesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListOnPremisesInstancesError {
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>The registration status was specified in an invalid format.</p>
    InvalidRegistrationStatusException(crate::error::InvalidRegistrationStatusException),
    /// <p>The tag filter was specified in an invalid format.</p>
    InvalidTagFilterException(crate::error::InvalidTagFilterException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListOnPremisesInstancesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListOnPremisesInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidRegistrationStatusException(_inner) => _inner.fmt(f),
            Self::InvalidTagFilterException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListOnPremisesInstancesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRegistrationStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagFilterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListOnPremisesInstancesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListOnPremisesInstancesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListOnPremisesInstancesError {
    /// Creates the `ListOnPremisesInstancesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListOnPremisesInstancesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidRegistrationStatusException(e) => e.meta(),
            Self::InvalidTagFilterException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListOnPremisesInstancesError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `ListOnPremisesInstancesError::InvalidRegistrationStatusException`.
    pub fn is_invalid_registration_status_exception(&self) -> bool {
        matches!(self, Self::InvalidRegistrationStatusException(_))
    }
    /// Returns `true` if the error kind is `ListOnPremisesInstancesError::InvalidTagFilterException`.
    pub fn is_invalid_tag_filter_exception(&self) -> bool {
        matches!(self, Self::InvalidTagFilterException(_))
    }
}
impl std::error::Error for ListOnPremisesInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidRegistrationStatusException(_inner) => Some(_inner),
            Self::InvalidTagFilterException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The tag filter was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTagFilterException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTagFilterException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagFilterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagFilterException")?;
        if let Some(inner_63) = &self.message {
            {
                write!(f, ": {}", inner_63)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagFilterException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTagFilterException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTagFilterException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTagFilterException {
    /// Creates a new builder-style object to manufacture [`InvalidTagFilterException`](crate::error::InvalidTagFilterException).
    pub fn builder() -> crate::error::invalid_tag_filter_exception::Builder {
        crate::error::invalid_tag_filter_exception::Builder::default()
    }
}

/// See [`InvalidTagFilterException`](crate::error::InvalidTagFilterException).
pub mod invalid_tag_filter_exception {

    /// A builder for [`InvalidTagFilterException`](crate::error::InvalidTagFilterException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagFilterException`](crate::error::InvalidTagFilterException).
        pub fn build(self) -> crate::error::InvalidTagFilterException {
            crate::error::InvalidTagFilterException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The registration status was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRegistrationStatusException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRegistrationStatusException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRegistrationStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRegistrationStatusException")?;
        if let Some(inner_64) = &self.message {
            {
                write!(f, ": {}", inner_64)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRegistrationStatusException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRegistrationStatusException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidRegistrationStatusException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidRegistrationStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidRegistrationStatusException`](crate::error::InvalidRegistrationStatusException).
    pub fn builder() -> crate::error::invalid_registration_status_exception::Builder {
        crate::error::invalid_registration_status_exception::Builder::default()
    }
}

/// See [`InvalidRegistrationStatusException`](crate::error::InvalidRegistrationStatusException).
pub mod invalid_registration_status_exception {

    /// A builder for [`InvalidRegistrationStatusException`](crate::error::InvalidRegistrationStatusException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRegistrationStatusException`](crate::error::InvalidRegistrationStatusException).
        pub fn build(self) -> crate::error::InvalidRegistrationStatusException {
            crate::error::InvalidRegistrationStatusException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The next token was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidNextTokenException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidNextTokenException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenException")?;
        if let Some(inner_65) = &self.message {
            {
                write!(f, ": {}", inner_65)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenException {}
impl aws_http::request_id::RequestId for crate::error::InvalidNextTokenException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidNextTokenException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidNextTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenException`](crate::error::InvalidNextTokenException).
    pub fn builder() -> crate::error::invalid_next_token_exception::Builder {
        crate::error::invalid_next_token_exception::Builder::default()
    }
}

/// See [`InvalidNextTokenException`](crate::error::InvalidNextTokenException).
pub mod invalid_next_token_exception {

    /// A builder for [`InvalidNextTokenException`](crate::error::InvalidNextTokenException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenException`](crate::error::InvalidNextTokenException).
        pub fn build(self) -> crate::error::InvalidNextTokenException {
            crate::error::InvalidNextTokenException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListGitHubAccountTokenNamesErrorKind = ListGitHubAccountTokenNamesError;
/// Error type for the `ListGitHubAccountTokenNamesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListGitHubAccountTokenNamesError {
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>The API used does not support the deployment.</p>
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    /// <p>The specified resource could not be validated.</p>
    ResourceValidationException(crate::error::ResourceValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListGitHubAccountTokenNamesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListGitHubAccountTokenNamesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::OperationNotSupportedException(_inner) => _inner.fmt(f),
            Self::ResourceValidationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListGitHubAccountTokenNamesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OperationNotSupportedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceValidationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListGitHubAccountTokenNamesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListGitHubAccountTokenNamesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListGitHubAccountTokenNamesError {
    /// Creates the `ListGitHubAccountTokenNamesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListGitHubAccountTokenNamesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::OperationNotSupportedException(e) => e.meta(),
            Self::ResourceValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListGitHubAccountTokenNamesError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `ListGitHubAccountTokenNamesError::OperationNotSupportedException`.
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(self, Self::OperationNotSupportedException(_))
    }
    /// Returns `true` if the error kind is `ListGitHubAccountTokenNamesError::ResourceValidationException`.
    pub fn is_resource_validation_exception(&self) -> bool {
        matches!(self, Self::ResourceValidationException(_))
    }
}
impl std::error::Error for ListGitHubAccountTokenNamesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::OperationNotSupportedException(_inner) => Some(_inner),
            Self::ResourceValidationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified resource could not be validated.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceValidationException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceValidationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceValidationException")?;
        if let Some(inner_66) = &self.message {
            {
                write!(f, ": {}", inner_66)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceValidationException {}
impl aws_http::request_id::RequestId for crate::error::ResourceValidationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceValidationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ResourceValidationException {
    /// Creates a new builder-style object to manufacture [`ResourceValidationException`](crate::error::ResourceValidationException).
    pub fn builder() -> crate::error::resource_validation_exception::Builder {
        crate::error::resource_validation_exception::Builder::default()
    }
}

/// See [`ResourceValidationException`](crate::error::ResourceValidationException).
pub mod resource_validation_exception {

    /// A builder for [`ResourceValidationException`](crate::error::ResourceValidationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResourceValidationException`](crate::error::ResourceValidationException).
        pub fn build(self) -> crate::error::ResourceValidationException {
            crate::error::ResourceValidationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The API used does not support the deployment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OperationNotSupportedException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OperationNotSupportedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OperationNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OperationNotSupportedException")?;
        if let Some(inner_67) = &self.message {
            {
                write!(f, ": {}", inner_67)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OperationNotSupportedException {}
impl aws_http::request_id::RequestId for crate::error::OperationNotSupportedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OperationNotSupportedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl OperationNotSupportedException {
    /// Creates a new builder-style object to manufacture [`OperationNotSupportedException`](crate::error::OperationNotSupportedException).
    pub fn builder() -> crate::error::operation_not_supported_exception::Builder {
        crate::error::operation_not_supported_exception::Builder::default()
    }
}

/// See [`OperationNotSupportedException`](crate::error::OperationNotSupportedException).
pub mod operation_not_supported_exception {

    /// A builder for [`OperationNotSupportedException`](crate::error::OperationNotSupportedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`OperationNotSupportedException`](crate::error::OperationNotSupportedException).
        pub fn build(self) -> crate::error::OperationNotSupportedException {
            crate::error::OperationNotSupportedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDeploymentTargetsErrorKind = ListDeploymentTargetsError;
/// Error type for the `ListDeploymentTargetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDeploymentTargetsError {
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>The specified deployment has not started.</p>
    DeploymentNotStartedException(crate::error::DeploymentNotStartedException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p>An instance type was specified for an in-place deployment. Instance types are supported for blue/green deployments only.</p>
    InvalidDeploymentInstanceTypeException(crate::error::InvalidDeploymentInstanceTypeException),
    /// <p>The specified instance status does not exist.</p>
    InvalidInstanceStatusException(crate::error::InvalidInstanceStatusException),
    /// <p>An invalid instance type was specified for instances in a blue/green deployment. Valid values include "Blue" for an original environment and "Green" for a replacement environment.</p>
    InvalidInstanceTypeException(crate::error::InvalidInstanceTypeException),
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDeploymentTargetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDeploymentTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentNotStartedException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentInstanceTypeException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceStatusException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceTypeException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDeploymentTargetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentNotStartedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentInstanceTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDeploymentTargetsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDeploymentTargetsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDeploymentTargetsError {
    /// Creates the `ListDeploymentTargetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDeploymentTargetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::DeploymentNotStartedException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::InvalidDeploymentInstanceTypeException(e) => e.meta(),
            Self::InvalidInstanceStatusException(e) => e.meta(),
            Self::InvalidInstanceTypeException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDeploymentTargetsError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentTargetsError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentTargetsError::DeploymentNotStartedException`.
    pub fn is_deployment_not_started_exception(&self) -> bool {
        matches!(self, Self::DeploymentNotStartedException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentTargetsError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentTargetsError::InvalidDeploymentInstanceTypeException`.
    pub fn is_invalid_deployment_instance_type_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentInstanceTypeException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentTargetsError::InvalidInstanceStatusException`.
    pub fn is_invalid_instance_status_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceStatusException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentTargetsError::InvalidInstanceTypeException`.
    pub fn is_invalid_instance_type_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceTypeException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentTargetsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
}
impl std::error::Error for ListDeploymentTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::DeploymentNotStartedException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::InvalidDeploymentInstanceTypeException(_inner) => Some(_inner),
            Self::InvalidInstanceStatusException(_inner) => Some(_inner),
            Self::InvalidInstanceTypeException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An invalid instance type was specified for instances in a blue/green deployment. Valid values include "Blue" for an original environment and "Green" for a replacement environment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidInstanceTypeException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidInstanceTypeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInstanceTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInstanceTypeException")?;
        if let Some(inner_68) = &self.message {
            {
                write!(f, ": {}", inner_68)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInstanceTypeException {}
impl aws_http::request_id::RequestId for crate::error::InvalidInstanceTypeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidInstanceTypeException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidInstanceTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidInstanceTypeException`](crate::error::InvalidInstanceTypeException).
    pub fn builder() -> crate::error::invalid_instance_type_exception::Builder {
        crate::error::invalid_instance_type_exception::Builder::default()
    }
}

/// See [`InvalidInstanceTypeException`](crate::error::InvalidInstanceTypeException).
pub mod invalid_instance_type_exception {

    /// A builder for [`InvalidInstanceTypeException`](crate::error::InvalidInstanceTypeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInstanceTypeException`](crate::error::InvalidInstanceTypeException).
        pub fn build(self) -> crate::error::InvalidInstanceTypeException {
            crate::error::InvalidInstanceTypeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified instance status does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidInstanceStatusException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidInstanceStatusException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidInstanceStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidInstanceStatusException")?;
        if let Some(inner_69) = &self.message {
            {
                write!(f, ": {}", inner_69)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidInstanceStatusException {}
impl aws_http::request_id::RequestId for crate::error::InvalidInstanceStatusException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidInstanceStatusException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidInstanceStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidInstanceStatusException`](crate::error::InvalidInstanceStatusException).
    pub fn builder() -> crate::error::invalid_instance_status_exception::Builder {
        crate::error::invalid_instance_status_exception::Builder::default()
    }
}

/// See [`InvalidInstanceStatusException`](crate::error::InvalidInstanceStatusException).
pub mod invalid_instance_status_exception {

    /// A builder for [`InvalidInstanceStatusException`](crate::error::InvalidInstanceStatusException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidInstanceStatusException`](crate::error::InvalidInstanceStatusException).
        pub fn build(self) -> crate::error::InvalidInstanceStatusException {
            crate::error::InvalidInstanceStatusException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An instance type was specified for an in-place deployment. Instance types are supported for blue/green deployments only.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDeploymentInstanceTypeException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDeploymentInstanceTypeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeploymentInstanceTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeploymentInstanceTypeException")?;
        if let Some(inner_70) = &self.message {
            {
                write!(f, ": {}", inner_70)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeploymentInstanceTypeException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDeploymentInstanceTypeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidDeploymentInstanceTypeException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDeploymentInstanceTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidDeploymentInstanceTypeException`](crate::error::InvalidDeploymentInstanceTypeException).
    pub fn builder() -> crate::error::invalid_deployment_instance_type_exception::Builder {
        crate::error::invalid_deployment_instance_type_exception::Builder::default()
    }
}

/// See [`InvalidDeploymentInstanceTypeException`](crate::error::InvalidDeploymentInstanceTypeException).
pub mod invalid_deployment_instance_type_exception {

    /// A builder for [`InvalidDeploymentInstanceTypeException`](crate::error::InvalidDeploymentInstanceTypeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeploymentInstanceTypeException`](crate::error::InvalidDeploymentInstanceTypeException).
        pub fn build(self) -> crate::error::InvalidDeploymentInstanceTypeException {
            crate::error::InvalidDeploymentInstanceTypeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDeploymentsErrorKind = ListDeploymentsError;
/// Error type for the `ListDeploymentsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDeploymentsError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The named deployment group with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentGroupDoesNotExistException(crate::error::DeploymentGroupDoesNotExistException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::error::DeploymentGroupNameRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::error::InvalidDeploymentGroupNameException),
    /// <p>The specified deployment status doesn't exist or cannot be determined.</p>
    InvalidDeploymentStatusException(crate::error::InvalidDeploymentStatusException),
    /// <p>The external ID was specified in an invalid format.</p>
    InvalidExternalIdException(crate::error::InvalidExternalIdException),
    /// <p>The input was specified in an invalid format.</p>
    InvalidInputException(crate::error::InvalidInputException),
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>The specified time range was specified in an invalid format.</p>
    InvalidTimeRangeException(crate::error::InvalidTimeRangeException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDeploymentsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDeploymentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentGroupNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentStatusException(_inner) => _inner.fmt(f),
            Self::InvalidExternalIdException(_inner) => _inner.fmt(f),
            Self::InvalidInputException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidTimeRangeException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDeploymentsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentGroupNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidExternalIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInputException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTimeRangeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDeploymentsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDeploymentsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDeploymentsError {
    /// Creates the `ListDeploymentsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDeploymentsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::DeploymentGroupDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupNameRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidDeploymentGroupNameException(e) => e.meta(),
            Self::InvalidDeploymentStatusException(e) => e.meta(),
            Self::InvalidExternalIdException(e) => e.meta(),
            Self::InvalidInputException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidTimeRangeException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::DeploymentGroupDoesNotExistException`.
    pub fn is_deployment_group_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::DeploymentGroupNameRequiredException`.
    pub fn is_deployment_group_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::InvalidDeploymentGroupNameException`.
    pub fn is_invalid_deployment_group_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentGroupNameException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::InvalidDeploymentStatusException`.
    pub fn is_invalid_deployment_status_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentStatusException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::InvalidExternalIdException`.
    pub fn is_invalid_external_id_exception(&self) -> bool {
        matches!(self, Self::InvalidExternalIdException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::InvalidInputException`.
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(self, Self::InvalidInputException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentsError::InvalidTimeRangeException`.
    pub fn is_invalid_time_range_exception(&self) -> bool {
        matches!(self, Self::InvalidTimeRangeException(_))
    }
}
impl std::error::Error for ListDeploymentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::DeploymentGroupDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentStatusException(_inner) => Some(_inner),
            Self::InvalidExternalIdException(_inner) => Some(_inner),
            Self::InvalidInputException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidTimeRangeException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified time range was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTimeRangeException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTimeRangeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTimeRangeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTimeRangeException")?;
        if let Some(inner_71) = &self.message {
            {
                write!(f, ": {}", inner_71)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTimeRangeException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTimeRangeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTimeRangeException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTimeRangeException {
    /// Creates a new builder-style object to manufacture [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException).
    pub fn builder() -> crate::error::invalid_time_range_exception::Builder {
        crate::error::invalid_time_range_exception::Builder::default()
    }
}

/// See [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException).
pub mod invalid_time_range_exception {

    /// A builder for [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTimeRangeException`](crate::error::InvalidTimeRangeException).
        pub fn build(self) -> crate::error::InvalidTimeRangeException {
            crate::error::InvalidTimeRangeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The external ID was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidExternalIdException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidExternalIdException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidExternalIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExternalIdException")?;
        if let Some(inner_72) = &self.message {
            {
                write!(f, ": {}", inner_72)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidExternalIdException {}
impl aws_http::request_id::RequestId for crate::error::InvalidExternalIdException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidExternalIdException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidExternalIdException {
    /// Creates a new builder-style object to manufacture [`InvalidExternalIdException`](crate::error::InvalidExternalIdException).
    pub fn builder() -> crate::error::invalid_external_id_exception::Builder {
        crate::error::invalid_external_id_exception::Builder::default()
    }
}

/// See [`InvalidExternalIdException`](crate::error::InvalidExternalIdException).
pub mod invalid_external_id_exception {

    /// A builder for [`InvalidExternalIdException`](crate::error::InvalidExternalIdException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidExternalIdException`](crate::error::InvalidExternalIdException).
        pub fn build(self) -> crate::error::InvalidExternalIdException {
            crate::error::InvalidExternalIdException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified deployment status doesn't exist or cannot be determined.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDeploymentStatusException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDeploymentStatusException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeploymentStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeploymentStatusException")?;
        if let Some(inner_73) = &self.message {
            {
                write!(f, ": {}", inner_73)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeploymentStatusException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDeploymentStatusException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDeploymentStatusException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDeploymentStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidDeploymentStatusException`](crate::error::InvalidDeploymentStatusException).
    pub fn builder() -> crate::error::invalid_deployment_status_exception::Builder {
        crate::error::invalid_deployment_status_exception::Builder::default()
    }
}

/// See [`InvalidDeploymentStatusException`](crate::error::InvalidDeploymentStatusException).
pub mod invalid_deployment_status_exception {

    /// A builder for [`InvalidDeploymentStatusException`](crate::error::InvalidDeploymentStatusException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeploymentStatusException`](crate::error::InvalidDeploymentStatusException).
        pub fn build(self) -> crate::error::InvalidDeploymentStatusException {
            crate::error::InvalidDeploymentStatusException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDeploymentInstancesErrorKind = ListDeploymentInstancesError;
/// Error type for the `ListDeploymentInstancesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDeploymentInstancesError {
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>The specified deployment has not started.</p>
    DeploymentNotStartedException(crate::error::DeploymentNotStartedException),
    /// <p>The computePlatform is invalid. The computePlatform should be <code>Lambda</code>, <code>Server</code>, or <code>ECS</code>.</p>
    InvalidComputePlatformException(crate::error::InvalidComputePlatformException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p>An instance type was specified for an in-place deployment. Instance types are supported for blue/green deployments only.</p>
    InvalidDeploymentInstanceTypeException(crate::error::InvalidDeploymentInstanceTypeException),
    /// <p>The specified instance status does not exist.</p>
    InvalidInstanceStatusException(crate::error::InvalidInstanceStatusException),
    /// <p>An invalid instance type was specified for instances in a blue/green deployment. Valid values include "Blue" for an original environment and "Green" for a replacement environment.</p>
    InvalidInstanceTypeException(crate::error::InvalidInstanceTypeException),
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p> The target filter name is invalid. </p>
    InvalidTargetFilterNameException(crate::error::InvalidTargetFilterNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDeploymentInstancesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDeploymentInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentNotStartedException(_inner) => _inner.fmt(f),
            Self::InvalidComputePlatformException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentInstanceTypeException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceStatusException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceTypeException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidTargetFilterNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDeploymentInstancesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentNotStartedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidComputePlatformException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentInstanceTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetFilterNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDeploymentInstancesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDeploymentInstancesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDeploymentInstancesError {
    /// Creates the `ListDeploymentInstancesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDeploymentInstancesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::DeploymentNotStartedException(e) => e.meta(),
            Self::InvalidComputePlatformException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::InvalidDeploymentInstanceTypeException(e) => e.meta(),
            Self::InvalidInstanceStatusException(e) => e.meta(),
            Self::InvalidInstanceTypeException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidTargetFilterNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDeploymentInstancesError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentInstancesError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentInstancesError::DeploymentNotStartedException`.
    pub fn is_deployment_not_started_exception(&self) -> bool {
        matches!(self, Self::DeploymentNotStartedException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentInstancesError::InvalidComputePlatformException`.
    pub fn is_invalid_compute_platform_exception(&self) -> bool {
        matches!(self, Self::InvalidComputePlatformException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentInstancesError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentInstancesError::InvalidDeploymentInstanceTypeException`.
    pub fn is_invalid_deployment_instance_type_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentInstanceTypeException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentInstancesError::InvalidInstanceStatusException`.
    pub fn is_invalid_instance_status_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceStatusException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentInstancesError::InvalidInstanceTypeException`.
    pub fn is_invalid_instance_type_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceTypeException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentInstancesError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentInstancesError::InvalidTargetFilterNameException`.
    pub fn is_invalid_target_filter_name_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetFilterNameException(_))
    }
}
impl std::error::Error for ListDeploymentInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::DeploymentNotStartedException(_inner) => Some(_inner),
            Self::InvalidComputePlatformException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::InvalidDeploymentInstanceTypeException(_inner) => Some(_inner),
            Self::InvalidInstanceStatusException(_inner) => Some(_inner),
            Self::InvalidInstanceTypeException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidTargetFilterNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p> The target filter name is invalid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTargetFilterNameException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTargetFilterNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetFilterNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetFilterNameException")?;
        if let Some(inner_74) = &self.message {
            {
                write!(f, ": {}", inner_74)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetFilterNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTargetFilterNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTargetFilterNameException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTargetFilterNameException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetFilterNameException`](crate::error::InvalidTargetFilterNameException).
    pub fn builder() -> crate::error::invalid_target_filter_name_exception::Builder {
        crate::error::invalid_target_filter_name_exception::Builder::default()
    }
}

/// See [`InvalidTargetFilterNameException`](crate::error::InvalidTargetFilterNameException).
pub mod invalid_target_filter_name_exception {

    /// A builder for [`InvalidTargetFilterNameException`](crate::error::InvalidTargetFilterNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetFilterNameException`](crate::error::InvalidTargetFilterNameException).
        pub fn build(self) -> crate::error::InvalidTargetFilterNameException {
            crate::error::InvalidTargetFilterNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The computePlatform is invalid. The computePlatform should be <code>Lambda</code>, <code>Server</code>, or <code>ECS</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidComputePlatformException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidComputePlatformException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidComputePlatformException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidComputePlatformException")?;
        if let Some(inner_75) = &self.message {
            {
                write!(f, ": {}", inner_75)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidComputePlatformException {}
impl aws_http::request_id::RequestId for crate::error::InvalidComputePlatformException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidComputePlatformException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidComputePlatformException {
    /// Creates a new builder-style object to manufacture [`InvalidComputePlatformException`](crate::error::InvalidComputePlatformException).
    pub fn builder() -> crate::error::invalid_compute_platform_exception::Builder {
        crate::error::invalid_compute_platform_exception::Builder::default()
    }
}

/// See [`InvalidComputePlatformException`](crate::error::InvalidComputePlatformException).
pub mod invalid_compute_platform_exception {

    /// A builder for [`InvalidComputePlatformException`](crate::error::InvalidComputePlatformException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidComputePlatformException`](crate::error::InvalidComputePlatformException).
        pub fn build(self) -> crate::error::InvalidComputePlatformException {
            crate::error::InvalidComputePlatformException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDeploymentGroupsErrorKind = ListDeploymentGroupsError;
/// Error type for the `ListDeploymentGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDeploymentGroupsError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDeploymentGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDeploymentGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDeploymentGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDeploymentGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDeploymentGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDeploymentGroupsError {
    /// Creates the `ListDeploymentGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDeploymentGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDeploymentGroupsError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentGroupsError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentGroupsError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `ListDeploymentGroupsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
}
impl std::error::Error for ListDeploymentGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListDeploymentConfigsErrorKind = ListDeploymentConfigsError;
/// Error type for the `ListDeploymentConfigsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDeploymentConfigsError {
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListDeploymentConfigsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListDeploymentConfigsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListDeploymentConfigsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListDeploymentConfigsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListDeploymentConfigsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDeploymentConfigsError {
    /// Creates the `ListDeploymentConfigsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListDeploymentConfigsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListDeploymentConfigsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
}
impl std::error::Error for ListDeploymentConfigsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListApplicationsErrorKind = ListApplicationsError;
/// Error type for the `ListApplicationsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListApplicationsError {
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListApplicationsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListApplicationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListApplicationsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListApplicationsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListApplicationsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListApplicationsError {
    /// Creates the `ListApplicationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListApplicationsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListApplicationsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
}
impl std::error::Error for ListApplicationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListApplicationRevisionsErrorKind = ListApplicationRevisionsError;
/// Error type for the `ListApplicationRevisionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListApplicationRevisionsError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>A bucket name is required, but was not provided.</p>
    BucketNameFilterRequiredException(crate::error::BucketNameFilterRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The bucket name either doesn't exist or was specified in an invalid format.</p>
    InvalidBucketNameFilterException(crate::error::InvalidBucketNameFilterException),
    /// <p>The deployed state filter was specified in an invalid format.</p>
    InvalidDeployedStateFilterException(crate::error::InvalidDeployedStateFilterException),
    /// <p>The specified key prefix filter was specified in an invalid format.</p>
    InvalidKeyPrefixFilterException(crate::error::InvalidKeyPrefixFilterException),
    /// <p>The next token was specified in an invalid format.</p>
    InvalidNextTokenException(crate::error::InvalidNextTokenException),
    /// <p>The column name to sort by is either not present or was specified in an invalid format.</p>
    InvalidSortByException(crate::error::InvalidSortByException),
    /// <p>The sort order was specified in an invalid format.</p>
    InvalidSortOrderException(crate::error::InvalidSortOrderException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListApplicationRevisionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListApplicationRevisionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::BucketNameFilterRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidBucketNameFilterException(_inner) => _inner.fmt(f),
            Self::InvalidDeployedStateFilterException(_inner) => _inner.fmt(f),
            Self::InvalidKeyPrefixFilterException(_inner) => _inner.fmt(f),
            Self::InvalidNextTokenException(_inner) => _inner.fmt(f),
            Self::InvalidSortByException(_inner) => _inner.fmt(f),
            Self::InvalidSortOrderException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListApplicationRevisionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BucketNameFilterRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBucketNameFilterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeployedStateFilterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidKeyPrefixFilterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidNextTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSortByException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSortOrderException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListApplicationRevisionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListApplicationRevisionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListApplicationRevisionsError {
    /// Creates the `ListApplicationRevisionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListApplicationRevisionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::BucketNameFilterRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidBucketNameFilterException(e) => e.meta(),
            Self::InvalidDeployedStateFilterException(e) => e.meta(),
            Self::InvalidKeyPrefixFilterException(e) => e.meta(),
            Self::InvalidNextTokenException(e) => e.meta(),
            Self::InvalidSortByException(e) => e.meta(),
            Self::InvalidSortOrderException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListApplicationRevisionsError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationRevisionsError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationRevisionsError::BucketNameFilterRequiredException`.
    pub fn is_bucket_name_filter_required_exception(&self) -> bool {
        matches!(self, Self::BucketNameFilterRequiredException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationRevisionsError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationRevisionsError::InvalidBucketNameFilterException`.
    pub fn is_invalid_bucket_name_filter_exception(&self) -> bool {
        matches!(self, Self::InvalidBucketNameFilterException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationRevisionsError::InvalidDeployedStateFilterException`.
    pub fn is_invalid_deployed_state_filter_exception(&self) -> bool {
        matches!(self, Self::InvalidDeployedStateFilterException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationRevisionsError::InvalidKeyPrefixFilterException`.
    pub fn is_invalid_key_prefix_filter_exception(&self) -> bool {
        matches!(self, Self::InvalidKeyPrefixFilterException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationRevisionsError::InvalidNextTokenException`.
    pub fn is_invalid_next_token_exception(&self) -> bool {
        matches!(self, Self::InvalidNextTokenException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationRevisionsError::InvalidSortByException`.
    pub fn is_invalid_sort_by_exception(&self) -> bool {
        matches!(self, Self::InvalidSortByException(_))
    }
    /// Returns `true` if the error kind is `ListApplicationRevisionsError::InvalidSortOrderException`.
    pub fn is_invalid_sort_order_exception(&self) -> bool {
        matches!(self, Self::InvalidSortOrderException(_))
    }
}
impl std::error::Error for ListApplicationRevisionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::BucketNameFilterRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidBucketNameFilterException(_inner) => Some(_inner),
            Self::InvalidDeployedStateFilterException(_inner) => Some(_inner),
            Self::InvalidKeyPrefixFilterException(_inner) => Some(_inner),
            Self::InvalidNextTokenException(_inner) => Some(_inner),
            Self::InvalidSortByException(_inner) => Some(_inner),
            Self::InvalidSortOrderException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The sort order was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSortOrderException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSortOrderException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSortOrderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSortOrderException")?;
        if let Some(inner_76) = &self.message {
            {
                write!(f, ": {}", inner_76)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSortOrderException {}
impl aws_http::request_id::RequestId for crate::error::InvalidSortOrderException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidSortOrderException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidSortOrderException {
    /// Creates a new builder-style object to manufacture [`InvalidSortOrderException`](crate::error::InvalidSortOrderException).
    pub fn builder() -> crate::error::invalid_sort_order_exception::Builder {
        crate::error::invalid_sort_order_exception::Builder::default()
    }
}

/// See [`InvalidSortOrderException`](crate::error::InvalidSortOrderException).
pub mod invalid_sort_order_exception {

    /// A builder for [`InvalidSortOrderException`](crate::error::InvalidSortOrderException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSortOrderException`](crate::error::InvalidSortOrderException).
        pub fn build(self) -> crate::error::InvalidSortOrderException {
            crate::error::InvalidSortOrderException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The column name to sort by is either not present or was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSortByException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSortByException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSortByException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSortByException")?;
        if let Some(inner_77) = &self.message {
            {
                write!(f, ": {}", inner_77)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSortByException {}
impl aws_http::request_id::RequestId for crate::error::InvalidSortByException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidSortByException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidSortByException {
    /// Creates a new builder-style object to manufacture [`InvalidSortByException`](crate::error::InvalidSortByException).
    pub fn builder() -> crate::error::invalid_sort_by_exception::Builder {
        crate::error::invalid_sort_by_exception::Builder::default()
    }
}

/// See [`InvalidSortByException`](crate::error::InvalidSortByException).
pub mod invalid_sort_by_exception {

    /// A builder for [`InvalidSortByException`](crate::error::InvalidSortByException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSortByException`](crate::error::InvalidSortByException).
        pub fn build(self) -> crate::error::InvalidSortByException {
            crate::error::InvalidSortByException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified key prefix filter was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidKeyPrefixFilterException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidKeyPrefixFilterException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidKeyPrefixFilterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidKeyPrefixFilterException")?;
        if let Some(inner_78) = &self.message {
            {
                write!(f, ": {}", inner_78)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidKeyPrefixFilterException {}
impl aws_http::request_id::RequestId for crate::error::InvalidKeyPrefixFilterException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidKeyPrefixFilterException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidKeyPrefixFilterException {
    /// Creates a new builder-style object to manufacture [`InvalidKeyPrefixFilterException`](crate::error::InvalidKeyPrefixFilterException).
    pub fn builder() -> crate::error::invalid_key_prefix_filter_exception::Builder {
        crate::error::invalid_key_prefix_filter_exception::Builder::default()
    }
}

/// See [`InvalidKeyPrefixFilterException`](crate::error::InvalidKeyPrefixFilterException).
pub mod invalid_key_prefix_filter_exception {

    /// A builder for [`InvalidKeyPrefixFilterException`](crate::error::InvalidKeyPrefixFilterException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidKeyPrefixFilterException`](crate::error::InvalidKeyPrefixFilterException).
        pub fn build(self) -> crate::error::InvalidKeyPrefixFilterException {
            crate::error::InvalidKeyPrefixFilterException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The deployed state filter was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDeployedStateFilterException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDeployedStateFilterException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeployedStateFilterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeployedStateFilterException")?;
        if let Some(inner_79) = &self.message {
            {
                write!(f, ": {}", inner_79)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeployedStateFilterException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDeployedStateFilterException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidDeployedStateFilterException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDeployedStateFilterException {
    /// Creates a new builder-style object to manufacture [`InvalidDeployedStateFilterException`](crate::error::InvalidDeployedStateFilterException).
    pub fn builder() -> crate::error::invalid_deployed_state_filter_exception::Builder {
        crate::error::invalid_deployed_state_filter_exception::Builder::default()
    }
}

/// See [`InvalidDeployedStateFilterException`](crate::error::InvalidDeployedStateFilterException).
pub mod invalid_deployed_state_filter_exception {

    /// A builder for [`InvalidDeployedStateFilterException`](crate::error::InvalidDeployedStateFilterException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeployedStateFilterException`](crate::error::InvalidDeployedStateFilterException).
        pub fn build(self) -> crate::error::InvalidDeployedStateFilterException {
            crate::error::InvalidDeployedStateFilterException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The bucket name either doesn't exist or was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidBucketNameFilterException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidBucketNameFilterException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidBucketNameFilterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidBucketNameFilterException")?;
        if let Some(inner_80) = &self.message {
            {
                write!(f, ": {}", inner_80)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidBucketNameFilterException {}
impl aws_http::request_id::RequestId for crate::error::InvalidBucketNameFilterException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidBucketNameFilterException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidBucketNameFilterException {
    /// Creates a new builder-style object to manufacture [`InvalidBucketNameFilterException`](crate::error::InvalidBucketNameFilterException).
    pub fn builder() -> crate::error::invalid_bucket_name_filter_exception::Builder {
        crate::error::invalid_bucket_name_filter_exception::Builder::default()
    }
}

/// See [`InvalidBucketNameFilterException`](crate::error::InvalidBucketNameFilterException).
pub mod invalid_bucket_name_filter_exception {

    /// A builder for [`InvalidBucketNameFilterException`](crate::error::InvalidBucketNameFilterException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidBucketNameFilterException`](crate::error::InvalidBucketNameFilterException).
        pub fn build(self) -> crate::error::InvalidBucketNameFilterException {
            crate::error::InvalidBucketNameFilterException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A bucket name is required, but was not provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BucketNameFilterRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BucketNameFilterRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BucketNameFilterRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BucketNameFilterRequiredException")?;
        if let Some(inner_81) = &self.message {
            {
                write!(f, ": {}", inner_81)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BucketNameFilterRequiredException {}
impl aws_http::request_id::RequestId for crate::error::BucketNameFilterRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BucketNameFilterRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl BucketNameFilterRequiredException {
    /// Creates a new builder-style object to manufacture [`BucketNameFilterRequiredException`](crate::error::BucketNameFilterRequiredException).
    pub fn builder() -> crate::error::bucket_name_filter_required_exception::Builder {
        crate::error::bucket_name_filter_required_exception::Builder::default()
    }
}

/// See [`BucketNameFilterRequiredException`](crate::error::BucketNameFilterRequiredException).
pub mod bucket_name_filter_required_exception {

    /// A builder for [`BucketNameFilterRequiredException`](crate::error::BucketNameFilterRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BucketNameFilterRequiredException`](crate::error::BucketNameFilterRequiredException).
        pub fn build(self) -> crate::error::BucketNameFilterRequiredException {
            crate::error::BucketNameFilterRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetOnPremisesInstanceErrorKind = GetOnPremisesInstanceError;
/// Error type for the `GetOnPremisesInstanceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetOnPremisesInstanceError {
    /// <p>An on-premises instance name was not specified.</p>
    InstanceNameRequiredException(crate::error::InstanceNameRequiredException),
    /// <p>The specified on-premises instance is not registered.</p>
    InstanceNotRegisteredException(crate::error::InstanceNotRegisteredException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetOnPremisesInstanceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetOnPremisesInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InstanceNameRequiredException(_inner) => _inner.fmt(f),
            Self::InstanceNotRegisteredException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetOnPremisesInstanceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InstanceNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceNotRegisteredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetOnPremisesInstanceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetOnPremisesInstanceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetOnPremisesInstanceError {
    /// Creates the `GetOnPremisesInstanceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetOnPremisesInstanceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InstanceNameRequiredException(e) => e.meta(),
            Self::InstanceNotRegisteredException(e) => e.meta(),
            Self::InvalidInstanceNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetOnPremisesInstanceError::InstanceNameRequiredException`.
    pub fn is_instance_name_required_exception(&self) -> bool {
        matches!(self, Self::InstanceNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetOnPremisesInstanceError::InstanceNotRegisteredException`.
    pub fn is_instance_not_registered_exception(&self) -> bool {
        matches!(self, Self::InstanceNotRegisteredException(_))
    }
    /// Returns `true` if the error kind is `GetOnPremisesInstanceError::InvalidInstanceNameException`.
    pub fn is_invalid_instance_name_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceNameException(_))
    }
}
impl std::error::Error for GetOnPremisesInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InstanceNameRequiredException(_inner) => Some(_inner),
            Self::InstanceNotRegisteredException(_inner) => Some(_inner),
            Self::InvalidInstanceNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDeploymentTargetErrorKind = GetDeploymentTargetError;
/// Error type for the `GetDeploymentTargetError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeploymentTargetError {
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>The specified deployment has not started.</p>
    DeploymentNotStartedException(crate::error::DeploymentNotStartedException),
    /// <p> The provided target ID does not belong to the attempted deployment. </p>
    DeploymentTargetDoesNotExistException(crate::error::DeploymentTargetDoesNotExistException),
    /// <p> A deployment target ID was not provided. </p>
    DeploymentTargetIdRequiredException(crate::error::DeploymentTargetIdRequiredException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p> The target ID provided was not valid. </p>
    InvalidDeploymentTargetIdException(crate::error::InvalidDeploymentTargetIdException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDeploymentTargetError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDeploymentTargetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentNotStartedException(_inner) => _inner.fmt(f),
            Self::DeploymentTargetDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentTargetIdRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentTargetIdException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDeploymentTargetError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentNotStartedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentTargetDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentTargetIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentTargetIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDeploymentTargetError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDeploymentTargetError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeploymentTargetError {
    /// Creates the `GetDeploymentTargetError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDeploymentTargetError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::DeploymentNotStartedException(e) => e.meta(),
            Self::DeploymentTargetDoesNotExistException(e) => e.meta(),
            Self::DeploymentTargetIdRequiredException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::InvalidDeploymentTargetIdException(e) => e.meta(),
            Self::InvalidInstanceNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDeploymentTargetError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentTargetError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentTargetError::DeploymentNotStartedException`.
    pub fn is_deployment_not_started_exception(&self) -> bool {
        matches!(self, Self::DeploymentNotStartedException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentTargetError::DeploymentTargetDoesNotExistException`.
    pub fn is_deployment_target_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentTargetDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentTargetError::DeploymentTargetIdRequiredException`.
    pub fn is_deployment_target_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentTargetIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentTargetError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentTargetError::InvalidDeploymentTargetIdException`.
    pub fn is_invalid_deployment_target_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentTargetIdException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentTargetError::InvalidInstanceNameException`.
    pub fn is_invalid_instance_name_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceNameException(_))
    }
}
impl std::error::Error for GetDeploymentTargetError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::DeploymentNotStartedException(_inner) => Some(_inner),
            Self::DeploymentTargetDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentTargetIdRequiredException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::InvalidDeploymentTargetIdException(_inner) => Some(_inner),
            Self::InvalidInstanceNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p> The target ID provided was not valid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDeploymentTargetIdException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDeploymentTargetIdException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeploymentTargetIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeploymentTargetIdException")?;
        if let Some(inner_82) = &self.message {
            {
                write!(f, ": {}", inner_82)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeploymentTargetIdException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDeploymentTargetIdException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidDeploymentTargetIdException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDeploymentTargetIdException {
    /// Creates a new builder-style object to manufacture [`InvalidDeploymentTargetIdException`](crate::error::InvalidDeploymentTargetIdException).
    pub fn builder() -> crate::error::invalid_deployment_target_id_exception::Builder {
        crate::error::invalid_deployment_target_id_exception::Builder::default()
    }
}

/// See [`InvalidDeploymentTargetIdException`](crate::error::InvalidDeploymentTargetIdException).
pub mod invalid_deployment_target_id_exception {

    /// A builder for [`InvalidDeploymentTargetIdException`](crate::error::InvalidDeploymentTargetIdException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeploymentTargetIdException`](crate::error::InvalidDeploymentTargetIdException).
        pub fn build(self) -> crate::error::InvalidDeploymentTargetIdException {
            crate::error::InvalidDeploymentTargetIdException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> A deployment target ID was not provided. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentTargetIdRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentTargetIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentTargetIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentTargetIdRequiredException")?;
        if let Some(inner_83) = &self.message {
            {
                write!(f, ": {}", inner_83)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentTargetIdRequiredException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentTargetIdRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentTargetIdRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentTargetIdRequiredException {
    /// Creates a new builder-style object to manufacture [`DeploymentTargetIdRequiredException`](crate::error::DeploymentTargetIdRequiredException).
    pub fn builder() -> crate::error::deployment_target_id_required_exception::Builder {
        crate::error::deployment_target_id_required_exception::Builder::default()
    }
}

/// See [`DeploymentTargetIdRequiredException`](crate::error::DeploymentTargetIdRequiredException).
pub mod deployment_target_id_required_exception {

    /// A builder for [`DeploymentTargetIdRequiredException`](crate::error::DeploymentTargetIdRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentTargetIdRequiredException`](crate::error::DeploymentTargetIdRequiredException).
        pub fn build(self) -> crate::error::DeploymentTargetIdRequiredException {
            crate::error::DeploymentTargetIdRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> The provided target ID does not belong to the attempted deployment. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentTargetDoesNotExistException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentTargetDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentTargetDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentTargetDoesNotExistException")?;
        if let Some(inner_84) = &self.message {
            {
                write!(f, ": {}", inner_84)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentTargetDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentTargetDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentTargetDoesNotExistException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentTargetDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`DeploymentTargetDoesNotExistException`](crate::error::DeploymentTargetDoesNotExistException).
    pub fn builder() -> crate::error::deployment_target_does_not_exist_exception::Builder {
        crate::error::deployment_target_does_not_exist_exception::Builder::default()
    }
}

/// See [`DeploymentTargetDoesNotExistException`](crate::error::DeploymentTargetDoesNotExistException).
pub mod deployment_target_does_not_exist_exception {

    /// A builder for [`DeploymentTargetDoesNotExistException`](crate::error::DeploymentTargetDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentTargetDoesNotExistException`](crate::error::DeploymentTargetDoesNotExistException).
        pub fn build(self) -> crate::error::DeploymentTargetDoesNotExistException {
            crate::error::DeploymentTargetDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDeploymentInstanceErrorKind = GetDeploymentInstanceError;
/// Error type for the `GetDeploymentInstanceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeploymentInstanceError {
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>The specified instance does not exist in the deployment group.</p>
    #[deprecated(
        note = "This exception is deprecated, use DeploymentTargetDoesNotExistException instead."
    )]
    InstanceDoesNotExistException(crate::error::InstanceDoesNotExistException),
    /// <p>The instance ID was not specified.</p>
    #[deprecated(
        note = "This exception is deprecated, use DeploymentTargetIdRequiredException instead."
    )]
    InstanceIdRequiredException(crate::error::InstanceIdRequiredException),
    /// <p>The computePlatform is invalid. The computePlatform should be <code>Lambda</code>, <code>Server</code>, or <code>ECS</code>.</p>
    InvalidComputePlatformException(crate::error::InvalidComputePlatformException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDeploymentInstanceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDeploymentInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::InstanceDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InstanceIdRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidComputePlatformException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDeploymentInstanceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidComputePlatformException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDeploymentInstanceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDeploymentInstanceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeploymentInstanceError {
    /// Creates the `GetDeploymentInstanceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDeploymentInstanceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::InstanceDoesNotExistException(e) => e.meta(),
            Self::InstanceIdRequiredException(e) => e.meta(),
            Self::InvalidComputePlatformException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::InvalidInstanceNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDeploymentInstanceError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentInstanceError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentInstanceError::InstanceDoesNotExistException`.
    pub fn is_instance_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::InstanceDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentInstanceError::InstanceIdRequiredException`.
    pub fn is_instance_id_required_exception(&self) -> bool {
        matches!(self, Self::InstanceIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentInstanceError::InvalidComputePlatformException`.
    pub fn is_invalid_compute_platform_exception(&self) -> bool {
        matches!(self, Self::InvalidComputePlatformException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentInstanceError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentInstanceError::InvalidInstanceNameException`.
    pub fn is_invalid_instance_name_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceNameException(_))
    }
}
impl std::error::Error for GetDeploymentInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::InstanceDoesNotExistException(_inner) => Some(_inner),
            Self::InstanceIdRequiredException(_inner) => Some(_inner),
            Self::InvalidComputePlatformException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::InvalidInstanceNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The instance ID was not specified.</p>
#[deprecated(
    note = "This exception is deprecated, use DeploymentTargetIdRequiredException instead."
)]
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceIdRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InstanceIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstanceIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstanceIdRequiredException")?;
        if let Some(inner_85) = &self.message {
            {
                write!(f, ": {}", inner_85)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InstanceIdRequiredException {}
impl aws_http::request_id::RequestId for crate::error::InstanceIdRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InstanceIdRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InstanceIdRequiredException {
    /// Creates a new builder-style object to manufacture [`InstanceIdRequiredException`](crate::error::InstanceIdRequiredException).
    pub fn builder() -> crate::error::instance_id_required_exception::Builder {
        crate::error::instance_id_required_exception::Builder::default()
    }
}

/// See [`InstanceIdRequiredException`](crate::error::InstanceIdRequiredException).
pub mod instance_id_required_exception {

    /// A builder for [`InstanceIdRequiredException`](crate::error::InstanceIdRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InstanceIdRequiredException`](crate::error::InstanceIdRequiredException).
        pub fn build(self) -> crate::error::InstanceIdRequiredException {
            crate::error::InstanceIdRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The specified instance does not exist in the deployment group.</p>
#[deprecated(
    note = "This exception is deprecated, use DeploymentTargetDoesNotExistException instead."
)]
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InstanceDoesNotExistException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InstanceDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InstanceDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InstanceDoesNotExistException")?;
        if let Some(inner_86) = &self.message {
            {
                write!(f, ": {}", inner_86)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InstanceDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::InstanceDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InstanceDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InstanceDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`InstanceDoesNotExistException`](crate::error::InstanceDoesNotExistException).
    pub fn builder() -> crate::error::instance_does_not_exist_exception::Builder {
        crate::error::instance_does_not_exist_exception::Builder::default()
    }
}

/// See [`InstanceDoesNotExistException`](crate::error::InstanceDoesNotExistException).
pub mod instance_does_not_exist_exception {

    /// A builder for [`InstanceDoesNotExistException`](crate::error::InstanceDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InstanceDoesNotExistException`](crate::error::InstanceDoesNotExistException).
        pub fn build(self) -> crate::error::InstanceDoesNotExistException {
            crate::error::InstanceDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDeploymentGroupErrorKind = GetDeploymentGroupError;
/// Error type for the `GetDeploymentGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeploymentGroupError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::error::DeploymentConfigDoesNotExistException),
    /// <p>The named deployment group with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentGroupDoesNotExistException(crate::error::DeploymentGroupDoesNotExistException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::error::DeploymentGroupNameRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::error::InvalidDeploymentGroupNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDeploymentGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDeploymentGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentGroupNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDeploymentGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentGroupNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDeploymentGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDeploymentGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeploymentGroupError {
    /// Creates the `GetDeploymentGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDeploymentGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::DeploymentConfigDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupNameRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidDeploymentGroupNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDeploymentGroupError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentGroupError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentGroupError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentGroupError::DeploymentGroupDoesNotExistException`.
    pub fn is_deployment_group_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentGroupError::DeploymentGroupNameRequiredException`.
    pub fn is_deployment_group_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentGroupError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentGroupError::InvalidDeploymentGroupNameException`.
    pub fn is_invalid_deployment_group_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentGroupNameException(_))
    }
}
impl std::error::Error for GetDeploymentGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDeploymentConfigErrorKind = GetDeploymentConfigError;
/// Error type for the `GetDeploymentConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeploymentConfigError {
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::error::DeploymentConfigDoesNotExistException),
    /// <p>The deployment configuration name was not specified.</p>
    DeploymentConfigNameRequiredException(crate::error::DeploymentConfigNameRequiredException),
    /// <p>The computePlatform is invalid. The computePlatform should be <code>Lambda</code>, <code>Server</code>, or <code>ECS</code>.</p>
    InvalidComputePlatformException(crate::error::InvalidComputePlatformException),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::error::InvalidDeploymentConfigNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDeploymentConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDeploymentConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidComputePlatformException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentConfigNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDeploymentConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentConfigDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidComputePlatformException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentConfigNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDeploymentConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDeploymentConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeploymentConfigError {
    /// Creates the `GetDeploymentConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDeploymentConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentConfigDoesNotExistException(e) => e.meta(),
            Self::DeploymentConfigNameRequiredException(e) => e.meta(),
            Self::InvalidComputePlatformException(e) => e.meta(),
            Self::InvalidDeploymentConfigNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDeploymentConfigError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentConfigError::DeploymentConfigNameRequiredException`.
    pub fn is_deployment_config_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentConfigError::InvalidComputePlatformException`.
    pub fn is_invalid_compute_platform_exception(&self) -> bool {
        matches!(self, Self::InvalidComputePlatformException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentConfigError::InvalidDeploymentConfigNameException`.
    pub fn is_invalid_deployment_config_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentConfigNameException(_))
    }
}
impl std::error::Error for GetDeploymentConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentConfigDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentConfigNameRequiredException(_inner) => Some(_inner),
            Self::InvalidComputePlatformException(_inner) => Some(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The deployment configuration name was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentConfigNameRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentConfigNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentConfigNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentConfigNameRequiredException")?;
        if let Some(inner_87) = &self.message {
            {
                write!(f, ": {}", inner_87)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentConfigNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentConfigNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentConfigNameRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentConfigNameRequiredException {
    /// Creates a new builder-style object to manufacture [`DeploymentConfigNameRequiredException`](crate::error::DeploymentConfigNameRequiredException).
    pub fn builder() -> crate::error::deployment_config_name_required_exception::Builder {
        crate::error::deployment_config_name_required_exception::Builder::default()
    }
}

/// See [`DeploymentConfigNameRequiredException`](crate::error::DeploymentConfigNameRequiredException).
pub mod deployment_config_name_required_exception {

    /// A builder for [`DeploymentConfigNameRequiredException`](crate::error::DeploymentConfigNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentConfigNameRequiredException`](crate::error::DeploymentConfigNameRequiredException).
        pub fn build(self) -> crate::error::DeploymentConfigNameRequiredException {
            crate::error::DeploymentConfigNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDeploymentErrorKind = GetDeploymentError;
/// Error type for the `GetDeploymentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeploymentError {
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDeploymentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDeploymentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDeploymentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDeploymentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeploymentError {
    /// Creates the `GetDeploymentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDeploymentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDeploymentError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetDeploymentError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
}
impl std::error::Error for GetDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetApplicationRevisionErrorKind = GetApplicationRevisionError;
/// Error type for the `GetApplicationRevisionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApplicationRevisionError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The revision was specified in an invalid format.</p>
    InvalidRevisionException(crate::error::InvalidRevisionException),
    /// <p>The named revision does not exist with the IAM user or Amazon Web Services account.</p>
    RevisionDoesNotExistException(crate::error::RevisionDoesNotExistException),
    /// <p>The revision ID was not specified.</p>
    RevisionRequiredException(crate::error::RevisionRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetApplicationRevisionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetApplicationRevisionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidRevisionException(_inner) => _inner.fmt(f),
            Self::RevisionDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RevisionRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetApplicationRevisionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRevisionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetApplicationRevisionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetApplicationRevisionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApplicationRevisionError {
    /// Creates the `GetApplicationRevisionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetApplicationRevisionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidRevisionException(e) => e.meta(),
            Self::RevisionDoesNotExistException(e) => e.meta(),
            Self::RevisionRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetApplicationRevisionError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationRevisionError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationRevisionError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationRevisionError::InvalidRevisionException`.
    pub fn is_invalid_revision_exception(&self) -> bool {
        matches!(self, Self::InvalidRevisionException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationRevisionError::RevisionDoesNotExistException`.
    pub fn is_revision_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RevisionDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationRevisionError::RevisionRequiredException`.
    pub fn is_revision_required_exception(&self) -> bool {
        matches!(self, Self::RevisionRequiredException(_))
    }
}
impl std::error::Error for GetApplicationRevisionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidRevisionException(_inner) => Some(_inner),
            Self::RevisionDoesNotExistException(_inner) => Some(_inner),
            Self::RevisionRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The named revision does not exist with the IAM user or Amazon Web Services account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RevisionDoesNotExistException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RevisionDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RevisionDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RevisionDoesNotExistException")?;
        if let Some(inner_88) = &self.message {
            {
                write!(f, ": {}", inner_88)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RevisionDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::RevisionDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RevisionDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl RevisionDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`RevisionDoesNotExistException`](crate::error::RevisionDoesNotExistException).
    pub fn builder() -> crate::error::revision_does_not_exist_exception::Builder {
        crate::error::revision_does_not_exist_exception::Builder::default()
    }
}

/// See [`RevisionDoesNotExistException`](crate::error::RevisionDoesNotExistException).
pub mod revision_does_not_exist_exception {

    /// A builder for [`RevisionDoesNotExistException`](crate::error::RevisionDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RevisionDoesNotExistException`](crate::error::RevisionDoesNotExistException).
        pub fn build(self) -> crate::error::RevisionDoesNotExistException {
            crate::error::RevisionDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetApplicationErrorKind = GetApplicationError;
/// Error type for the `GetApplicationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApplicationError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetApplicationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetApplicationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetApplicationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetApplicationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApplicationError {
    /// Creates the `GetApplicationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetApplicationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetApplicationError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetApplicationError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
}
impl std::error::Error for GetApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeregisterOnPremisesInstanceErrorKind = DeregisterOnPremisesInstanceError;
/// Error type for the `DeregisterOnPremisesInstanceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeregisterOnPremisesInstanceError {
    /// <p>An on-premises instance name was not specified.</p>
    InstanceNameRequiredException(crate::error::InstanceNameRequiredException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeregisterOnPremisesInstanceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeregisterOnPremisesInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InstanceNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeregisterOnPremisesInstanceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InstanceNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeregisterOnPremisesInstanceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeregisterOnPremisesInstanceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeregisterOnPremisesInstanceError {
    /// Creates the `DeregisterOnPremisesInstanceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeregisterOnPremisesInstanceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InstanceNameRequiredException(e) => e.meta(),
            Self::InvalidInstanceNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeregisterOnPremisesInstanceError::InstanceNameRequiredException`.
    pub fn is_instance_name_required_exception(&self) -> bool {
        matches!(self, Self::InstanceNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeregisterOnPremisesInstanceError::InvalidInstanceNameException`.
    pub fn is_invalid_instance_name_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceNameException(_))
    }
}
impl std::error::Error for DeregisterOnPremisesInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InstanceNameRequiredException(_inner) => Some(_inner),
            Self::InvalidInstanceNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteResourcesByExternalIdErrorKind = DeleteResourcesByExternalIdError;
/// Error type for the `DeleteResourcesByExternalIdError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourcesByExternalIdError {
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteResourcesByExternalIdError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteResourcesByExternalIdError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteResourcesByExternalIdError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteResourcesByExternalIdError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteResourcesByExternalIdError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourcesByExternalIdError {
    /// Creates the `DeleteResourcesByExternalIdError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteResourcesByExternalIdError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::Unhandled(e) => e.meta(),
        }
    }
}
impl std::error::Error for DeleteResourcesByExternalIdError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteGitHubAccountTokenErrorKind = DeleteGitHubAccountTokenError;
/// Error type for the `DeleteGitHubAccountTokenError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteGitHubAccountTokenError {
    /// <p>No GitHub account connection exists with the named specified in the call.</p>
    GitHubAccountTokenDoesNotExistException(crate::error::GitHubAccountTokenDoesNotExistException),
    /// <p>The call is missing a required GitHub account connection name.</p>
    GitHubAccountTokenNameRequiredException(crate::error::GitHubAccountTokenNameRequiredException),
    /// <p>The format of the specified GitHub account connection name is invalid.</p>
    InvalidGitHubAccountTokenNameException(crate::error::InvalidGitHubAccountTokenNameException),
    /// <p>The API used does not support the deployment.</p>
    OperationNotSupportedException(crate::error::OperationNotSupportedException),
    /// <p>The specified resource could not be validated.</p>
    ResourceValidationException(crate::error::ResourceValidationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteGitHubAccountTokenError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteGitHubAccountTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::GitHubAccountTokenDoesNotExistException(_inner) => _inner.fmt(f),
            Self::GitHubAccountTokenNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidGitHubAccountTokenNameException(_inner) => _inner.fmt(f),
            Self::OperationNotSupportedException(_inner) => _inner.fmt(f),
            Self::ResourceValidationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteGitHubAccountTokenError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::GitHubAccountTokenDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::GitHubAccountTokenNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGitHubAccountTokenNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OperationNotSupportedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceValidationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteGitHubAccountTokenError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteGitHubAccountTokenError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteGitHubAccountTokenError {
    /// Creates the `DeleteGitHubAccountTokenError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteGitHubAccountTokenError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::GitHubAccountTokenDoesNotExistException(e) => e.meta(),
            Self::GitHubAccountTokenNameRequiredException(e) => e.meta(),
            Self::InvalidGitHubAccountTokenNameException(e) => e.meta(),
            Self::OperationNotSupportedException(e) => e.meta(),
            Self::ResourceValidationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteGitHubAccountTokenError::GitHubAccountTokenDoesNotExistException`.
    pub fn is_git_hub_account_token_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::GitHubAccountTokenDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteGitHubAccountTokenError::GitHubAccountTokenNameRequiredException`.
    pub fn is_git_hub_account_token_name_required_exception(&self) -> bool {
        matches!(self, Self::GitHubAccountTokenNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteGitHubAccountTokenError::InvalidGitHubAccountTokenNameException`.
    pub fn is_invalid_git_hub_account_token_name_exception(&self) -> bool {
        matches!(self, Self::InvalidGitHubAccountTokenNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteGitHubAccountTokenError::OperationNotSupportedException`.
    pub fn is_operation_not_supported_exception(&self) -> bool {
        matches!(self, Self::OperationNotSupportedException(_))
    }
    /// Returns `true` if the error kind is `DeleteGitHubAccountTokenError::ResourceValidationException`.
    pub fn is_resource_validation_exception(&self) -> bool {
        matches!(self, Self::ResourceValidationException(_))
    }
}
impl std::error::Error for DeleteGitHubAccountTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::GitHubAccountTokenDoesNotExistException(_inner) => Some(_inner),
            Self::GitHubAccountTokenNameRequiredException(_inner) => Some(_inner),
            Self::InvalidGitHubAccountTokenNameException(_inner) => Some(_inner),
            Self::OperationNotSupportedException(_inner) => Some(_inner),
            Self::ResourceValidationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The format of the specified GitHub account connection name is invalid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidGitHubAccountTokenNameException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidGitHubAccountTokenNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGitHubAccountTokenNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGitHubAccountTokenNameException")?;
        if let Some(inner_89) = &self.message {
            {
                write!(f, ": {}", inner_89)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGitHubAccountTokenNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidGitHubAccountTokenNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidGitHubAccountTokenNameException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidGitHubAccountTokenNameException {
    /// Creates a new builder-style object to manufacture [`InvalidGitHubAccountTokenNameException`](crate::error::InvalidGitHubAccountTokenNameException).
    pub fn builder() -> crate::error::invalid_git_hub_account_token_name_exception::Builder {
        crate::error::invalid_git_hub_account_token_name_exception::Builder::default()
    }
}

/// See [`InvalidGitHubAccountTokenNameException`](crate::error::InvalidGitHubAccountTokenNameException).
pub mod invalid_git_hub_account_token_name_exception {

    /// A builder for [`InvalidGitHubAccountTokenNameException`](crate::error::InvalidGitHubAccountTokenNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGitHubAccountTokenNameException`](crate::error::InvalidGitHubAccountTokenNameException).
        pub fn build(self) -> crate::error::InvalidGitHubAccountTokenNameException {
            crate::error::InvalidGitHubAccountTokenNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The call is missing a required GitHub account connection name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GitHubAccountTokenNameRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl GitHubAccountTokenNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GitHubAccountTokenNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GitHubAccountTokenNameRequiredException")?;
        if let Some(inner_90) = &self.message {
            {
                write!(f, ": {}", inner_90)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for GitHubAccountTokenNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::GitHubAccountTokenNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GitHubAccountTokenNameRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl GitHubAccountTokenNameRequiredException {
    /// Creates a new builder-style object to manufacture [`GitHubAccountTokenNameRequiredException`](crate::error::GitHubAccountTokenNameRequiredException).
    pub fn builder() -> crate::error::git_hub_account_token_name_required_exception::Builder {
        crate::error::git_hub_account_token_name_required_exception::Builder::default()
    }
}

/// See [`GitHubAccountTokenNameRequiredException`](crate::error::GitHubAccountTokenNameRequiredException).
pub mod git_hub_account_token_name_required_exception {

    /// A builder for [`GitHubAccountTokenNameRequiredException`](crate::error::GitHubAccountTokenNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`GitHubAccountTokenNameRequiredException`](crate::error::GitHubAccountTokenNameRequiredException).
        pub fn build(self) -> crate::error::GitHubAccountTokenNameRequiredException {
            crate::error::GitHubAccountTokenNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>No GitHub account connection exists with the named specified in the call.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GitHubAccountTokenDoesNotExistException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl GitHubAccountTokenDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for GitHubAccountTokenDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GitHubAccountTokenDoesNotExistException")?;
        if let Some(inner_91) = &self.message {
            {
                write!(f, ": {}", inner_91)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for GitHubAccountTokenDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::GitHubAccountTokenDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for GitHubAccountTokenDoesNotExistException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl GitHubAccountTokenDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`GitHubAccountTokenDoesNotExistException`](crate::error::GitHubAccountTokenDoesNotExistException).
    pub fn builder() -> crate::error::git_hub_account_token_does_not_exist_exception::Builder {
        crate::error::git_hub_account_token_does_not_exist_exception::Builder::default()
    }
}

/// See [`GitHubAccountTokenDoesNotExistException`](crate::error::GitHubAccountTokenDoesNotExistException).
pub mod git_hub_account_token_does_not_exist_exception {

    /// A builder for [`GitHubAccountTokenDoesNotExistException`](crate::error::GitHubAccountTokenDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`GitHubAccountTokenDoesNotExistException`](crate::error::GitHubAccountTokenDoesNotExistException).
        pub fn build(self) -> crate::error::GitHubAccountTokenDoesNotExistException {
            crate::error::GitHubAccountTokenDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDeploymentGroupErrorKind = DeleteDeploymentGroupError;
/// Error type for the `DeleteDeploymentGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDeploymentGroupError {
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::error::DeploymentGroupNameRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::error::InvalidDeploymentGroupNameException),
    /// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
    InvalidRoleException(crate::error::InvalidRoleException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDeploymentGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDeploymentGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentGroupNameException(_inner) => _inner.fmt(f),
            Self::InvalidRoleException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDeploymentGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentGroupNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRoleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDeploymentGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDeploymentGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDeploymentGroupError {
    /// Creates the `DeleteDeploymentGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDeploymentGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::DeploymentGroupNameRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidDeploymentGroupNameException(e) => e.meta(),
            Self::InvalidRoleException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDeploymentGroupError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteDeploymentGroupError::DeploymentGroupNameRequiredException`.
    pub fn is_deployment_group_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteDeploymentGroupError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteDeploymentGroupError::InvalidDeploymentGroupNameException`.
    pub fn is_invalid_deployment_group_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentGroupNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteDeploymentGroupError::InvalidRoleException`.
    pub fn is_invalid_role_exception(&self) -> bool {
        matches!(self, Self::InvalidRoleException(_))
    }
}
impl std::error::Error for DeleteDeploymentGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => Some(_inner),
            Self::InvalidRoleException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteDeploymentConfigErrorKind = DeleteDeploymentConfigError;
/// Error type for the `DeleteDeploymentConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDeploymentConfigError {
    /// <p>The deployment configuration is still in use.</p>
    DeploymentConfigInUseException(crate::error::DeploymentConfigInUseException),
    /// <p>The deployment configuration name was not specified.</p>
    DeploymentConfigNameRequiredException(crate::error::DeploymentConfigNameRequiredException),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::error::InvalidDeploymentConfigNameException),
    /// <p>An invalid operation was detected.</p>
    InvalidOperationException(crate::error::InvalidOperationException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteDeploymentConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteDeploymentConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentConfigInUseException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentConfigNameException(_inner) => _inner.fmt(f),
            Self::InvalidOperationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteDeploymentConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentConfigInUseException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentConfigNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOperationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteDeploymentConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteDeploymentConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDeploymentConfigError {
    /// Creates the `DeleteDeploymentConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteDeploymentConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentConfigInUseException(e) => e.meta(),
            Self::DeploymentConfigNameRequiredException(e) => e.meta(),
            Self::InvalidDeploymentConfigNameException(e) => e.meta(),
            Self::InvalidOperationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteDeploymentConfigError::DeploymentConfigInUseException`.
    pub fn is_deployment_config_in_use_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigInUseException(_))
    }
    /// Returns `true` if the error kind is `DeleteDeploymentConfigError::DeploymentConfigNameRequiredException`.
    pub fn is_deployment_config_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteDeploymentConfigError::InvalidDeploymentConfigNameException`.
    pub fn is_invalid_deployment_config_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentConfigNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteDeploymentConfigError::InvalidOperationException`.
    pub fn is_invalid_operation_exception(&self) -> bool {
        matches!(self, Self::InvalidOperationException(_))
    }
}
impl std::error::Error for DeleteDeploymentConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentConfigInUseException(_inner) => Some(_inner),
            Self::DeploymentConfigNameRequiredException(_inner) => Some(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => Some(_inner),
            Self::InvalidOperationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An invalid operation was detected.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidOperationException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidOperationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOperationException")?;
        if let Some(inner_92) = &self.message {
            {
                write!(f, ": {}", inner_92)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOperationException {}
impl aws_http::request_id::RequestId for crate::error::InvalidOperationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidOperationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidOperationException {
    /// Creates a new builder-style object to manufacture [`InvalidOperationException`](crate::error::InvalidOperationException).
    pub fn builder() -> crate::error::invalid_operation_exception::Builder {
        crate::error::invalid_operation_exception::Builder::default()
    }
}

/// See [`InvalidOperationException`](crate::error::InvalidOperationException).
pub mod invalid_operation_exception {

    /// A builder for [`InvalidOperationException`](crate::error::InvalidOperationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOperationException`](crate::error::InvalidOperationException).
        pub fn build(self) -> crate::error::InvalidOperationException {
            crate::error::InvalidOperationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The deployment configuration is still in use.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentConfigInUseException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentConfigInUseException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentConfigInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentConfigInUseException")?;
        if let Some(inner_93) = &self.message {
            {
                write!(f, ": {}", inner_93)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentConfigInUseException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentConfigInUseException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeploymentConfigInUseException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentConfigInUseException {
    /// Creates a new builder-style object to manufacture [`DeploymentConfigInUseException`](crate::error::DeploymentConfigInUseException).
    pub fn builder() -> crate::error::deployment_config_in_use_exception::Builder {
        crate::error::deployment_config_in_use_exception::Builder::default()
    }
}

/// See [`DeploymentConfigInUseException`](crate::error::DeploymentConfigInUseException).
pub mod deployment_config_in_use_exception {

    /// A builder for [`DeploymentConfigInUseException`](crate::error::DeploymentConfigInUseException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentConfigInUseException`](crate::error::DeploymentConfigInUseException).
        pub fn build(self) -> crate::error::DeploymentConfigInUseException {
            crate::error::DeploymentConfigInUseException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteApplicationErrorKind = DeleteApplicationError;
/// Error type for the `DeleteApplicationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApplicationError {
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
    InvalidRoleException(crate::error::InvalidRoleException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteApplicationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidRoleException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteApplicationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRoleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteApplicationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteApplicationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApplicationError {
    /// Creates the `DeleteApplicationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteApplicationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidRoleException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteApplicationError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteApplicationError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteApplicationError::InvalidRoleException`.
    pub fn is_invalid_role_exception(&self) -> bool {
        matches!(self, Self::InvalidRoleException(_))
    }
}
impl std::error::Error for DeleteApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidRoleException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDeploymentGroupErrorKind = CreateDeploymentGroupError;
/// Error type for the `CreateDeploymentGroupError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDeploymentGroupError {
    /// <p>The maximum number of alarms for a deployment group (10) was exceeded.</p>
    AlarmsLimitExceededException(crate::error::AlarmsLimitExceededException),
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::error::DeploymentConfigDoesNotExistException),
    /// <p>A deployment group with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    DeploymentGroupAlreadyExistsException(crate::error::DeploymentGroupAlreadyExistsException),
    /// <p> The deployment groups limit was exceeded.</p>
    DeploymentGroupLimitExceededException(crate::error::DeploymentGroupLimitExceededException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::error::DeploymentGroupNameRequiredException),
    /// <p> The Amazon ECS service is associated with more than one deployment groups. An Amazon ECS service can be associated with only one deployment group. </p>
    EcsServiceMappingLimitExceededException(crate::error::EcsServiceMappingLimitExceededException),
    /// <p>The format of the alarm configuration is invalid. Possible causes include:</p>
    /// <ul>
    /// <li> <p>The alarm list is null.</p> </li>
    /// <li> <p>The alarm object is null.</p> </li>
    /// <li> <p>The alarm name is empty or null or exceeds the limit of 255 characters.</p> </li>
    /// <li> <p>Two alarms with the same name have been specified.</p> </li>
    /// <li> <p>The alarm configuration is enabled, but the alarm list is empty.</p> </li>
    /// </ul>
    InvalidAlarmConfigException(crate::error::InvalidAlarmConfigException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The automatic rollback configuration was specified in an invalid format. For example, automatic rollback is enabled, but an invalid triggering event type or no event types were listed.</p>
    InvalidAutoRollbackConfigException(crate::error::InvalidAutoRollbackConfigException),
    /// <p>The Auto Scaling group was specified in an invalid format or does not exist.</p>
    InvalidAutoScalingGroupException(crate::error::InvalidAutoScalingGroupException),
    /// <p>The configuration for the blue/green deployment group was provided in an invalid format. For information about deployment configuration format, see <code>CreateDeploymentConfig</code>.</p>
    InvalidBlueGreenDeploymentConfigurationException(
        crate::error::InvalidBlueGreenDeploymentConfigurationException,
    ),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::error::InvalidDeploymentConfigNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::error::InvalidDeploymentGroupNameException),
    /// <p>An invalid deployment style was specified. Valid deployment types include "IN_PLACE" and "BLUE_GREEN." Valid deployment options include "WITH_TRAFFIC_CONTROL" and "WITHOUT_TRAFFIC_CONTROL."</p>
    InvalidDeploymentStyleException(crate::error::InvalidDeploymentStyleException),
    /// <p>A call was submitted that specified both Ec2TagFilters and Ec2TagSet, but only one of these data types can be used in a single call.</p>
    InvalidEc2TagCombinationException(crate::error::InvalidEc2TagCombinationException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidEc2TagException(crate::error::InvalidEc2TagException),
    /// <p> The Amazon ECS service identifier is not valid. </p>
    InvalidEcsServiceException(crate::error::InvalidEcsServiceException),
    /// <p>The input was specified in an invalid format.</p>
    InvalidInputException(crate::error::InvalidInputException),
    /// <p>An invalid load balancer name, or no load balancer name, was specified.</p>
    InvalidLoadBalancerInfoException(crate::error::InvalidLoadBalancerInfoException),
    /// <p>A call was submitted that specified both OnPremisesTagFilters and OnPremisesTagSet, but only one of these data types can be used in a single call.</p>
    InvalidOnPremisesTagCombinationException(
        crate::error::InvalidOnPremisesTagCombinationException,
    ),
    /// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
    InvalidRoleException(crate::error::InvalidRoleException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p> The specified tags are not valid. </p>
    InvalidTagsToAddException(crate::error::InvalidTagsToAddException),
    /// <p> A target group pair associated with this deployment is not valid. </p>
    InvalidTargetGroupPairException(crate::error::InvalidTargetGroupPairException),
    /// <p> The configuration that specifies how traffic is routed during a deployment is invalid.</p>
    InvalidTrafficRoutingConfigurationException(
        crate::error::InvalidTrafficRoutingConfigurationException,
    ),
    /// <p>The trigger was specified in an invalid format.</p>
    InvalidTriggerConfigException(crate::error::InvalidTriggerConfigException),
    /// <p>The limit for lifecycle hooks was exceeded.</p>
    LifecycleHookLimitExceededException(crate::error::LifecycleHookLimitExceededException),
    /// <p>The role ID was not specified.</p>
    RoleRequiredException(crate::error::RoleRequiredException),
    /// <p>The number of tag groups included in the tag set list exceeded the maximum allowed limit of 3.</p>
    TagSetListLimitExceededException(crate::error::TagSetListLimitExceededException),
    /// <p>An API function was called too frequently.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// <p>The maximum allowed number of triggers was exceeded.</p>
    TriggerTargetsLimitExceededException(crate::error::TriggerTargetsLimitExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDeploymentGroupError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDeploymentGroupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AlarmsLimitExceededException(_inner) => _inner.fmt(f),
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupLimitExceededException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupNameRequiredException(_inner) => _inner.fmt(f),
            Self::EcsServiceMappingLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidAlarmConfigException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidAutoRollbackConfigException(_inner) => _inner.fmt(f),
            Self::InvalidAutoScalingGroupException(_inner) => _inner.fmt(f),
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentConfigNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentGroupNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentStyleException(_inner) => _inner.fmt(f),
            Self::InvalidEc2TagCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidEc2TagException(_inner) => _inner.fmt(f),
            Self::InvalidEcsServiceException(_inner) => _inner.fmt(f),
            Self::InvalidInputException(_inner) => _inner.fmt(f),
            Self::InvalidLoadBalancerInfoException(_inner) => _inner.fmt(f),
            Self::InvalidOnPremisesTagCombinationException(_inner) => _inner.fmt(f),
            Self::InvalidRoleException(_inner) => _inner.fmt(f),
            Self::InvalidTagException(_inner) => _inner.fmt(f),
            Self::InvalidTagsToAddException(_inner) => _inner.fmt(f),
            Self::InvalidTargetGroupPairException(_inner) => _inner.fmt(f),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => _inner.fmt(f),
            Self::InvalidTriggerConfigException(_inner) => _inner.fmt(f),
            Self::LifecycleHookLimitExceededException(_inner) => _inner.fmt(f),
            Self::RoleRequiredException(_inner) => _inner.fmt(f),
            Self::TagSetListLimitExceededException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::TriggerTargetsLimitExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDeploymentGroupError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AlarmsLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EcsServiceMappingLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAlarmConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAutoRollbackConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAutoScalingGroupException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentConfigNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentGroupNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentStyleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEc2TagCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEc2TagException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEcsServiceException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInputException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLoadBalancerInfoException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOnPremisesTagCombinationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRoleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagsToAddException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetGroupPairException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTrafficRoutingConfigurationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTriggerConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::LifecycleHookLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RoleRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagSetListLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ThrottlingException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TriggerTargetsLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDeploymentGroupError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDeploymentGroupError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDeploymentGroupError {
    /// Creates the `CreateDeploymentGroupError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDeploymentGroupError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AlarmsLimitExceededException(e) => e.meta(),
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::DeploymentConfigDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupAlreadyExistsException(e) => e.meta(),
            Self::DeploymentGroupLimitExceededException(e) => e.meta(),
            Self::DeploymentGroupNameRequiredException(e) => e.meta(),
            Self::EcsServiceMappingLimitExceededException(e) => e.meta(),
            Self::InvalidAlarmConfigException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidAutoRollbackConfigException(e) => e.meta(),
            Self::InvalidAutoScalingGroupException(e) => e.meta(),
            Self::InvalidBlueGreenDeploymentConfigurationException(e) => e.meta(),
            Self::InvalidDeploymentConfigNameException(e) => e.meta(),
            Self::InvalidDeploymentGroupNameException(e) => e.meta(),
            Self::InvalidDeploymentStyleException(e) => e.meta(),
            Self::InvalidEc2TagCombinationException(e) => e.meta(),
            Self::InvalidEc2TagException(e) => e.meta(),
            Self::InvalidEcsServiceException(e) => e.meta(),
            Self::InvalidInputException(e) => e.meta(),
            Self::InvalidLoadBalancerInfoException(e) => e.meta(),
            Self::InvalidOnPremisesTagCombinationException(e) => e.meta(),
            Self::InvalidRoleException(e) => e.meta(),
            Self::InvalidTagException(e) => e.meta(),
            Self::InvalidTagsToAddException(e) => e.meta(),
            Self::InvalidTargetGroupPairException(e) => e.meta(),
            Self::InvalidTrafficRoutingConfigurationException(e) => e.meta(),
            Self::InvalidTriggerConfigException(e) => e.meta(),
            Self::LifecycleHookLimitExceededException(e) => e.meta(),
            Self::RoleRequiredException(e) => e.meta(),
            Self::TagSetListLimitExceededException(e) => e.meta(),
            Self::ThrottlingException(e) => e.meta(),
            Self::TriggerTargetsLimitExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::AlarmsLimitExceededException`.
    pub fn is_alarms_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::AlarmsLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentGroupAlreadyExistsException`.
    pub fn is_deployment_group_already_exists_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentGroupLimitExceededException`.
    pub fn is_deployment_group_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::DeploymentGroupNameRequiredException`.
    pub fn is_deployment_group_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::EcsServiceMappingLimitExceededException`.
    pub fn is_ecs_service_mapping_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::EcsServiceMappingLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidAlarmConfigException`.
    pub fn is_invalid_alarm_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAlarmConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidAutoRollbackConfigException`.
    pub fn is_invalid_auto_rollback_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoRollbackConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidAutoScalingGroupException`.
    pub fn is_invalid_auto_scaling_group_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoScalingGroupException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidBlueGreenDeploymentConfigurationException`.
    pub fn is_invalid_blue_green_deployment_configuration_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidBlueGreenDeploymentConfigurationException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidDeploymentConfigNameException`.
    pub fn is_invalid_deployment_config_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentConfigNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidDeploymentGroupNameException`.
    pub fn is_invalid_deployment_group_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentGroupNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidDeploymentStyleException`.
    pub fn is_invalid_deployment_style_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentStyleException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidEc2TagCombinationException`.
    pub fn is_invalid_ec2_tag_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidEc2TagCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidEc2TagException`.
    pub fn is_invalid_ec2_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidEc2TagException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidEcsServiceException`.
    pub fn is_invalid_ecs_service_exception(&self) -> bool {
        matches!(self, Self::InvalidEcsServiceException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidInputException`.
    pub fn is_invalid_input_exception(&self) -> bool {
        matches!(self, Self::InvalidInputException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidLoadBalancerInfoException`.
    pub fn is_invalid_load_balancer_info_exception(&self) -> bool {
        matches!(self, Self::InvalidLoadBalancerInfoException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidOnPremisesTagCombinationException`.
    pub fn is_invalid_on_premises_tag_combination_exception(&self) -> bool {
        matches!(self, Self::InvalidOnPremisesTagCombinationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidRoleException`.
    pub fn is_invalid_role_exception(&self) -> bool {
        matches!(self, Self::InvalidRoleException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidTagException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTagsToAddException`.
    pub fn is_invalid_tags_to_add_exception(&self) -> bool {
        matches!(self, Self::InvalidTagsToAddException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTargetGroupPairException`.
    pub fn is_invalid_target_group_pair_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetGroupPairException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTrafficRoutingConfigurationException`.
    pub fn is_invalid_traffic_routing_configuration_exception(&self) -> bool {
        matches!(self, Self::InvalidTrafficRoutingConfigurationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::InvalidTriggerConfigException`.
    pub fn is_invalid_trigger_config_exception(&self) -> bool {
        matches!(self, Self::InvalidTriggerConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::LifecycleHookLimitExceededException`.
    pub fn is_lifecycle_hook_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LifecycleHookLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::RoleRequiredException`.
    pub fn is_role_required_exception(&self) -> bool {
        matches!(self, Self::RoleRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::TagSetListLimitExceededException`.
    pub fn is_tag_set_list_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TagSetListLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentGroupError::TriggerTargetsLimitExceededException`.
    pub fn is_trigger_targets_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TriggerTargetsLimitExceededException(_))
    }
}
impl std::error::Error for CreateDeploymentGroupError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AlarmsLimitExceededException(_inner) => Some(_inner),
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupAlreadyExistsException(_inner) => Some(_inner),
            Self::DeploymentGroupLimitExceededException(_inner) => Some(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => Some(_inner),
            Self::EcsServiceMappingLimitExceededException(_inner) => Some(_inner),
            Self::InvalidAlarmConfigException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidAutoRollbackConfigException(_inner) => Some(_inner),
            Self::InvalidAutoScalingGroupException(_inner) => Some(_inner),
            Self::InvalidBlueGreenDeploymentConfigurationException(_inner) => Some(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentStyleException(_inner) => Some(_inner),
            Self::InvalidEc2TagCombinationException(_inner) => Some(_inner),
            Self::InvalidEc2TagException(_inner) => Some(_inner),
            Self::InvalidEcsServiceException(_inner) => Some(_inner),
            Self::InvalidInputException(_inner) => Some(_inner),
            Self::InvalidLoadBalancerInfoException(_inner) => Some(_inner),
            Self::InvalidOnPremisesTagCombinationException(_inner) => Some(_inner),
            Self::InvalidRoleException(_inner) => Some(_inner),
            Self::InvalidTagException(_inner) => Some(_inner),
            Self::InvalidTagsToAddException(_inner) => Some(_inner),
            Self::InvalidTargetGroupPairException(_inner) => Some(_inner),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => Some(_inner),
            Self::InvalidTriggerConfigException(_inner) => Some(_inner),
            Self::LifecycleHookLimitExceededException(_inner) => Some(_inner),
            Self::RoleRequiredException(_inner) => Some(_inner),
            Self::TagSetListLimitExceededException(_inner) => Some(_inner),
            Self::ThrottlingException(_inner) => Some(_inner),
            Self::TriggerTargetsLimitExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The role ID was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RoleRequiredException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RoleRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RoleRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RoleRequiredException")?;
        if let Some(inner_94) = &self.message {
            {
                write!(f, ": {}", inner_94)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RoleRequiredException {}
impl aws_http::request_id::RequestId for crate::error::RoleRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RoleRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl RoleRequiredException {
    /// Creates a new builder-style object to manufacture [`RoleRequiredException`](crate::error::RoleRequiredException).
    pub fn builder() -> crate::error::role_required_exception::Builder {
        crate::error::role_required_exception::Builder::default()
    }
}

/// See [`RoleRequiredException`](crate::error::RoleRequiredException).
pub mod role_required_exception {

    /// A builder for [`RoleRequiredException`](crate::error::RoleRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RoleRequiredException`](crate::error::RoleRequiredException).
        pub fn build(self) -> crate::error::RoleRequiredException {
            crate::error::RoleRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p> The deployment groups limit was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentGroupLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentGroupLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentGroupLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentGroupLimitExceededException")?;
        if let Some(inner_95) = &self.message {
            {
                write!(f, ": {}", inner_95)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentGroupLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentGroupLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentGroupLimitExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentGroupLimitExceededException {
    /// Creates a new builder-style object to manufacture [`DeploymentGroupLimitExceededException`](crate::error::DeploymentGroupLimitExceededException).
    pub fn builder() -> crate::error::deployment_group_limit_exceeded_exception::Builder {
        crate::error::deployment_group_limit_exceeded_exception::Builder::default()
    }
}

/// See [`DeploymentGroupLimitExceededException`](crate::error::DeploymentGroupLimitExceededException).
pub mod deployment_group_limit_exceeded_exception {

    /// A builder for [`DeploymentGroupLimitExceededException`](crate::error::DeploymentGroupLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentGroupLimitExceededException`](crate::error::DeploymentGroupLimitExceededException).
        pub fn build(self) -> crate::error::DeploymentGroupLimitExceededException {
            crate::error::DeploymentGroupLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDeploymentConfigErrorKind = CreateDeploymentConfigError;
/// Error type for the `CreateDeploymentConfigError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDeploymentConfigError {
    /// <p>A deployment configuration with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    DeploymentConfigAlreadyExistsException(crate::error::DeploymentConfigAlreadyExistsException),
    /// <p>The deployment configurations limit was exceeded.</p>
    DeploymentConfigLimitExceededException(crate::error::DeploymentConfigLimitExceededException),
    /// <p>The deployment configuration name was not specified.</p>
    DeploymentConfigNameRequiredException(crate::error::DeploymentConfigNameRequiredException),
    /// <p>The computePlatform is invalid. The computePlatform should be <code>Lambda</code>, <code>Server</code>, or <code>ECS</code>.</p>
    InvalidComputePlatformException(crate::error::InvalidComputePlatformException),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::error::InvalidDeploymentConfigNameException),
    /// <p>The minimum healthy instance value was specified in an invalid format.</p>
    InvalidMinimumHealthyHostValueException(crate::error::InvalidMinimumHealthyHostValueException),
    /// <p> The configuration that specifies how traffic is routed during a deployment is invalid.</p>
    InvalidTrafficRoutingConfigurationException(
        crate::error::InvalidTrafficRoutingConfigurationException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDeploymentConfigError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDeploymentConfigError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentConfigAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigLimitExceededException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidComputePlatformException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentConfigNameException(_inner) => _inner.fmt(f),
            Self::InvalidMinimumHealthyHostValueException(_inner) => _inner.fmt(f),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDeploymentConfigError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentConfigAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidComputePlatformException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentConfigNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMinimumHealthyHostValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTrafficRoutingConfigurationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDeploymentConfigError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDeploymentConfigError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDeploymentConfigError {
    /// Creates the `CreateDeploymentConfigError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDeploymentConfigError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentConfigAlreadyExistsException(e) => e.meta(),
            Self::DeploymentConfigLimitExceededException(e) => e.meta(),
            Self::DeploymentConfigNameRequiredException(e) => e.meta(),
            Self::InvalidComputePlatformException(e) => e.meta(),
            Self::InvalidDeploymentConfigNameException(e) => e.meta(),
            Self::InvalidMinimumHealthyHostValueException(e) => e.meta(),
            Self::InvalidTrafficRoutingConfigurationException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDeploymentConfigError::DeploymentConfigAlreadyExistsException`.
    pub fn is_deployment_config_already_exists_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentConfigError::DeploymentConfigLimitExceededException`.
    pub fn is_deployment_config_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentConfigError::DeploymentConfigNameRequiredException`.
    pub fn is_deployment_config_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentConfigError::InvalidComputePlatformException`.
    pub fn is_invalid_compute_platform_exception(&self) -> bool {
        matches!(self, Self::InvalidComputePlatformException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentConfigError::InvalidDeploymentConfigNameException`.
    pub fn is_invalid_deployment_config_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentConfigNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentConfigError::InvalidMinimumHealthyHostValueException`.
    pub fn is_invalid_minimum_healthy_host_value_exception(&self) -> bool {
        matches!(self, Self::InvalidMinimumHealthyHostValueException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentConfigError::InvalidTrafficRoutingConfigurationException`.
    pub fn is_invalid_traffic_routing_configuration_exception(&self) -> bool {
        matches!(self, Self::InvalidTrafficRoutingConfigurationException(_))
    }
}
impl std::error::Error for CreateDeploymentConfigError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentConfigAlreadyExistsException(_inner) => Some(_inner),
            Self::DeploymentConfigLimitExceededException(_inner) => Some(_inner),
            Self::DeploymentConfigNameRequiredException(_inner) => Some(_inner),
            Self::InvalidComputePlatformException(_inner) => Some(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => Some(_inner),
            Self::InvalidMinimumHealthyHostValueException(_inner) => Some(_inner),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The minimum healthy instance value was specified in an invalid format.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidMinimumHealthyHostValueException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidMinimumHealthyHostValueException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMinimumHealthyHostValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMinimumHealthyHostValueException")?;
        if let Some(inner_96) = &self.message {
            {
                write!(f, ": {}", inner_96)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMinimumHealthyHostValueException {}
impl aws_http::request_id::RequestId for crate::error::InvalidMinimumHealthyHostValueException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidMinimumHealthyHostValueException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidMinimumHealthyHostValueException {
    /// Creates a new builder-style object to manufacture [`InvalidMinimumHealthyHostValueException`](crate::error::InvalidMinimumHealthyHostValueException).
    pub fn builder() -> crate::error::invalid_minimum_healthy_host_value_exception::Builder {
        crate::error::invalid_minimum_healthy_host_value_exception::Builder::default()
    }
}

/// See [`InvalidMinimumHealthyHostValueException`](crate::error::InvalidMinimumHealthyHostValueException).
pub mod invalid_minimum_healthy_host_value_exception {

    /// A builder for [`InvalidMinimumHealthyHostValueException`](crate::error::InvalidMinimumHealthyHostValueException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMinimumHealthyHostValueException`](crate::error::InvalidMinimumHealthyHostValueException).
        pub fn build(self) -> crate::error::InvalidMinimumHealthyHostValueException {
            crate::error::InvalidMinimumHealthyHostValueException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The deployment configurations limit was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentConfigLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentConfigLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentConfigLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentConfigLimitExceededException")?;
        if let Some(inner_97) = &self.message {
            {
                write!(f, ": {}", inner_97)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentConfigLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentConfigLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentConfigLimitExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentConfigLimitExceededException {
    /// Creates a new builder-style object to manufacture [`DeploymentConfigLimitExceededException`](crate::error::DeploymentConfigLimitExceededException).
    pub fn builder() -> crate::error::deployment_config_limit_exceeded_exception::Builder {
        crate::error::deployment_config_limit_exceeded_exception::Builder::default()
    }
}

/// See [`DeploymentConfigLimitExceededException`](crate::error::DeploymentConfigLimitExceededException).
pub mod deployment_config_limit_exceeded_exception {

    /// A builder for [`DeploymentConfigLimitExceededException`](crate::error::DeploymentConfigLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentConfigLimitExceededException`](crate::error::DeploymentConfigLimitExceededException).
        pub fn build(self) -> crate::error::DeploymentConfigLimitExceededException {
            crate::error::DeploymentConfigLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>A deployment configuration with the specified name with the IAM user or Amazon Web Services account already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentConfigAlreadyExistsException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentConfigAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentConfigAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentConfigAlreadyExistsException")?;
        if let Some(inner_98) = &self.message {
            {
                write!(f, ": {}", inner_98)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentConfigAlreadyExistsException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentConfigAlreadyExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentConfigAlreadyExistsException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentConfigAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`DeploymentConfigAlreadyExistsException`](crate::error::DeploymentConfigAlreadyExistsException).
    pub fn builder() -> crate::error::deployment_config_already_exists_exception::Builder {
        crate::error::deployment_config_already_exists_exception::Builder::default()
    }
}

/// See [`DeploymentConfigAlreadyExistsException`](crate::error::DeploymentConfigAlreadyExistsException).
pub mod deployment_config_already_exists_exception {

    /// A builder for [`DeploymentConfigAlreadyExistsException`](crate::error::DeploymentConfigAlreadyExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentConfigAlreadyExistsException`](crate::error::DeploymentConfigAlreadyExistsException).
        pub fn build(self) -> crate::error::DeploymentConfigAlreadyExistsException {
            crate::error::DeploymentConfigAlreadyExistsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateDeploymentErrorKind = CreateDeploymentError;
/// Error type for the `CreateDeploymentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDeploymentError {
    /// <p>The maximum number of alarms for a deployment group (10) was exceeded.</p>
    AlarmsLimitExceededException(crate::error::AlarmsLimitExceededException),
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::error::DeploymentConfigDoesNotExistException),
    /// <p>The named deployment group with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentGroupDoesNotExistException(crate::error::DeploymentGroupDoesNotExistException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::error::DeploymentGroupNameRequiredException),
    /// <p>The number of allowed deployments was exceeded.</p>
    DeploymentLimitExceededException(crate::error::DeploymentLimitExceededException),
    /// <p>The description is too long.</p>
    DescriptionTooLongException(crate::error::DescriptionTooLongException),
    /// <p>The format of the alarm configuration is invalid. Possible causes include:</p>
    /// <ul>
    /// <li> <p>The alarm list is null.</p> </li>
    /// <li> <p>The alarm object is null.</p> </li>
    /// <li> <p>The alarm name is empty or null or exceeds the limit of 255 characters.</p> </li>
    /// <li> <p>Two alarms with the same name have been specified.</p> </li>
    /// <li> <p>The alarm configuration is enabled, but the alarm list is empty.</p> </li>
    /// </ul>
    InvalidAlarmConfigException(crate::error::InvalidAlarmConfigException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The automatic rollback configuration was specified in an invalid format. For example, automatic rollback is enabled, but an invalid triggering event type or no event types were listed.</p>
    InvalidAutoRollbackConfigException(crate::error::InvalidAutoRollbackConfigException),
    /// <p>The Auto Scaling group was specified in an invalid format or does not exist.</p>
    InvalidAutoScalingGroupException(crate::error::InvalidAutoScalingGroupException),
    /// <p>The deployment configuration name was specified in an invalid format.</p>
    InvalidDeploymentConfigNameException(crate::error::InvalidDeploymentConfigNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::error::InvalidDeploymentGroupNameException),
    /// <p>An invalid fileExistsBehavior option was specified to determine how CodeDeploy handles files or directories that already exist in a deployment target location, but weren't part of the previous successful deployment. Valid values include "DISALLOW," "OVERWRITE," and "RETAIN."</p>
    InvalidFileExistsBehaviorException(crate::error::InvalidFileExistsBehaviorException),
    /// <p>The GitHub token is not valid.</p>
    InvalidGitHubAccountTokenException(crate::error::InvalidGitHubAccountTokenException),
    /// <p>The IgnoreApplicationStopFailures value is invalid. For Lambda deployments, <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code> or <code>false</code> is expected.</p>
    InvalidIgnoreApplicationStopFailuresValueException(
        crate::error::InvalidIgnoreApplicationStopFailuresValueException,
    ),
    /// <p>An invalid load balancer name, or no load balancer name, was specified.</p>
    InvalidLoadBalancerInfoException(crate::error::InvalidLoadBalancerInfoException),
    /// <p>The revision was specified in an invalid format.</p>
    InvalidRevisionException(crate::error::InvalidRevisionException),
    /// <p>The service role ARN was specified in an invalid format. Or, if an Auto Scaling group was specified, the specified service role does not grant the appropriate permissions to Amazon EC2 Auto Scaling.</p>
    InvalidRoleException(crate::error::InvalidRoleException),
    /// <p>The target instance configuration is invalid. Possible causes include:</p>
    /// <ul>
    /// <li> <p>Configuration data for target instances was entered for an in-place deployment.</p> </li>
    /// <li> <p>The limit of 10 tags for a tag type was exceeded.</p> </li>
    /// <li> <p>The combined length of the tag names exceeded the limit. </p> </li>
    /// <li> <p>A specified tag is not currently applied to any instances.</p> </li>
    /// </ul>
    InvalidTargetInstancesException(crate::error::InvalidTargetInstancesException),
    /// <p> The configuration that specifies how traffic is routed during a deployment is invalid.</p>
    InvalidTrafficRoutingConfigurationException(
        crate::error::InvalidTrafficRoutingConfigurationException,
    ),
    /// <p>The UpdateOutdatedInstancesOnly value is invalid. For Lambda deployments, <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code> or <code>false</code> is expected.</p>
    InvalidUpdateOutdatedInstancesOnlyValueException(
        crate::error::InvalidUpdateOutdatedInstancesOnlyValueException,
    ),
    /// <p>The named revision does not exist with the IAM user or Amazon Web Services account.</p>
    RevisionDoesNotExistException(crate::error::RevisionDoesNotExistException),
    /// <p>The revision ID was not specified.</p>
    RevisionRequiredException(crate::error::RevisionRequiredException),
    /// <p>An API function was called too frequently.</p>
    ThrottlingException(crate::error::ThrottlingException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateDeploymentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AlarmsLimitExceededException(_inner) => _inner.fmt(f),
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupNameRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentLimitExceededException(_inner) => _inner.fmt(f),
            Self::DescriptionTooLongException(_inner) => _inner.fmt(f),
            Self::InvalidAlarmConfigException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidAutoRollbackConfigException(_inner) => _inner.fmt(f),
            Self::InvalidAutoScalingGroupException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentConfigNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentGroupNameException(_inner) => _inner.fmt(f),
            Self::InvalidFileExistsBehaviorException(_inner) => _inner.fmt(f),
            Self::InvalidGitHubAccountTokenException(_inner) => _inner.fmt(f),
            Self::InvalidIgnoreApplicationStopFailuresValueException(_inner) => _inner.fmt(f),
            Self::InvalidLoadBalancerInfoException(_inner) => _inner.fmt(f),
            Self::InvalidRevisionException(_inner) => _inner.fmt(f),
            Self::InvalidRoleException(_inner) => _inner.fmt(f),
            Self::InvalidTargetInstancesException(_inner) => _inner.fmt(f),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => _inner.fmt(f),
            Self::InvalidUpdateOutdatedInstancesOnlyValueException(_inner) => _inner.fmt(f),
            Self::RevisionDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RevisionRequiredException(_inner) => _inner.fmt(f),
            Self::ThrottlingException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateDeploymentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AlarmsLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DescriptionTooLongException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAlarmConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAutoRollbackConfigException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAutoScalingGroupException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentConfigNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentGroupNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileExistsBehaviorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidGitHubAccountTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidIgnoreApplicationStopFailuresValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidLoadBalancerInfoException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRevisionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRoleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetInstancesException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTrafficRoutingConfigurationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidUpdateOutdatedInstancesOnlyValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ThrottlingException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateDeploymentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateDeploymentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDeploymentError {
    /// Creates the `CreateDeploymentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateDeploymentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AlarmsLimitExceededException(e) => e.meta(),
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::DeploymentConfigDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupNameRequiredException(e) => e.meta(),
            Self::DeploymentLimitExceededException(e) => e.meta(),
            Self::DescriptionTooLongException(e) => e.meta(),
            Self::InvalidAlarmConfigException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidAutoRollbackConfigException(e) => e.meta(),
            Self::InvalidAutoScalingGroupException(e) => e.meta(),
            Self::InvalidDeploymentConfigNameException(e) => e.meta(),
            Self::InvalidDeploymentGroupNameException(e) => e.meta(),
            Self::InvalidFileExistsBehaviorException(e) => e.meta(),
            Self::InvalidGitHubAccountTokenException(e) => e.meta(),
            Self::InvalidIgnoreApplicationStopFailuresValueException(e) => e.meta(),
            Self::InvalidLoadBalancerInfoException(e) => e.meta(),
            Self::InvalidRevisionException(e) => e.meta(),
            Self::InvalidRoleException(e) => e.meta(),
            Self::InvalidTargetInstancesException(e) => e.meta(),
            Self::InvalidTrafficRoutingConfigurationException(e) => e.meta(),
            Self::InvalidUpdateOutdatedInstancesOnlyValueException(e) => e.meta(),
            Self::RevisionDoesNotExistException(e) => e.meta(),
            Self::RevisionRequiredException(e) => e.meta(),
            Self::ThrottlingException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::AlarmsLimitExceededException`.
    pub fn is_alarms_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::AlarmsLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::DeploymentGroupDoesNotExistException`.
    pub fn is_deployment_group_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::DeploymentGroupNameRequiredException`.
    pub fn is_deployment_group_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::DeploymentLimitExceededException`.
    pub fn is_deployment_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::DeploymentLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::DescriptionTooLongException`.
    pub fn is_description_too_long_exception(&self) -> bool {
        matches!(self, Self::DescriptionTooLongException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidAlarmConfigException`.
    pub fn is_invalid_alarm_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAlarmConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidAutoRollbackConfigException`.
    pub fn is_invalid_auto_rollback_config_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoRollbackConfigException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidAutoScalingGroupException`.
    pub fn is_invalid_auto_scaling_group_exception(&self) -> bool {
        matches!(self, Self::InvalidAutoScalingGroupException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidDeploymentConfigNameException`.
    pub fn is_invalid_deployment_config_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentConfigNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidDeploymentGroupNameException`.
    pub fn is_invalid_deployment_group_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentGroupNameException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidFileExistsBehaviorException`.
    pub fn is_invalid_file_exists_behavior_exception(&self) -> bool {
        matches!(self, Self::InvalidFileExistsBehaviorException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidGitHubAccountTokenException`.
    pub fn is_invalid_git_hub_account_token_exception(&self) -> bool {
        matches!(self, Self::InvalidGitHubAccountTokenException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidIgnoreApplicationStopFailuresValueException`.
    pub fn is_invalid_ignore_application_stop_failures_value_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidIgnoreApplicationStopFailuresValueException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidLoadBalancerInfoException`.
    pub fn is_invalid_load_balancer_info_exception(&self) -> bool {
        matches!(self, Self::InvalidLoadBalancerInfoException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidRevisionException`.
    pub fn is_invalid_revision_exception(&self) -> bool {
        matches!(self, Self::InvalidRevisionException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidRoleException`.
    pub fn is_invalid_role_exception(&self) -> bool {
        matches!(self, Self::InvalidRoleException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidTargetInstancesException`.
    pub fn is_invalid_target_instances_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetInstancesException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidTrafficRoutingConfigurationException`.
    pub fn is_invalid_traffic_routing_configuration_exception(&self) -> bool {
        matches!(self, Self::InvalidTrafficRoutingConfigurationException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::InvalidUpdateOutdatedInstancesOnlyValueException`.
    pub fn is_invalid_update_outdated_instances_only_value_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidUpdateOutdatedInstancesOnlyValueException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::RevisionDoesNotExistException`.
    pub fn is_revision_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RevisionDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::RevisionRequiredException`.
    pub fn is_revision_required_exception(&self) -> bool {
        matches!(self, Self::RevisionRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateDeploymentError::ThrottlingException`.
    pub fn is_throttling_exception(&self) -> bool {
        matches!(self, Self::ThrottlingException(_))
    }
}
impl std::error::Error for CreateDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AlarmsLimitExceededException(_inner) => Some(_inner),
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => Some(_inner),
            Self::DeploymentLimitExceededException(_inner) => Some(_inner),
            Self::DescriptionTooLongException(_inner) => Some(_inner),
            Self::InvalidAlarmConfigException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidAutoRollbackConfigException(_inner) => Some(_inner),
            Self::InvalidAutoScalingGroupException(_inner) => Some(_inner),
            Self::InvalidDeploymentConfigNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => Some(_inner),
            Self::InvalidFileExistsBehaviorException(_inner) => Some(_inner),
            Self::InvalidGitHubAccountTokenException(_inner) => Some(_inner),
            Self::InvalidIgnoreApplicationStopFailuresValueException(_inner) => Some(_inner),
            Self::InvalidLoadBalancerInfoException(_inner) => Some(_inner),
            Self::InvalidRevisionException(_inner) => Some(_inner),
            Self::InvalidRoleException(_inner) => Some(_inner),
            Self::InvalidTargetInstancesException(_inner) => Some(_inner),
            Self::InvalidTrafficRoutingConfigurationException(_inner) => Some(_inner),
            Self::InvalidUpdateOutdatedInstancesOnlyValueException(_inner) => Some(_inner),
            Self::RevisionDoesNotExistException(_inner) => Some(_inner),
            Self::RevisionRequiredException(_inner) => Some(_inner),
            Self::ThrottlingException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The UpdateOutdatedInstancesOnly value is invalid. For Lambda deployments, <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code> or <code>false</code> is expected.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidUpdateOutdatedInstancesOnlyValueException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidUpdateOutdatedInstancesOnlyValueException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidUpdateOutdatedInstancesOnlyValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidUpdateOutdatedInstancesOnlyValueException")?;
        if let Some(inner_99) = &self.message {
            {
                write!(f, ": {}", inner_99)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidUpdateOutdatedInstancesOnlyValueException {}
impl aws_http::request_id::RequestId
    for crate::error::InvalidUpdateOutdatedInstancesOnlyValueException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidUpdateOutdatedInstancesOnlyValueException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidUpdateOutdatedInstancesOnlyValueException {
    /// Creates a new builder-style object to manufacture [`InvalidUpdateOutdatedInstancesOnlyValueException`](crate::error::InvalidUpdateOutdatedInstancesOnlyValueException).
    pub fn builder() -> crate::error::invalid_update_outdated_instances_only_value_exception::Builder
    {
        crate::error::invalid_update_outdated_instances_only_value_exception::Builder::default()
    }
}

/// See [`InvalidUpdateOutdatedInstancesOnlyValueException`](crate::error::InvalidUpdateOutdatedInstancesOnlyValueException).
pub mod invalid_update_outdated_instances_only_value_exception {

    /// A builder for [`InvalidUpdateOutdatedInstancesOnlyValueException`](crate::error::InvalidUpdateOutdatedInstancesOnlyValueException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidUpdateOutdatedInstancesOnlyValueException`](crate::error::InvalidUpdateOutdatedInstancesOnlyValueException).
        pub fn build(self) -> crate::error::InvalidUpdateOutdatedInstancesOnlyValueException {
            crate::error::InvalidUpdateOutdatedInstancesOnlyValueException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The target instance configuration is invalid. Possible causes include:</p>
/// <ul>
/// <li> <p>Configuration data for target instances was entered for an in-place deployment.</p> </li>
/// <li> <p>The limit of 10 tags for a tag type was exceeded.</p> </li>
/// <li> <p>The combined length of the tag names exceeded the limit. </p> </li>
/// <li> <p>A specified tag is not currently applied to any instances.</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTargetInstancesException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTargetInstancesException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetInstancesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetInstancesException")?;
        if let Some(inner_100) = &self.message {
            {
                write!(f, ": {}", inner_100)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetInstancesException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTargetInstancesException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTargetInstancesException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidTargetInstancesException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetInstancesException`](crate::error::InvalidTargetInstancesException).
    pub fn builder() -> crate::error::invalid_target_instances_exception::Builder {
        crate::error::invalid_target_instances_exception::Builder::default()
    }
}

/// See [`InvalidTargetInstancesException`](crate::error::InvalidTargetInstancesException).
pub mod invalid_target_instances_exception {

    /// A builder for [`InvalidTargetInstancesException`](crate::error::InvalidTargetInstancesException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetInstancesException`](crate::error::InvalidTargetInstancesException).
        pub fn build(self) -> crate::error::InvalidTargetInstancesException {
            crate::error::InvalidTargetInstancesException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The IgnoreApplicationStopFailures value is invalid. For Lambda deployments, <code>false</code> is expected. For EC2/On-premises deployments, <code>true</code> or <code>false</code> is expected.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidIgnoreApplicationStopFailuresValueException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidIgnoreApplicationStopFailuresValueException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidIgnoreApplicationStopFailuresValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidIgnoreApplicationStopFailuresValueException")?;
        if let Some(inner_101) = &self.message {
            {
                write!(f, ": {}", inner_101)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidIgnoreApplicationStopFailuresValueException {}
impl aws_http::request_id::RequestId
    for crate::error::InvalidIgnoreApplicationStopFailuresValueException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidIgnoreApplicationStopFailuresValueException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidIgnoreApplicationStopFailuresValueException {
    /// Creates a new builder-style object to manufacture [`InvalidIgnoreApplicationStopFailuresValueException`](crate::error::InvalidIgnoreApplicationStopFailuresValueException).
    pub fn builder(
    ) -> crate::error::invalid_ignore_application_stop_failures_value_exception::Builder {
        crate::error::invalid_ignore_application_stop_failures_value_exception::Builder::default()
    }
}

/// See [`InvalidIgnoreApplicationStopFailuresValueException`](crate::error::InvalidIgnoreApplicationStopFailuresValueException).
pub mod invalid_ignore_application_stop_failures_value_exception {

    /// A builder for [`InvalidIgnoreApplicationStopFailuresValueException`](crate::error::InvalidIgnoreApplicationStopFailuresValueException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidIgnoreApplicationStopFailuresValueException`](crate::error::InvalidIgnoreApplicationStopFailuresValueException).
        pub fn build(self) -> crate::error::InvalidIgnoreApplicationStopFailuresValueException {
            crate::error::InvalidIgnoreApplicationStopFailuresValueException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The GitHub token is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidGitHubAccountTokenException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidGitHubAccountTokenException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidGitHubAccountTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidGitHubAccountTokenException")?;
        if let Some(inner_102) = &self.message {
            {
                write!(f, ": {}", inner_102)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidGitHubAccountTokenException {}
impl aws_http::request_id::RequestId for crate::error::InvalidGitHubAccountTokenException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidGitHubAccountTokenException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidGitHubAccountTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidGitHubAccountTokenException`](crate::error::InvalidGitHubAccountTokenException).
    pub fn builder() -> crate::error::invalid_git_hub_account_token_exception::Builder {
        crate::error::invalid_git_hub_account_token_exception::Builder::default()
    }
}

/// See [`InvalidGitHubAccountTokenException`](crate::error::InvalidGitHubAccountTokenException).
pub mod invalid_git_hub_account_token_exception {

    /// A builder for [`InvalidGitHubAccountTokenException`](crate::error::InvalidGitHubAccountTokenException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidGitHubAccountTokenException`](crate::error::InvalidGitHubAccountTokenException).
        pub fn build(self) -> crate::error::InvalidGitHubAccountTokenException {
            crate::error::InvalidGitHubAccountTokenException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>An invalid fileExistsBehavior option was specified to determine how CodeDeploy handles files or directories that already exist in a deployment target location, but weren't part of the previous successful deployment. Valid values include "DISALLOW," "OVERWRITE," and "RETAIN."</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidFileExistsBehaviorException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidFileExistsBehaviorException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFileExistsBehaviorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFileExistsBehaviorException")?;
        if let Some(inner_103) = &self.message {
            {
                write!(f, ": {}", inner_103)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFileExistsBehaviorException {}
impl aws_http::request_id::RequestId for crate::error::InvalidFileExistsBehaviorException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidFileExistsBehaviorException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidFileExistsBehaviorException {
    /// Creates a new builder-style object to manufacture [`InvalidFileExistsBehaviorException`](crate::error::InvalidFileExistsBehaviorException).
    pub fn builder() -> crate::error::invalid_file_exists_behavior_exception::Builder {
        crate::error::invalid_file_exists_behavior_exception::Builder::default()
    }
}

/// See [`InvalidFileExistsBehaviorException`](crate::error::InvalidFileExistsBehaviorException).
pub mod invalid_file_exists_behavior_exception {

    /// A builder for [`InvalidFileExistsBehaviorException`](crate::error::InvalidFileExistsBehaviorException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFileExistsBehaviorException`](crate::error::InvalidFileExistsBehaviorException).
        pub fn build(self) -> crate::error::InvalidFileExistsBehaviorException {
            crate::error::InvalidFileExistsBehaviorException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The number of allowed deployments was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentLimitExceededException")?;
        if let Some(inner_104) = &self.message {
            {
                write!(f, ": {}", inner_104)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeploymentLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentLimitExceededException {
    /// Creates a new builder-style object to manufacture [`DeploymentLimitExceededException`](crate::error::DeploymentLimitExceededException).
    pub fn builder() -> crate::error::deployment_limit_exceeded_exception::Builder {
        crate::error::deployment_limit_exceeded_exception::Builder::default()
    }
}

/// See [`DeploymentLimitExceededException`](crate::error::DeploymentLimitExceededException).
pub mod deployment_limit_exceeded_exception {

    /// A builder for [`DeploymentLimitExceededException`](crate::error::DeploymentLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentLimitExceededException`](crate::error::DeploymentLimitExceededException).
        pub fn build(self) -> crate::error::DeploymentLimitExceededException {
            crate::error::DeploymentLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateApplicationErrorKind = CreateApplicationError;
/// Error type for the `CreateApplicationError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateApplicationError {
    /// <p>An application with the specified name with the IAM user or Amazon Web Services account already exists.</p>
    ApplicationAlreadyExistsException(crate::error::ApplicationAlreadyExistsException),
    /// <p>More applications were attempted to be created than are allowed.</p>
    ApplicationLimitExceededException(crate::error::ApplicationLimitExceededException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The computePlatform is invalid. The computePlatform should be <code>Lambda</code>, <code>Server</code>, or <code>ECS</code>.</p>
    InvalidComputePlatformException(crate::error::InvalidComputePlatformException),
    /// <p> The specified tags are not valid. </p>
    InvalidTagsToAddException(crate::error::InvalidTagsToAddException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateApplicationError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateApplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::ApplicationLimitExceededException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidComputePlatformException(_inner) => _inner.fmt(f),
            Self::InvalidTagsToAddException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateApplicationError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidComputePlatformException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagsToAddException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateApplicationError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateApplicationError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateApplicationError {
    /// Creates the `CreateApplicationError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateApplicationError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationAlreadyExistsException(e) => e.meta(),
            Self::ApplicationLimitExceededException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidComputePlatformException(e) => e.meta(),
            Self::InvalidTagsToAddException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateApplicationError::ApplicationAlreadyExistsException`.
    pub fn is_application_already_exists_exception(&self) -> bool {
        matches!(self, Self::ApplicationAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateApplicationError::ApplicationLimitExceededException`.
    pub fn is_application_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::ApplicationLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateApplicationError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateApplicationError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `CreateApplicationError::InvalidComputePlatformException`.
    pub fn is_invalid_compute_platform_exception(&self) -> bool {
        matches!(self, Self::InvalidComputePlatformException(_))
    }
    /// Returns `true` if the error kind is `CreateApplicationError::InvalidTagsToAddException`.
    pub fn is_invalid_tags_to_add_exception(&self) -> bool {
        matches!(self, Self::InvalidTagsToAddException(_))
    }
}
impl std::error::Error for CreateApplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationAlreadyExistsException(_inner) => Some(_inner),
            Self::ApplicationLimitExceededException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidComputePlatformException(_inner) => Some(_inner),
            Self::InvalidTagsToAddException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>More applications were attempted to be created than are allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApplicationLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApplicationLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApplicationLimitExceededException")?;
        if let Some(inner_105) = &self.message {
            {
                write!(f, ": {}", inner_105)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApplicationLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::ApplicationLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ApplicationLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ApplicationLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ApplicationLimitExceededException`](crate::error::ApplicationLimitExceededException).
    pub fn builder() -> crate::error::application_limit_exceeded_exception::Builder {
        crate::error::application_limit_exceeded_exception::Builder::default()
    }
}

/// See [`ApplicationLimitExceededException`](crate::error::ApplicationLimitExceededException).
pub mod application_limit_exceeded_exception {

    /// A builder for [`ApplicationLimitExceededException`](crate::error::ApplicationLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationLimitExceededException`](crate::error::ApplicationLimitExceededException).
        pub fn build(self) -> crate::error::ApplicationLimitExceededException {
            crate::error::ApplicationLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ContinueDeploymentErrorKind = ContinueDeploymentError;
/// Error type for the `ContinueDeploymentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ContinueDeploymentError {
    /// <p>The deployment is already complete.</p>
    DeploymentAlreadyCompletedException(crate::error::DeploymentAlreadyCompletedException),
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>The deployment does not have a status of Ready and can't continue yet.</p>
    DeploymentIsNotInReadyStateException(crate::error::DeploymentIsNotInReadyStateException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p>The specified deployment status doesn't exist or cannot be determined.</p>
    InvalidDeploymentStatusException(crate::error::InvalidDeploymentStatusException),
    /// <p> The wait type is invalid. </p>
    InvalidDeploymentWaitTypeException(crate::error::InvalidDeploymentWaitTypeException),
    /// <p>A call was submitted that is not supported for the specified deployment type.</p>
    UnsupportedActionForDeploymentTypeException(
        crate::error::UnsupportedActionForDeploymentTypeException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ContinueDeploymentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ContinueDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentAlreadyCompletedException(_inner) => _inner.fmt(f),
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentIsNotInReadyStateException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentStatusException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentWaitTypeException(_inner) => _inner.fmt(f),
            Self::UnsupportedActionForDeploymentTypeException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ContinueDeploymentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentAlreadyCompletedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIsNotInReadyStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentWaitTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::UnsupportedActionForDeploymentTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ContinueDeploymentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ContinueDeploymentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ContinueDeploymentError {
    /// Creates the `ContinueDeploymentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ContinueDeploymentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentAlreadyCompletedException(e) => e.meta(),
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::DeploymentIsNotInReadyStateException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::InvalidDeploymentStatusException(e) => e.meta(),
            Self::InvalidDeploymentWaitTypeException(e) => e.meta(),
            Self::UnsupportedActionForDeploymentTypeException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ContinueDeploymentError::DeploymentAlreadyCompletedException`.
    pub fn is_deployment_already_completed_exception(&self) -> bool {
        matches!(self, Self::DeploymentAlreadyCompletedException(_))
    }
    /// Returns `true` if the error kind is `ContinueDeploymentError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ContinueDeploymentError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `ContinueDeploymentError::DeploymentIsNotInReadyStateException`.
    pub fn is_deployment_is_not_in_ready_state_exception(&self) -> bool {
        matches!(self, Self::DeploymentIsNotInReadyStateException(_))
    }
    /// Returns `true` if the error kind is `ContinueDeploymentError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `ContinueDeploymentError::InvalidDeploymentStatusException`.
    pub fn is_invalid_deployment_status_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentStatusException(_))
    }
    /// Returns `true` if the error kind is `ContinueDeploymentError::InvalidDeploymentWaitTypeException`.
    pub fn is_invalid_deployment_wait_type_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentWaitTypeException(_))
    }
    /// Returns `true` if the error kind is `ContinueDeploymentError::UnsupportedActionForDeploymentTypeException`.
    pub fn is_unsupported_action_for_deployment_type_exception(&self) -> bool {
        matches!(self, Self::UnsupportedActionForDeploymentTypeException(_))
    }
}
impl std::error::Error for ContinueDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentAlreadyCompletedException(_inner) => Some(_inner),
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::DeploymentIsNotInReadyStateException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::InvalidDeploymentStatusException(_inner) => Some(_inner),
            Self::InvalidDeploymentWaitTypeException(_inner) => Some(_inner),
            Self::UnsupportedActionForDeploymentTypeException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p> The wait type is invalid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDeploymentWaitTypeException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDeploymentWaitTypeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeploymentWaitTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeploymentWaitTypeException")?;
        if let Some(inner_106) = &self.message {
            {
                write!(f, ": {}", inner_106)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeploymentWaitTypeException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDeploymentWaitTypeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidDeploymentWaitTypeException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl InvalidDeploymentWaitTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidDeploymentWaitTypeException`](crate::error::InvalidDeploymentWaitTypeException).
    pub fn builder() -> crate::error::invalid_deployment_wait_type_exception::Builder {
        crate::error::invalid_deployment_wait_type_exception::Builder::default()
    }
}

/// See [`InvalidDeploymentWaitTypeException`](crate::error::InvalidDeploymentWaitTypeException).
pub mod invalid_deployment_wait_type_exception {

    /// A builder for [`InvalidDeploymentWaitTypeException`](crate::error::InvalidDeploymentWaitTypeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeploymentWaitTypeException`](crate::error::InvalidDeploymentWaitTypeException).
        pub fn build(self) -> crate::error::InvalidDeploymentWaitTypeException {
            crate::error::InvalidDeploymentWaitTypeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// <p>The deployment does not have a status of Ready and can't continue yet.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentIsNotInReadyStateException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentIsNotInReadyStateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentIsNotInReadyStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentIsNotInReadyStateException")?;
        if let Some(inner_107) = &self.message {
            {
                write!(f, ": {}", inner_107)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentIsNotInReadyStateException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentIsNotInReadyStateException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentIsNotInReadyStateException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentIsNotInReadyStateException {
    /// Creates a new builder-style object to manufacture [`DeploymentIsNotInReadyStateException`](crate::error::DeploymentIsNotInReadyStateException).
    pub fn builder() -> crate::error::deployment_is_not_in_ready_state_exception::Builder {
        crate::error::deployment_is_not_in_ready_state_exception::Builder::default()
    }
}

/// See [`DeploymentIsNotInReadyStateException`](crate::error::DeploymentIsNotInReadyStateException).
pub mod deployment_is_not_in_ready_state_exception {

    /// A builder for [`DeploymentIsNotInReadyStateException`](crate::error::DeploymentIsNotInReadyStateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentIsNotInReadyStateException`](crate::error::DeploymentIsNotInReadyStateException).
        pub fn build(self) -> crate::error::DeploymentIsNotInReadyStateException {
            crate::error::DeploymentIsNotInReadyStateException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchGetOnPremisesInstancesErrorKind = BatchGetOnPremisesInstancesError;
/// Error type for the `BatchGetOnPremisesInstancesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetOnPremisesInstancesError {
    /// <p>The maximum number of names or IDs allowed for this request (100) was exceeded.</p>
    BatchLimitExceededException(crate::error::BatchLimitExceededException),
    /// <p>An on-premises instance name was not specified.</p>
    InstanceNameRequiredException(crate::error::InstanceNameRequiredException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetOnPremisesInstancesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchGetOnPremisesInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BatchLimitExceededException(_inner) => _inner.fmt(f),
            Self::InstanceNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchGetOnPremisesInstancesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BatchLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchGetOnPremisesInstancesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetOnPremisesInstancesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetOnPremisesInstancesError {
    /// Creates the `BatchGetOnPremisesInstancesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchGetOnPremisesInstancesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BatchLimitExceededException(e) => e.meta(),
            Self::InstanceNameRequiredException(e) => e.meta(),
            Self::InvalidInstanceNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchGetOnPremisesInstancesError::BatchLimitExceededException`.
    pub fn is_batch_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::BatchLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchGetOnPremisesInstancesError::InstanceNameRequiredException`.
    pub fn is_instance_name_required_exception(&self) -> bool {
        matches!(self, Self::InstanceNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetOnPremisesInstancesError::InvalidInstanceNameException`.
    pub fn is_invalid_instance_name_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceNameException(_))
    }
}
impl std::error::Error for BatchGetOnPremisesInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BatchLimitExceededException(_inner) => Some(_inner),
            Self::InstanceNameRequiredException(_inner) => Some(_inner),
            Self::InvalidInstanceNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of names or IDs allowed for this request (100) was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BatchLimitExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BatchLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BatchLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BatchLimitExceededException")?;
        if let Some(inner_108) = &self.message {
            {
                write!(f, ": {}", inner_108)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BatchLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::BatchLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl BatchLimitExceededException {
    /// Creates a new builder-style object to manufacture [`BatchLimitExceededException`](crate::error::BatchLimitExceededException).
    pub fn builder() -> crate::error::batch_limit_exceeded_exception::Builder {
        crate::error::batch_limit_exceeded_exception::Builder::default()
    }
}

/// See [`BatchLimitExceededException`](crate::error::BatchLimitExceededException).
pub mod batch_limit_exceeded_exception {

    /// A builder for [`BatchLimitExceededException`](crate::error::BatchLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BatchLimitExceededException`](crate::error::BatchLimitExceededException).
        pub fn build(self) -> crate::error::BatchLimitExceededException {
            crate::error::BatchLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchGetDeploymentTargetsErrorKind = BatchGetDeploymentTargetsError;
/// Error type for the `BatchGetDeploymentTargetsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetDeploymentTargetsError {
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>The specified deployment has not started.</p>
    DeploymentNotStartedException(crate::error::DeploymentNotStartedException),
    /// <p> The provided target ID does not belong to the attempted deployment. </p>
    DeploymentTargetDoesNotExistException(crate::error::DeploymentTargetDoesNotExistException),
    /// <p> A deployment target ID was not provided. </p>
    DeploymentTargetIdRequiredException(crate::error::DeploymentTargetIdRequiredException),
    /// <p> The maximum number of targets that can be associated with an Amazon ECS or Lambda deployment was exceeded. The target list of both types of deployments must have exactly one item. This exception does not apply to EC2/On-premises deployments. </p>
    DeploymentTargetListSizeExceededException(
        crate::error::DeploymentTargetListSizeExceededException,
    ),
    /// <p>The specified instance does not exist in the deployment group.</p>
    #[deprecated(
        note = "This exception is deprecated, use DeploymentTargetDoesNotExistException instead."
    )]
    InstanceDoesNotExistException(crate::error::InstanceDoesNotExistException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p> The target ID provided was not valid. </p>
    InvalidDeploymentTargetIdException(crate::error::InvalidDeploymentTargetIdException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetDeploymentTargetsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchGetDeploymentTargetsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentNotStartedException(_inner) => _inner.fmt(f),
            Self::DeploymentTargetDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentTargetIdRequiredException(_inner) => _inner.fmt(f),
            Self::DeploymentTargetListSizeExceededException(_inner) => _inner.fmt(f),
            Self::InstanceDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentTargetIdException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchGetDeploymentTargetsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentNotStartedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentTargetDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentTargetIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentTargetListSizeExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentTargetIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchGetDeploymentTargetsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetDeploymentTargetsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetDeploymentTargetsError {
    /// Creates the `BatchGetDeploymentTargetsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchGetDeploymentTargetsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::DeploymentNotStartedException(e) => e.meta(),
            Self::DeploymentTargetDoesNotExistException(e) => e.meta(),
            Self::DeploymentTargetIdRequiredException(e) => e.meta(),
            Self::DeploymentTargetListSizeExceededException(e) => e.meta(),
            Self::InstanceDoesNotExistException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::InvalidDeploymentTargetIdException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentNotStartedException`.
    pub fn is_deployment_not_started_exception(&self) -> bool {
        matches!(self, Self::DeploymentNotStartedException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentTargetDoesNotExistException`.
    pub fn is_deployment_target_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentTargetDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentTargetIdRequiredException`.
    pub fn is_deployment_target_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentTargetIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::DeploymentTargetListSizeExceededException`.
    pub fn is_deployment_target_list_size_exceeded_exception(&self) -> bool {
        matches!(self, Self::DeploymentTargetListSizeExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::InstanceDoesNotExistException`.
    pub fn is_instance_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::InstanceDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentTargetsError::InvalidDeploymentTargetIdException`.
    pub fn is_invalid_deployment_target_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentTargetIdException(_))
    }
}
impl std::error::Error for BatchGetDeploymentTargetsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::DeploymentNotStartedException(_inner) => Some(_inner),
            Self::DeploymentTargetDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentTargetIdRequiredException(_inner) => Some(_inner),
            Self::DeploymentTargetListSizeExceededException(_inner) => Some(_inner),
            Self::InstanceDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::InvalidDeploymentTargetIdException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p> The maximum number of targets that can be associated with an Amazon ECS or Lambda deployment was exceeded. The target list of both types of deployments must have exactly one item. This exception does not apply to EC2/On-premises deployments. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeploymentTargetListSizeExceededException {
    /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DeploymentTargetListSizeExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DeploymentTargetListSizeExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DeploymentTargetListSizeExceededException")?;
        if let Some(inner_109) = &self.message {
            {
                write!(f, ": {}", inner_109)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DeploymentTargetListSizeExceededException {}
impl aws_http::request_id::RequestId for crate::error::DeploymentTargetListSizeExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeploymentTargetListSizeExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl DeploymentTargetListSizeExceededException {
    /// Creates a new builder-style object to manufacture [`DeploymentTargetListSizeExceededException`](crate::error::DeploymentTargetListSizeExceededException).
    pub fn builder() -> crate::error::deployment_target_list_size_exceeded_exception::Builder {
        crate::error::deployment_target_list_size_exceeded_exception::Builder::default()
    }
}

/// See [`DeploymentTargetListSizeExceededException`](crate::error::DeploymentTargetListSizeExceededException).
pub mod deployment_target_list_size_exceeded_exception {

    /// A builder for [`DeploymentTargetListSizeExceededException`](crate::error::DeploymentTargetListSizeExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>The message that corresponds to the exception thrown by CodeDeploy.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DeploymentTargetListSizeExceededException`](crate::error::DeploymentTargetListSizeExceededException).
        pub fn build(self) -> crate::error::DeploymentTargetListSizeExceededException {
            crate::error::DeploymentTargetListSizeExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchGetDeploymentsErrorKind = BatchGetDeploymentsError;
/// Error type for the `BatchGetDeploymentsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetDeploymentsError {
    /// <p>The maximum number of names or IDs allowed for this request (100) was exceeded.</p>
    BatchLimitExceededException(crate::error::BatchLimitExceededException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetDeploymentsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchGetDeploymentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BatchLimitExceededException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchGetDeploymentsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BatchLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchGetDeploymentsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetDeploymentsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetDeploymentsError {
    /// Creates the `BatchGetDeploymentsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchGetDeploymentsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BatchLimitExceededException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentsError::BatchLimitExceededException`.
    pub fn is_batch_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::BatchLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentsError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentsError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
}
impl std::error::Error for BatchGetDeploymentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BatchLimitExceededException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchGetDeploymentInstancesErrorKind = BatchGetDeploymentInstancesError;
/// Error type for the `BatchGetDeploymentInstancesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetDeploymentInstancesError {
    /// <p>The maximum number of names or IDs allowed for this request (100) was exceeded.</p>
    BatchLimitExceededException(crate::error::BatchLimitExceededException),
    /// <p>The deployment with the IAM user or Amazon Web Services account does not exist.</p>
    DeploymentDoesNotExistException(crate::error::DeploymentDoesNotExistException),
    /// <p>At least one deployment ID must be specified.</p>
    DeploymentIdRequiredException(crate::error::DeploymentIdRequiredException),
    /// <p>The instance ID was not specified.</p>
    #[deprecated(
        note = "This exception is deprecated, use DeploymentTargetIdRequiredException instead."
    )]
    InstanceIdRequiredException(crate::error::InstanceIdRequiredException),
    /// <p>The computePlatform is invalid. The computePlatform should be <code>Lambda</code>, <code>Server</code>, or <code>ECS</code>.</p>
    InvalidComputePlatformException(crate::error::InvalidComputePlatformException),
    /// <p>At least one of the deployment IDs was specified in an invalid format.</p>
    InvalidDeploymentIdException(crate::error::InvalidDeploymentIdException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetDeploymentInstancesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchGetDeploymentInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BatchLimitExceededException(_inner) => _inner.fmt(f),
            Self::DeploymentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentIdRequiredException(_inner) => _inner.fmt(f),
            Self::InstanceIdRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidComputePlatformException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentIdException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchGetDeploymentInstancesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BatchLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidComputePlatformException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchGetDeploymentInstancesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetDeploymentInstancesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetDeploymentInstancesError {
    /// Creates the `BatchGetDeploymentInstancesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchGetDeploymentInstancesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BatchLimitExceededException(e) => e.meta(),
            Self::DeploymentDoesNotExistException(e) => e.meta(),
            Self::DeploymentIdRequiredException(e) => e.meta(),
            Self::InstanceIdRequiredException(e) => e.meta(),
            Self::InvalidComputePlatformException(e) => e.meta(),
            Self::InvalidDeploymentIdException(e) => e.meta(),
            Self::InvalidInstanceNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentInstancesError::BatchLimitExceededException`.
    pub fn is_batch_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::BatchLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentInstancesError::DeploymentDoesNotExistException`.
    pub fn is_deployment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentInstancesError::DeploymentIdRequiredException`.
    pub fn is_deployment_id_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentInstancesError::InstanceIdRequiredException`.
    pub fn is_instance_id_required_exception(&self) -> bool {
        matches!(self, Self::InstanceIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentInstancesError::InvalidComputePlatformException`.
    pub fn is_invalid_compute_platform_exception(&self) -> bool {
        matches!(self, Self::InvalidComputePlatformException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentInstancesError::InvalidDeploymentIdException`.
    pub fn is_invalid_deployment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentIdException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentInstancesError::InvalidInstanceNameException`.
    pub fn is_invalid_instance_name_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceNameException(_))
    }
}
impl std::error::Error for BatchGetDeploymentInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BatchLimitExceededException(_inner) => Some(_inner),
            Self::DeploymentDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentIdRequiredException(_inner) => Some(_inner),
            Self::InstanceIdRequiredException(_inner) => Some(_inner),
            Self::InvalidComputePlatformException(_inner) => Some(_inner),
            Self::InvalidDeploymentIdException(_inner) => Some(_inner),
            Self::InvalidInstanceNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchGetDeploymentGroupsErrorKind = BatchGetDeploymentGroupsError;
/// Error type for the `BatchGetDeploymentGroupsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetDeploymentGroupsError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The maximum number of names or IDs allowed for this request (100) was exceeded.</p>
    BatchLimitExceededException(crate::error::BatchLimitExceededException),
    /// <p>The deployment configuration does not exist with the IAM user or Amazon Web Services account.</p>
    DeploymentConfigDoesNotExistException(crate::error::DeploymentConfigDoesNotExistException),
    /// <p>The deployment group name was not specified.</p>
    DeploymentGroupNameRequiredException(crate::error::DeploymentGroupNameRequiredException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The deployment group name was specified in an invalid format.</p>
    InvalidDeploymentGroupNameException(crate::error::InvalidDeploymentGroupNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetDeploymentGroupsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchGetDeploymentGroupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::BatchLimitExceededException(_inner) => _inner.fmt(f),
            Self::DeploymentConfigDoesNotExistException(_inner) => _inner.fmt(f),
            Self::DeploymentGroupNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeploymentGroupNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchGetDeploymentGroupsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BatchLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentConfigDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DeploymentGroupNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeploymentGroupNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchGetDeploymentGroupsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetDeploymentGroupsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetDeploymentGroupsError {
    /// Creates the `BatchGetDeploymentGroupsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchGetDeploymentGroupsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::BatchLimitExceededException(e) => e.meta(),
            Self::DeploymentConfigDoesNotExistException(e) => e.meta(),
            Self::DeploymentGroupNameRequiredException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidDeploymentGroupNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentGroupsError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentGroupsError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentGroupsError::BatchLimitExceededException`.
    pub fn is_batch_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::BatchLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentGroupsError::DeploymentConfigDoesNotExistException`.
    pub fn is_deployment_config_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::DeploymentConfigDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentGroupsError::DeploymentGroupNameRequiredException`.
    pub fn is_deployment_group_name_required_exception(&self) -> bool {
        matches!(self, Self::DeploymentGroupNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentGroupsError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `BatchGetDeploymentGroupsError::InvalidDeploymentGroupNameException`.
    pub fn is_invalid_deployment_group_name_exception(&self) -> bool {
        matches!(self, Self::InvalidDeploymentGroupNameException(_))
    }
}
impl std::error::Error for BatchGetDeploymentGroupsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::BatchLimitExceededException(_inner) => Some(_inner),
            Self::DeploymentConfigDoesNotExistException(_inner) => Some(_inner),
            Self::DeploymentGroupNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidDeploymentGroupNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchGetApplicationsErrorKind = BatchGetApplicationsError;
/// Error type for the `BatchGetApplicationsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetApplicationsError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The maximum number of names or IDs allowed for this request (100) was exceeded.</p>
    BatchLimitExceededException(crate::error::BatchLimitExceededException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetApplicationsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchGetApplicationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::BatchLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchGetApplicationsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BatchLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchGetApplicationsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetApplicationsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetApplicationsError {
    /// Creates the `BatchGetApplicationsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchGetApplicationsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::BatchLimitExceededException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchGetApplicationsError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetApplicationsError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetApplicationsError::BatchLimitExceededException`.
    pub fn is_batch_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::BatchLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchGetApplicationsError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
}
impl std::error::Error for BatchGetApplicationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::BatchLimitExceededException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchGetApplicationRevisionsErrorKind = BatchGetApplicationRevisionsError;
/// Error type for the `BatchGetApplicationRevisionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetApplicationRevisionsError {
    /// <p>The application does not exist with the IAM user or Amazon Web Services account.</p>
    ApplicationDoesNotExistException(crate::error::ApplicationDoesNotExistException),
    /// <p>The minimum number of required application names was not specified.</p>
    ApplicationNameRequiredException(crate::error::ApplicationNameRequiredException),
    /// <p>The maximum number of names or IDs allowed for this request (100) was exceeded.</p>
    BatchLimitExceededException(crate::error::BatchLimitExceededException),
    /// <p>The application name was specified in an invalid format.</p>
    InvalidApplicationNameException(crate::error::InvalidApplicationNameException),
    /// <p>The revision was specified in an invalid format.</p>
    InvalidRevisionException(crate::error::InvalidRevisionException),
    /// <p>The revision ID was not specified.</p>
    RevisionRequiredException(crate::error::RevisionRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetApplicationRevisionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchGetApplicationRevisionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApplicationNameRequiredException(_inner) => _inner.fmt(f),
            Self::BatchLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidApplicationNameException(_inner) => _inner.fmt(f),
            Self::InvalidRevisionException(_inner) => _inner.fmt(f),
            Self::RevisionRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchGetApplicationRevisionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApplicationNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BatchLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApplicationNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRevisionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchGetApplicationRevisionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetApplicationRevisionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetApplicationRevisionsError {
    /// Creates the `BatchGetApplicationRevisionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchGetApplicationRevisionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApplicationDoesNotExistException(e) => e.meta(),
            Self::ApplicationNameRequiredException(e) => e.meta(),
            Self::BatchLimitExceededException(e) => e.meta(),
            Self::InvalidApplicationNameException(e) => e.meta(),
            Self::InvalidRevisionException(e) => e.meta(),
            Self::RevisionRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchGetApplicationRevisionsError::ApplicationDoesNotExistException`.
    pub fn is_application_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApplicationDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetApplicationRevisionsError::ApplicationNameRequiredException`.
    pub fn is_application_name_required_exception(&self) -> bool {
        matches!(self, Self::ApplicationNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetApplicationRevisionsError::BatchLimitExceededException`.
    pub fn is_batch_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::BatchLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchGetApplicationRevisionsError::InvalidApplicationNameException`.
    pub fn is_invalid_application_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApplicationNameException(_))
    }
    /// Returns `true` if the error kind is `BatchGetApplicationRevisionsError::InvalidRevisionException`.
    pub fn is_invalid_revision_exception(&self) -> bool {
        matches!(self, Self::InvalidRevisionException(_))
    }
    /// Returns `true` if the error kind is `BatchGetApplicationRevisionsError::RevisionRequiredException`.
    pub fn is_revision_required_exception(&self) -> bool {
        matches!(self, Self::RevisionRequiredException(_))
    }
}
impl std::error::Error for BatchGetApplicationRevisionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApplicationDoesNotExistException(_inner) => Some(_inner),
            Self::ApplicationNameRequiredException(_inner) => Some(_inner),
            Self::BatchLimitExceededException(_inner) => Some(_inner),
            Self::InvalidApplicationNameException(_inner) => Some(_inner),
            Self::InvalidRevisionException(_inner) => Some(_inner),
            Self::RevisionRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AddTagsToOnPremisesInstancesErrorKind = AddTagsToOnPremisesInstancesError;
/// Error type for the `AddTagsToOnPremisesInstancesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AddTagsToOnPremisesInstancesError {
    /// <p>The maximum number of allowed on-premises instances in a single call was exceeded.</p>
    InstanceLimitExceededException(crate::error::InstanceLimitExceededException),
    /// <p>An on-premises instance name was not specified.</p>
    InstanceNameRequiredException(crate::error::InstanceNameRequiredException),
    /// <p>The specified on-premises instance is not registered.</p>
    InstanceNotRegisteredException(crate::error::InstanceNotRegisteredException),
    /// <p>The on-premises instance name was specified in an invalid format.</p>
    InvalidInstanceNameException(crate::error::InvalidInstanceNameException),
    /// <p>The tag was specified in an invalid format.</p>
    InvalidTagException(crate::error::InvalidTagException),
    /// <p>The maximum allowed number of tags was exceeded.</p>
    TagLimitExceededException(crate::error::TagLimitExceededException),
    /// <p>A tag was not specified.</p>
    TagRequiredException(crate::error::TagRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for AddTagsToOnPremisesInstancesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AddTagsToOnPremisesInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InstanceLimitExceededException(_inner) => _inner.fmt(f),
            Self::InstanceNameRequiredException(_inner) => _inner.fmt(f),
            Self::InstanceNotRegisteredException(_inner) => _inner.fmt(f),
            Self::InvalidInstanceNameException(_inner) => _inner.fmt(f),
            Self::InvalidTagException(_inner) => _inner.fmt(f),
            Self::TagLimitExceededException(_inner) => _inner.fmt(f),
            Self::TagRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AddTagsToOnPremisesInstancesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InstanceLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InstanceNotRegisteredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidInstanceNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::AddTagsToOnPremisesInstancesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for AddTagsToOnPremisesInstancesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AddTagsToOnPremisesInstancesError {
    /// Creates the `AddTagsToOnPremisesInstancesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AddTagsToOnPremisesInstancesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InstanceLimitExceededException(e) => e.meta(),
            Self::InstanceNameRequiredException(e) => e.meta(),
            Self::InstanceNotRegisteredException(e) => e.meta(),
            Self::InvalidInstanceNameException(e) => e.meta(),
            Self::InvalidTagException(e) => e.meta(),
            Self::TagLimitExceededException(e) => e.meta(),
            Self::TagRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AddTagsToOnPremisesInstancesError::InstanceLimitExceededException`.
    pub fn is_instance_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::InstanceLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `AddTagsToOnPremisesInstancesError::InstanceNameRequiredException`.
    pub fn is_instance_name_required_exception(&self) -> bool {
        matches!(self, Self::InstanceNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `AddTagsToOnPremisesInstancesError::InstanceNotRegisteredException`.
    pub fn is_instance_not_registered_exception(&self) -> bool {
        matches!(self, Self::InstanceNotRegisteredException(_))
    }
    /// Returns `true` if the error kind is `AddTagsToOnPremisesInstancesError::InvalidInstanceNameException`.
    pub fn is_invalid_instance_name_exception(&self) -> bool {
        matches!(self, Self::InvalidInstanceNameException(_))
    }
    /// Returns `true` if the error kind is `AddTagsToOnPremisesInstancesError::InvalidTagException`.
    pub fn is_invalid_tag_exception(&self) -> bool {
        matches!(self, Self::InvalidTagException(_))
    }
    /// Returns `true` if the error kind is `AddTagsToOnPremisesInstancesError::TagLimitExceededException`.
    pub fn is_tag_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::TagLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `AddTagsToOnPremisesInstancesError::TagRequiredException`.
    pub fn is_tag_required_exception(&self) -> bool {
        matches!(self, Self::TagRequiredException(_))
    }
}
impl std::error::Error for AddTagsToOnPremisesInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InstanceLimitExceededException(_inner) => Some(_inner),
            Self::InstanceNameRequiredException(_inner) => Some(_inner),
            Self::InstanceNotRegisteredException(_inner) => Some(_inner),
            Self::InvalidInstanceNameException(_inner) => Some(_inner),
            Self::InvalidTagException(_inner) => Some(_inner),
            Self::TagLimitExceededException(_inner) => Some(_inner),
            Self::TagRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}
