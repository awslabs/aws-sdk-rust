// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::create_studio::_create_studio_output::CreateStudioOutputBuilder;

pub use crate::operation::create_studio::_create_studio_input::CreateStudioInputBuilder;

impl CreateStudioInputBuilder {
    /// Sends a request with this input using the given client.
    pub async fn send_with(
        self,
        client: &crate::Client,
    ) -> ::std::result::Result<
        crate::operation::create_studio::CreateStudioOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_studio::CreateStudioError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let mut fluent_builder = client.create_studio();
        fluent_builder.inner = self;
        fluent_builder.send().await
    }
}
/// Fluent builder constructing a request to `CreateStudio`.
///
/// <p>Create a new studio.</p>
/// <p>When creating a studio, two IAM roles must be provided: the admin role and the user role. These roles are assumed by your users when they log in to the Nimble Studio portal.</p>
/// <p>The user role must have the <code>AmazonNimbleStudio-StudioUser</code> managed policy attached for the portal to function properly.</p>
/// <p>The admin role must have the <code>AmazonNimbleStudio-StudioAdmin</code> managed policy attached for the portal to function properly.</p>
/// <p>You may optionally specify a KMS key in the <code>StudioEncryptionConfiguration</code>.</p>
/// <p>In Nimble Studio, resource names, descriptions, initialization scripts, and other data you provide are always encrypted at rest using an KMS key. By default, this key is owned by Amazon Web Services and managed on your behalf. You may provide your own KMS key when calling <code>CreateStudio</code> to encrypt this data using a key you own and manage.</p>
/// <p>When providing an KMS key during studio creation, Nimble Studio creates KMS grants in your account to provide your studio user and admin roles access to these KMS keys.</p>
/// <p>If you delete this grant, the studio will no longer be accessible to your portal users.</p>
/// <p>If you delete the studio KMS key, your studio will no longer be accessible.</p>
#[derive(::std::clone::Clone, ::std::fmt::Debug)]
pub struct CreateStudioFluentBuilder {
    handle: ::std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::create_studio::builders::CreateStudioInputBuilder,
    config_override: ::std::option::Option<crate::config::Builder>,
}
impl
    crate::client::customize::internal::CustomizableSend<
        crate::operation::create_studio::CreateStudioOutput,
        crate::operation::create_studio::CreateStudioError,
    > for CreateStudioFluentBuilder
{
    fn send(
        self,
        config_override: crate::config::Builder,
    ) -> crate::client::customize::internal::BoxFuture<
        crate::client::customize::internal::SendResult<
            crate::operation::create_studio::CreateStudioOutput,
            crate::operation::create_studio::CreateStudioError,
        >,
    > {
        ::std::boxed::Box::pin(async move { self.config_override(config_override).send().await })
    }
}
impl CreateStudioFluentBuilder {
    /// Creates a new `CreateStudio`.
    pub(crate) fn new(handle: ::std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: ::std::default::Default::default(),
            config_override: ::std::option::Option::None,
        }
    }
    /// Access the CreateStudio as a reference.
    pub fn as_input(&self) -> &crate::operation::create_studio::builders::CreateStudioInputBuilder {
        &self.inner
    }
    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> ::std::result::Result<
        crate::operation::create_studio::CreateStudioOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_studio::CreateStudioError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = self
            .inner
            .build()
            .map_err(::aws_smithy_runtime_api::client::result::SdkError::construction_failure)?;
        let runtime_plugins = crate::operation::create_studio::CreateStudio::operation_runtime_plugins(
            self.handle.runtime_plugins.clone(),
            &self.handle.conf,
            self.config_override,
        );
        crate::operation::create_studio::CreateStudio::orchestrate(&runtime_plugins, input).await
    }

    /// Consumes this builder, creating a customizable operation that can be modified before being sent.
    pub fn customize(
        self,
    ) -> crate::client::customize::CustomizableOperation<
        crate::operation::create_studio::CreateStudioOutput,
        crate::operation::create_studio::CreateStudioError,
        Self,
    > {
        crate::client::customize::CustomizableOperation::new(self)
    }
    pub(crate) fn config_override(mut self, config_override: impl Into<crate::config::Builder>) -> Self {
        self.set_config_override(Some(config_override.into()));
        self
    }

    pub(crate) fn set_config_override(&mut self, config_override: Option<crate::config::Builder>) -> &mut Self {
        self.config_override = config_override;
        self
    }
    /// <p>The IAM role that studio admins will assume when logging in to the Nimble Studio portal.</p>
    pub fn admin_role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.admin_role_arn(input.into());
        self
    }
    /// <p>The IAM role that studio admins will assume when logging in to the Nimble Studio portal.</p>
    pub fn set_admin_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_admin_role_arn(input);
        self
    }
    /// <p>The IAM role that studio admins will assume when logging in to the Nimble Studio portal.</p>
    pub fn get_admin_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_admin_role_arn()
    }
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.client_token(input.into());
        self
    }
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_client_token(input);
        self
    }
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_client_token()
    }
    /// <p>A friendly name for the studio.</p>
    pub fn display_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.display_name(input.into());
        self
    }
    /// <p>A friendly name for the studio.</p>
    pub fn set_display_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_display_name(input);
        self
    }
    /// <p>A friendly name for the studio.</p>
    pub fn get_display_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_display_name()
    }
    /// <p>The studio encryption configuration.</p>
    pub fn studio_encryption_configuration(mut self, input: crate::types::StudioEncryptionConfiguration) -> Self {
        self.inner = self.inner.studio_encryption_configuration(input);
        self
    }
    /// <p>The studio encryption configuration.</p>
    pub fn set_studio_encryption_configuration(mut self, input: ::std::option::Option<crate::types::StudioEncryptionConfiguration>) -> Self {
        self.inner = self.inner.set_studio_encryption_configuration(input);
        self
    }
    /// <p>The studio encryption configuration.</p>
    pub fn get_studio_encryption_configuration(&self) -> &::std::option::Option<crate::types::StudioEncryptionConfiguration> {
        self.inner.get_studio_encryption_configuration()
    }
    /// <p>The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.</p>
    pub fn studio_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.studio_name(input.into());
        self
    }
    /// <p>The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.</p>
    pub fn set_studio_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_studio_name(input);
        self
    }
    /// <p>The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.</p>
    pub fn get_studio_name(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_studio_name()
    }
    /// Adds a key-value pair to `tags`.
    ///
    /// To override the contents of this collection use [`set_tags`](Self::set_tags).
    ///
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    pub fn tags(mut self, k: impl ::std::convert::Into<::std::string::String>, v: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.tags(k.into(), v.into());
        self
    }
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    pub fn set_tags(mut self, input: ::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>>) -> Self {
        self.inner = self.inner.set_tags(input);
        self
    }
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    pub fn get_tags(&self) -> &::std::option::Option<::std::collections::HashMap<::std::string::String, ::std::string::String>> {
        self.inner.get_tags()
    }
    /// <p>The IAM role that studio users will assume when logging in to the Nimble Studio portal.</p>
    pub fn user_role_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.inner = self.inner.user_role_arn(input.into());
        self
    }
    /// <p>The IAM role that studio users will assume when logging in to the Nimble Studio portal.</p>
    pub fn set_user_role_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.inner = self.inner.set_user_role_arn(input);
        self
    }
    /// <p>The IAM role that studio users will assume when logging in to the Nimble Studio portal.</p>
    pub fn get_user_role_arn(&self) -> &::std::option::Option<::std::string::String> {
        self.inner.get_user_role_arn()
    }
}
