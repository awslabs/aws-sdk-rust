// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn accept_eulas(&self) -> fluent_builders::AcceptEulas<C> {
        fluent_builders::AcceptEulas::new(self.handle.clone())
    }
    pub fn create_launch_profile(&self) -> fluent_builders::CreateLaunchProfile<C> {
        fluent_builders::CreateLaunchProfile::new(self.handle.clone())
    }
    pub fn create_streaming_image(&self) -> fluent_builders::CreateStreamingImage<C> {
        fluent_builders::CreateStreamingImage::new(self.handle.clone())
    }
    pub fn create_streaming_session(&self) -> fluent_builders::CreateStreamingSession<C> {
        fluent_builders::CreateStreamingSession::new(self.handle.clone())
    }
    pub fn create_streaming_session_stream(
        &self,
    ) -> fluent_builders::CreateStreamingSessionStream<C> {
        fluent_builders::CreateStreamingSessionStream::new(self.handle.clone())
    }
    pub fn create_studio(&self) -> fluent_builders::CreateStudio<C> {
        fluent_builders::CreateStudio::new(self.handle.clone())
    }
    pub fn create_studio_component(&self) -> fluent_builders::CreateStudioComponent<C> {
        fluent_builders::CreateStudioComponent::new(self.handle.clone())
    }
    pub fn delete_launch_profile(&self) -> fluent_builders::DeleteLaunchProfile<C> {
        fluent_builders::DeleteLaunchProfile::new(self.handle.clone())
    }
    pub fn delete_launch_profile_member(&self) -> fluent_builders::DeleteLaunchProfileMember<C> {
        fluent_builders::DeleteLaunchProfileMember::new(self.handle.clone())
    }
    pub fn delete_streaming_image(&self) -> fluent_builders::DeleteStreamingImage<C> {
        fluent_builders::DeleteStreamingImage::new(self.handle.clone())
    }
    pub fn delete_streaming_session(&self) -> fluent_builders::DeleteStreamingSession<C> {
        fluent_builders::DeleteStreamingSession::new(self.handle.clone())
    }
    pub fn delete_studio(&self) -> fluent_builders::DeleteStudio<C> {
        fluent_builders::DeleteStudio::new(self.handle.clone())
    }
    pub fn delete_studio_component(&self) -> fluent_builders::DeleteStudioComponent<C> {
        fluent_builders::DeleteStudioComponent::new(self.handle.clone())
    }
    pub fn delete_studio_member(&self) -> fluent_builders::DeleteStudioMember<C> {
        fluent_builders::DeleteStudioMember::new(self.handle.clone())
    }
    pub fn get_eula(&self) -> fluent_builders::GetEula<C> {
        fluent_builders::GetEula::new(self.handle.clone())
    }
    pub fn get_launch_profile(&self) -> fluent_builders::GetLaunchProfile<C> {
        fluent_builders::GetLaunchProfile::new(self.handle.clone())
    }
    pub fn get_launch_profile_details(&self) -> fluent_builders::GetLaunchProfileDetails<C> {
        fluent_builders::GetLaunchProfileDetails::new(self.handle.clone())
    }
    pub fn get_launch_profile_initialization(
        &self,
    ) -> fluent_builders::GetLaunchProfileInitialization<C> {
        fluent_builders::GetLaunchProfileInitialization::new(self.handle.clone())
    }
    pub fn get_launch_profile_member(&self) -> fluent_builders::GetLaunchProfileMember<C> {
        fluent_builders::GetLaunchProfileMember::new(self.handle.clone())
    }
    pub fn get_streaming_image(&self) -> fluent_builders::GetStreamingImage<C> {
        fluent_builders::GetStreamingImage::new(self.handle.clone())
    }
    pub fn get_streaming_session(&self) -> fluent_builders::GetStreamingSession<C> {
        fluent_builders::GetStreamingSession::new(self.handle.clone())
    }
    pub fn get_streaming_session_stream(&self) -> fluent_builders::GetStreamingSessionStream<C> {
        fluent_builders::GetStreamingSessionStream::new(self.handle.clone())
    }
    pub fn get_studio(&self) -> fluent_builders::GetStudio<C> {
        fluent_builders::GetStudio::new(self.handle.clone())
    }
    pub fn get_studio_component(&self) -> fluent_builders::GetStudioComponent<C> {
        fluent_builders::GetStudioComponent::new(self.handle.clone())
    }
    pub fn get_studio_member(&self) -> fluent_builders::GetStudioMember<C> {
        fluent_builders::GetStudioMember::new(self.handle.clone())
    }
    pub fn list_eula_acceptances(&self) -> fluent_builders::ListEulaAcceptances<C> {
        fluent_builders::ListEulaAcceptances::new(self.handle.clone())
    }
    pub fn list_eulas(&self) -> fluent_builders::ListEulas<C> {
        fluent_builders::ListEulas::new(self.handle.clone())
    }
    pub fn list_launch_profile_members(&self) -> fluent_builders::ListLaunchProfileMembers<C> {
        fluent_builders::ListLaunchProfileMembers::new(self.handle.clone())
    }
    pub fn list_launch_profiles(&self) -> fluent_builders::ListLaunchProfiles<C> {
        fluent_builders::ListLaunchProfiles::new(self.handle.clone())
    }
    pub fn list_streaming_images(&self) -> fluent_builders::ListStreamingImages<C> {
        fluent_builders::ListStreamingImages::new(self.handle.clone())
    }
    pub fn list_streaming_sessions(&self) -> fluent_builders::ListStreamingSessions<C> {
        fluent_builders::ListStreamingSessions::new(self.handle.clone())
    }
    pub fn list_studio_components(&self) -> fluent_builders::ListStudioComponents<C> {
        fluent_builders::ListStudioComponents::new(self.handle.clone())
    }
    pub fn list_studio_members(&self) -> fluent_builders::ListStudioMembers<C> {
        fluent_builders::ListStudioMembers::new(self.handle.clone())
    }
    pub fn list_studios(&self) -> fluent_builders::ListStudios<C> {
        fluent_builders::ListStudios::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn put_launch_profile_members(&self) -> fluent_builders::PutLaunchProfileMembers<C> {
        fluent_builders::PutLaunchProfileMembers::new(self.handle.clone())
    }
    pub fn put_studio_members(&self) -> fluent_builders::PutStudioMembers<C> {
        fluent_builders::PutStudioMembers::new(self.handle.clone())
    }
    pub fn start_studio_sso_configuration_repair(
        &self,
    ) -> fluent_builders::StartStudioSSOConfigurationRepair<C> {
        fluent_builders::StartStudioSSOConfigurationRepair::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_launch_profile(&self) -> fluent_builders::UpdateLaunchProfile<C> {
        fluent_builders::UpdateLaunchProfile::new(self.handle.clone())
    }
    pub fn update_launch_profile_member(&self) -> fluent_builders::UpdateLaunchProfileMember<C> {
        fluent_builders::UpdateLaunchProfileMember::new(self.handle.clone())
    }
    pub fn update_streaming_image(&self) -> fluent_builders::UpdateStreamingImage<C> {
        fluent_builders::UpdateStreamingImage::new(self.handle.clone())
    }
    pub fn update_studio(&self) -> fluent_builders::UpdateStudio<C> {
        fluent_builders::UpdateStudio::new(self.handle.clone())
    }
    pub fn update_studio_component(&self) -> fluent_builders::UpdateStudioComponent<C> {
        fluent_builders::UpdateStudioComponent::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptEulas<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::accept_eulas_input::Builder,
    }
    impl<C> AcceptEulas<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptEulasOutput,
            smithy_http::result::SdkError<crate::error::AcceptEulasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The EULA ID.</p>
        pub fn eula_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.eula_ids(inp);
            self
        }
        pub fn set_eula_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_eula_ids(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLaunchProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_launch_profile_input::Builder,
    }
    impl<C> CreateLaunchProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLaunchProfileOutput,
            smithy_http::result::SdkError<crate::error::CreateLaunchProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        pub fn ec2_subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ec2_subnet_ids(inp);
            self
        }
        pub fn set_ec2_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ec2_subnet_ids(input);
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_versions(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.launch_profile_protocol_versions(inp);
            self
        }
        pub fn set_launch_profile_protocol_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_protocol_versions(input);
            self
        }
        /// <p>The name for the launch profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A configuration for a streaming session.</p>
        pub fn stream_configuration(
            mut self,
            input: crate::model::StreamConfigurationCreate,
        ) -> Self {
            self.inner = self.inner.stream_configuration(input);
            self
        }
        pub fn set_stream_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamConfigurationCreate>,
        ) -> Self {
            self.inner = self.inner.set_stream_configuration(input);
            self
        }
        /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
        pub fn studio_component_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_component_ids(inp);
            self
        }
        pub fn set_studio_component_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_studio_component_ids(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamingImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_streaming_image_input::Builder,
    }
    impl<C> CreateStreamingImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamingImageOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamingImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A human-readable description of the streaming image.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The ID of an EC2 machine image with which to create this streaming image.</p>
        pub fn ec2_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ec2_image_id(input);
            self
        }
        pub fn set_ec2_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ec2_image_id(input);
            self
        }
        /// <p>A friendly name for a streaming image resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamingSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_streaming_session_input::Builder,
    }
    impl<C> CreateStreamingSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamingSessionOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamingSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The EC2 Instance type used for the streaming session.</p>
        pub fn ec2_instance_type(mut self, input: crate::model::StreamingInstanceType) -> Self {
            self.inner = self.inner.ec2_instance_type(input);
            self
        }
        pub fn set_ec2_instance_type(
            mut self,
            input: std::option::Option<crate::model::StreamingInstanceType>,
        ) -> Self {
            self.inner = self.inner.set_ec2_instance_type(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn streaming_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.streaming_image_id(input);
            self
        }
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_streaming_image_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamingSessionStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_streaming_session_stream_input::Builder,
    }
    impl<C> CreateStreamingSessionStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamingSessionStreamOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamingSessionStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The expiration time in seconds.</p>
        pub fn expiration_in_seconds(mut self, input: i32) -> Self {
            self.inner = self.inner.expiration_in_seconds(input);
            self
        }
        pub fn set_expiration_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_expiration_in_seconds(input);
            self
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(input);
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStudio<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_studio_input::Builder,
    }
    impl<C> CreateStudio<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStudioOutput,
            smithy_http::result::SdkError<crate::error::CreateStudioError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.</p>
        pub fn admin_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.admin_role_arn(input);
            self
        }
        pub fn set_admin_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_admin_role_arn(input);
            self
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A friendly name for the studio.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.display_name(input);
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_display_name(input);
            self
        }
        /// <p>The studio encryption configuration.</p>
        pub fn studio_encryption_configuration(
            mut self,
            input: crate::model::StudioEncryptionConfiguration,
        ) -> Self {
            self.inner = self.inner.studio_encryption_configuration(input);
            self
        }
        pub fn set_studio_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioEncryptionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_studio_encryption_configuration(input);
            self
        }
        /// <p>The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.</p>
        pub fn studio_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_name(input);
            self
        }
        pub fn set_studio_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_name(input);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.</p>
        pub fn user_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_role_arn(input);
            self
        }
        pub fn set_user_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_user_role_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStudioComponent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_studio_component_input::Builder,
    }
    impl<C> CreateStudioComponent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStudioComponentOutput,
            smithy_http::result::SdkError<crate::error::CreateStudioComponentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The configuration of the studio component, based on component type.</p>
        pub fn configuration(mut self, input: crate::model::StudioComponentConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioComponentConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn ec2_security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ec2_security_group_ids(inp);
            self
        }
        pub fn set_ec2_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ec2_security_group_ids(input);
            self
        }
        /// <p>Initialization scripts for studio components.</p>
        pub fn initialization_scripts(
            mut self,
            inp: impl Into<crate::model::StudioComponentInitializationScript>,
        ) -> Self {
            self.inner = self.inner.initialization_scripts(inp);
            self
        }
        pub fn set_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::StudioComponentInitializationScript>,
            >,
        ) -> Self {
            self.inner = self.inner.set_initialization_scripts(input);
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Parameters for the studio component scripts.</p>
        pub fn script_parameters(
            mut self,
            inp: impl Into<crate::model::ScriptParameterKeyValue>,
        ) -> Self {
            self.inner = self.inner.script_parameters(inp);
            self
        }
        pub fn set_script_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
        ) -> Self {
            self.inner = self.inner.set_script_parameters(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn subtype(mut self, input: crate::model::StudioComponentSubtype) -> Self {
            self.inner = self.inner.subtype(input);
            self
        }
        pub fn set_subtype(
            mut self,
            input: std::option::Option<crate::model::StudioComponentSubtype>,
        ) -> Self {
            self.inner = self.inner.set_subtype(input);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn r#type(mut self, input: crate::model::StudioComponentType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StudioComponentType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLaunchProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_launch_profile_input::Builder,
    }
    impl<C> DeleteLaunchProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLaunchProfileOutput,
            smithy_http::result::SdkError<crate::error::DeleteLaunchProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLaunchProfileMember<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_launch_profile_member_input::Builder,
    }
    impl<C> DeleteLaunchProfileMember<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLaunchProfileMemberOutput,
            smithy_http::result::SdkError<crate::error::DeleteLaunchProfileMemberError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(input);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStreamingImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_streaming_image_input::Builder,
    }
    impl<C> DeleteStreamingImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStreamingImageOutput,
            smithy_http::result::SdkError<crate::error::DeleteStreamingImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The streaming image ID.</p>
        pub fn streaming_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.streaming_image_id(input);
            self
        }
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_streaming_image_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStreamingSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_streaming_session_input::Builder,
    }
    impl<C> DeleteStreamingSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStreamingSessionOutput,
            smithy_http::result::SdkError<crate::error::DeleteStreamingSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(input);
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStudio<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_studio_input::Builder,
    }
    impl<C> DeleteStudio<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStudioOutput,
            smithy_http::result::SdkError<crate::error::DeleteStudioError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStudioComponent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_studio_component_input::Builder,
    }
    impl<C> DeleteStudioComponent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStudioComponentOutput,
            smithy_http::result::SdkError<crate::error::DeleteStudioComponentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The studio component ID.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_component_id(input);
            self
        }
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_studio_component_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStudioMember<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_studio_member_input::Builder,
    }
    impl<C> DeleteStudioMember<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStudioMemberOutput,
            smithy_http::result::SdkError<crate::error::DeleteStudioMemberError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(input);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetEula<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_eula_input::Builder,
    }
    impl<C> GetEula<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetEulaOutput,
            smithy_http::result::SdkError<crate::error::GetEulaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The EULA ID.</p>
        pub fn eula_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.eula_id(input);
            self
        }
        pub fn set_eula_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_eula_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLaunchProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_launch_profile_input::Builder,
    }
    impl<C> GetLaunchProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLaunchProfileOutput,
            smithy_http::result::SdkError<crate::error::GetLaunchProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLaunchProfileDetails<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_launch_profile_details_input::Builder,
    }
    impl<C> GetLaunchProfileDetails<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLaunchProfileDetailsOutput,
            smithy_http::result::SdkError<crate::error::GetLaunchProfileDetailsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLaunchProfileInitialization<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_launch_profile_initialization_input::Builder,
    }
    impl<C> GetLaunchProfileInitialization<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLaunchProfileInitializationOutput,
            smithy_http::result::SdkError<crate::error::GetLaunchProfileInitializationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>A collection of launch profile protocol versions.</p>
        pub fn launch_profile_protocol_versions(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.launch_profile_protocol_versions(inp);
            self
        }
        pub fn set_launch_profile_protocol_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_protocol_versions(input);
            self
        }
        /// <p>The launch purpose.</p>
        pub fn launch_purpose(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_purpose(input);
            self
        }
        pub fn set_launch_purpose(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_purpose(input);
            self
        }
        /// <p>The platform.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform(input);
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_platform(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLaunchProfileMember<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_launch_profile_member_input::Builder,
    }
    impl<C> GetLaunchProfileMember<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLaunchProfileMemberOutput,
            smithy_http::result::SdkError<crate::error::GetLaunchProfileMemberError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(input);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStreamingImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_streaming_image_input::Builder,
    }
    impl<C> GetStreamingImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStreamingImageOutput,
            smithy_http::result::SdkError<crate::error::GetStreamingImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The streaming image ID.</p>
        pub fn streaming_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.streaming_image_id(input);
            self
        }
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_streaming_image_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStreamingSession<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_streaming_session_input::Builder,
    }
    impl<C> GetStreamingSession<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStreamingSessionOutput,
            smithy_http::result::SdkError<crate::error::GetStreamingSessionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(input);
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStreamingSessionStream<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_streaming_session_stream_input::Builder,
    }
    impl<C> GetStreamingSessionStream<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStreamingSessionStreamOutput,
            smithy_http::result::SdkError<crate::error::GetStreamingSessionStreamError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(input);
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(input);
            self
        }
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_id(input);
            self
        }
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStudio<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_studio_input::Builder,
    }
    impl<C> GetStudio<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStudioOutput,
            smithy_http::result::SdkError<crate::error::GetStudioError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStudioComponent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_studio_component_input::Builder,
    }
    impl<C> GetStudioComponent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStudioComponentOutput,
            smithy_http::result::SdkError<crate::error::GetStudioComponentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The studio component ID.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_component_id(input);
            self
        }
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_studio_component_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStudioMember<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_studio_member_input::Builder,
    }
    impl<C> GetStudioMember<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStudioMemberOutput,
            smithy_http::result::SdkError<crate::error::GetStudioMemberError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(input);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListEulaAcceptances<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_eula_acceptances_input::Builder,
    }
    impl<C> ListEulaAcceptances<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListEulaAcceptancesOutput,
            smithy_http::result::SdkError<crate::error::ListEulaAcceptancesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A collection of EULA IDs.</p>
        pub fn eula_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.eula_ids(inp);
            self
        }
        pub fn set_eula_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_eula_ids(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListEulas<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_eulas_input::Builder,
    }
    impl<C> ListEulas<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListEulasOutput,
            smithy_http::result::SdkError<crate::error::ListEulasError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>A collection of EULA IDs.</p>
        pub fn eula_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.eula_ids(inp);
            self
        }
        pub fn set_eula_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_eula_ids(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLaunchProfileMembers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_launch_profile_members_input::Builder,
    }
    impl<C> ListLaunchProfileMembers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLaunchProfileMembersOutput,
            smithy_http::result::SdkError<crate::error::ListLaunchProfileMembersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLaunchProfiles<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_launch_profiles_input::Builder,
    }
    impl<C> ListLaunchProfiles<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLaunchProfilesOutput,
            smithy_http::result::SdkError<crate::error::ListLaunchProfilesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(input);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>A list of states.</p>
        pub fn states(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.states(inp);
            self
        }
        pub fn set_states(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_states(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStreamingImages<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_streaming_images_input::Builder,
    }
    impl<C> ListStreamingImages<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStreamingImagesOutput,
            smithy_http::result::SdkError<crate::error::ListStreamingImagesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The owner.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owner(input);
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_owner(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStreamingSessions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_streaming_sessions_input::Builder,
    }
    impl<C> ListStreamingSessions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStreamingSessionsOutput,
            smithy_http::result::SdkError<crate::error::ListStreamingSessionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The user ID.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.created_by(input);
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_created_by(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A collection of session IDs.</p>
        pub fn session_ids(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_ids(input);
            self
        }
        pub fn set_session_ids(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_ids(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStudioComponents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_studio_components_input::Builder,
    }
    impl<C> ListStudioComponents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStudioComponentsOutput,
            smithy_http::result::SdkError<crate::error::ListStudioComponentsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A list of states.</p>
        pub fn states(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.states(inp);
            self
        }
        pub fn set_states(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_states(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// <p>The types.</p>
        pub fn types(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.types(inp);
            self
        }
        pub fn set_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_types(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStudioMembers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_studio_members_input::Builder,
    }
    impl<C> ListStudioMembers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStudioMembersOutput,
            smithy_http::result::SdkError<crate::error::ListStudioMembersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStudios<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_studios_input::Builder,
    }
    impl<C> ListStudios<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStudiosOutput,
            smithy_http::result::SdkError<crate::error::ListStudiosError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the target resource for tagging operations.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutLaunchProfileMembers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_launch_profile_members_input::Builder,
    }
    impl<C> PutLaunchProfileMembers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutLaunchProfileMembersOutput,
            smithy_http::result::SdkError<crate::error::PutLaunchProfileMembersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The ID of the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity_store_id(input);
            self
        }
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_identity_store_id(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>A list of members.</p>
        pub fn members(mut self, inp: impl Into<crate::model::NewLaunchProfileMember>) -> Self {
            self.inner = self.inner.members(inp);
            self
        }
        pub fn set_members(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NewLaunchProfileMember>>,
        ) -> Self {
            self.inner = self.inner.set_members(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutStudioMembers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_studio_members_input::Builder,
    }
    impl<C> PutStudioMembers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutStudioMembersOutput,
            smithy_http::result::SdkError<crate::error::PutStudioMembersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The ID of the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity_store_id(input);
            self
        }
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_identity_store_id(input);
            self
        }
        /// <p>A list of members.</p>
        pub fn members(mut self, inp: impl Into<crate::model::NewStudioMember>) -> Self {
            self.inner = self.inner.members(inp);
            self
        }
        pub fn set_members(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NewStudioMember>>,
        ) -> Self {
            self.inner = self.inner.set_members(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartStudioSSOConfigurationRepair<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::start_studio_sso_configuration_repair_input::Builder,
    }
    impl<C> StartStudioSSOConfigurationRepair<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartStudioSsoConfigurationRepairOutput,
            smithy_http::result::SdkError<crate::error::StartStudioSSOConfigurationRepairError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the target resource for tagging operations.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the target resource for tagging operations.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>An array of tag keys to delete.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLaunchProfile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_launch_profile_input::Builder,
    }
    impl<C> UpdateLaunchProfile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLaunchProfileOutput,
            smithy_http::result::SdkError<crate::error::UpdateLaunchProfileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_versions(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.launch_profile_protocol_versions(inp);
            self
        }
        pub fn set_launch_profile_protocol_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_protocol_versions(input);
            self
        }
        /// <p>The name for the launch profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A configuration for a streaming session.</p>
        pub fn stream_configuration(
            mut self,
            input: crate::model::StreamConfigurationCreate,
        ) -> Self {
            self.inner = self.inner.stream_configuration(input);
            self
        }
        pub fn set_stream_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamConfigurationCreate>,
        ) -> Self {
            self.inner = self.inner.set_stream_configuration(input);
            self
        }
        /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
        pub fn studio_component_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_component_ids(inp);
            self
        }
        pub fn set_studio_component_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_studio_component_ids(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLaunchProfileMember<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_launch_profile_member_input::Builder,
    }
    impl<C> UpdateLaunchProfileMember<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLaunchProfileMemberOutput,
            smithy_http::result::SdkError<crate::error::UpdateLaunchProfileMemberError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(input);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::LaunchProfilePersona) -> Self {
            self.inner = self.inner.persona(input);
            self
        }
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePersona>,
        ) -> Self {
            self.inner = self.inner.set_persona(input);
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(input);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateStreamingImage<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_streaming_image_input::Builder,
    }
    impl<C> UpdateStreamingImage<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateStreamingImageOutput,
            smithy_http::result::SdkError<crate::error::UpdateStreamingImageError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The name for the streaming image.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The streaming image ID.</p>
        pub fn streaming_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.streaming_image_id(input);
            self
        }
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_streaming_image_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateStudio<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_studio_input::Builder,
    }
    impl<C> UpdateStudio<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateStudioOutput,
            smithy_http::result::SdkError<crate::error::UpdateStudioError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.</p>
        pub fn admin_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.admin_role_arn(input);
            self
        }
        pub fn set_admin_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_admin_role_arn(input);
            self
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A friendly name for the studio.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.display_name(input);
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_display_name(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// <p>The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.</p>
        pub fn user_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_role_arn(input);
            self
        }
        pub fn set_user_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_user_role_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateStudioComponent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_studio_component_input::Builder,
    }
    impl<C> UpdateStudioComponent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateStudioComponentOutput,
            smithy_http::result::SdkError<crate::error::UpdateStudioComponentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(input);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The configuration of the studio component, based on component type.</p>
        pub fn configuration(mut self, input: crate::model::StudioComponentConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioComponentConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn ec2_security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ec2_security_group_ids(inp);
            self
        }
        pub fn set_ec2_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ec2_security_group_ids(input);
            self
        }
        /// <p>Initialization scripts for studio components.</p>
        pub fn initialization_scripts(
            mut self,
            inp: impl Into<crate::model::StudioComponentInitializationScript>,
        ) -> Self {
            self.inner = self.inner.initialization_scripts(inp);
            self
        }
        pub fn set_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::StudioComponentInitializationScript>,
            >,
        ) -> Self {
            self.inner = self.inner.set_initialization_scripts(input);
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Parameters for the studio component scripts.</p>
        pub fn script_parameters(
            mut self,
            inp: impl Into<crate::model::ScriptParameterKeyValue>,
        ) -> Self {
            self.inner = self.inner.script_parameters(inp);
            self
        }
        pub fn set_script_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
        ) -> Self {
            self.inner = self.inner.set_script_parameters(input);
            self
        }
        /// <p>The studio component ID.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_component_id(input);
            self
        }
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_studio_component_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(input);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn subtype(mut self, input: crate::model::StudioComponentSubtype) -> Self {
            self.inner = self.inner.subtype(input);
            self
        }
        pub fn set_subtype(
            mut self,
            input: std::option::Option<crate::model::StudioComponentSubtype>,
        ) -> Self {
            self.inner = self.inner.set_subtype(input);
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn r#type(mut self, input: crate::model::StudioComponentType) -> Self {
            self.inner = self.inner.r#type(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StudioComponentType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
}
