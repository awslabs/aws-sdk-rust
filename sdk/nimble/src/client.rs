// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `nimble`.
///
/// This client allows ergonomic access to a `nimble`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn accept_eulas(&self) -> fluent_builders::AcceptEulas<C, M, R> {
        fluent_builders::AcceptEulas::new(self.handle.clone())
    }
    pub fn create_launch_profile(&self) -> fluent_builders::CreateLaunchProfile<C, M, R> {
        fluent_builders::CreateLaunchProfile::new(self.handle.clone())
    }
    pub fn create_streaming_image(&self) -> fluent_builders::CreateStreamingImage<C, M, R> {
        fluent_builders::CreateStreamingImage::new(self.handle.clone())
    }
    pub fn create_streaming_session(&self) -> fluent_builders::CreateStreamingSession<C, M, R> {
        fluent_builders::CreateStreamingSession::new(self.handle.clone())
    }
    pub fn create_streaming_session_stream(
        &self,
    ) -> fluent_builders::CreateStreamingSessionStream<C, M, R> {
        fluent_builders::CreateStreamingSessionStream::new(self.handle.clone())
    }
    pub fn create_studio(&self) -> fluent_builders::CreateStudio<C, M, R> {
        fluent_builders::CreateStudio::new(self.handle.clone())
    }
    pub fn create_studio_component(&self) -> fluent_builders::CreateStudioComponent<C, M, R> {
        fluent_builders::CreateStudioComponent::new(self.handle.clone())
    }
    pub fn delete_launch_profile(&self) -> fluent_builders::DeleteLaunchProfile<C, M, R> {
        fluent_builders::DeleteLaunchProfile::new(self.handle.clone())
    }
    pub fn delete_launch_profile_member(
        &self,
    ) -> fluent_builders::DeleteLaunchProfileMember<C, M, R> {
        fluent_builders::DeleteLaunchProfileMember::new(self.handle.clone())
    }
    pub fn delete_streaming_image(&self) -> fluent_builders::DeleteStreamingImage<C, M, R> {
        fluent_builders::DeleteStreamingImage::new(self.handle.clone())
    }
    pub fn delete_streaming_session(&self) -> fluent_builders::DeleteStreamingSession<C, M, R> {
        fluent_builders::DeleteStreamingSession::new(self.handle.clone())
    }
    pub fn delete_studio(&self) -> fluent_builders::DeleteStudio<C, M, R> {
        fluent_builders::DeleteStudio::new(self.handle.clone())
    }
    pub fn delete_studio_component(&self) -> fluent_builders::DeleteStudioComponent<C, M, R> {
        fluent_builders::DeleteStudioComponent::new(self.handle.clone())
    }
    pub fn delete_studio_member(&self) -> fluent_builders::DeleteStudioMember<C, M, R> {
        fluent_builders::DeleteStudioMember::new(self.handle.clone())
    }
    pub fn get_eula(&self) -> fluent_builders::GetEula<C, M, R> {
        fluent_builders::GetEula::new(self.handle.clone())
    }
    pub fn get_launch_profile(&self) -> fluent_builders::GetLaunchProfile<C, M, R> {
        fluent_builders::GetLaunchProfile::new(self.handle.clone())
    }
    pub fn get_launch_profile_details(&self) -> fluent_builders::GetLaunchProfileDetails<C, M, R> {
        fluent_builders::GetLaunchProfileDetails::new(self.handle.clone())
    }
    pub fn get_launch_profile_initialization(
        &self,
    ) -> fluent_builders::GetLaunchProfileInitialization<C, M, R> {
        fluent_builders::GetLaunchProfileInitialization::new(self.handle.clone())
    }
    pub fn get_launch_profile_member(&self) -> fluent_builders::GetLaunchProfileMember<C, M, R> {
        fluent_builders::GetLaunchProfileMember::new(self.handle.clone())
    }
    pub fn get_streaming_image(&self) -> fluent_builders::GetStreamingImage<C, M, R> {
        fluent_builders::GetStreamingImage::new(self.handle.clone())
    }
    pub fn get_streaming_session(&self) -> fluent_builders::GetStreamingSession<C, M, R> {
        fluent_builders::GetStreamingSession::new(self.handle.clone())
    }
    pub fn get_streaming_session_stream(
        &self,
    ) -> fluent_builders::GetStreamingSessionStream<C, M, R> {
        fluent_builders::GetStreamingSessionStream::new(self.handle.clone())
    }
    pub fn get_studio(&self) -> fluent_builders::GetStudio<C, M, R> {
        fluent_builders::GetStudio::new(self.handle.clone())
    }
    pub fn get_studio_component(&self) -> fluent_builders::GetStudioComponent<C, M, R> {
        fluent_builders::GetStudioComponent::new(self.handle.clone())
    }
    pub fn get_studio_member(&self) -> fluent_builders::GetStudioMember<C, M, R> {
        fluent_builders::GetStudioMember::new(self.handle.clone())
    }
    pub fn list_eula_acceptances(&self) -> fluent_builders::ListEulaAcceptances<C, M, R> {
        fluent_builders::ListEulaAcceptances::new(self.handle.clone())
    }
    pub fn list_eulas(&self) -> fluent_builders::ListEulas<C, M, R> {
        fluent_builders::ListEulas::new(self.handle.clone())
    }
    pub fn list_launch_profile_members(
        &self,
    ) -> fluent_builders::ListLaunchProfileMembers<C, M, R> {
        fluent_builders::ListLaunchProfileMembers::new(self.handle.clone())
    }
    pub fn list_launch_profiles(&self) -> fluent_builders::ListLaunchProfiles<C, M, R> {
        fluent_builders::ListLaunchProfiles::new(self.handle.clone())
    }
    pub fn list_streaming_images(&self) -> fluent_builders::ListStreamingImages<C, M, R> {
        fluent_builders::ListStreamingImages::new(self.handle.clone())
    }
    pub fn list_streaming_sessions(&self) -> fluent_builders::ListStreamingSessions<C, M, R> {
        fluent_builders::ListStreamingSessions::new(self.handle.clone())
    }
    pub fn list_studio_components(&self) -> fluent_builders::ListStudioComponents<C, M, R> {
        fluent_builders::ListStudioComponents::new(self.handle.clone())
    }
    pub fn list_studio_members(&self) -> fluent_builders::ListStudioMembers<C, M, R> {
        fluent_builders::ListStudioMembers::new(self.handle.clone())
    }
    pub fn list_studios(&self) -> fluent_builders::ListStudios<C, M, R> {
        fluent_builders::ListStudios::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C, M, R> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn put_launch_profile_members(&self) -> fluent_builders::PutLaunchProfileMembers<C, M, R> {
        fluent_builders::PutLaunchProfileMembers::new(self.handle.clone())
    }
    pub fn put_studio_members(&self) -> fluent_builders::PutStudioMembers<C, M, R> {
        fluent_builders::PutStudioMembers::new(self.handle.clone())
    }
    pub fn start_studio_sso_configuration_repair(
        &self,
    ) -> fluent_builders::StartStudioSSOConfigurationRepair<C, M, R> {
        fluent_builders::StartStudioSSOConfigurationRepair::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_launch_profile(&self) -> fluent_builders::UpdateLaunchProfile<C, M, R> {
        fluent_builders::UpdateLaunchProfile::new(self.handle.clone())
    }
    pub fn update_launch_profile_member(
        &self,
    ) -> fluent_builders::UpdateLaunchProfileMember<C, M, R> {
        fluent_builders::UpdateLaunchProfileMember::new(self.handle.clone())
    }
    pub fn update_streaming_image(&self) -> fluent_builders::UpdateStreamingImage<C, M, R> {
        fluent_builders::UpdateStreamingImage::new(self.handle.clone())
    }
    pub fn update_studio(&self) -> fluent_builders::UpdateStudio<C, M, R> {
        fluent_builders::UpdateStudio::new(self.handle.clone())
    }
    pub fn update_studio_component(&self) -> fluent_builders::UpdateStudioComponent<C, M, R> {
        fluent_builders::UpdateStudioComponent::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AcceptEulas<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::accept_eulas_input::Builder,
    }
    impl<C, M, R> AcceptEulas<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AcceptEulasOutput,
            smithy_http::result::SdkError<crate::error::AcceptEulasError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::AcceptEulasInputOperationOutputAlias,
                crate::output::AcceptEulasOutput,
                crate::error::AcceptEulasError,
                crate::input::AcceptEulasInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// Appends an item to `eulaIds`.
        ///
        /// To override the contents of this collection use [`set_eula_ids`](Self::set_eula_ids).
        /// <p>The EULA ID.</p>
        pub fn eula_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.eula_ids(inp);
            self
        }
        pub fn set_eula_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_eula_ids(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateLaunchProfile<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_launch_profile_input::Builder,
    }
    impl<C, M, R> CreateLaunchProfile<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateLaunchProfileOutput,
            smithy_http::result::SdkError<crate::error::CreateLaunchProfileError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateLaunchProfileInputOperationOutputAlias,
                crate::output::CreateLaunchProfileOutput,
                crate::error::CreateLaunchProfileError,
                crate::input::CreateLaunchProfileInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Appends an item to `ec2SubnetIds`.
        ///
        /// To override the contents of this collection use [`set_ec2_subnet_ids`](Self::set_ec2_subnet_ids).
        pub fn ec2_subnet_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ec2_subnet_ids(inp);
            self
        }
        pub fn set_ec2_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ec2_subnet_ids(input);
            self
        }
        /// Appends an item to `launchProfileProtocolVersions`.
        ///
        /// To override the contents of this collection use [`set_launch_profile_protocol_versions`](Self::set_launch_profile_protocol_versions).
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_versions(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.launch_profile_protocol_versions(inp);
            self
        }
        pub fn set_launch_profile_protocol_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_protocol_versions(input);
            self
        }
        /// <p>The name for the launch profile.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A configuration for a streaming session.</p>
        pub fn stream_configuration(
            mut self,
            inp: crate::model::StreamConfigurationCreate,
        ) -> Self {
            self.inner = self.inner.stream_configuration(inp);
            self
        }
        pub fn set_stream_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamConfigurationCreate>,
        ) -> Self {
            self.inner = self.inner.set_stream_configuration(input);
            self
        }
        /// Appends an item to `studioComponentIds`.
        ///
        /// To override the contents of this collection use [`set_studio_component_ids`](Self::set_studio_component_ids).
        /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
        pub fn studio_component_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_component_ids(inp);
            self
        }
        pub fn set_studio_component_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_studio_component_ids(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamingImage<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_streaming_image_input::Builder,
    }
    impl<C, M, R> CreateStreamingImage<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamingImageOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamingImageError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateStreamingImageInputOperationOutputAlias,
                crate::output::CreateStreamingImageOutput,
                crate::error::CreateStreamingImageError,
                crate::input::CreateStreamingImageInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A human-readable description of the streaming image.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The ID of an EC2 machine image with which to create this streaming image.</p>
        pub fn ec2_image_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ec2_image_id(inp);
            self
        }
        pub fn set_ec2_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_ec2_image_id(input);
            self
        }
        /// <p>A friendly name for a streaming image resource.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamingSession<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_streaming_session_input::Builder,
    }
    impl<C, M, R> CreateStreamingSession<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamingSessionOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamingSessionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateStreamingSessionInputOperationOutputAlias,
                crate::output::CreateStreamingSessionOutput,
                crate::error::CreateStreamingSessionError,
                crate::input::CreateStreamingSessionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The EC2 Instance type used for the streaming session.</p>
        pub fn ec2_instance_type(mut self, inp: crate::model::StreamingInstanceType) -> Self {
            self.inner = self.inner.ec2_instance_type(inp);
            self
        }
        pub fn set_ec2_instance_type(
            mut self,
            input: std::option::Option<crate::model::StreamingInstanceType>,
        ) -> Self {
            self.inner = self.inner.set_ec2_instance_type(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The user ID of the user that owns the streaming session.</p>
        pub fn owned_by(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owned_by(inp);
            self
        }
        pub fn set_owned_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_owned_by(input);
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn streaming_image_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.streaming_image_id(inp);
            self
        }
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_streaming_image_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStreamingSessionStream<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_streaming_session_stream_input::Builder,
    }
    impl<C, M, R> CreateStreamingSessionStream<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStreamingSessionStreamOutput,
            smithy_http::result::SdkError<crate::error::CreateStreamingSessionStreamError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateStreamingSessionStreamInputOperationOutputAlias,
                crate::output::CreateStreamingSessionStreamOutput,
                crate::error::CreateStreamingSessionStreamError,
                crate::input::CreateStreamingSessionStreamInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The expiration time in seconds.</p>
        pub fn expiration_in_seconds(mut self, inp: i32) -> Self {
            self.inner = self.inner.expiration_in_seconds(inp);
            self
        }
        pub fn set_expiration_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_expiration_in_seconds(input);
            self
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(inp);
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStudio<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_studio_input::Builder,
    }
    impl<C, M, R> CreateStudio<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStudioOutput,
            smithy_http::result::SdkError<crate::error::CreateStudioError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateStudioInputOperationOutputAlias,
                crate::output::CreateStudioOutput,
                crate::error::CreateStudioError,
                crate::input::CreateStudioInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.</p>
        pub fn admin_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.admin_role_arn(inp);
            self
        }
        pub fn set_admin_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_admin_role_arn(input);
            self
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A friendly name for the studio.</p>
        pub fn display_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.display_name(inp);
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_display_name(input);
            self
        }
        /// <p>The studio encryption configuration.</p>
        pub fn studio_encryption_configuration(
            mut self,
            inp: crate::model::StudioEncryptionConfiguration,
        ) -> Self {
            self.inner = self.inner.studio_encryption_configuration(inp);
            self
        }
        pub fn set_studio_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioEncryptionConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_studio_encryption_configuration(input);
            self
        }
        /// <p>The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.</p>
        pub fn studio_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_name(inp);
            self
        }
        pub fn set_studio_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_name(input);
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.</p>
        pub fn user_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_role_arn(inp);
            self
        }
        pub fn set_user_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_user_role_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateStudioComponent<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_studio_component_input::Builder,
    }
    impl<C, M, R> CreateStudioComponent<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateStudioComponentOutput,
            smithy_http::result::SdkError<crate::error::CreateStudioComponentError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateStudioComponentInputOperationOutputAlias,
                crate::output::CreateStudioComponentOutput,
                crate::error::CreateStudioComponentError,
                crate::input::CreateStudioComponentInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The configuration of the studio component, based on component type.</p>
        pub fn configuration(mut self, inp: crate::model::StudioComponentConfiguration) -> Self {
            self.inner = self.inner.configuration(inp);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioComponentConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Appends an item to `ec2SecurityGroupIds`.
        ///
        /// To override the contents of this collection use [`set_ec2_security_group_ids`](Self::set_ec2_security_group_ids).
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn ec2_security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ec2_security_group_ids(inp);
            self
        }
        pub fn set_ec2_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ec2_security_group_ids(input);
            self
        }
        /// Appends an item to `initializationScripts`.
        ///
        /// To override the contents of this collection use [`set_initialization_scripts`](Self::set_initialization_scripts).
        /// <p>Initialization scripts for studio components.</p>
        pub fn initialization_scripts(
            mut self,
            inp: impl Into<crate::model::StudioComponentInitializationScript>,
        ) -> Self {
            self.inner = self.inner.initialization_scripts(inp);
            self
        }
        pub fn set_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::StudioComponentInitializationScript>,
            >,
        ) -> Self {
            self.inner = self.inner.set_initialization_scripts(input);
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// Appends an item to `scriptParameters`.
        ///
        /// To override the contents of this collection use [`set_script_parameters`](Self::set_script_parameters).
        /// <p>Parameters for the studio component scripts.</p>
        pub fn script_parameters(
            mut self,
            inp: impl Into<crate::model::ScriptParameterKeyValue>,
        ) -> Self {
            self.inner = self.inner.script_parameters(inp);
            self
        }
        pub fn set_script_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
        ) -> Self {
            self.inner = self.inner.set_script_parameters(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn subtype(mut self, inp: crate::model::StudioComponentSubtype) -> Self {
            self.inner = self.inner.subtype(inp);
            self
        }
        pub fn set_subtype(
            mut self,
            input: std::option::Option<crate::model::StudioComponentSubtype>,
        ) -> Self {
            self.inner = self.inner.set_subtype(input);
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn r#type(mut self, inp: crate::model::StudioComponentType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StudioComponentType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLaunchProfile<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_launch_profile_input::Builder,
    }
    impl<C, M, R> DeleteLaunchProfile<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLaunchProfileOutput,
            smithy_http::result::SdkError<crate::error::DeleteLaunchProfileError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteLaunchProfileInputOperationOutputAlias,
                crate::output::DeleteLaunchProfileOutput,
                crate::error::DeleteLaunchProfileError,
                crate::input::DeleteLaunchProfileInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteLaunchProfileMember<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_launch_profile_member_input::Builder,
    }
    impl<C, M, R> DeleteLaunchProfileMember<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteLaunchProfileMemberOutput,
            smithy_http::result::SdkError<crate::error::DeleteLaunchProfileMemberError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteLaunchProfileMemberInputOperationOutputAlias,
                crate::output::DeleteLaunchProfileMemberOutput,
                crate::error::DeleteLaunchProfileMemberError,
                crate::input::DeleteLaunchProfileMemberInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(inp);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStreamingImage<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_streaming_image_input::Builder,
    }
    impl<C, M, R> DeleteStreamingImage<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStreamingImageOutput,
            smithy_http::result::SdkError<crate::error::DeleteStreamingImageError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteStreamingImageInputOperationOutputAlias,
                crate::output::DeleteStreamingImageOutput,
                crate::error::DeleteStreamingImageError,
                crate::input::DeleteStreamingImageInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The streaming image ID.</p>
        pub fn streaming_image_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.streaming_image_id(inp);
            self
        }
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_streaming_image_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStreamingSession<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_streaming_session_input::Builder,
    }
    impl<C, M, R> DeleteStreamingSession<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStreamingSessionOutput,
            smithy_http::result::SdkError<crate::error::DeleteStreamingSessionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteStreamingSessionInputOperationOutputAlias,
                crate::output::DeleteStreamingSessionOutput,
                crate::error::DeleteStreamingSessionError,
                crate::input::DeleteStreamingSessionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(inp);
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStudio<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_studio_input::Builder,
    }
    impl<C, M, R> DeleteStudio<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStudioOutput,
            smithy_http::result::SdkError<crate::error::DeleteStudioError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteStudioInputOperationOutputAlias,
                crate::output::DeleteStudioOutput,
                crate::error::DeleteStudioError,
                crate::input::DeleteStudioInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStudioComponent<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_studio_component_input::Builder,
    }
    impl<C, M, R> DeleteStudioComponent<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStudioComponentOutput,
            smithy_http::result::SdkError<crate::error::DeleteStudioComponentError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteStudioComponentInputOperationOutputAlias,
                crate::output::DeleteStudioComponentOutput,
                crate::error::DeleteStudioComponentError,
                crate::input::DeleteStudioComponentInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The studio component ID.</p>
        pub fn studio_component_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_component_id(inp);
            self
        }
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_studio_component_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStudioMember<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_studio_member_input::Builder,
    }
    impl<C, M, R> DeleteStudioMember<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStudioMemberOutput,
            smithy_http::result::SdkError<crate::error::DeleteStudioMemberError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteStudioMemberInputOperationOutputAlias,
                crate::output::DeleteStudioMemberOutput,
                crate::error::DeleteStudioMemberError,
                crate::input::DeleteStudioMemberInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(inp);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetEula<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_eula_input::Builder,
    }
    impl<C, M, R> GetEula<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetEulaOutput,
            smithy_http::result::SdkError<crate::error::GetEulaError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetEulaInputOperationOutputAlias,
                crate::output::GetEulaOutput,
                crate::error::GetEulaError,
                crate::input::GetEulaInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The EULA ID.</p>
        pub fn eula_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.eula_id(inp);
            self
        }
        pub fn set_eula_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_eula_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLaunchProfile<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_launch_profile_input::Builder,
    }
    impl<C, M, R> GetLaunchProfile<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLaunchProfileOutput,
            smithy_http::result::SdkError<crate::error::GetLaunchProfileError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetLaunchProfileInputOperationOutputAlias,
                crate::output::GetLaunchProfileOutput,
                crate::error::GetLaunchProfileError,
                crate::input::GetLaunchProfileInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLaunchProfileDetails<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_launch_profile_details_input::Builder,
    }
    impl<C, M, R> GetLaunchProfileDetails<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLaunchProfileDetailsOutput,
            smithy_http::result::SdkError<crate::error::GetLaunchProfileDetailsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetLaunchProfileDetailsInputOperationOutputAlias,
                crate::output::GetLaunchProfileDetailsOutput,
                crate::error::GetLaunchProfileDetailsError,
                crate::input::GetLaunchProfileDetailsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLaunchProfileInitialization<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_launch_profile_initialization_input::Builder,
    }
    impl<C, M, R> GetLaunchProfileInitialization<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLaunchProfileInitializationOutput,
            smithy_http::result::SdkError<crate::error::GetLaunchProfileInitializationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetLaunchProfileInitializationInputOperationOutputAlias,
                crate::output::GetLaunchProfileInitializationOutput,
                crate::error::GetLaunchProfileInitializationError,
                crate::input::GetLaunchProfileInitializationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// Appends an item to `launchProfileProtocolVersions`.
        ///
        /// To override the contents of this collection use [`set_launch_profile_protocol_versions`](Self::set_launch_profile_protocol_versions).
        /// <p>A collection of launch profile protocol versions.</p>
        pub fn launch_profile_protocol_versions(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.launch_profile_protocol_versions(inp);
            self
        }
        pub fn set_launch_profile_protocol_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_protocol_versions(input);
            self
        }
        /// <p>The launch purpose.</p>
        pub fn launch_purpose(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_purpose(inp);
            self
        }
        pub fn set_launch_purpose(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_purpose(input);
            self
        }
        /// <p>The platform.</p>
        pub fn platform(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.platform(inp);
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_platform(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetLaunchProfileMember<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_launch_profile_member_input::Builder,
    }
    impl<C, M, R> GetLaunchProfileMember<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetLaunchProfileMemberOutput,
            smithy_http::result::SdkError<crate::error::GetLaunchProfileMemberError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetLaunchProfileMemberInputOperationOutputAlias,
                crate::output::GetLaunchProfileMemberOutput,
                crate::error::GetLaunchProfileMemberError,
                crate::input::GetLaunchProfileMemberInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(inp);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStreamingImage<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_streaming_image_input::Builder,
    }
    impl<C, M, R> GetStreamingImage<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStreamingImageOutput,
            smithy_http::result::SdkError<crate::error::GetStreamingImageError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetStreamingImageInputOperationOutputAlias,
                crate::output::GetStreamingImageOutput,
                crate::error::GetStreamingImageError,
                crate::input::GetStreamingImageInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The streaming image ID.</p>
        pub fn streaming_image_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.streaming_image_id(inp);
            self
        }
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_streaming_image_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStreamingSession<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_streaming_session_input::Builder,
    }
    impl<C, M, R> GetStreamingSession<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStreamingSessionOutput,
            smithy_http::result::SdkError<crate::error::GetStreamingSessionError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetStreamingSessionInputOperationOutputAlias,
                crate::output::GetStreamingSessionOutput,
                crate::error::GetStreamingSessionError,
                crate::input::GetStreamingSessionInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(inp);
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStreamingSessionStream<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_streaming_session_stream_input::Builder,
    }
    impl<C, M, R> GetStreamingSessionStream<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStreamingSessionStreamOutput,
            smithy_http::result::SdkError<crate::error::GetStreamingSessionStreamError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetStreamingSessionStreamInputOperationOutputAlias,
                crate::output::GetStreamingSessionStreamOutput,
                crate::error::GetStreamingSessionStreamError,
                crate::input::GetStreamingSessionStreamInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_id(inp);
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_id(input);
            self
        }
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.stream_id(inp);
            self
        }
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_stream_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStudio<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_studio_input::Builder,
    }
    impl<C, M, R> GetStudio<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStudioOutput,
            smithy_http::result::SdkError<crate::error::GetStudioError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetStudioInputOperationOutputAlias,
                crate::output::GetStudioOutput,
                crate::error::GetStudioError,
                crate::input::GetStudioInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStudioComponent<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_studio_component_input::Builder,
    }
    impl<C, M, R> GetStudioComponent<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStudioComponentOutput,
            smithy_http::result::SdkError<crate::error::GetStudioComponentError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetStudioComponentInputOperationOutputAlias,
                crate::output::GetStudioComponentOutput,
                crate::error::GetStudioComponentError,
                crate::input::GetStudioComponentInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The studio component ID.</p>
        pub fn studio_component_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_component_id(inp);
            self
        }
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_studio_component_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStudioMember<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_studio_member_input::Builder,
    }
    impl<C, M, R> GetStudioMember<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStudioMemberOutput,
            smithy_http::result::SdkError<crate::error::GetStudioMemberError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetStudioMemberInputOperationOutputAlias,
                crate::output::GetStudioMemberOutput,
                crate::error::GetStudioMemberError,
                crate::input::GetStudioMemberInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(inp);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListEulaAcceptances<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_eula_acceptances_input::Builder,
    }
    impl<C, M, R> ListEulaAcceptances<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListEulaAcceptancesOutput,
            smithy_http::result::SdkError<crate::error::ListEulaAcceptancesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListEulaAcceptancesInputOperationOutputAlias,
                crate::output::ListEulaAcceptancesOutput,
                crate::error::ListEulaAcceptancesError,
                crate::input::ListEulaAcceptancesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `eulaIds`.
        ///
        /// To override the contents of this collection use [`set_eula_ids`](Self::set_eula_ids).
        /// <p>A collection of EULA IDs.</p>
        pub fn eula_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.eula_ids(inp);
            self
        }
        pub fn set_eula_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_eula_ids(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListEulas<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_eulas_input::Builder,
    }
    impl<C, M, R> ListEulas<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListEulasOutput,
            smithy_http::result::SdkError<crate::error::ListEulasError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListEulasInputOperationOutputAlias,
                crate::output::ListEulasOutput,
                crate::error::ListEulasError,
                crate::input::ListEulasInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// Appends an item to `eulaIds`.
        ///
        /// To override the contents of this collection use [`set_eula_ids`](Self::set_eula_ids).
        /// <p>A collection of EULA IDs.</p>
        pub fn eula_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.eula_ids(inp);
            self
        }
        pub fn set_eula_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_eula_ids(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLaunchProfileMembers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_launch_profile_members_input::Builder,
    }
    impl<C, M, R> ListLaunchProfileMembers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLaunchProfileMembersOutput,
            smithy_http::result::SdkError<crate::error::ListLaunchProfileMembersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListLaunchProfileMembersInputOperationOutputAlias,
                crate::output::ListLaunchProfileMembersOutput,
                crate::error::ListLaunchProfileMembersError,
                crate::input::ListLaunchProfileMembersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListLaunchProfiles<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_launch_profiles_input::Builder,
    }
    impl<C, M, R> ListLaunchProfiles<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListLaunchProfilesOutput,
            smithy_http::result::SdkError<crate::error::ListLaunchProfilesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListLaunchProfilesInputOperationOutputAlias,
                crate::output::ListLaunchProfilesOutput,
                crate::error::ListLaunchProfilesError,
                crate::input::ListLaunchProfilesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(inp);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// Appends an item to `states`.
        ///
        /// To override the contents of this collection use [`set_states`](Self::set_states).
        /// <p>A list of states.</p>
        pub fn states(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.states(inp);
            self
        }
        pub fn set_states(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_states(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStreamingImages<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_streaming_images_input::Builder,
    }
    impl<C, M, R> ListStreamingImages<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStreamingImagesOutput,
            smithy_http::result::SdkError<crate::error::ListStreamingImagesError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListStreamingImagesInputOperationOutputAlias,
                crate::output::ListStreamingImagesOutput,
                crate::error::ListStreamingImagesError,
                crate::input::ListStreamingImagesInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The owner.</p>
        pub fn owner(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owner(inp);
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_owner(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStreamingSessions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_streaming_sessions_input::Builder,
    }
    impl<C, M, R> ListStreamingSessions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStreamingSessionsOutput,
            smithy_http::result::SdkError<crate::error::ListStreamingSessionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListStreamingSessionsInputOperationOutputAlias,
                crate::output::ListStreamingSessionsOutput,
                crate::error::ListStreamingSessionsError,
                crate::input::ListStreamingSessionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The user ID of the user that created the streaming session.</p>
        pub fn created_by(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.created_by(inp);
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_created_by(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The user ID of the user that owns the streaming session.</p>
        pub fn owned_by(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.owned_by(inp);
            self
        }
        pub fn set_owned_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_owned_by(input);
            self
        }
        /// <p>A collection of session IDs.</p>
        pub fn session_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.session_ids(inp);
            self
        }
        pub fn set_session_ids(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_session_ids(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStudioComponents<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_studio_components_input::Builder,
    }
    impl<C, M, R> ListStudioComponents<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStudioComponentsOutput,
            smithy_http::result::SdkError<crate::error::ListStudioComponentsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListStudioComponentsInputOperationOutputAlias,
                crate::output::ListStudioComponentsOutput,
                crate::error::ListStudioComponentsError,
                crate::input::ListStudioComponentsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// Appends an item to `states`.
        ///
        /// To override the contents of this collection use [`set_states`](Self::set_states).
        /// <p>A list of states.</p>
        pub fn states(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.states(inp);
            self
        }
        pub fn set_states(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_states(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// Appends an item to `types`.
        ///
        /// To override the contents of this collection use [`set_types`](Self::set_types).
        /// <p>The types.</p>
        pub fn types(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.types(inp);
            self
        }
        pub fn set_types(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_types(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStudioMembers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_studio_members_input::Builder,
    }
    impl<C, M, R> ListStudioMembers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStudioMembersOutput,
            smithy_http::result::SdkError<crate::error::ListStudioMembersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListStudioMembersInputOperationOutputAlias,
                crate::output::ListStudioMembersOutput,
                crate::error::ListStudioMembersError,
                crate::input::ListStudioMembersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The maximum number of results to be returned per request.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStudios<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_studios_input::Builder,
    }
    impl<C, M, R> ListStudios<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStudiosOutput,
            smithy_http::result::SdkError<crate::error::ListStudiosError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListStudiosInputOperationOutputAlias,
                crate::output::ListStudiosOutput,
                crate::error::ListStudiosError,
                crate::input::ListStudiosInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The token for the next set of results, or null if there are no more results.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C, M, R> ListTagsForResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListTagsForResourceInputOperationOutputAlias,
                crate::output::ListTagsForResourceOutput,
                crate::error::ListTagsForResourceError,
                crate::input::ListTagsForResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the target resource for tagging operations.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutLaunchProfileMembers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_launch_profile_members_input::Builder,
    }
    impl<C, M, R> PutLaunchProfileMembers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutLaunchProfileMembersOutput,
            smithy_http::result::SdkError<crate::error::PutLaunchProfileMembersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutLaunchProfileMembersInputOperationOutputAlias,
                crate::output::PutLaunchProfileMembersOutput,
                crate::error::PutLaunchProfileMembersError,
                crate::input::PutLaunchProfileMembersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The ID of the identity store.</p>
        pub fn identity_store_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity_store_id(inp);
            self
        }
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_identity_store_id(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// Appends an item to `members`.
        ///
        /// To override the contents of this collection use [`set_members`](Self::set_members).
        /// <p>A list of members.</p>
        pub fn members(mut self, inp: impl Into<crate::model::NewLaunchProfileMember>) -> Self {
            self.inner = self.inner.members(inp);
            self
        }
        pub fn set_members(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NewLaunchProfileMember>>,
        ) -> Self {
            self.inner = self.inner.set_members(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutStudioMembers<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_studio_members_input::Builder,
    }
    impl<C, M, R> PutStudioMembers<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutStudioMembersOutput,
            smithy_http::result::SdkError<crate::error::PutStudioMembersError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutStudioMembersInputOperationOutputAlias,
                crate::output::PutStudioMembersOutput,
                crate::error::PutStudioMembersError,
                crate::input::PutStudioMembersInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The ID of the identity store.</p>
        pub fn identity_store_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.identity_store_id(inp);
            self
        }
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_identity_store_id(input);
            self
        }
        /// Appends an item to `members`.
        ///
        /// To override the contents of this collection use [`set_members`](Self::set_members).
        /// <p>A list of members.</p>
        pub fn members(mut self, inp: impl Into<crate::model::NewStudioMember>) -> Self {
            self.inner = self.inner.members(inp);
            self
        }
        pub fn set_members(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::NewStudioMember>>,
        ) -> Self {
            self.inner = self.inner.set_members(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StartStudioSSOConfigurationRepair<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::start_studio_sso_configuration_repair_input::Builder,
    }
    impl<C, M, R> StartStudioSSOConfigurationRepair<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StartStudioSsoConfigurationRepairOutput,
            smithy_http::result::SdkError<crate::error::StartStudioSSOConfigurationRepairError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StartStudioSsoConfigurationRepairInputOperationOutputAlias,
                crate::output::StartStudioSsoConfigurationRepairOutput,
                crate::error::StartStudioSSOConfigurationRepairError,
                crate::input::StartStudioSsoConfigurationRepairInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the target resource for tagging operations.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ARN of the target resource for tagging operations.</p>
        pub fn resource_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(inp);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// Appends an item to `tagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        /// <p>An array of tag keys to delete.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLaunchProfile<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_launch_profile_input::Builder,
    }
    impl<C, M, R> UpdateLaunchProfile<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLaunchProfileOutput,
            smithy_http::result::SdkError<crate::error::UpdateLaunchProfileError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateLaunchProfileInputOperationOutputAlias,
                crate::output::UpdateLaunchProfileOutput,
                crate::error::UpdateLaunchProfileError,
                crate::input::UpdateLaunchProfileInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// Appends an item to `launchProfileProtocolVersions`.
        ///
        /// To override the contents of this collection use [`set_launch_profile_protocol_versions`](Self::set_launch_profile_protocol_versions).
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_versions(
            mut self,
            inp: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.launch_profile_protocol_versions(inp);
            self
        }
        pub fn set_launch_profile_protocol_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_protocol_versions(input);
            self
        }
        /// <p>The name for the launch profile.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>A configuration for a streaming session.</p>
        pub fn stream_configuration(
            mut self,
            inp: crate::model::StreamConfigurationCreate,
        ) -> Self {
            self.inner = self.inner.stream_configuration(inp);
            self
        }
        pub fn set_stream_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamConfigurationCreate>,
        ) -> Self {
            self.inner = self.inner.set_stream_configuration(input);
            self
        }
        /// Appends an item to `studioComponentIds`.
        ///
        /// To override the contents of this collection use [`set_studio_component_ids`](Self::set_studio_component_ids).
        /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
        pub fn studio_component_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_component_ids(inp);
            self
        }
        pub fn set_studio_component_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_studio_component_ids(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateLaunchProfileMember<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_launch_profile_member_input::Builder,
    }
    impl<C, M, R> UpdateLaunchProfileMember<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateLaunchProfileMemberOutput,
            smithy_http::result::SdkError<crate::error::UpdateLaunchProfileMemberError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateLaunchProfileMemberInputOperationOutputAlias,
                crate::output::UpdateLaunchProfileMemberOutput,
                crate::error::UpdateLaunchProfileMemberError,
                crate::input::UpdateLaunchProfileMemberInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.launch_profile_id(inp);
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_launch_profile_id(input);
            self
        }
        /// <p>The persona.</p>
        pub fn persona(mut self, inp: crate::model::LaunchProfilePersona) -> Self {
            self.inner = self.inner.persona(inp);
            self
        }
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePersona>,
        ) -> Self {
            self.inner = self.inner.set_persona(input);
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.principal_id(inp);
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_principal_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateStreamingImage<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_streaming_image_input::Builder,
    }
    impl<C, M, R> UpdateStreamingImage<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateStreamingImageOutput,
            smithy_http::result::SdkError<crate::error::UpdateStreamingImageError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateStreamingImageInputOperationOutputAlias,
                crate::output::UpdateStreamingImageOutput,
                crate::error::UpdateStreamingImageError,
                crate::input::UpdateStreamingImageInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The name for the streaming image.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The streaming image ID.</p>
        pub fn streaming_image_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.streaming_image_id(inp);
            self
        }
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_streaming_image_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateStudio<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_studio_input::Builder,
    }
    impl<C, M, R> UpdateStudio<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateStudioOutput,
            smithy_http::result::SdkError<crate::error::UpdateStudioError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateStudioInputOperationOutputAlias,
                crate::output::UpdateStudioOutput,
                crate::error::UpdateStudioError,
                crate::input::UpdateStudioInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.</p>
        pub fn admin_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.admin_role_arn(inp);
            self
        }
        pub fn set_admin_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_admin_role_arn(input);
            self
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>A friendly name for the studio.</p>
        pub fn display_name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.display_name(inp);
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_display_name(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// <p>The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.</p>
        pub fn user_role_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.user_role_arn(inp);
            self
        }
        pub fn set_user_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_user_role_arn(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateStudioComponent<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_studio_component_input::Builder,
    }
    impl<C, M, R> UpdateStudioComponent<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateStudioComponentOutput,
            smithy_http::result::SdkError<crate::error::UpdateStudioComponentError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateStudioComponentInputOperationOutputAlias,
                crate::output::UpdateStudioComponentOutput,
                crate::error::UpdateStudioComponentError,
                crate::input::UpdateStudioComponentInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>To make an idempotent API request using one of these actions, specify a client token in the request. You should not reuse the same client token for other API requests. If you retry a request that completed successfully using the same client token and the same parameters, the retry succeeds without performing any further actions. If you retry a successful request using the same client token, but one or more of the parameters are different, the retry fails with a ValidationException error.</p>
        pub fn client_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_token(inp);
            self
        }
        pub fn set_client_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_client_token(input);
            self
        }
        /// <p>The configuration of the studio component, based on component type.</p>
        pub fn configuration(mut self, inp: crate::model::StudioComponentConfiguration) -> Self {
            self.inner = self.inner.configuration(inp);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioComponentConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// Appends an item to `ec2SecurityGroupIds`.
        ///
        /// To override the contents of this collection use [`set_ec2_security_group_ids`](Self::set_ec2_security_group_ids).
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn ec2_security_group_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.ec2_security_group_ids(inp);
            self
        }
        pub fn set_ec2_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_ec2_security_group_ids(input);
            self
        }
        /// Appends an item to `initializationScripts`.
        ///
        /// To override the contents of this collection use [`set_initialization_scripts`](Self::set_initialization_scripts).
        /// <p>Initialization scripts for studio components.</p>
        pub fn initialization_scripts(
            mut self,
            inp: impl Into<crate::model::StudioComponentInitializationScript>,
        ) -> Self {
            self.inner = self.inner.initialization_scripts(inp);
            self
        }
        pub fn set_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::StudioComponentInitializationScript>,
            >,
        ) -> Self {
            self.inner = self.inner.set_initialization_scripts(input);
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// Appends an item to `scriptParameters`.
        ///
        /// To override the contents of this collection use [`set_script_parameters`](Self::set_script_parameters).
        /// <p>Parameters for the studio component scripts.</p>
        pub fn script_parameters(
            mut self,
            inp: impl Into<crate::model::ScriptParameterKeyValue>,
        ) -> Self {
            self.inner = self.inner.script_parameters(inp);
            self
        }
        pub fn set_script_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
        ) -> Self {
            self.inner = self.inner.set_script_parameters(input);
            self
        }
        /// <p>The studio component ID.</p>
        pub fn studio_component_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_component_id(inp);
            self
        }
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_studio_component_id(input);
            self
        }
        /// <p>The studio ID.</p>
        pub fn studio_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.studio_id(inp);
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_studio_id(input);
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn subtype(mut self, inp: crate::model::StudioComponentSubtype) -> Self {
            self.inner = self.inner.subtype(inp);
            self
        }
        pub fn set_subtype(
            mut self,
            input: std::option::Option<crate::model::StudioComponentSubtype>,
        ) -> Self {
            self.inner = self.inner.set_subtype(input);
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn r#type(mut self, inp: crate::model::StudioComponentType) -> Self {
            self.inner = self.inner.r#type(inp);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StudioComponentType>,
        ) -> Self {
            self.inner = self.inner.set_type(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::new(conn).with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let retry_config = conf.retry_config.as_ref().cloned().unwrap_or_default();
        let client = aws_hyper::Client::https().with_retry_config(retry_config.into());
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
