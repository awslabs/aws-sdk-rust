// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>A network that is used by a studioâ€™s users and workflows, including render farm, Active Directory, licensing, and file system.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioComponent {
    /// <p>The ARN of the resource.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The configuration of the studio component, based on component type.</p>
    pub configuration: std::option::Option<crate::model::StudioComponentConfiguration>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<smithy_types::Instant>,
    /// <p>The user ID of the user that created the studio component.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>A human-readable description for the studio component resource.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The EC2 security groups that control access to the studio component.</p>
    pub ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Initialization scripts for studio components.</p>
    pub initialization_scripts:
        std::option::Option<std::vec::Vec<crate::model::StudioComponentInitializationScript>>,
    /// <p>A friendly name for the studio component resource.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Parameters for the studio component scripts.</p>
    pub script_parameters:
        std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::StudioComponentState>,
    /// <p>The status code.</p>
    pub status_code: std::option::Option<crate::model::StudioComponentStatusCode>,
    /// <p>The status message for the studio component.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The specific subtype of a studio component.</p>
    pub subtype: std::option::Option<crate::model::StudioComponentSubtype>,
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The type of the studio component.</p>
    pub r#type: std::option::Option<crate::model::StudioComponentType>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<smithy_types::Instant>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub updated_by: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StudioComponent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioComponent");
        formatter.field("arn", &self.arn);
        formatter.field("configuration", &self.configuration);
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("description", &self.description);
        formatter.field("ec2_security_group_ids", &self.ec2_security_group_ids);
        formatter.field("initialization_scripts", &self.initialization_scripts);
        formatter.field("name", &self.name);
        formatter.field("script_parameters", &self.script_parameters);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("subtype", &self.subtype);
        formatter.field("tags", &self.tags);
        formatter.field("r#type", &self.r#type);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.finish()
    }
}
/// See [`StudioComponent`](crate::model::StudioComponent)
pub mod studio_component {
    /// A builder for [`StudioComponent`](crate::model::StudioComponent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) configuration: std::option::Option<crate::model::StudioComponentConfiguration>,
        pub(crate) created_at: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) initialization_scripts:
            std::option::Option<std::vec::Vec<crate::model::StudioComponentInitializationScript>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) script_parameters:
            std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
        pub(crate) state: std::option::Option<crate::model::StudioComponentState>,
        pub(crate) status_code: std::option::Option<crate::model::StudioComponentStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) subtype: std::option::Option<crate::model::StudioComponentSubtype>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) r#type: std::option::Option<crate::model::StudioComponentType>,
        pub(crate) updated_at: std::option::Option<smithy_types::Instant>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The configuration of the studio component, based on component type.</p>
        pub fn configuration(mut self, input: crate::model::StudioComponentConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioComponentConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        pub fn set_created_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the studio component.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>A human-readable description for the studio component resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn ec2_security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ec2_security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.ec2_security_group_ids = Some(v);
            self
        }
        pub fn set_ec2_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ec2_security_group_ids = input;
            self
        }
        pub fn initialization_scripts(
            mut self,
            input: impl Into<crate::model::StudioComponentInitializationScript>,
        ) -> Self {
            let mut v = self.initialization_scripts.unwrap_or_default();
            v.push(input.into());
            self.initialization_scripts = Some(v);
            self
        }
        pub fn set_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::StudioComponentInitializationScript>,
            >,
        ) -> Self {
            self.initialization_scripts = input;
            self
        }
        /// <p>A friendly name for the studio component resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        pub fn script_parameters(
            mut self,
            input: impl Into<crate::model::ScriptParameterKeyValue>,
        ) -> Self {
            let mut v = self.script_parameters.unwrap_or_default();
            v.push(input.into());
            self.script_parameters = Some(v);
            self
        }
        pub fn set_script_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
        ) -> Self {
            self.script_parameters = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StudioComponentState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StudioComponentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::StudioComponentStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StudioComponentStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the studio component.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn subtype(mut self, input: crate::model::StudioComponentSubtype) -> Self {
            self.subtype = Some(input);
            self
        }
        pub fn set_subtype(
            mut self,
            input: std::option::Option<crate::model::StudioComponentSubtype>,
        ) -> Self {
            self.subtype = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn r#type(mut self, input: crate::model::StudioComponentType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StudioComponentType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: smithy_types::Instant) -> Self {
            self.updated_at = Some(input);
            self
        }
        pub fn set_updated_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioComponent`](crate::model::StudioComponent)
        pub fn build(self) -> crate::model::StudioComponent {
            crate::model::StudioComponent {
                arn: self.arn,
                configuration: self.configuration,
                created_at: self.created_at,
                created_by: self.created_by,
                description: self.description,
                ec2_security_group_ids: self.ec2_security_group_ids,
                initialization_scripts: self.initialization_scripts,
                name: self.name,
                script_parameters: self.script_parameters,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                studio_component_id: self.studio_component_id,
                subtype: self.subtype,
                tags: self.tags,
                r#type: self.r#type,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
            }
        }
    }
}
impl StudioComponent {
    /// Creates a new builder-style object to manufacture [`StudioComponent`](crate::model::StudioComponent)
    pub fn builder() -> crate::model::studio_component::Builder {
        crate::model::studio_component::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentType {
    ActiveDirectory,
    ComputeFarm,
    Custom,
    LicenseService,
    SharedFileSystem,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioComponentType {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_DIRECTORY" => StudioComponentType::ActiveDirectory,
            "COMPUTE_FARM" => StudioComponentType::ComputeFarm,
            "CUSTOM" => StudioComponentType::Custom,
            "LICENSE_SERVICE" => StudioComponentType::LicenseService,
            "SHARED_FILE_SYSTEM" => StudioComponentType::SharedFileSystem,
            other => StudioComponentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioComponentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentType::from(s))
    }
}
impl StudioComponentType {
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentType::ActiveDirectory => "ACTIVE_DIRECTORY",
            StudioComponentType::ComputeFarm => "COMPUTE_FARM",
            StudioComponentType::Custom => "CUSTOM",
            StudioComponentType::LicenseService => "LICENSE_SERVICE",
            StudioComponentType::SharedFileSystem => "SHARED_FILE_SYSTEM",
            StudioComponentType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE_DIRECTORY",
            "COMPUTE_FARM",
            "CUSTOM",
            "LICENSE_SERVICE",
            "SHARED_FILE_SYSTEM",
        ]
    }
}
impl AsRef<str> for StudioComponentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentSubtype {
    AmazonFsxForLustre,
    AmazonFsxForWindows,
    AwsManagedMicrosoftAd,
    Custom,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioComponentSubtype {
    fn from(s: &str) -> Self {
        match s {
            "AMAZON_FSX_FOR_LUSTRE" => StudioComponentSubtype::AmazonFsxForLustre,
            "AMAZON_FSX_FOR_WINDOWS" => StudioComponentSubtype::AmazonFsxForWindows,
            "AWS_MANAGED_MICROSOFT_AD" => StudioComponentSubtype::AwsManagedMicrosoftAd,
            "CUSTOM" => StudioComponentSubtype::Custom,
            other => StudioComponentSubtype::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioComponentSubtype {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentSubtype::from(s))
    }
}
impl StudioComponentSubtype {
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentSubtype::AmazonFsxForLustre => "AMAZON_FSX_FOR_LUSTRE",
            StudioComponentSubtype::AmazonFsxForWindows => "AMAZON_FSX_FOR_WINDOWS",
            StudioComponentSubtype::AwsManagedMicrosoftAd => "AWS_MANAGED_MICROSOFT_AD",
            StudioComponentSubtype::Custom => "CUSTOM",
            StudioComponentSubtype::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AMAZON_FSX_FOR_LUSTRE",
            "AMAZON_FSX_FOR_WINDOWS",
            "AWS_MANAGED_MICROSOFT_AD",
            "CUSTOM",
        ]
    }
}
impl AsRef<str> for StudioComponentSubtype {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The current status of the studio component resource.</p> <p>When the resource is in the 'READY' state, the status code signals what the last mutation made to the resource was.</p> <p>When the resource is in a CREATE_FAILED/UPDATE_FAILED/DELETE_FAILED state, the status code signals what went wrong and why the mutation failed.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentStatusCode {
    ActiveDirectoryAlreadyExists,
    EncryptionKeyAccessDenied,
    EncryptionKeyNotFound,
    InternalError,
    StudioComponentCreated,
    StudioComponentCreateInProgress,
    StudioComponentDeleted,
    StudioComponentDeleteInProgress,
    StudioComponentUpdated,
    StudioComponentUpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioComponentStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_DIRECTORY_ALREADY_EXISTS" => {
                StudioComponentStatusCode::ActiveDirectoryAlreadyExists
            }
            "ENCRYPTION_KEY_ACCESS_DENIED" => StudioComponentStatusCode::EncryptionKeyAccessDenied,
            "ENCRYPTION_KEY_NOT_FOUND" => StudioComponentStatusCode::EncryptionKeyNotFound,
            "INTERNAL_ERROR" => StudioComponentStatusCode::InternalError,
            "STUDIO_COMPONENT_CREATED" => StudioComponentStatusCode::StudioComponentCreated,
            "STUDIO_COMPONENT_CREATE_IN_PROGRESS" => {
                StudioComponentStatusCode::StudioComponentCreateInProgress
            }
            "STUDIO_COMPONENT_DELETED" => StudioComponentStatusCode::StudioComponentDeleted,
            "STUDIO_COMPONENT_DELETE_IN_PROGRESS" => {
                StudioComponentStatusCode::StudioComponentDeleteInProgress
            }
            "STUDIO_COMPONENT_UPDATED" => StudioComponentStatusCode::StudioComponentUpdated,
            "STUDIO_COMPONENT_UPDATE_IN_PROGRESS" => {
                StudioComponentStatusCode::StudioComponentUpdateInProgress
            }
            other => StudioComponentStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioComponentStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentStatusCode::from(s))
    }
}
impl StudioComponentStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentStatusCode::ActiveDirectoryAlreadyExists => {
                "ACTIVE_DIRECTORY_ALREADY_EXISTS"
            }
            StudioComponentStatusCode::EncryptionKeyAccessDenied => "ENCRYPTION_KEY_ACCESS_DENIED",
            StudioComponentStatusCode::EncryptionKeyNotFound => "ENCRYPTION_KEY_NOT_FOUND",
            StudioComponentStatusCode::InternalError => "INTERNAL_ERROR",
            StudioComponentStatusCode::StudioComponentCreated => "STUDIO_COMPONENT_CREATED",
            StudioComponentStatusCode::StudioComponentCreateInProgress => {
                "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
            }
            StudioComponentStatusCode::StudioComponentDeleted => "STUDIO_COMPONENT_DELETED",
            StudioComponentStatusCode::StudioComponentDeleteInProgress => {
                "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
            }
            StudioComponentStatusCode::StudioComponentUpdated => "STUDIO_COMPONENT_UPDATED",
            StudioComponentStatusCode::StudioComponentUpdateInProgress => {
                "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
            }
            StudioComponentStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE_DIRECTORY_ALREADY_EXISTS",
            "ENCRYPTION_KEY_ACCESS_DENIED",
            "ENCRYPTION_KEY_NOT_FOUND",
            "INTERNAL_ERROR",
            "STUDIO_COMPONENT_CREATED",
            "STUDIO_COMPONENT_CREATE_IN_PROGRESS",
            "STUDIO_COMPONENT_DELETED",
            "STUDIO_COMPONENT_DELETE_IN_PROGRESS",
            "STUDIO_COMPONENT_UPDATED",
            "STUDIO_COMPONENT_UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StudioComponentStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The current state of the studio component resource.</p> <p>While a studio component is being created, modified, or deleted, its state will equal "CREATE_IN_PROGRESS", "UPDATE_IN_PROGRESS", or "DELETE_IN_PROGRESS"</p> <p>These are called 'transition states'.</p> <p>No modifications may be made to the studio component while it is in a transition state.</p> <p>If creation of the resource fails, the state will change to `CREATE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why creation failed. The resource in this state will automatically be deleted from your account after a period of time.</p> <p>If updating the resource fails, the state will change to `UPDATE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked.</p> <p>If deleting the resource fails, the state will change to `DELETE_FAILED`. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked. After the resource is deleted successfully, it will change to the "DELETED" state. The resource will no longer count against service quotas and cannot be used or acted upon any futher. It will be removed from your account after a period of time.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentState {
    CreateFailed,
    CreateInProgress,
    Deleted,
    DeleteFailed,
    DeleteInProgress,
    Ready,
    UpdateFailed,
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioComponentState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StudioComponentState::CreateFailed,
            "CREATE_IN_PROGRESS" => StudioComponentState::CreateInProgress,
            "DELETED" => StudioComponentState::Deleted,
            "DELETE_FAILED" => StudioComponentState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StudioComponentState::DeleteInProgress,
            "READY" => StudioComponentState::Ready,
            "UPDATE_FAILED" => StudioComponentState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => StudioComponentState::UpdateInProgress,
            other => StudioComponentState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioComponentState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentState::from(s))
    }
}
impl StudioComponentState {
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentState::CreateFailed => "CREATE_FAILED",
            StudioComponentState::CreateInProgress => "CREATE_IN_PROGRESS",
            StudioComponentState::Deleted => "DELETED",
            StudioComponentState::DeleteFailed => "DELETE_FAILED",
            StudioComponentState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StudioComponentState::Ready => "READY",
            StudioComponentState::UpdateFailed => "UPDATE_FAILED",
            StudioComponentState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            StudioComponentState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StudioComponentState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A parameter for a studio component script, in the form of a key:value pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScriptParameterKeyValue {
    /// <p>A script parameter key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>A script parameter value.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ScriptParameterKeyValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScriptParameterKeyValue");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue)
pub mod script_parameter_key_value {
    /// A builder for [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A script parameter key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>A script parameter value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue)
        pub fn build(self) -> crate::model::ScriptParameterKeyValue {
            crate::model::ScriptParameterKeyValue {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl ScriptParameterKeyValue {
    /// Creates a new builder-style object to manufacture [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue)
    pub fn builder() -> crate::model::script_parameter_key_value::Builder {
        crate::model::script_parameter_key_value::Builder::default()
    }
}

/// <p>Initialization scripts for studio components.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioComponentInitializationScript {
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub launch_profile_protocol_version: std::option::Option<std::string::String>,
    /// <p>The platform of the initialization script, either WINDOWS or LINUX.</p>
    pub platform: std::option::Option<crate::model::LaunchProfilePlatform>,
    /// <p>The method to use when running the initialization script.</p>
    pub run_context:
        std::option::Option<crate::model::StudioComponentInitializationScriptRunContext>,
    /// <p>The initialization script.</p>
    pub script: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StudioComponentInitializationScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioComponentInitializationScript");
        formatter.field(
            "launch_profile_protocol_version",
            &self.launch_profile_protocol_version,
        );
        formatter.field("platform", &self.platform);
        formatter.field("run_context", &self.run_context);
        formatter.field("script", &self.script);
        formatter.finish()
    }
}
/// See [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript)
pub mod studio_component_initialization_script {
    /// A builder for [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_profile_protocol_version: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<crate::model::LaunchProfilePlatform>,
        pub(crate) run_context:
            std::option::Option<crate::model::StudioComponentInitializationScriptRunContext>,
        pub(crate) script: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_version(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = Some(input.into());
            self
        }
        pub fn set_launch_profile_protocol_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = input;
            self
        }
        /// <p>The platform of the initialization script, either WINDOWS or LINUX.</p>
        pub fn platform(mut self, input: crate::model::LaunchProfilePlatform) -> Self {
            self.platform = Some(input);
            self
        }
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePlatform>,
        ) -> Self {
            self.platform = input;
            self
        }
        /// <p>The method to use when running the initialization script.</p>
        pub fn run_context(
            mut self,
            input: crate::model::StudioComponentInitializationScriptRunContext,
        ) -> Self {
            self.run_context = Some(input);
            self
        }
        pub fn set_run_context(
            mut self,
            input: std::option::Option<crate::model::StudioComponentInitializationScriptRunContext>,
        ) -> Self {
            self.run_context = input;
            self
        }
        /// <p>The initialization script.</p>
        pub fn script(mut self, input: impl Into<std::string::String>) -> Self {
            self.script = Some(input.into());
            self
        }
        pub fn set_script(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.script = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript)
        pub fn build(self) -> crate::model::StudioComponentInitializationScript {
            crate::model::StudioComponentInitializationScript {
                launch_profile_protocol_version: self.launch_profile_protocol_version,
                platform: self.platform,
                run_context: self.run_context,
                script: self.script,
            }
        }
    }
}
impl StudioComponentInitializationScript {
    /// Creates a new builder-style object to manufacture [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript)
    pub fn builder() -> crate::model::studio_component_initialization_script::Builder {
        crate::model::studio_component_initialization_script::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentInitializationScriptRunContext {
    SystemInitialization,
    UserInitialization,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioComponentInitializationScriptRunContext {
    fn from(s: &str) -> Self {
        match s {
            "SYSTEM_INITIALIZATION" => {
                StudioComponentInitializationScriptRunContext::SystemInitialization
            }
            "USER_INITIALIZATION" => {
                StudioComponentInitializationScriptRunContext::UserInitialization
            }
            other => StudioComponentInitializationScriptRunContext::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioComponentInitializationScriptRunContext {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentInitializationScriptRunContext::from(s))
    }
}
impl StudioComponentInitializationScriptRunContext {
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentInitializationScriptRunContext::SystemInitialization => {
                "SYSTEM_INITIALIZATION"
            }
            StudioComponentInitializationScriptRunContext::UserInitialization => {
                "USER_INITIALIZATION"
            }
            StudioComponentInitializationScriptRunContext::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["SYSTEM_INITIALIZATION", "USER_INITIALIZATION"]
    }
}
impl AsRef<str> for StudioComponentInitializationScriptRunContext {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfilePlatform {
    Linux,
    Windows,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfilePlatform {
    fn from(s: &str) -> Self {
        match s {
            "LINUX" => LaunchProfilePlatform::Linux,
            "WINDOWS" => LaunchProfilePlatform::Windows,
            other => LaunchProfilePlatform::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchProfilePlatform {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfilePlatform::from(s))
    }
}
impl LaunchProfilePlatform {
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfilePlatform::Linux => "LINUX",
            LaunchProfilePlatform::Windows => "WINDOWS",
            LaunchProfilePlatform::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["LINUX", "WINDOWS"]
    }
}
impl AsRef<str> for LaunchProfilePlatform {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of the studio component, based on component type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioComponentConfiguration {
    /// <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.</p>
    pub active_directory_configuration:
        std::option::Option<crate::model::ActiveDirectoryConfiguration>,
    /// <p>The configuration for a render farm that is associated with a studio resource.</p>
    pub compute_farm_configuration: std::option::Option<crate::model::ComputeFarmConfiguration>,
    /// <p>The configuration for a license service that is associated with a studio resource.</p>
    pub license_service_configuration:
        std::option::Option<crate::model::LicenseServiceConfiguration>,
    /// <p>The configuration for a shared file storage system that is associated with a studio resource.</p>
    pub shared_file_system_configuration:
        std::option::Option<crate::model::SharedFileSystemConfiguration>,
}
impl std::fmt::Debug for StudioComponentConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioComponentConfiguration");
        formatter.field(
            "active_directory_configuration",
            &self.active_directory_configuration,
        );
        formatter.field(
            "compute_farm_configuration",
            &self.compute_farm_configuration,
        );
        formatter.field(
            "license_service_configuration",
            &self.license_service_configuration,
        );
        formatter.field(
            "shared_file_system_configuration",
            &self.shared_file_system_configuration,
        );
        formatter.finish()
    }
}
/// See [`StudioComponentConfiguration`](crate::model::StudioComponentConfiguration)
pub mod studio_component_configuration {
    /// A builder for [`StudioComponentConfiguration`](crate::model::StudioComponentConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_directory_configuration:
            std::option::Option<crate::model::ActiveDirectoryConfiguration>,
        pub(crate) compute_farm_configuration:
            std::option::Option<crate::model::ComputeFarmConfiguration>,
        pub(crate) license_service_configuration:
            std::option::Option<crate::model::LicenseServiceConfiguration>,
        pub(crate) shared_file_system_configuration:
            std::option::Option<crate::model::SharedFileSystemConfiguration>,
    }
    impl Builder {
        /// <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.</p>
        pub fn active_directory_configuration(
            mut self,
            input: crate::model::ActiveDirectoryConfiguration,
        ) -> Self {
            self.active_directory_configuration = Some(input);
            self
        }
        pub fn set_active_directory_configuration(
            mut self,
            input: std::option::Option<crate::model::ActiveDirectoryConfiguration>,
        ) -> Self {
            self.active_directory_configuration = input;
            self
        }
        /// <p>The configuration for a render farm that is associated with a studio resource.</p>
        pub fn compute_farm_configuration(
            mut self,
            input: crate::model::ComputeFarmConfiguration,
        ) -> Self {
            self.compute_farm_configuration = Some(input);
            self
        }
        pub fn set_compute_farm_configuration(
            mut self,
            input: std::option::Option<crate::model::ComputeFarmConfiguration>,
        ) -> Self {
            self.compute_farm_configuration = input;
            self
        }
        /// <p>The configuration for a license service that is associated with a studio resource.</p>
        pub fn license_service_configuration(
            mut self,
            input: crate::model::LicenseServiceConfiguration,
        ) -> Self {
            self.license_service_configuration = Some(input);
            self
        }
        pub fn set_license_service_configuration(
            mut self,
            input: std::option::Option<crate::model::LicenseServiceConfiguration>,
        ) -> Self {
            self.license_service_configuration = input;
            self
        }
        /// <p>The configuration for a shared file storage system that is associated with a studio resource.</p>
        pub fn shared_file_system_configuration(
            mut self,
            input: crate::model::SharedFileSystemConfiguration,
        ) -> Self {
            self.shared_file_system_configuration = Some(input);
            self
        }
        pub fn set_shared_file_system_configuration(
            mut self,
            input: std::option::Option<crate::model::SharedFileSystemConfiguration>,
        ) -> Self {
            self.shared_file_system_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioComponentConfiguration`](crate::model::StudioComponentConfiguration)
        pub fn build(self) -> crate::model::StudioComponentConfiguration {
            crate::model::StudioComponentConfiguration {
                active_directory_configuration: self.active_directory_configuration,
                compute_farm_configuration: self.compute_farm_configuration,
                license_service_configuration: self.license_service_configuration,
                shared_file_system_configuration: self.shared_file_system_configuration,
            }
        }
    }
}
impl StudioComponentConfiguration {
    /// Creates a new builder-style object to manufacture [`StudioComponentConfiguration`](crate::model::StudioComponentConfiguration)
    pub fn builder() -> crate::model::studio_component_configuration::Builder {
        crate::model::studio_component_configuration::Builder::default()
    }
}

/// <p>The configuration for a shared file storage system that is associated with a studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SharedFileSystemConfiguration {
    /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
    pub endpoint: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a file system.</p>
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
    pub linux_mount_point: std::option::Option<std::string::String>,
    /// <p>The name of the file share.</p>
    pub share_name: std::option::Option<std::string::String>,
    /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
    pub windows_mount_drive: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SharedFileSystemConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SharedFileSystemConfiguration");
        formatter.field("endpoint", &self.endpoint);
        formatter.field("file_system_id", &self.file_system_id);
        formatter.field("linux_mount_point", &self.linux_mount_point);
        formatter.field("share_name", &self.share_name);
        formatter.field("windows_mount_drive", &self.windows_mount_drive);
        formatter.finish()
    }
}
/// See [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration)
pub mod shared_file_system_configuration {
    /// A builder for [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint: std::option::Option<std::string::String>,
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) linux_mount_point: std::option::Option<std::string::String>,
        pub(crate) share_name: std::option::Option<std::string::String>,
        pub(crate) windows_mount_drive: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>The unique identifier for a file system.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
        pub fn linux_mount_point(mut self, input: impl Into<std::string::String>) -> Self {
            self.linux_mount_point = Some(input.into());
            self
        }
        pub fn set_linux_mount_point(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.linux_mount_point = input;
            self
        }
        /// <p>The name of the file share.</p>
        pub fn share_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_name = Some(input.into());
            self
        }
        pub fn set_share_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.share_name = input;
            self
        }
        /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
        pub fn windows_mount_drive(mut self, input: impl Into<std::string::String>) -> Self {
            self.windows_mount_drive = Some(input.into());
            self
        }
        pub fn set_windows_mount_drive(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.windows_mount_drive = input;
            self
        }
        /// Consumes the builder and constructs a [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration)
        pub fn build(self) -> crate::model::SharedFileSystemConfiguration {
            crate::model::SharedFileSystemConfiguration {
                endpoint: self.endpoint,
                file_system_id: self.file_system_id,
                linux_mount_point: self.linux_mount_point,
                share_name: self.share_name,
                windows_mount_drive: self.windows_mount_drive,
            }
        }
    }
}
impl SharedFileSystemConfiguration {
    /// Creates a new builder-style object to manufacture [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration)
    pub fn builder() -> crate::model::shared_file_system_configuration::Builder {
        crate::model::shared_file_system_configuration::Builder::default()
    }
}

/// <p>The configuration for a license service that is associated with a studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LicenseServiceConfiguration {
    /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
    pub endpoint: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LicenseServiceConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LicenseServiceConfiguration");
        formatter.field("endpoint", &self.endpoint);
        formatter.finish()
    }
}
/// See [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration)
pub mod license_service_configuration {
    /// A builder for [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration)
        pub fn build(self) -> crate::model::LicenseServiceConfiguration {
            crate::model::LicenseServiceConfiguration {
                endpoint: self.endpoint,
            }
        }
    }
}
impl LicenseServiceConfiguration {
    /// Creates a new builder-style object to manufacture [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration)
    pub fn builder() -> crate::model::license_service_configuration::Builder {
        crate::model::license_service_configuration::Builder::default()
    }
}

/// <p>The configuration for a render farm that is associated with a studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ComputeFarmConfiguration {
    /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
    pub active_directory_user: std::option::Option<std::string::String>,
    /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
    pub endpoint: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ComputeFarmConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComputeFarmConfiguration");
        formatter.field("active_directory_user", &self.active_directory_user);
        formatter.field("endpoint", &self.endpoint);
        formatter.finish()
    }
}
/// See [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration)
pub mod compute_farm_configuration {
    /// A builder for [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_directory_user: std::option::Option<std::string::String>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
        pub fn active_directory_user(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_directory_user = Some(input.into());
            self
        }
        pub fn set_active_directory_user(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_directory_user = input;
            self
        }
        /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration)
        pub fn build(self) -> crate::model::ComputeFarmConfiguration {
            crate::model::ComputeFarmConfiguration {
                active_directory_user: self.active_directory_user,
                endpoint: self.endpoint,
            }
        }
    }
}
impl ComputeFarmConfiguration {
    /// Creates a new builder-style object to manufacture [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration)
    pub fn builder() -> crate::model::compute_farm_configuration::Builder {
        crate::model::compute_farm_configuration::Builder::default()
    }
}

/// <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActiveDirectoryConfiguration {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    pub computer_attributes:
        std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
    /// <p>The directory ID of the AWS Directory Service for Microsoft AD to access using this studio component.</p>
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
    pub organizational_unit_distinguished_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ActiveDirectoryConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActiveDirectoryConfiguration");
        formatter.field("computer_attributes", &self.computer_attributes);
        formatter.field("directory_id", &self.directory_id);
        formatter.field(
            "organizational_unit_distinguished_name",
            &self.organizational_unit_distinguished_name,
        );
        formatter.finish()
    }
}
/// See [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration)
pub mod active_directory_configuration {
    /// A builder for [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computer_attributes:
            std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) organizational_unit_distinguished_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn computer_attributes(
            mut self,
            input: impl Into<crate::model::ActiveDirectoryComputerAttribute>,
        ) -> Self {
            let mut v = self.computer_attributes.unwrap_or_default();
            v.push(input.into());
            self.computer_attributes = Some(v);
            self
        }
        pub fn set_computer_attributes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>,
            >,
        ) -> Self {
            self.computer_attributes = input;
            self
        }
        /// <p>The directory ID of the AWS Directory Service for Microsoft AD to access using this studio component.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
        pub fn organizational_unit_distinguished_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = Some(input.into());
            self
        }
        pub fn set_organizational_unit_distinguished_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration)
        pub fn build(self) -> crate::model::ActiveDirectoryConfiguration {
            crate::model::ActiveDirectoryConfiguration {
                computer_attributes: self.computer_attributes,
                directory_id: self.directory_id,
                organizational_unit_distinguished_name: self.organizational_unit_distinguished_name,
            }
        }
    }
}
impl ActiveDirectoryConfiguration {
    /// Creates a new builder-style object to manufacture [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration)
    pub fn builder() -> crate::model::active_directory_configuration::Builder {
        crate::model::active_directory_configuration::Builder::default()
    }
}

/// <p>An LDAP attribute of an Active Directory computer account, in the form of a name:value pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActiveDirectoryComputerAttribute {
    /// <p>The name for the LDAP attribute.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value for the LDAP attribute.</p>
    pub value: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ActiveDirectoryComputerAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActiveDirectoryComputerAttribute");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute)
pub mod active_directory_computer_attribute {
    /// A builder for [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name for the LDAP attribute.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value for the LDAP attribute.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute)
        pub fn build(self) -> crate::model::ActiveDirectoryComputerAttribute {
            crate::model::ActiveDirectoryComputerAttribute {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl ActiveDirectoryComputerAttribute {
    /// Creates a new builder-style object to manufacture [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute)
    pub fn builder() -> crate::model::active_directory_computer_attribute::Builder {
        crate::model::active_directory_computer_attribute::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Studio {
    /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
    pub admin_role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<smithy_types::Instant>,
    /// <p>A friendly name for the studio.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The AWS region where the studio resource is located.</p>
    pub home_region: std::option::Option<std::string::String>,
    /// <p>The AWS SSO application client ID used to integrate with AWS SSO to enable AWS SSO users to log in to Nimble portal.</p>
    pub sso_client_id: std::option::Option<std::string::String>,
    /// <p>The current state of the studio resource.</p>
    pub state: std::option::Option<crate::model::StudioState>,
    /// <p>Status codes that provide additional detail on the studio state.</p>
    pub status_code: std::option::Option<crate::model::StudioStatusCode>,
    /// <p>Additional detail on the studio state.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Configuration of the encryption method that is used for the studio.</p>
    pub studio_encryption_configuration:
        std::option::Option<crate::model::StudioEncryptionConfiguration>,
    /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
    pub studio_id: std::option::Option<std::string::String>,
    /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
    pub studio_name: std::option::Option<std::string::String>,
    /// <p>The address of the web page for the studio.</p>
    pub studio_url: std::option::Option<std::string::String>,
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<smithy_types::Instant>,
    /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
    pub user_role_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for Studio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Studio");
        formatter.field("admin_role_arn", &self.admin_role_arn);
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("display_name", &self.display_name);
        formatter.field("home_region", &self.home_region);
        formatter.field("sso_client_id", &self.sso_client_id);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field(
            "studio_encryption_configuration",
            &self.studio_encryption_configuration,
        );
        formatter.field("studio_id", &self.studio_id);
        formatter.field("studio_name", &self.studio_name);
        formatter.field("studio_url", &self.studio_url);
        formatter.field("tags", &self.tags);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("user_role_arn", &self.user_role_arn);
        formatter.finish()
    }
}
/// See [`Studio`](crate::model::Studio)
pub mod studio {
    /// A builder for [`Studio`](crate::model::Studio)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) admin_role_arn: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<smithy_types::Instant>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) home_region: std::option::Option<std::string::String>,
        pub(crate) sso_client_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StudioState>,
        pub(crate) status_code: std::option::Option<crate::model::StudioStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) studio_encryption_configuration:
            std::option::Option<crate::model::StudioEncryptionConfiguration>,
        pub(crate) studio_id: std::option::Option<std::string::String>,
        pub(crate) studio_name: std::option::Option<std::string::String>,
        pub(crate) studio_url: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) updated_at: std::option::Option<smithy_types::Instant>,
        pub(crate) user_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
        pub fn admin_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_role_arn = Some(input.into());
            self
        }
        pub fn set_admin_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.admin_role_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        pub fn set_created_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>A friendly name for the studio.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The AWS region where the studio resource is located.</p>
        pub fn home_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.home_region = Some(input.into());
            self
        }
        pub fn set_home_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.home_region = input;
            self
        }
        /// <p>The AWS SSO application client ID used to integrate with AWS SSO to enable AWS SSO users to log in to Nimble portal.</p>
        pub fn sso_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sso_client_id = Some(input.into());
            self
        }
        pub fn set_sso_client_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sso_client_id = input;
            self
        }
        /// <p>The current state of the studio resource.</p>
        pub fn state(mut self, input: crate::model::StudioState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(mut self, input: std::option::Option<crate::model::StudioState>) -> Self {
            self.state = input;
            self
        }
        /// <p>Status codes that provide additional detail on the studio state.</p>
        pub fn status_code(mut self, input: crate::model::StudioStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StudioStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>Additional detail on the studio state.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>Configuration of the encryption method that is used for the studio.</p>
        pub fn studio_encryption_configuration(
            mut self,
            input: crate::model::StudioEncryptionConfiguration,
        ) -> Self {
            self.studio_encryption_configuration = Some(input);
            self
        }
        pub fn set_studio_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioEncryptionConfiguration>,
        ) -> Self {
            self.studio_encryption_configuration = input;
            self
        }
        /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_id = Some(input.into());
            self
        }
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.studio_id = input;
            self
        }
        /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
        pub fn studio_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_name = Some(input.into());
            self
        }
        pub fn set_studio_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.studio_name = input;
            self
        }
        /// <p>The address of the web page for the studio.</p>
        pub fn studio_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_url = Some(input.into());
            self
        }
        pub fn set_studio_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.studio_url = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: smithy_types::Instant) -> Self {
            self.updated_at = Some(input);
            self
        }
        pub fn set_updated_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
        pub fn user_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_role_arn = Some(input.into());
            self
        }
        pub fn set_user_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Studio`](crate::model::Studio)
        pub fn build(self) -> crate::model::Studio {
            crate::model::Studio {
                admin_role_arn: self.admin_role_arn,
                arn: self.arn,
                created_at: self.created_at,
                display_name: self.display_name,
                home_region: self.home_region,
                sso_client_id: self.sso_client_id,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                studio_encryption_configuration: self.studio_encryption_configuration,
                studio_id: self.studio_id,
                studio_name: self.studio_name,
                studio_url: self.studio_url,
                tags: self.tags,
                updated_at: self.updated_at,
                user_role_arn: self.user_role_arn,
            }
        }
    }
}
impl Studio {
    /// Creates a new builder-style object to manufacture [`Studio`](crate::model::Studio)
    pub fn builder() -> crate::model::studio::Builder {
        crate::model::studio::Builder::default()
    }
}

/// <p>Configuration of the encryption method that is used for the studio.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioEncryptionConfiguration {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    pub key_arn: std::option::Option<std::string::String>,
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    pub key_type: std::option::Option<crate::model::StudioEncryptionConfigurationKeyType>,
}
impl std::fmt::Debug for StudioEncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioEncryptionConfiguration");
        formatter.field("key_arn", &self.key_arn);
        formatter.field("key_type", &self.key_type);
        formatter.finish()
    }
}
/// See [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration)
pub mod studio_encryption_configuration {
    /// A builder for [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_arn: std::option::Option<std::string::String>,
        pub(crate) key_type:
            std::option::Option<crate::model::StudioEncryptionConfigurationKeyType>,
    }
    impl Builder {
        /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        pub fn key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_arn = Some(input.into());
            self
        }
        pub fn set_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_arn = input;
            self
        }
        /// <p>The type of KMS key that is used to encrypt studio data.</p>
        pub fn key_type(
            mut self,
            input: crate::model::StudioEncryptionConfigurationKeyType,
        ) -> Self {
            self.key_type = Some(input);
            self
        }
        pub fn set_key_type(
            mut self,
            input: std::option::Option<crate::model::StudioEncryptionConfigurationKeyType>,
        ) -> Self {
            self.key_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration)
        pub fn build(self) -> crate::model::StudioEncryptionConfiguration {
            crate::model::StudioEncryptionConfiguration {
                key_arn: self.key_arn,
                key_type: self.key_type,
            }
        }
    }
}
impl StudioEncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration)
    pub fn builder() -> crate::model::studio_encryption_configuration::Builder {
        crate::model::studio_encryption_configuration::Builder::default()
    }
}

/// <p>The type of KMS key that is used to encrypt studio data.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioEncryptionConfigurationKeyType {
    AwsOwnedKey,
    CustomerManagedKey,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioEncryptionConfigurationKeyType {
    fn from(s: &str) -> Self {
        match s {
            "AWS_OWNED_KEY" => StudioEncryptionConfigurationKeyType::AwsOwnedKey,
            "CUSTOMER_MANAGED_KEY" => StudioEncryptionConfigurationKeyType::CustomerManagedKey,
            other => StudioEncryptionConfigurationKeyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioEncryptionConfigurationKeyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioEncryptionConfigurationKeyType::from(s))
    }
}
impl StudioEncryptionConfigurationKeyType {
    pub fn as_str(&self) -> &str {
        match self {
            StudioEncryptionConfigurationKeyType::AwsOwnedKey => "AWS_OWNED_KEY",
            StudioEncryptionConfigurationKeyType::CustomerManagedKey => "CUSTOMER_MANAGED_KEY",
            StudioEncryptionConfigurationKeyType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["AWS_OWNED_KEY", "CUSTOMER_MANAGED_KEY"]
    }
}
impl AsRef<str> for StudioEncryptionConfigurationKeyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The status code.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioStatusCode {
    AwsSsoAccessDenied,
    AwsSsoConfigurationRepaired,
    AwsSsoConfigurationRepairInProgress,
    AwsSsoNotEnabled,
    EncryptionKeyAccessDenied,
    EncryptionKeyNotFound,
    InternalError,
    RoleCouldNotBeAssumed,
    RoleNotOwnedByStudioOwner,
    StudioCreated,
    StudioCreateInProgress,
    StudioDeleted,
    StudioDeleteInProgress,
    StudioUpdated,
    StudioUpdateInProgress,
    StudioWithLaunchProfilesNotDeleted,
    StudioWithStreamingImagesNotDeleted,
    StudioWithStudioComponentsNotDeleted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "AWS_SSO_ACCESS_DENIED" => StudioStatusCode::AwsSsoAccessDenied,
            "AWS_SSO_CONFIGURATION_REPAIRED" => StudioStatusCode::AwsSsoConfigurationRepaired,
            "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS" => {
                StudioStatusCode::AwsSsoConfigurationRepairInProgress
            }
            "AWS_SSO_NOT_ENABLED" => StudioStatusCode::AwsSsoNotEnabled,
            "ENCRYPTION_KEY_ACCESS_DENIED" => StudioStatusCode::EncryptionKeyAccessDenied,
            "ENCRYPTION_KEY_NOT_FOUND" => StudioStatusCode::EncryptionKeyNotFound,
            "INTERNAL_ERROR" => StudioStatusCode::InternalError,
            "ROLE_COULD_NOT_BE_ASSUMED" => StudioStatusCode::RoleCouldNotBeAssumed,
            "ROLE_NOT_OWNED_BY_STUDIO_OWNER" => StudioStatusCode::RoleNotOwnedByStudioOwner,
            "STUDIO_CREATED" => StudioStatusCode::StudioCreated,
            "STUDIO_CREATE_IN_PROGRESS" => StudioStatusCode::StudioCreateInProgress,
            "STUDIO_DELETED" => StudioStatusCode::StudioDeleted,
            "STUDIO_DELETE_IN_PROGRESS" => StudioStatusCode::StudioDeleteInProgress,
            "STUDIO_UPDATED" => StudioStatusCode::StudioUpdated,
            "STUDIO_UPDATE_IN_PROGRESS" => StudioStatusCode::StudioUpdateInProgress,
            "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED" => {
                StudioStatusCode::StudioWithLaunchProfilesNotDeleted
            }
            "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED" => {
                StudioStatusCode::StudioWithStreamingImagesNotDeleted
            }
            "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED" => {
                StudioStatusCode::StudioWithStudioComponentsNotDeleted
            }
            other => StudioStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioStatusCode::from(s))
    }
}
impl StudioStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            StudioStatusCode::AwsSsoAccessDenied => "AWS_SSO_ACCESS_DENIED",
            StudioStatusCode::AwsSsoConfigurationRepaired => "AWS_SSO_CONFIGURATION_REPAIRED",
            StudioStatusCode::AwsSsoConfigurationRepairInProgress => {
                "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
            }
            StudioStatusCode::AwsSsoNotEnabled => "AWS_SSO_NOT_ENABLED",
            StudioStatusCode::EncryptionKeyAccessDenied => "ENCRYPTION_KEY_ACCESS_DENIED",
            StudioStatusCode::EncryptionKeyNotFound => "ENCRYPTION_KEY_NOT_FOUND",
            StudioStatusCode::InternalError => "INTERNAL_ERROR",
            StudioStatusCode::RoleCouldNotBeAssumed => "ROLE_COULD_NOT_BE_ASSUMED",
            StudioStatusCode::RoleNotOwnedByStudioOwner => "ROLE_NOT_OWNED_BY_STUDIO_OWNER",
            StudioStatusCode::StudioCreated => "STUDIO_CREATED",
            StudioStatusCode::StudioCreateInProgress => "STUDIO_CREATE_IN_PROGRESS",
            StudioStatusCode::StudioDeleted => "STUDIO_DELETED",
            StudioStatusCode::StudioDeleteInProgress => "STUDIO_DELETE_IN_PROGRESS",
            StudioStatusCode::StudioUpdated => "STUDIO_UPDATED",
            StudioStatusCode::StudioUpdateInProgress => "STUDIO_UPDATE_IN_PROGRESS",
            StudioStatusCode::StudioWithLaunchProfilesNotDeleted => {
                "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
            }
            StudioStatusCode::StudioWithStreamingImagesNotDeleted => {
                "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
            }
            StudioStatusCode::StudioWithStudioComponentsNotDeleted => {
                "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
            }
            StudioStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "AWS_SSO_ACCESS_DENIED",
            "AWS_SSO_CONFIGURATION_REPAIRED",
            "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS",
            "AWS_SSO_NOT_ENABLED",
            "ENCRYPTION_KEY_ACCESS_DENIED",
            "ENCRYPTION_KEY_NOT_FOUND",
            "INTERNAL_ERROR",
            "ROLE_COULD_NOT_BE_ASSUMED",
            "ROLE_NOT_OWNED_BY_STUDIO_OWNER",
            "STUDIO_CREATED",
            "STUDIO_CREATE_IN_PROGRESS",
            "STUDIO_DELETED",
            "STUDIO_DELETE_IN_PROGRESS",
            "STUDIO_UPDATED",
            "STUDIO_UPDATE_IN_PROGRESS",
            "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED",
            "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED",
            "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED",
        ]
    }
}
impl AsRef<str> for StudioStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioState {
    CreateFailed,
    CreateInProgress,
    Deleted,
    DeleteFailed,
    DeleteInProgress,
    Ready,
    UpdateFailed,
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StudioState::CreateFailed,
            "CREATE_IN_PROGRESS" => StudioState::CreateInProgress,
            "DELETED" => StudioState::Deleted,
            "DELETE_FAILED" => StudioState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StudioState::DeleteInProgress,
            "READY" => StudioState::Ready,
            "UPDATE_FAILED" => StudioState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => StudioState::UpdateInProgress,
            other => StudioState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioState::from(s))
    }
}
impl StudioState {
    pub fn as_str(&self) -> &str {
        match self {
            StudioState::CreateFailed => "CREATE_FAILED",
            StudioState::CreateInProgress => "CREATE_IN_PROGRESS",
            StudioState::Deleted => "DELETED",
            StudioState::DeleteFailed => "DELETE_FAILED",
            StudioState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StudioState::Ready => "READY",
            StudioState::UpdateFailed => "UPDATE_FAILED",
            StudioState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            StudioState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StudioState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingImage {
    /// <p>The ARN of the resource.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>A human-readable description of the streaming image.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
    pub ec2_image_id: std::option::Option<std::string::String>,
    /// <p>The encryption configuration.</p>
    pub encryption_configuration:
        std::option::Option<crate::model::StreamingImageEncryptionConfiguration>,
    /// <p>The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.</p>
    pub eula_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A friendly name for a streaming image resource.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.</p>
    pub owner: std::option::Option<std::string::String>,
    /// <p>The platform of the streaming image, either WINDOWS or LINUX.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::StreamingImageState>,
    /// <p>The status code.</p>
    pub status_code: std::option::Option<crate::model::StreamingImageStatusCode>,
    /// <p>The status message for the streaming image.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The ID of the streaming image.</p>
    pub streaming_image_id: std::option::Option<std::string::String>,
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl std::fmt::Debug for StreamingImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingImage");
        formatter.field("arn", &self.arn);
        formatter.field("description", &self.description);
        formatter.field("ec2_image_id", &self.ec2_image_id);
        formatter.field("encryption_configuration", &self.encryption_configuration);
        formatter.field("eula_ids", &self.eula_ids);
        formatter.field("name", &self.name);
        formatter.field("owner", &self.owner);
        formatter.field("platform", &self.platform);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("streaming_image_id", &self.streaming_image_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`StreamingImage`](crate::model::StreamingImage)
pub mod streaming_image {
    /// A builder for [`StreamingImage`](crate::model::StreamingImage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ec2_image_id: std::option::Option<std::string::String>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::StreamingImageEncryptionConfiguration>,
        pub(crate) eula_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StreamingImageState>,
        pub(crate) status_code: std::option::Option<crate::model::StreamingImageStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) streaming_image_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A human-readable description of the streaming image.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
        pub fn ec2_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_image_id = Some(input.into());
            self
        }
        pub fn set_ec2_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ec2_image_id = input;
            self
        }
        /// <p>The encryption configuration.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::StreamingImageEncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamingImageEncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        pub fn eula_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.eula_ids.unwrap_or_default();
            v.push(input.into());
            self.eula_ids = Some(v);
            self
        }
        pub fn set_eula_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.eula_ids = input;
            self
        }
        /// <p>A friendly name for a streaming image resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The platform of the streaming image, either WINDOWS or LINUX.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StreamingImageState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StreamingImageState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::StreamingImageStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StreamingImageStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the streaming image.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn streaming_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.streaming_image_id = Some(input.into());
            self
        }
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.streaming_image_id = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingImage`](crate::model::StreamingImage)
        pub fn build(self) -> crate::model::StreamingImage {
            crate::model::StreamingImage {
                arn: self.arn,
                description: self.description,
                ec2_image_id: self.ec2_image_id,
                encryption_configuration: self.encryption_configuration,
                eula_ids: self.eula_ids,
                name: self.name,
                owner: self.owner,
                platform: self.platform,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                streaming_image_id: self.streaming_image_id,
                tags: self.tags,
            }
        }
    }
}
impl StreamingImage {
    /// Creates a new builder-style object to manufacture [`StreamingImage`](crate::model::StreamingImage)
    pub fn builder() -> crate::model::streaming_image::Builder {
        crate::model::streaming_image::Builder::default()
    }
}

/// <p>The status code.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingImageStatusCode {
    InternalError,
    StreamingImageCreateInProgress,
    StreamingImageDeleted,
    StreamingImageDeleteInProgress,
    StreamingImageReady,
    StreamingImageUpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingImageStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_ERROR" => StreamingImageStatusCode::InternalError,
            "STREAMING_IMAGE_CREATE_IN_PROGRESS" => {
                StreamingImageStatusCode::StreamingImageCreateInProgress
            }
            "STREAMING_IMAGE_DELETED" => StreamingImageStatusCode::StreamingImageDeleted,
            "STREAMING_IMAGE_DELETE_IN_PROGRESS" => {
                StreamingImageStatusCode::StreamingImageDeleteInProgress
            }
            "STREAMING_IMAGE_READY" => StreamingImageStatusCode::StreamingImageReady,
            "STREAMING_IMAGE_UPDATE_IN_PROGRESS" => {
                StreamingImageStatusCode::StreamingImageUpdateInProgress
            }
            other => StreamingImageStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingImageStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingImageStatusCode::from(s))
    }
}
impl StreamingImageStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            StreamingImageStatusCode::InternalError => "INTERNAL_ERROR",
            StreamingImageStatusCode::StreamingImageCreateInProgress => {
                "STREAMING_IMAGE_CREATE_IN_PROGRESS"
            }
            StreamingImageStatusCode::StreamingImageDeleted => "STREAMING_IMAGE_DELETED",
            StreamingImageStatusCode::StreamingImageDeleteInProgress => {
                "STREAMING_IMAGE_DELETE_IN_PROGRESS"
            }
            StreamingImageStatusCode::StreamingImageReady => "STREAMING_IMAGE_READY",
            StreamingImageStatusCode::StreamingImageUpdateInProgress => {
                "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
            }
            StreamingImageStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "INTERNAL_ERROR",
            "STREAMING_IMAGE_CREATE_IN_PROGRESS",
            "STREAMING_IMAGE_DELETED",
            "STREAMING_IMAGE_DELETE_IN_PROGRESS",
            "STREAMING_IMAGE_READY",
            "STREAMING_IMAGE_UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StreamingImageStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingImageState {
    CreateFailed,
    CreateInProgress,
    Deleted,
    DeleteFailed,
    DeleteInProgress,
    Ready,
    UpdateFailed,
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingImageState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StreamingImageState::CreateFailed,
            "CREATE_IN_PROGRESS" => StreamingImageState::CreateInProgress,
            "DELETED" => StreamingImageState::Deleted,
            "DELETE_FAILED" => StreamingImageState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StreamingImageState::DeleteInProgress,
            "READY" => StreamingImageState::Ready,
            "UPDATE_FAILED" => StreamingImageState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => StreamingImageState::UpdateInProgress,
            other => StreamingImageState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingImageState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingImageState::from(s))
    }
}
impl StreamingImageState {
    pub fn as_str(&self) -> &str {
        match self {
            StreamingImageState::CreateFailed => "CREATE_FAILED",
            StreamingImageState::CreateInProgress => "CREATE_IN_PROGRESS",
            StreamingImageState::Deleted => "DELETED",
            StreamingImageState::DeleteFailed => "DELETE_FAILED",
            StreamingImageState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StreamingImageState::Ready => "READY",
            StreamingImageState::UpdateFailed => "UPDATE_FAILED",
            StreamingImageState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            StreamingImageState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StreamingImageState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingImageEncryptionConfiguration {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    pub key_arn: std::option::Option<std::string::String>,
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    pub key_type: std::option::Option<crate::model::StreamingImageEncryptionConfigurationKeyType>,
}
impl std::fmt::Debug for StreamingImageEncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingImageEncryptionConfiguration");
        formatter.field("key_arn", &self.key_arn);
        formatter.field("key_type", &self.key_type);
        formatter.finish()
    }
}
/// See [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration)
pub mod streaming_image_encryption_configuration {
    /// A builder for [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_arn: std::option::Option<std::string::String>,
        pub(crate) key_type:
            std::option::Option<crate::model::StreamingImageEncryptionConfigurationKeyType>,
    }
    impl Builder {
        /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        pub fn key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_arn = Some(input.into());
            self
        }
        pub fn set_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_arn = input;
            self
        }
        /// <p>The type of KMS key that is used to encrypt studio data.</p>
        pub fn key_type(
            mut self,
            input: crate::model::StreamingImageEncryptionConfigurationKeyType,
        ) -> Self {
            self.key_type = Some(input);
            self
        }
        pub fn set_key_type(
            mut self,
            input: std::option::Option<crate::model::StreamingImageEncryptionConfigurationKeyType>,
        ) -> Self {
            self.key_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration)
        pub fn build(self) -> crate::model::StreamingImageEncryptionConfiguration {
            crate::model::StreamingImageEncryptionConfiguration {
                key_arn: self.key_arn,
                key_type: self.key_type,
            }
        }
    }
}
impl StreamingImageEncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration)
    pub fn builder() -> crate::model::streaming_image_encryption_configuration::Builder {
        crate::model::streaming_image_encryption_configuration::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingImageEncryptionConfigurationKeyType {
    CustomerManagedKey,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingImageEncryptionConfigurationKeyType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOMER_MANAGED_KEY" => {
                StreamingImageEncryptionConfigurationKeyType::CustomerManagedKey
            }
            other => StreamingImageEncryptionConfigurationKeyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingImageEncryptionConfigurationKeyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingImageEncryptionConfigurationKeyType::from(s))
    }
}
impl StreamingImageEncryptionConfigurationKeyType {
    pub fn as_str(&self) -> &str {
        match self {
            StreamingImageEncryptionConfigurationKeyType::CustomerManagedKey => {
                "CUSTOMER_MANAGED_KEY"
            }
            StreamingImageEncryptionConfigurationKeyType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["CUSTOMER_MANAGED_KEY"]
    }
}
impl AsRef<str> for StreamingImageEncryptionConfigurationKeyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileMembership {
    /// <p>The ID of the identity store.</p>
    pub identity_store_id: std::option::Option<std::string::String>,
    /// <p>The persona.</p>
    pub persona: std::option::Option<crate::model::LaunchProfilePersona>,
    /// <p>The principal ID.</p>
    pub principal_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchProfileMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileMembership");
        formatter.field("identity_store_id", &self.identity_store_id);
        formatter.field("persona", &self.persona);
        formatter.field("principal_id", &self.principal_id);
        formatter.finish()
    }
}
/// See [`LaunchProfileMembership`](crate::model::LaunchProfileMembership)
pub mod launch_profile_membership {
    /// A builder for [`LaunchProfileMembership`](crate::model::LaunchProfileMembership)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_store_id: std::option::Option<std::string::String>,
        pub(crate) persona: std::option::Option<crate::model::LaunchProfilePersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_store_id = Some(input.into());
            self
        }
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_store_id = input;
            self
        }
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::LaunchProfilePersona) -> Self {
            self.persona = Some(input);
            self
        }
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileMembership`](crate::model::LaunchProfileMembership)
        pub fn build(self) -> crate::model::LaunchProfileMembership {
            crate::model::LaunchProfileMembership {
                identity_store_id: self.identity_store_id,
                persona: self.persona,
                principal_id: self.principal_id,
            }
        }
    }
}
impl LaunchProfileMembership {
    /// Creates a new builder-style object to manufacture [`LaunchProfileMembership`](crate::model::LaunchProfileMembership)
    pub fn builder() -> crate::model::launch_profile_membership::Builder {
        crate::model::launch_profile_membership::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfilePersona {
    User,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfilePersona {
    fn from(s: &str) -> Self {
        match s {
            "USER" => LaunchProfilePersona::User,
            other => LaunchProfilePersona::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchProfilePersona {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfilePersona::from(s))
    }
}
impl LaunchProfilePersona {
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfilePersona::User => "USER",
            LaunchProfilePersona::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["USER"]
    }
}
impl AsRef<str> for LaunchProfilePersona {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfile {
    /// <p>The ARN of the resource.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<smithy_types::Instant>,
    /// <p>The user ID of the user that created the launch profile.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>A human-readable description of the launch profile.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Unique identifiers for a collection of EC2 subnets.</p>
    pub ec2_subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The launch profile ID.</p>
    pub launch_profile_id: std::option::Option<std::string::String>,
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub launch_profile_protocol_versions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A friendly name for the launch profile.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::LaunchProfileState>,
    /// <p>The status code.</p>
    pub status_code: std::option::Option<crate::model::LaunchProfileStatusCode>,
    /// <p>The status message for the launch profile.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>A configuration for a streaming session.</p>
    pub stream_configuration: std::option::Option<crate::model::StreamConfiguration>,
    /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
    pub studio_component_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<smithy_types::Instant>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub updated_by: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfile");
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("description", &self.description);
        formatter.field("ec2_subnet_ids", &self.ec2_subnet_ids);
        formatter.field("launch_profile_id", &self.launch_profile_id);
        formatter.field(
            "launch_profile_protocol_versions",
            &self.launch_profile_protocol_versions,
        );
        formatter.field("name", &self.name);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("stream_configuration", &self.stream_configuration);
        formatter.field("studio_component_ids", &self.studio_component_ids);
        formatter.field("tags", &self.tags);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.finish()
    }
}
/// See [`LaunchProfile`](crate::model::LaunchProfile)
pub mod launch_profile {
    /// A builder for [`LaunchProfile`](crate::model::LaunchProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ec2_subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) launch_profile_id: std::option::Option<std::string::String>,
        pub(crate) launch_profile_protocol_versions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::LaunchProfileState>,
        pub(crate) status_code: std::option::Option<crate::model::LaunchProfileStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) stream_configuration: std::option::Option<crate::model::StreamConfiguration>,
        pub(crate) studio_component_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) updated_at: std::option::Option<smithy_types::Instant>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        pub fn set_created_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the launch profile.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>A human-readable description of the launch profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        pub fn ec2_subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ec2_subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.ec2_subnet_ids = Some(v);
            self
        }
        pub fn set_ec2_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ec2_subnet_ids = input;
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_profile_id = Some(input.into());
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_id = input;
            self
        }
        pub fn launch_profile_protocol_versions(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.launch_profile_protocol_versions.unwrap_or_default();
            v.push(input.into());
            self.launch_profile_protocol_versions = Some(v);
            self
        }
        pub fn set_launch_profile_protocol_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.launch_profile_protocol_versions = input;
            self
        }
        /// <p>A friendly name for the launch profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::LaunchProfileState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::LaunchProfileStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the launch profile.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>A configuration for a streaming session.</p>
        pub fn stream_configuration(mut self, input: crate::model::StreamConfiguration) -> Self {
            self.stream_configuration = Some(input);
            self
        }
        pub fn set_stream_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamConfiguration>,
        ) -> Self {
            self.stream_configuration = input;
            self
        }
        pub fn studio_component_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.studio_component_ids.unwrap_or_default();
            v.push(input.into());
            self.studio_component_ids = Some(v);
            self
        }
        pub fn set_studio_component_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.studio_component_ids = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: smithy_types::Instant) -> Self {
            self.updated_at = Some(input);
            self
        }
        pub fn set_updated_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfile`](crate::model::LaunchProfile)
        pub fn build(self) -> crate::model::LaunchProfile {
            crate::model::LaunchProfile {
                arn: self.arn,
                created_at: self.created_at,
                created_by: self.created_by,
                description: self.description,
                ec2_subnet_ids: self.ec2_subnet_ids,
                launch_profile_id: self.launch_profile_id,
                launch_profile_protocol_versions: self.launch_profile_protocol_versions,
                name: self.name,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                stream_configuration: self.stream_configuration,
                studio_component_ids: self.studio_component_ids,
                tags: self.tags,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
            }
        }
    }
}
impl LaunchProfile {
    /// Creates a new builder-style object to manufacture [`LaunchProfile`](crate::model::LaunchProfile)
    pub fn builder() -> crate::model::launch_profile::Builder {
        crate::model::launch_profile::Builder::default()
    }
}

/// <p>A configuration for a streaming session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamConfiguration {
    /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    pub clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    pub ec2_instance_types: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
    /// <p>The length of time, in minutes, that a streaming session can run. After this point, Nimble Studio automatically terminates the session.</p>
    pub max_session_length_in_minutes: i32,
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    pub streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for StreamConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamConfiguration");
        formatter.field("clipboard_mode", &self.clipboard_mode);
        formatter.field("ec2_instance_types", &self.ec2_instance_types);
        formatter.field(
            "max_session_length_in_minutes",
            &self.max_session_length_in_minutes,
        );
        formatter.field("streaming_image_ids", &self.streaming_image_ids);
        formatter.finish()
    }
}
/// See [`StreamConfiguration`](crate::model::StreamConfiguration)
pub mod stream_configuration {
    /// A builder for [`StreamConfiguration`](crate::model::StreamConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
        pub(crate) ec2_instance_types:
            std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        pub(crate) max_session_length_in_minutes: std::option::Option<i32>,
        pub(crate) streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
        pub fn clipboard_mode(mut self, input: crate::model::StreamingClipboardMode) -> Self {
            self.clipboard_mode = Some(input);
            self
        }
        pub fn set_clipboard_mode(
            mut self,
            input: std::option::Option<crate::model::StreamingClipboardMode>,
        ) -> Self {
            self.clipboard_mode = input;
            self
        }
        pub fn ec2_instance_types(
            mut self,
            input: impl Into<crate::model::StreamingInstanceType>,
        ) -> Self {
            let mut v = self.ec2_instance_types.unwrap_or_default();
            v.push(input.into());
            self.ec2_instance_types = Some(v);
            self
        }
        pub fn set_ec2_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        ) -> Self {
            self.ec2_instance_types = input;
            self
        }
        /// <p>The length of time, in minutes, that a streaming session can run. After this point, Nimble Studio automatically terminates the session.</p>
        pub fn max_session_length_in_minutes(mut self, input: i32) -> Self {
            self.max_session_length_in_minutes = Some(input);
            self
        }
        pub fn set_max_session_length_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_session_length_in_minutes = input;
            self
        }
        pub fn streaming_image_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.streaming_image_ids.unwrap_or_default();
            v.push(input.into());
            self.streaming_image_ids = Some(v);
            self
        }
        pub fn set_streaming_image_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.streaming_image_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamConfiguration`](crate::model::StreamConfiguration)
        pub fn build(self) -> crate::model::StreamConfiguration {
            crate::model::StreamConfiguration {
                clipboard_mode: self.clipboard_mode,
                ec2_instance_types: self.ec2_instance_types,
                max_session_length_in_minutes: self
                    .max_session_length_in_minutes
                    .unwrap_or_default(),
                streaming_image_ids: self.streaming_image_ids,
            }
        }
    }
}
impl StreamConfiguration {
    /// Creates a new builder-style object to manufacture [`StreamConfiguration`](crate::model::StreamConfiguration)
    pub fn builder() -> crate::model::stream_configuration::Builder {
        crate::model::stream_configuration::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingInstanceType {
    G4dn12xlarge,
    G4dn16xlarge,
    G4dn2xlarge,
    G4dn4xlarge,
    G4dn8xlarge,
    G4dnXlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "g4dn.12xlarge" => StreamingInstanceType::G4dn12xlarge,
            "g4dn.16xlarge" => StreamingInstanceType::G4dn16xlarge,
            "g4dn.2xlarge" => StreamingInstanceType::G4dn2xlarge,
            "g4dn.4xlarge" => StreamingInstanceType::G4dn4xlarge,
            "g4dn.8xlarge" => StreamingInstanceType::G4dn8xlarge,
            "g4dn.xlarge" => StreamingInstanceType::G4dnXlarge,
            other => StreamingInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingInstanceType::from(s))
    }
}
impl StreamingInstanceType {
    pub fn as_str(&self) -> &str {
        match self {
            StreamingInstanceType::G4dn12xlarge => "g4dn.12xlarge",
            StreamingInstanceType::G4dn16xlarge => "g4dn.16xlarge",
            StreamingInstanceType::G4dn2xlarge => "g4dn.2xlarge",
            StreamingInstanceType::G4dn4xlarge => "g4dn.4xlarge",
            StreamingInstanceType::G4dn8xlarge => "g4dn.8xlarge",
            StreamingInstanceType::G4dnXlarge => "g4dn.xlarge",
            StreamingInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "g4dn.12xlarge",
            "g4dn.16xlarge",
            "g4dn.2xlarge",
            "g4dn.4xlarge",
            "g4dn.8xlarge",
            "g4dn.xlarge",
        ]
    }
}
impl AsRef<str> for StreamingInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingClipboardMode {
    Disabled,
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingClipboardMode {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => StreamingClipboardMode::Disabled,
            "ENABLED" => StreamingClipboardMode::Enabled,
            other => StreamingClipboardMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingClipboardMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingClipboardMode::from(s))
    }
}
impl StreamingClipboardMode {
    pub fn as_str(&self) -> &str {
        match self {
            StreamingClipboardMode::Disabled => "DISABLED",
            StreamingClipboardMode::Enabled => "ENABLED",
            StreamingClipboardMode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for StreamingClipboardMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileStatusCode {
    EncryptionKeyAccessDenied,
    EncryptionKeyNotFound,
    InternalError,
    InvalidSubnetsProvided,
    LaunchProfileCreated,
    LaunchProfileCreateInProgress,
    LaunchProfileDeleted,
    LaunchProfileDeleteInProgress,
    LaunchProfileUpdated,
    LaunchProfileUpdateInProgress,
    LaunchProfileWithStreamSessionsNotDeleted,
    StreamingImageNotFound,
    StreamingImageNotReady,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfileStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ENCRYPTION_KEY_ACCESS_DENIED" => LaunchProfileStatusCode::EncryptionKeyAccessDenied,
            "ENCRYPTION_KEY_NOT_FOUND" => LaunchProfileStatusCode::EncryptionKeyNotFound,
            "INTERNAL_ERROR" => LaunchProfileStatusCode::InternalError,
            "INVALID_SUBNETS_PROVIDED" => LaunchProfileStatusCode::InvalidSubnetsProvided,
            "LAUNCH_PROFILE_CREATED" => LaunchProfileStatusCode::LaunchProfileCreated,
            "LAUNCH_PROFILE_CREATE_IN_PROGRESS" => {
                LaunchProfileStatusCode::LaunchProfileCreateInProgress
            }
            "LAUNCH_PROFILE_DELETED" => LaunchProfileStatusCode::LaunchProfileDeleted,
            "LAUNCH_PROFILE_DELETE_IN_PROGRESS" => {
                LaunchProfileStatusCode::LaunchProfileDeleteInProgress
            }
            "LAUNCH_PROFILE_UPDATED" => LaunchProfileStatusCode::LaunchProfileUpdated,
            "LAUNCH_PROFILE_UPDATE_IN_PROGRESS" => {
                LaunchProfileStatusCode::LaunchProfileUpdateInProgress
            }
            "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED" => {
                LaunchProfileStatusCode::LaunchProfileWithStreamSessionsNotDeleted
            }
            "STREAMING_IMAGE_NOT_FOUND" => LaunchProfileStatusCode::StreamingImageNotFound,
            "STREAMING_IMAGE_NOT_READY" => LaunchProfileStatusCode::StreamingImageNotReady,
            other => LaunchProfileStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchProfileStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileStatusCode::from(s))
    }
}
impl LaunchProfileStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileStatusCode::EncryptionKeyAccessDenied => "ENCRYPTION_KEY_ACCESS_DENIED",
            LaunchProfileStatusCode::EncryptionKeyNotFound => "ENCRYPTION_KEY_NOT_FOUND",
            LaunchProfileStatusCode::InternalError => "INTERNAL_ERROR",
            LaunchProfileStatusCode::InvalidSubnetsProvided => "INVALID_SUBNETS_PROVIDED",
            LaunchProfileStatusCode::LaunchProfileCreated => "LAUNCH_PROFILE_CREATED",
            LaunchProfileStatusCode::LaunchProfileCreateInProgress => {
                "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
            }
            LaunchProfileStatusCode::LaunchProfileDeleted => "LAUNCH_PROFILE_DELETED",
            LaunchProfileStatusCode::LaunchProfileDeleteInProgress => {
                "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
            }
            LaunchProfileStatusCode::LaunchProfileUpdated => "LAUNCH_PROFILE_UPDATED",
            LaunchProfileStatusCode::LaunchProfileUpdateInProgress => {
                "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
            }
            LaunchProfileStatusCode::LaunchProfileWithStreamSessionsNotDeleted => {
                "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
            }
            LaunchProfileStatusCode::StreamingImageNotFound => "STREAMING_IMAGE_NOT_FOUND",
            LaunchProfileStatusCode::StreamingImageNotReady => "STREAMING_IMAGE_NOT_READY",
            LaunchProfileStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ENCRYPTION_KEY_ACCESS_DENIED",
            "ENCRYPTION_KEY_NOT_FOUND",
            "INTERNAL_ERROR",
            "INVALID_SUBNETS_PROVIDED",
            "LAUNCH_PROFILE_CREATED",
            "LAUNCH_PROFILE_CREATE_IN_PROGRESS",
            "LAUNCH_PROFILE_DELETED",
            "LAUNCH_PROFILE_DELETE_IN_PROGRESS",
            "LAUNCH_PROFILE_UPDATED",
            "LAUNCH_PROFILE_UPDATE_IN_PROGRESS",
            "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED",
            "STREAMING_IMAGE_NOT_FOUND",
            "STREAMING_IMAGE_NOT_READY",
        ]
    }
}
impl AsRef<str> for LaunchProfileStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileState {
    CreateFailed,
    CreateInProgress,
    Deleted,
    DeleteFailed,
    DeleteInProgress,
    Ready,
    UpdateFailed,
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfileState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => LaunchProfileState::CreateFailed,
            "CREATE_IN_PROGRESS" => LaunchProfileState::CreateInProgress,
            "DELETED" => LaunchProfileState::Deleted,
            "DELETE_FAILED" => LaunchProfileState::DeleteFailed,
            "DELETE_IN_PROGRESS" => LaunchProfileState::DeleteInProgress,
            "READY" => LaunchProfileState::Ready,
            "UPDATE_FAILED" => LaunchProfileState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => LaunchProfileState::UpdateInProgress,
            other => LaunchProfileState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchProfileState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileState::from(s))
    }
}
impl LaunchProfileState {
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileState::CreateFailed => "CREATE_FAILED",
            LaunchProfileState::CreateInProgress => "CREATE_IN_PROGRESS",
            LaunchProfileState::Deleted => "DELETED",
            LaunchProfileState::DeleteFailed => "DELETE_FAILED",
            LaunchProfileState::DeleteInProgress => "DELETE_IN_PROGRESS",
            LaunchProfileState::Ready => "READY",
            LaunchProfileState::UpdateFailed => "UPDATE_FAILED",
            LaunchProfileState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            LaunchProfileState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for LaunchProfileState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamConfigurationCreate {
    /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    pub clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    pub ec2_instance_types: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
    /// <p>The length of time, in minutes, that a streaming session can run. After this point, Nimble Studio automatically terminates the session.</p>
    pub max_session_length_in_minutes: i32,
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    pub streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for StreamConfigurationCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamConfigurationCreate");
        formatter.field("clipboard_mode", &self.clipboard_mode);
        formatter.field("ec2_instance_types", &self.ec2_instance_types);
        formatter.field(
            "max_session_length_in_minutes",
            &self.max_session_length_in_minutes,
        );
        formatter.field("streaming_image_ids", &self.streaming_image_ids);
        formatter.finish()
    }
}
/// See [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate)
pub mod stream_configuration_create {
    /// A builder for [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
        pub(crate) ec2_instance_types:
            std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        pub(crate) max_session_length_in_minutes: std::option::Option<i32>,
        pub(crate) streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
        pub fn clipboard_mode(mut self, input: crate::model::StreamingClipboardMode) -> Self {
            self.clipboard_mode = Some(input);
            self
        }
        pub fn set_clipboard_mode(
            mut self,
            input: std::option::Option<crate::model::StreamingClipboardMode>,
        ) -> Self {
            self.clipboard_mode = input;
            self
        }
        pub fn ec2_instance_types(
            mut self,
            input: impl Into<crate::model::StreamingInstanceType>,
        ) -> Self {
            let mut v = self.ec2_instance_types.unwrap_or_default();
            v.push(input.into());
            self.ec2_instance_types = Some(v);
            self
        }
        pub fn set_ec2_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        ) -> Self {
            self.ec2_instance_types = input;
            self
        }
        /// <p>The length of time, in minutes, that a streaming session can run. After this point, Nimble Studio automatically terminates the session.</p>
        pub fn max_session_length_in_minutes(mut self, input: i32) -> Self {
            self.max_session_length_in_minutes = Some(input);
            self
        }
        pub fn set_max_session_length_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_session_length_in_minutes = input;
            self
        }
        pub fn streaming_image_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.streaming_image_ids.unwrap_or_default();
            v.push(input.into());
            self.streaming_image_ids = Some(v);
            self
        }
        pub fn set_streaming_image_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.streaming_image_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate)
        pub fn build(self) -> crate::model::StreamConfigurationCreate {
            crate::model::StreamConfigurationCreate {
                clipboard_mode: self.clipboard_mode,
                ec2_instance_types: self.ec2_instance_types,
                max_session_length_in_minutes: self
                    .max_session_length_in_minutes
                    .unwrap_or_default(),
                streaming_image_ids: self.streaming_image_ids,
            }
        }
    }
}
impl StreamConfigurationCreate {
    /// Creates a new builder-style object to manufacture [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate)
    pub fn builder() -> crate::model::stream_configuration_create::Builder {
        crate::model::stream_configuration_create::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NewStudioMember {
    /// <p>The persona.</p>
    pub persona: std::option::Option<crate::model::StudioPersona>,
    /// <p>The principal ID.</p>
    pub principal_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NewStudioMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NewStudioMember");
        formatter.field("persona", &self.persona);
        formatter.field("principal_id", &self.principal_id);
        formatter.finish()
    }
}
/// See [`NewStudioMember`](crate::model::NewStudioMember)
pub mod new_studio_member {
    /// A builder for [`NewStudioMember`](crate::model::NewStudioMember)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) persona: std::option::Option<crate::model::StudioPersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::StudioPersona) -> Self {
            self.persona = Some(input);
            self
        }
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::StudioPersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NewStudioMember`](crate::model::NewStudioMember)
        pub fn build(self) -> crate::model::NewStudioMember {
            crate::model::NewStudioMember {
                persona: self.persona,
                principal_id: self.principal_id,
            }
        }
    }
}
impl NewStudioMember {
    /// Creates a new builder-style object to manufacture [`NewStudioMember`](crate::model::NewStudioMember)
    pub fn builder() -> crate::model::new_studio_member::Builder {
        crate::model::new_studio_member::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioPersona {
    Administrator,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioPersona {
    fn from(s: &str) -> Self {
        match s {
            "ADMINISTRATOR" => StudioPersona::Administrator,
            other => StudioPersona::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioPersona {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioPersona::from(s))
    }
}
impl StudioPersona {
    pub fn as_str(&self) -> &str {
        match self {
            StudioPersona::Administrator => "ADMINISTRATOR",
            StudioPersona::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &["ADMINISTRATOR"]
    }
}
impl AsRef<str> for StudioPersona {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NewLaunchProfileMember {
    /// <p>The persona.</p>
    pub persona: std::option::Option<crate::model::LaunchProfilePersona>,
    /// <p>The principal ID.</p>
    pub principal_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NewLaunchProfileMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NewLaunchProfileMember");
        formatter.field("persona", &self.persona);
        formatter.field("principal_id", &self.principal_id);
        formatter.finish()
    }
}
/// See [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember)
pub mod new_launch_profile_member {
    /// A builder for [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) persona: std::option::Option<crate::model::LaunchProfilePersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::LaunchProfilePersona) -> Self {
            self.persona = Some(input);
            self
        }
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember)
        pub fn build(self) -> crate::model::NewLaunchProfileMember {
            crate::model::NewLaunchProfileMember {
                persona: self.persona,
                principal_id: self.principal_id,
            }
        }
    }
}
impl NewLaunchProfileMember {
    /// Creates a new builder-style object to manufacture [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember)
    pub fn builder() -> crate::model::new_launch_profile_member::Builder {
        crate::model::new_launch_profile_member::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioMembership {
    /// <p>The ID of the identity store.</p>
    pub identity_store_id: std::option::Option<std::string::String>,
    /// <p>The persona.</p>
    pub persona: std::option::Option<crate::model::StudioPersona>,
    /// <p>The principal ID.</p>
    pub principal_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StudioMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioMembership");
        formatter.field("identity_store_id", &self.identity_store_id);
        formatter.field("persona", &self.persona);
        formatter.field("principal_id", &self.principal_id);
        formatter.finish()
    }
}
/// See [`StudioMembership`](crate::model::StudioMembership)
pub mod studio_membership {
    /// A builder for [`StudioMembership`](crate::model::StudioMembership)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_store_id: std::option::Option<std::string::String>,
        pub(crate) persona: std::option::Option<crate::model::StudioPersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_store_id = Some(input.into());
            self
        }
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_store_id = input;
            self
        }
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::StudioPersona) -> Self {
            self.persona = Some(input);
            self
        }
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::StudioPersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioMembership`](crate::model::StudioMembership)
        pub fn build(self) -> crate::model::StudioMembership {
            crate::model::StudioMembership {
                identity_store_id: self.identity_store_id,
                persona: self.persona,
                principal_id: self.principal_id,
            }
        }
    }
}
impl StudioMembership {
    /// Creates a new builder-style object to manufacture [`StudioMembership`](crate::model::StudioMembership)
    pub fn builder() -> crate::model::studio_membership::Builder {
        crate::model::studio_membership::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingSession {
    /// <p>The ARN of the resource.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<smithy_types::Instant>,
    /// <p>The user ID of the user that created the streaming session.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The EC2 Instance type used for the streaming session.</p>
    pub ec2_instance_type: std::option::Option<std::string::String>,
    /// <p>The ID of the launch profile used to control access from the streaming session.</p>
    pub launch_profile_id: std::option::Option<std::string::String>,
    /// <p>The session ID.</p>
    pub session_id: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::StreamingSessionState>,
    /// <p>The status code.</p>
    pub status_code: std::option::Option<crate::model::StreamingSessionStatusCode>,
    /// <p>The status message for the streaming session.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The ID of the streaming image.</p>
    pub streaming_image_id: std::option::Option<std::string::String>,
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
    pub terminate_at: std::option::Option<smithy_types::Instant>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<smithy_types::Instant>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub updated_by: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StreamingSession {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingSession");
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("ec2_instance_type", &self.ec2_instance_type);
        formatter.field("launch_profile_id", &self.launch_profile_id);
        formatter.field("session_id", &self.session_id);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("streaming_image_id", &self.streaming_image_id);
        formatter.field("tags", &self.tags);
        formatter.field("terminate_at", &self.terminate_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.finish()
    }
}
/// See [`StreamingSession`](crate::model::StreamingSession)
pub mod streaming_session {
    /// A builder for [`StreamingSession`](crate::model::StreamingSession)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) ec2_instance_type: std::option::Option<std::string::String>,
        pub(crate) launch_profile_id: std::option::Option<std::string::String>,
        pub(crate) session_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StreamingSessionState>,
        pub(crate) status_code: std::option::Option<crate::model::StreamingSessionStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) streaming_image_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) terminate_at: std::option::Option<smithy_types::Instant>,
        pub(crate) updated_at: std::option::Option<smithy_types::Instant>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        pub fn set_created_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the streaming session.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The EC2 Instance type used for the streaming session.</p>
        pub fn ec2_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_instance_type = Some(input.into());
            self
        }
        pub fn set_ec2_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ec2_instance_type = input;
            self
        }
        /// <p>The ID of the launch profile used to control access from the streaming session.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_profile_id = Some(input.into());
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_id = input;
            self
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_id = Some(input.into());
            self
        }
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.session_id = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StreamingSessionState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::StreamingSessionStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the streaming session.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn streaming_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.streaming_image_id = Some(input.into());
            self
        }
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.streaming_image_id = input;
            self
        }
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
        pub fn terminate_at(mut self, input: smithy_types::Instant) -> Self {
            self.terminate_at = Some(input);
            self
        }
        pub fn set_terminate_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.terminate_at = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: smithy_types::Instant) -> Self {
            self.updated_at = Some(input);
            self
        }
        pub fn set_updated_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingSession`](crate::model::StreamingSession)
        pub fn build(self) -> crate::model::StreamingSession {
            crate::model::StreamingSession {
                arn: self.arn,
                created_at: self.created_at,
                created_by: self.created_by,
                ec2_instance_type: self.ec2_instance_type,
                launch_profile_id: self.launch_profile_id,
                session_id: self.session_id,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                streaming_image_id: self.streaming_image_id,
                tags: self.tags,
                terminate_at: self.terminate_at,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
            }
        }
    }
}
impl StreamingSession {
    /// Creates a new builder-style object to manufacture [`StreamingSession`](crate::model::StreamingSession)
    pub fn builder() -> crate::model::streaming_session::Builder {
        crate::model::streaming_session::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStatusCode {
    ActiveDirectoryDomainJoinError,
    DecryptStreamingImageError,
    InitializationScriptError,
    InsufficientCapacity,
    InternalError,
    NetworkConnectionError,
    NetworkInterfaceError,
    StreamingSessionCreateInProgress,
    StreamingSessionDeleted,
    StreamingSessionDeleteInProgress,
    StreamingSessionReady,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingSessionStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR" => {
                StreamingSessionStatusCode::ActiveDirectoryDomainJoinError
            }
            "DECRYPT_STREAMING_IMAGE_ERROR" => {
                StreamingSessionStatusCode::DecryptStreamingImageError
            }
            "INITIALIZATION_SCRIPT_ERROR" => StreamingSessionStatusCode::InitializationScriptError,
            "INSUFFICIENT_CAPACITY" => StreamingSessionStatusCode::InsufficientCapacity,
            "INTERNAL_ERROR" => StreamingSessionStatusCode::InternalError,
            "NETWORK_CONNECTION_ERROR" => StreamingSessionStatusCode::NetworkConnectionError,
            "NETWORK_INTERFACE_ERROR" => StreamingSessionStatusCode::NetworkInterfaceError,
            "STREAMING_SESSION_CREATE_IN_PROGRESS" => {
                StreamingSessionStatusCode::StreamingSessionCreateInProgress
            }
            "STREAMING_SESSION_DELETED" => StreamingSessionStatusCode::StreamingSessionDeleted,
            "STREAMING_SESSION_DELETE_IN_PROGRESS" => {
                StreamingSessionStatusCode::StreamingSessionDeleteInProgress
            }
            "STREAMING_SESSION_READY" => StreamingSessionStatusCode::StreamingSessionReady,
            other => StreamingSessionStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingSessionStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStatusCode::from(s))
    }
}
impl StreamingSessionStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStatusCode::ActiveDirectoryDomainJoinError => {
                "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
            }
            StreamingSessionStatusCode::DecryptStreamingImageError => {
                "DECRYPT_STREAMING_IMAGE_ERROR"
            }
            StreamingSessionStatusCode::InitializationScriptError => "INITIALIZATION_SCRIPT_ERROR",
            StreamingSessionStatusCode::InsufficientCapacity => "INSUFFICIENT_CAPACITY",
            StreamingSessionStatusCode::InternalError => "INTERNAL_ERROR",
            StreamingSessionStatusCode::NetworkConnectionError => "NETWORK_CONNECTION_ERROR",
            StreamingSessionStatusCode::NetworkInterfaceError => "NETWORK_INTERFACE_ERROR",
            StreamingSessionStatusCode::StreamingSessionCreateInProgress => {
                "STREAMING_SESSION_CREATE_IN_PROGRESS"
            }
            StreamingSessionStatusCode::StreamingSessionDeleted => "STREAMING_SESSION_DELETED",
            StreamingSessionStatusCode::StreamingSessionDeleteInProgress => {
                "STREAMING_SESSION_DELETE_IN_PROGRESS"
            }
            StreamingSessionStatusCode::StreamingSessionReady => "STREAMING_SESSION_READY",
            StreamingSessionStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR",
            "DECRYPT_STREAMING_IMAGE_ERROR",
            "INITIALIZATION_SCRIPT_ERROR",
            "INSUFFICIENT_CAPACITY",
            "INTERNAL_ERROR",
            "NETWORK_CONNECTION_ERROR",
            "NETWORK_INTERFACE_ERROR",
            "STREAMING_SESSION_CREATE_IN_PROGRESS",
            "STREAMING_SESSION_DELETED",
            "STREAMING_SESSION_DELETE_IN_PROGRESS",
            "STREAMING_SESSION_READY",
        ]
    }
}
impl AsRef<str> for StreamingSessionStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The streaming session state.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionState {
    CreateFailed,
    CreateInProgress,
    Deleted,
    DeleteFailed,
    DeleteInProgress,
    Ready,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingSessionState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StreamingSessionState::CreateFailed,
            "CREATE_IN_PROGRESS" => StreamingSessionState::CreateInProgress,
            "DELETED" => StreamingSessionState::Deleted,
            "DELETE_FAILED" => StreamingSessionState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StreamingSessionState::DeleteInProgress,
            "READY" => StreamingSessionState::Ready,
            other => StreamingSessionState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingSessionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionState::from(s))
    }
}
impl StreamingSessionState {
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionState::CreateFailed => "CREATE_FAILED",
            StreamingSessionState::CreateInProgress => "CREATE_IN_PROGRESS",
            StreamingSessionState::Deleted => "DELETED",
            StreamingSessionState::DeleteFailed => "DELETE_FAILED",
            StreamingSessionState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StreamingSessionState::Ready => "READY",
            StreamingSessionState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
        ]
    }
}
impl AsRef<str> for StreamingSessionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a EULA resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Eula {
    /// <p>The EULA content.</p>
    pub content: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<smithy_types::Instant>,
    /// <p>The EULA ID.</p>
    pub eula_id: std::option::Option<std::string::String>,
    /// <p>The name for the EULA.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for Eula {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Eula");
        formatter.field("content", &self.content);
        formatter.field("created_at", &self.created_at);
        formatter.field("eula_id", &self.eula_id);
        formatter.field("name", &self.name);
        formatter.field("updated_at", &self.updated_at);
        formatter.finish()
    }
}
/// See [`Eula`](crate::model::Eula)
pub mod eula {
    /// A builder for [`Eula`](crate::model::Eula)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<smithy_types::Instant>,
        pub(crate) eula_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) updated_at: std::option::Option<smithy_types::Instant>,
    }
    impl Builder {
        /// <p>The EULA content.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        pub fn set_created_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The EULA ID.</p>
        pub fn eula_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.eula_id = Some(input.into());
            self
        }
        pub fn set_eula_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.eula_id = input;
            self
        }
        /// <p>The name for the EULA.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: smithy_types::Instant) -> Self {
            self.updated_at = Some(input);
            self
        }
        pub fn set_updated_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`Eula`](crate::model::Eula)
        pub fn build(self) -> crate::model::Eula {
            crate::model::Eula {
                content: self.content,
                created_at: self.created_at,
                eula_id: self.eula_id,
                name: self.name,
                updated_at: self.updated_at,
            }
        }
    }
}
impl Eula {
    /// Creates a new builder-style object to manufacture [`Eula`](crate::model::Eula)
    pub fn builder() -> crate::model::eula::Builder {
        crate::model::eula::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EulaAcceptance {
    /// <p>The Unix epoch timestamp in seconds for when the EULA was accepted.</p>
    pub accepted_at: std::option::Option<smithy_types::Instant>,
    /// <p>The ID of the person who accepted the EULA.</p>
    pub accepted_by: std::option::Option<std::string::String>,
    /// <p>The ID of the acceptee.</p>
    pub acceptee_id: std::option::Option<std::string::String>,
    /// <p>The EULA acceptance ID.</p>
    pub eula_acceptance_id: std::option::Option<std::string::String>,
    /// <p>The EULA ID.</p>
    pub eula_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EulaAcceptance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EulaAcceptance");
        formatter.field("accepted_at", &self.accepted_at);
        formatter.field("accepted_by", &self.accepted_by);
        formatter.field("acceptee_id", &self.acceptee_id);
        formatter.field("eula_acceptance_id", &self.eula_acceptance_id);
        formatter.field("eula_id", &self.eula_id);
        formatter.finish()
    }
}
/// See [`EulaAcceptance`](crate::model::EulaAcceptance)
pub mod eula_acceptance {
    /// A builder for [`EulaAcceptance`](crate::model::EulaAcceptance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accepted_at: std::option::Option<smithy_types::Instant>,
        pub(crate) accepted_by: std::option::Option<std::string::String>,
        pub(crate) acceptee_id: std::option::Option<std::string::String>,
        pub(crate) eula_acceptance_id: std::option::Option<std::string::String>,
        pub(crate) eula_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Unix epoch timestamp in seconds for when the EULA was accepted.</p>
        pub fn accepted_at(mut self, input: smithy_types::Instant) -> Self {
            self.accepted_at = Some(input);
            self
        }
        pub fn set_accepted_at(
            mut self,
            input: std::option::Option<smithy_types::Instant>,
        ) -> Self {
            self.accepted_at = input;
            self
        }
        /// <p>The ID of the person who accepted the EULA.</p>
        pub fn accepted_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.accepted_by = Some(input.into());
            self
        }
        pub fn set_accepted_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.accepted_by = input;
            self
        }
        /// <p>The ID of the acceptee.</p>
        pub fn acceptee_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.acceptee_id = Some(input.into());
            self
        }
        pub fn set_acceptee_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.acceptee_id = input;
            self
        }
        /// <p>The EULA acceptance ID.</p>
        pub fn eula_acceptance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.eula_acceptance_id = Some(input.into());
            self
        }
        pub fn set_eula_acceptance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.eula_acceptance_id = input;
            self
        }
        /// <p>The EULA ID.</p>
        pub fn eula_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.eula_id = Some(input.into());
            self
        }
        pub fn set_eula_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.eula_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EulaAcceptance`](crate::model::EulaAcceptance)
        pub fn build(self) -> crate::model::EulaAcceptance {
            crate::model::EulaAcceptance {
                accepted_at: self.accepted_at,
                accepted_by: self.accepted_by,
                acceptee_id: self.acceptee_id,
                eula_acceptance_id: self.eula_acceptance_id,
                eula_id: self.eula_id,
            }
        }
    }
}
impl EulaAcceptance {
    /// Creates a new builder-style object to manufacture [`EulaAcceptance`](crate::model::EulaAcceptance)
    pub fn builder() -> crate::model::eula_acceptance::Builder {
        crate::model::eula_acceptance::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingSessionStream {
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<smithy_types::Instant>,
    /// <p>The user ID of the user that created the streaming session stream.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource expires.</p>
    pub expires_at: std::option::Option<smithy_types::Instant>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::StreamingSessionStreamState>,
    /// <p>The streaming session stream status code.</p>
    pub status_code: std::option::Option<crate::model::StreamingSessionStreamStatusCode>,
    /// <p>The stream ID.</p>
    pub stream_id: std::option::Option<std::string::String>,
    /// <p>The URL to connect to this stream using the DCV client.</p>
    pub url: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StreamingSessionStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingSessionStream");
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("expires_at", &self.expires_at);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("stream_id", &self.stream_id);
        formatter.field("url", &self.url);
        formatter.finish()
    }
}
/// See [`StreamingSessionStream`](crate::model::StreamingSessionStream)
pub mod streaming_session_stream {
    /// A builder for [`StreamingSessionStream`](crate::model::StreamingSessionStream)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) created_at: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) expires_at: std::option::Option<smithy_types::Instant>,
        pub(crate) state: std::option::Option<crate::model::StreamingSessionStreamState>,
        pub(crate) status_code: std::option::Option<crate::model::StreamingSessionStreamStatusCode>,
        pub(crate) stream_id: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        pub fn set_created_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the streaming session stream.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource expires.</p>
        pub fn expires_at(mut self, input: smithy_types::Instant) -> Self {
            self.expires_at = Some(input);
            self
        }
        pub fn set_expires_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.expires_at = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StreamingSessionStreamState) -> Self {
            self.state = Some(input);
            self
        }
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStreamState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The streaming session stream status code.</p>
        pub fn status_code(
            mut self,
            input: crate::model::StreamingSessionStreamStatusCode,
        ) -> Self {
            self.status_code = Some(input);
            self
        }
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStreamStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// <p>The URL to connect to this stream using the DCV client.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingSessionStream`](crate::model::StreamingSessionStream)
        pub fn build(self) -> crate::model::StreamingSessionStream {
            crate::model::StreamingSessionStream {
                created_at: self.created_at,
                created_by: self.created_by,
                expires_at: self.expires_at,
                state: self.state,
                status_code: self.status_code,
                stream_id: self.stream_id,
                url: self.url,
            }
        }
    }
}
impl StreamingSessionStream {
    /// Creates a new builder-style object to manufacture [`StreamingSessionStream`](crate::model::StreamingSessionStream)
    pub fn builder() -> crate::model::streaming_session_stream::Builder {
        crate::model::streaming_session_stream::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStreamStatusCode {
    InternalError,
    NetworkConnectionError,
    StreamCreateInProgress,
    StreamDeleted,
    StreamDeleteInProgress,
    StreamReady,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingSessionStreamStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_ERROR" => StreamingSessionStreamStatusCode::InternalError,
            "NETWORK_CONNECTION_ERROR" => StreamingSessionStreamStatusCode::NetworkConnectionError,
            "STREAM_CREATE_IN_PROGRESS" => StreamingSessionStreamStatusCode::StreamCreateInProgress,
            "STREAM_DELETED" => StreamingSessionStreamStatusCode::StreamDeleted,
            "STREAM_DELETE_IN_PROGRESS" => StreamingSessionStreamStatusCode::StreamDeleteInProgress,
            "STREAM_READY" => StreamingSessionStreamStatusCode::StreamReady,
            other => StreamingSessionStreamStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingSessionStreamStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStreamStatusCode::from(s))
    }
}
impl StreamingSessionStreamStatusCode {
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStreamStatusCode::InternalError => "INTERNAL_ERROR",
            StreamingSessionStreamStatusCode::NetworkConnectionError => "NETWORK_CONNECTION_ERROR",
            StreamingSessionStreamStatusCode::StreamCreateInProgress => "STREAM_CREATE_IN_PROGRESS",
            StreamingSessionStreamStatusCode::StreamDeleted => "STREAM_DELETED",
            StreamingSessionStreamStatusCode::StreamDeleteInProgress => "STREAM_DELETE_IN_PROGRESS",
            StreamingSessionStreamStatusCode::StreamReady => "STREAM_READY",
            StreamingSessionStreamStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "INTERNAL_ERROR",
            "NETWORK_CONNECTION_ERROR",
            "STREAM_CREATE_IN_PROGRESS",
            "STREAM_DELETED",
            "STREAM_DELETE_IN_PROGRESS",
            "STREAM_READY",
        ]
    }
}
impl AsRef<str> for StreamingSessionStreamStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStreamState {
    CreateFailed,
    CreateInProgress,
    Deleted,
    DeleteFailed,
    DeleteInProgress,
    Ready,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingSessionStreamState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StreamingSessionStreamState::CreateFailed,
            "CREATE_IN_PROGRESS" => StreamingSessionStreamState::CreateInProgress,
            "DELETED" => StreamingSessionStreamState::Deleted,
            "DELETE_FAILED" => StreamingSessionStreamState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StreamingSessionStreamState::DeleteInProgress,
            "READY" => StreamingSessionStreamState::Ready,
            other => StreamingSessionStreamState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingSessionStreamState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStreamState::from(s))
    }
}
impl StreamingSessionStreamState {
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStreamState::CreateFailed => "CREATE_FAILED",
            StreamingSessionStreamState::CreateInProgress => "CREATE_IN_PROGRESS",
            StreamingSessionStreamState::Deleted => "DELETED",
            StreamingSessionStreamState::DeleteFailed => "DELETE_FAILED",
            StreamingSessionStreamState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StreamingSessionStreamState::Ready => "READY",
            StreamingSessionStreamState::Unknown(s) => s.as_ref(),
        }
    }
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
        ]
    }
}
impl AsRef<str> for StreamingSessionStreamState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileInitialization {
    /// <p>A LaunchProfileInitializationActiveDirectory resource.</p>
    pub active_directory:
        std::option::Option<crate::model::LaunchProfileInitializationActiveDirectory>,
    /// <p>The EC2 security groups that control access to the studio component.</p>
    pub ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The launch profile ID.</p>
    pub launch_profile_id: std::option::Option<std::string::String>,
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub launch_profile_protocol_version: std::option::Option<std::string::String>,
    /// <p>The launch purpose.</p>
    pub launch_purpose: std::option::Option<std::string::String>,
    /// <p>The name for the launch profile.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The platform of the launch platform, either WINDOWS or LINUX.</p>
    pub platform: std::option::Option<crate::model::LaunchProfilePlatform>,
    /// <p>The system initializtion scripts.</p>
    pub system_initialization_scripts:
        std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
    /// <p>The user initializtion scripts.</p>
    pub user_initialization_scripts:
        std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
}
impl std::fmt::Debug for LaunchProfileInitialization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileInitialization");
        formatter.field("active_directory", &self.active_directory);
        formatter.field("ec2_security_group_ids", &self.ec2_security_group_ids);
        formatter.field("launch_profile_id", &self.launch_profile_id);
        formatter.field(
            "launch_profile_protocol_version",
            &self.launch_profile_protocol_version,
        );
        formatter.field("launch_purpose", &self.launch_purpose);
        formatter.field("name", &self.name);
        formatter.field("platform", &self.platform);
        formatter.field(
            "system_initialization_scripts",
            &self.system_initialization_scripts,
        );
        formatter.field(
            "user_initialization_scripts",
            &self.user_initialization_scripts,
        );
        formatter.finish()
    }
}
/// See [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization)
pub mod launch_profile_initialization {
    /// A builder for [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_directory:
            std::option::Option<crate::model::LaunchProfileInitializationActiveDirectory>,
        pub(crate) ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) launch_profile_id: std::option::Option<std::string::String>,
        pub(crate) launch_profile_protocol_version: std::option::Option<std::string::String>,
        pub(crate) launch_purpose: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<crate::model::LaunchProfilePlatform>,
        pub(crate) system_initialization_scripts:
            std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
        pub(crate) user_initialization_scripts:
            std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
    }
    impl Builder {
        /// <p>A LaunchProfileInitializationActiveDirectory resource.</p>
        pub fn active_directory(
            mut self,
            input: crate::model::LaunchProfileInitializationActiveDirectory,
        ) -> Self {
            self.active_directory = Some(input);
            self
        }
        pub fn set_active_directory(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileInitializationActiveDirectory>,
        ) -> Self {
            self.active_directory = input;
            self
        }
        pub fn ec2_security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ec2_security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.ec2_security_group_ids = Some(v);
            self
        }
        pub fn set_ec2_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ec2_security_group_ids = input;
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_profile_id = Some(input.into());
            self
        }
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_id = input;
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_version(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = Some(input.into());
            self
        }
        pub fn set_launch_profile_protocol_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = input;
            self
        }
        /// <p>The launch purpose.</p>
        pub fn launch_purpose(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_purpose = Some(input.into());
            self
        }
        pub fn set_launch_purpose(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_purpose = input;
            self
        }
        /// <p>The name for the launch profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The platform of the launch platform, either WINDOWS or LINUX.</p>
        pub fn platform(mut self, input: crate::model::LaunchProfilePlatform) -> Self {
            self.platform = Some(input);
            self
        }
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePlatform>,
        ) -> Self {
            self.platform = input;
            self
        }
        pub fn system_initialization_scripts(
            mut self,
            input: impl Into<crate::model::LaunchProfileInitializationScript>,
        ) -> Self {
            let mut v = self.system_initialization_scripts.unwrap_or_default();
            v.push(input.into());
            self.system_initialization_scripts = Some(v);
            self
        }
        pub fn set_system_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchProfileInitializationScript>,
            >,
        ) -> Self {
            self.system_initialization_scripts = input;
            self
        }
        pub fn user_initialization_scripts(
            mut self,
            input: impl Into<crate::model::LaunchProfileInitializationScript>,
        ) -> Self {
            let mut v = self.user_initialization_scripts.unwrap_or_default();
            v.push(input.into());
            self.user_initialization_scripts = Some(v);
            self
        }
        pub fn set_user_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchProfileInitializationScript>,
            >,
        ) -> Self {
            self.user_initialization_scripts = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization)
        pub fn build(self) -> crate::model::LaunchProfileInitialization {
            crate::model::LaunchProfileInitialization {
                active_directory: self.active_directory,
                ec2_security_group_ids: self.ec2_security_group_ids,
                launch_profile_id: self.launch_profile_id,
                launch_profile_protocol_version: self.launch_profile_protocol_version,
                launch_purpose: self.launch_purpose,
                name: self.name,
                platform: self.platform,
                system_initialization_scripts: self.system_initialization_scripts,
                user_initialization_scripts: self.user_initialization_scripts,
            }
        }
    }
}
impl LaunchProfileInitialization {
    /// Creates a new builder-style object to manufacture [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization)
    pub fn builder() -> crate::model::launch_profile_initialization::Builder {
        crate::model::launch_profile_initialization::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileInitializationScript {
    /// <p>The initialization script.</p>
    pub script: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The name for the studio component.</p>
    pub studio_component_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchProfileInitializationScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileInitializationScript");
        formatter.field("script", &self.script);
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("studio_component_name", &self.studio_component_name);
        formatter.finish()
    }
}
/// See [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript)
pub mod launch_profile_initialization_script {
    /// A builder for [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) script: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) studio_component_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The initialization script.</p>
        pub fn script(mut self, input: impl Into<std::string::String>) -> Self {
            self.script = Some(input.into());
            self
        }
        pub fn set_script(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.script = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn studio_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_name = Some(input.into());
            self
        }
        pub fn set_studio_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_name = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript)
        pub fn build(self) -> crate::model::LaunchProfileInitializationScript {
            crate::model::LaunchProfileInitializationScript {
                script: self.script,
                studio_component_id: self.studio_component_id,
                studio_component_name: self.studio_component_name,
            }
        }
    }
}
impl LaunchProfileInitializationScript {
    /// Creates a new builder-style object to manufacture [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript)
    pub fn builder() -> crate::model::launch_profile_initialization_script::Builder {
        crate::model::launch_profile_initialization_script::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileInitializationActiveDirectory {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    pub computer_attributes:
        std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
    /// <p>The directory ID of the AWS Directory Service for Microsoft AD to access using this launch profile.</p>
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The directory name.</p>
    pub directory_name: std::option::Option<std::string::String>,
    /// <p>The DNS IP address.</p>
    pub dns_ip_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name for the organizational unit distinguished name.</p>
    pub organizational_unit_distinguished_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The name for the studio component.</p>
    pub studio_component_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LaunchProfileInitializationActiveDirectory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileInitializationActiveDirectory");
        formatter.field("computer_attributes", &self.computer_attributes);
        formatter.field("directory_id", &self.directory_id);
        formatter.field("directory_name", &self.directory_name);
        formatter.field("dns_ip_addresses", &self.dns_ip_addresses);
        formatter.field(
            "organizational_unit_distinguished_name",
            &self.organizational_unit_distinguished_name,
        );
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("studio_component_name", &self.studio_component_name);
        formatter.finish()
    }
}
/// See [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory)
pub mod launch_profile_initialization_active_directory {
    /// A builder for [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computer_attributes:
            std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) directory_name: std::option::Option<std::string::String>,
        pub(crate) dns_ip_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) organizational_unit_distinguished_name: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) studio_component_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn computer_attributes(
            mut self,
            input: impl Into<crate::model::ActiveDirectoryComputerAttribute>,
        ) -> Self {
            let mut v = self.computer_attributes.unwrap_or_default();
            v.push(input.into());
            self.computer_attributes = Some(v);
            self
        }
        pub fn set_computer_attributes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>,
            >,
        ) -> Self {
            self.computer_attributes = input;
            self
        }
        /// <p>The directory ID of the AWS Directory Service for Microsoft AD to access using this launch profile.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>The directory name.</p>
        pub fn directory_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_name = Some(input.into());
            self
        }
        pub fn set_directory_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_name = input;
            self
        }
        pub fn dns_ip_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dns_ip_addresses.unwrap_or_default();
            v.push(input.into());
            self.dns_ip_addresses = Some(v);
            self
        }
        pub fn set_dns_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dns_ip_addresses = input;
            self
        }
        /// <p>The name for the organizational unit distinguished name.</p>
        pub fn organizational_unit_distinguished_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = Some(input.into());
            self
        }
        pub fn set_organizational_unit_distinguished_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn studio_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_name = Some(input.into());
            self
        }
        pub fn set_studio_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_name = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory)
        pub fn build(self) -> crate::model::LaunchProfileInitializationActiveDirectory {
            crate::model::LaunchProfileInitializationActiveDirectory {
                computer_attributes: self.computer_attributes,
                directory_id: self.directory_id,
                directory_name: self.directory_name,
                dns_ip_addresses: self.dns_ip_addresses,
                organizational_unit_distinguished_name: self.organizational_unit_distinguished_name,
                studio_component_id: self.studio_component_id,
                studio_component_name: self.studio_component_name,
            }
        }
    }
}
impl LaunchProfileInitializationActiveDirectory {
    /// Creates a new builder-style object to manufacture [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory)
    pub fn builder() -> crate::model::launch_profile_initialization_active_directory::Builder {
        crate::model::launch_profile_initialization_active_directory::Builder::default()
    }
}

/// <p></p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioComponentSummary {
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<smithy_types::Instant>,
    /// <p>The user ID of the user that created the studio component.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The name for the studio component.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The specific subtype of a studio component.</p>
    pub subtype: std::option::Option<crate::model::StudioComponentSubtype>,
    /// <p>The type of the studio component.</p>
    pub r#type: std::option::Option<crate::model::StudioComponentType>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<smithy_types::Instant>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub updated_by: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StudioComponentSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioComponentSummary");
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("description", &self.description);
        formatter.field("name", &self.name);
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("subtype", &self.subtype);
        formatter.field("r#type", &self.r#type);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.finish()
    }
}
/// See [`StudioComponentSummary`](crate::model::StudioComponentSummary)
pub mod studio_component_summary {
    /// A builder for [`StudioComponentSummary`](crate::model::StudioComponentSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) created_at: std::option::Option<smithy_types::Instant>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) subtype: std::option::Option<crate::model::StudioComponentSubtype>,
        pub(crate) r#type: std::option::Option<crate::model::StudioComponentType>,
        pub(crate) updated_at: std::option::Option<smithy_types::Instant>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: smithy_types::Instant) -> Self {
            self.created_at = Some(input);
            self
        }
        pub fn set_created_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the studio component.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn subtype(mut self, input: crate::model::StudioComponentSubtype) -> Self {
            self.subtype = Some(input);
            self
        }
        pub fn set_subtype(
            mut self,
            input: std::option::Option<crate::model::StudioComponentSubtype>,
        ) -> Self {
            self.subtype = input;
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn r#type(mut self, input: crate::model::StudioComponentType) -> Self {
            self.r#type = Some(input);
            self
        }
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StudioComponentType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: smithy_types::Instant) -> Self {
            self.updated_at = Some(input);
            self
        }
        pub fn set_updated_at(mut self, input: std::option::Option<smithy_types::Instant>) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioComponentSummary`](crate::model::StudioComponentSummary)
        pub fn build(self) -> crate::model::StudioComponentSummary {
            crate::model::StudioComponentSummary {
                created_at: self.created_at,
                created_by: self.created_by,
                description: self.description,
                name: self.name,
                studio_component_id: self.studio_component_id,
                subtype: self.subtype,
                r#type: self.r#type,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
            }
        }
    }
}
impl StudioComponentSummary {
    /// Creates a new builder-style object to manufacture [`StudioComponentSummary`](crate::model::StudioComponentSummary)
    pub fn builder() -> crate::model::studio_component_summary::Builder {
        crate::model::studio_component_summary::Builder::default()
    }
}
