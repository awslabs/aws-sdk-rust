// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents a studio resource.</p>
/// <p>A studio is the core resource used with Nimble Studio. You must create a studio first, before any other resource type can be created. All other resources you create and manage in Nimble Studio are contained within a studio.</p>
/// <p>When creating a studio, you must provides two IAM roles for use with the Nimble Studio portal. These roles are assumed by your users when they log in to the Nimble Studio portal via IAM Identity Center and your identity source.</p>
/// <p>The user role must have the <code>AmazonNimbleStudio-StudioUser</code> managed policy attached for the portal to function properly.</p>
/// <p>The admin role must have the <code>AmazonNimbleStudio-StudioAdmin</code> managed policy attached for the portal to function properly.</p>
/// <p>Your studio roles must trust the <code>identity.nimble.amazonaws.com</code> service principal to function properly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Studio {
    /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
    #[doc(hidden)]
    pub admin_role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A friendly name for the studio.</p>
    #[doc(hidden)]
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region where the studio resource is located.</p>
    #[doc(hidden)]
    pub home_region: std::option::Option<std::string::String>,
    /// <p>The IAM Identity Center application client ID used to integrate with IAM Identity Center. This ID allows IAM Identity Center users to log in to Nimble Studio portal.</p>
    #[doc(hidden)]
    pub sso_client_id: std::option::Option<std::string::String>,
    /// <p>The current state of the studio resource.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::StudioState>,
    /// <p>Status codes that provide additional detail on the studio state.</p>
    #[doc(hidden)]
    pub status_code: std::option::Option<crate::model::StudioStatusCode>,
    /// <p>Additional detail on the studio state.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Configuration of the encryption method that is used for the studio.</p>
    #[doc(hidden)]
    pub studio_encryption_configuration:
        std::option::Option<crate::model::StudioEncryptionConfiguration>,
    /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
    #[doc(hidden)]
    pub studio_id: std::option::Option<std::string::String>,
    /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
    #[doc(hidden)]
    pub studio_name: std::option::Option<std::string::String>,
    /// <p>The address of the web page for the studio.</p>
    #[doc(hidden)]
    pub studio_url: std::option::Option<std::string::String>,
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
    #[doc(hidden)]
    pub user_role_arn: std::option::Option<std::string::String>,
}
impl Studio {
    /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
    pub fn admin_role_arn(&self) -> std::option::Option<&str> {
        self.admin_role_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>A friendly name for the studio.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The Amazon Web Services Region where the studio resource is located.</p>
    pub fn home_region(&self) -> std::option::Option<&str> {
        self.home_region.as_deref()
    }
    /// <p>The IAM Identity Center application client ID used to integrate with IAM Identity Center. This ID allows IAM Identity Center users to log in to Nimble Studio portal.</p>
    pub fn sso_client_id(&self) -> std::option::Option<&str> {
        self.sso_client_id.as_deref()
    }
    /// <p>The current state of the studio resource.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StudioState> {
        self.state.as_ref()
    }
    /// <p>Status codes that provide additional detail on the studio state.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::StudioStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>Additional detail on the studio state.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>Configuration of the encryption method that is used for the studio.</p>
    pub fn studio_encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::StudioEncryptionConfiguration> {
        self.studio_encryption_configuration.as_ref()
    }
    /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
    pub fn studio_id(&self) -> std::option::Option<&str> {
        self.studio_id.as_deref()
    }
    /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
    pub fn studio_name(&self) -> std::option::Option<&str> {
        self.studio_name.as_deref()
    }
    /// <p>The address of the web page for the studio.</p>
    pub fn studio_url(&self) -> std::option::Option<&str> {
        self.studio_url.as_deref()
    }
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
    pub fn user_role_arn(&self) -> std::option::Option<&str> {
        self.user_role_arn.as_deref()
    }
}
impl std::fmt::Debug for Studio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Studio");
        formatter.field("admin_role_arn", &self.admin_role_arn);
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("display_name", &"*** Sensitive Data Redacted ***");
        formatter.field("home_region", &self.home_region);
        formatter.field("sso_client_id", &self.sso_client_id);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field(
            "studio_encryption_configuration",
            &self.studio_encryption_configuration,
        );
        formatter.field("studio_id", &self.studio_id);
        formatter.field("studio_name", &self.studio_name);
        formatter.field("studio_url", &self.studio_url);
        formatter.field("tags", &self.tags);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("user_role_arn", &self.user_role_arn);
        formatter.finish()
    }
}
impl Studio {
    /// Creates a new builder-style object to manufacture [`Studio`](crate::model::Studio).
    pub fn builder() -> crate::model::studio::Builder {
        crate::model::studio::Builder::default()
    }
}

/// See [`Studio`](crate::model::Studio).
pub mod studio {

    /// A builder for [`Studio`](crate::model::Studio).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) admin_role_arn: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) home_region: std::option::Option<std::string::String>,
        pub(crate) sso_client_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StudioState>,
        pub(crate) status_code: std::option::Option<crate::model::StudioStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) studio_encryption_configuration:
            std::option::Option<crate::model::StudioEncryptionConfiguration>,
        pub(crate) studio_id: std::option::Option<std::string::String>,
        pub(crate) studio_name: std::option::Option<std::string::String>,
        pub(crate) studio_url: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) user_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
        pub fn admin_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_role_arn = Some(input.into());
            self
        }
        /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
        pub fn set_admin_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.admin_role_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>A friendly name for the studio.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the studio.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The Amazon Web Services Region where the studio resource is located.</p>
        pub fn home_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.home_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region where the studio resource is located.</p>
        pub fn set_home_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.home_region = input;
            self
        }
        /// <p>The IAM Identity Center application client ID used to integrate with IAM Identity Center. This ID allows IAM Identity Center users to log in to Nimble Studio portal.</p>
        pub fn sso_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sso_client_id = Some(input.into());
            self
        }
        /// <p>The IAM Identity Center application client ID used to integrate with IAM Identity Center. This ID allows IAM Identity Center users to log in to Nimble Studio portal.</p>
        pub fn set_sso_client_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sso_client_id = input;
            self
        }
        /// <p>The current state of the studio resource.</p>
        pub fn state(mut self, input: crate::model::StudioState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the studio resource.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::StudioState>) -> Self {
            self.state = input;
            self
        }
        /// <p>Status codes that provide additional detail on the studio state.</p>
        pub fn status_code(mut self, input: crate::model::StudioStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>Status codes that provide additional detail on the studio state.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StudioStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>Additional detail on the studio state.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>Additional detail on the studio state.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>Configuration of the encryption method that is used for the studio.</p>
        pub fn studio_encryption_configuration(
            mut self,
            input: crate::model::StudioEncryptionConfiguration,
        ) -> Self {
            self.studio_encryption_configuration = Some(input);
            self
        }
        /// <p>Configuration of the encryption method that is used for the studio.</p>
        pub fn set_studio_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioEncryptionConfiguration>,
        ) -> Self {
            self.studio_encryption_configuration = input;
            self
        }
        /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.studio_id = input;
            self
        }
        /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
        pub fn studio_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_name = Some(input.into());
            self
        }
        /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
        pub fn set_studio_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.studio_name = input;
            self
        }
        /// <p>The address of the web page for the studio.</p>
        pub fn studio_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_url = Some(input.into());
            self
        }
        /// <p>The address of the web page for the studio.</p>
        pub fn set_studio_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.studio_url = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
        pub fn user_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_role_arn = Some(input.into());
            self
        }
        /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
        pub fn set_user_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Studio`](crate::model::Studio).
        pub fn build(self) -> crate::model::Studio {
            crate::model::Studio {
                admin_role_arn: self.admin_role_arn,
                arn: self.arn,
                created_at: self.created_at,
                display_name: self.display_name,
                home_region: self.home_region,
                sso_client_id: self.sso_client_id,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                studio_encryption_configuration: self.studio_encryption_configuration,
                studio_id: self.studio_id,
                studio_name: self.studio_name,
                studio_url: self.studio_url,
                tags: self.tags,
                updated_at: self.updated_at,
                user_role_arn: self.user_role_arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("admin_role_arn", &self.admin_role_arn);
            formatter.field("arn", &self.arn);
            formatter.field("created_at", &self.created_at);
            formatter.field("display_name", &"*** Sensitive Data Redacted ***");
            formatter.field("home_region", &self.home_region);
            formatter.field("sso_client_id", &self.sso_client_id);
            formatter.field("state", &self.state);
            formatter.field("status_code", &self.status_code);
            formatter.field("status_message", &self.status_message);
            formatter.field(
                "studio_encryption_configuration",
                &self.studio_encryption_configuration,
            );
            formatter.field("studio_id", &self.studio_id);
            formatter.field("studio_name", &self.studio_name);
            formatter.field("studio_url", &self.studio_url);
            formatter.field("tags", &self.tags);
            formatter.field("updated_at", &self.updated_at);
            formatter.field("user_role_arn", &self.user_role_arn);
            formatter.finish()
        }
    }
}

/// <p>Configuration of the encryption method that is used for the studio.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StudioEncryptionConfiguration {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    #[doc(hidden)]
    pub key_arn: std::option::Option<std::string::String>,
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    #[doc(hidden)]
    pub key_type: std::option::Option<crate::model::StudioEncryptionConfigurationKeyType>,
}
impl StudioEncryptionConfiguration {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    pub fn key_arn(&self) -> std::option::Option<&str> {
        self.key_arn.as_deref()
    }
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    pub fn key_type(
        &self,
    ) -> std::option::Option<&crate::model::StudioEncryptionConfigurationKeyType> {
        self.key_type.as_ref()
    }
}
impl StudioEncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration).
    pub fn builder() -> crate::model::studio_encryption_configuration::Builder {
        crate::model::studio_encryption_configuration::Builder::default()
    }
}

/// See [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration).
pub mod studio_encryption_configuration {

    /// A builder for [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_arn: std::option::Option<std::string::String>,
        pub(crate) key_type:
            std::option::Option<crate::model::StudioEncryptionConfigurationKeyType>,
    }
    impl Builder {
        /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        pub fn key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_arn = Some(input.into());
            self
        }
        /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        pub fn set_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_arn = input;
            self
        }
        /// <p>The type of KMS key that is used to encrypt studio data.</p>
        pub fn key_type(
            mut self,
            input: crate::model::StudioEncryptionConfigurationKeyType,
        ) -> Self {
            self.key_type = Some(input);
            self
        }
        /// <p>The type of KMS key that is used to encrypt studio data.</p>
        pub fn set_key_type(
            mut self,
            input: std::option::Option<crate::model::StudioEncryptionConfigurationKeyType>,
        ) -> Self {
            self.key_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration).
        pub fn build(self) -> crate::model::StudioEncryptionConfiguration {
            crate::model::StudioEncryptionConfiguration {
                key_arn: self.key_arn,
                key_type: self.key_type,
            }
        }
    }
}

/// When writing a match expression against `StudioEncryptionConfigurationKeyType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let studioencryptionconfigurationkeytype = unimplemented!();
/// match studioencryptionconfigurationkeytype {
///     StudioEncryptionConfigurationKeyType::AwsOwnedKey => { /* ... */ },
///     StudioEncryptionConfigurationKeyType::CustomerManagedKey => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `studioencryptionconfigurationkeytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StudioEncryptionConfigurationKeyType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StudioEncryptionConfigurationKeyType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StudioEncryptionConfigurationKeyType::NewFeature` is defined.
/// Specifically, when `studioencryptionconfigurationkeytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StudioEncryptionConfigurationKeyType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The type of KMS key that is used to encrypt studio data.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioEncryptionConfigurationKeyType {
    #[allow(missing_docs)] // documentation missing in model
    AwsOwnedKey,
    #[allow(missing_docs)] // documentation missing in model
    CustomerManagedKey,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StudioEncryptionConfigurationKeyType {
    fn from(s: &str) -> Self {
        match s {
            "AWS_OWNED_KEY" => StudioEncryptionConfigurationKeyType::AwsOwnedKey,
            "CUSTOMER_MANAGED_KEY" => StudioEncryptionConfigurationKeyType::CustomerManagedKey,
            other => StudioEncryptionConfigurationKeyType::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for StudioEncryptionConfigurationKeyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioEncryptionConfigurationKeyType::from(s))
    }
}
impl StudioEncryptionConfigurationKeyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioEncryptionConfigurationKeyType::AwsOwnedKey => "AWS_OWNED_KEY",
            StudioEncryptionConfigurationKeyType::CustomerManagedKey => "CUSTOMER_MANAGED_KEY",
            StudioEncryptionConfigurationKeyType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AWS_OWNED_KEY", "CUSTOMER_MANAGED_KEY"]
    }
}
impl AsRef<str> for StudioEncryptionConfigurationKeyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StudioStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let studiostatuscode = unimplemented!();
/// match studiostatuscode {
///     StudioStatusCode::AwsSsoAccessDenied => { /* ... */ },
///     StudioStatusCode::AwsSsoConfigurationRepaired => { /* ... */ },
///     StudioStatusCode::AwsSsoConfigurationRepairInProgress => { /* ... */ },
///     StudioStatusCode::AwsSsoNotEnabled => { /* ... */ },
///     StudioStatusCode::AwsStsRegionDisabled => { /* ... */ },
///     StudioStatusCode::EncryptionKeyAccessDenied => { /* ... */ },
///     StudioStatusCode::EncryptionKeyNotFound => { /* ... */ },
///     StudioStatusCode::InternalError => { /* ... */ },
///     StudioStatusCode::RoleCouldNotBeAssumed => { /* ... */ },
///     StudioStatusCode::RoleNotOwnedByStudioOwner => { /* ... */ },
///     StudioStatusCode::StudioCreated => { /* ... */ },
///     StudioStatusCode::StudioCreateInProgress => { /* ... */ },
///     StudioStatusCode::StudioDeleted => { /* ... */ },
///     StudioStatusCode::StudioDeleteInProgress => { /* ... */ },
///     StudioStatusCode::StudioUpdated => { /* ... */ },
///     StudioStatusCode::StudioUpdateInProgress => { /* ... */ },
///     StudioStatusCode::StudioWithLaunchProfilesNotDeleted => { /* ... */ },
///     StudioStatusCode::StudioWithStreamingImagesNotDeleted => { /* ... */ },
///     StudioStatusCode::StudioWithStudioComponentsNotDeleted => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `studiostatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StudioStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StudioStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StudioStatusCode::NewFeature` is defined.
/// Specifically, when `studiostatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StudioStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The status code.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    AwsSsoAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    AwsSsoConfigurationRepaired,
    #[allow(missing_docs)] // documentation missing in model
    AwsSsoConfigurationRepairInProgress,
    #[allow(missing_docs)] // documentation missing in model
    AwsSsoNotEnabled,
    #[allow(missing_docs)] // documentation missing in model
    AwsStsRegionDisabled,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyNotFound,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    RoleCouldNotBeAssumed,
    #[allow(missing_docs)] // documentation missing in model
    RoleNotOwnedByStudioOwner,
    #[allow(missing_docs)] // documentation missing in model
    StudioCreated,
    #[allow(missing_docs)] // documentation missing in model
    StudioCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StudioDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StudioDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StudioUpdated,
    #[allow(missing_docs)] // documentation missing in model
    StudioUpdateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StudioWithLaunchProfilesNotDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StudioWithStreamingImagesNotDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StudioWithStudioComponentsNotDeleted,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StudioStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "AWS_SSO_ACCESS_DENIED" => StudioStatusCode::AwsSsoAccessDenied,
            "AWS_SSO_CONFIGURATION_REPAIRED" => StudioStatusCode::AwsSsoConfigurationRepaired,
            "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS" => {
                StudioStatusCode::AwsSsoConfigurationRepairInProgress
            }
            "AWS_SSO_NOT_ENABLED" => StudioStatusCode::AwsSsoNotEnabled,
            "AWS_STS_REGION_DISABLED" => StudioStatusCode::AwsStsRegionDisabled,
            "ENCRYPTION_KEY_ACCESS_DENIED" => StudioStatusCode::EncryptionKeyAccessDenied,
            "ENCRYPTION_KEY_NOT_FOUND" => StudioStatusCode::EncryptionKeyNotFound,
            "INTERNAL_ERROR" => StudioStatusCode::InternalError,
            "ROLE_COULD_NOT_BE_ASSUMED" => StudioStatusCode::RoleCouldNotBeAssumed,
            "ROLE_NOT_OWNED_BY_STUDIO_OWNER" => StudioStatusCode::RoleNotOwnedByStudioOwner,
            "STUDIO_CREATED" => StudioStatusCode::StudioCreated,
            "STUDIO_CREATE_IN_PROGRESS" => StudioStatusCode::StudioCreateInProgress,
            "STUDIO_DELETED" => StudioStatusCode::StudioDeleted,
            "STUDIO_DELETE_IN_PROGRESS" => StudioStatusCode::StudioDeleteInProgress,
            "STUDIO_UPDATED" => StudioStatusCode::StudioUpdated,
            "STUDIO_UPDATE_IN_PROGRESS" => StudioStatusCode::StudioUpdateInProgress,
            "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED" => {
                StudioStatusCode::StudioWithLaunchProfilesNotDeleted
            }
            "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED" => {
                StudioStatusCode::StudioWithStreamingImagesNotDeleted
            }
            "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED" => {
                StudioStatusCode::StudioWithStudioComponentsNotDeleted
            }
            other => StudioStatusCode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StudioStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioStatusCode::from(s))
    }
}
impl StudioStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioStatusCode::AwsSsoAccessDenied => "AWS_SSO_ACCESS_DENIED",
            StudioStatusCode::AwsSsoConfigurationRepaired => "AWS_SSO_CONFIGURATION_REPAIRED",
            StudioStatusCode::AwsSsoConfigurationRepairInProgress => {
                "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
            }
            StudioStatusCode::AwsSsoNotEnabled => "AWS_SSO_NOT_ENABLED",
            StudioStatusCode::AwsStsRegionDisabled => "AWS_STS_REGION_DISABLED",
            StudioStatusCode::EncryptionKeyAccessDenied => "ENCRYPTION_KEY_ACCESS_DENIED",
            StudioStatusCode::EncryptionKeyNotFound => "ENCRYPTION_KEY_NOT_FOUND",
            StudioStatusCode::InternalError => "INTERNAL_ERROR",
            StudioStatusCode::RoleCouldNotBeAssumed => "ROLE_COULD_NOT_BE_ASSUMED",
            StudioStatusCode::RoleNotOwnedByStudioOwner => "ROLE_NOT_OWNED_BY_STUDIO_OWNER",
            StudioStatusCode::StudioCreated => "STUDIO_CREATED",
            StudioStatusCode::StudioCreateInProgress => "STUDIO_CREATE_IN_PROGRESS",
            StudioStatusCode::StudioDeleted => "STUDIO_DELETED",
            StudioStatusCode::StudioDeleteInProgress => "STUDIO_DELETE_IN_PROGRESS",
            StudioStatusCode::StudioUpdated => "STUDIO_UPDATED",
            StudioStatusCode::StudioUpdateInProgress => "STUDIO_UPDATE_IN_PROGRESS",
            StudioStatusCode::StudioWithLaunchProfilesNotDeleted => {
                "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
            }
            StudioStatusCode::StudioWithStreamingImagesNotDeleted => {
                "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
            }
            StudioStatusCode::StudioWithStudioComponentsNotDeleted => {
                "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
            }
            StudioStatusCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AWS_SSO_ACCESS_DENIED",
            "AWS_SSO_CONFIGURATION_REPAIRED",
            "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS",
            "AWS_SSO_NOT_ENABLED",
            "AWS_STS_REGION_DISABLED",
            "ENCRYPTION_KEY_ACCESS_DENIED",
            "ENCRYPTION_KEY_NOT_FOUND",
            "INTERNAL_ERROR",
            "ROLE_COULD_NOT_BE_ASSUMED",
            "ROLE_NOT_OWNED_BY_STUDIO_OWNER",
            "STUDIO_CREATED",
            "STUDIO_CREATE_IN_PROGRESS",
            "STUDIO_DELETED",
            "STUDIO_DELETE_IN_PROGRESS",
            "STUDIO_UPDATED",
            "STUDIO_UPDATE_IN_PROGRESS",
            "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED",
            "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED",
            "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED",
        ]
    }
}
impl AsRef<str> for StudioStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StudioState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let studiostate = unimplemented!();
/// match studiostate {
///     StudioState::CreateFailed => { /* ... */ },
///     StudioState::CreateInProgress => { /* ... */ },
///     StudioState::Deleted => { /* ... */ },
///     StudioState::DeleteFailed => { /* ... */ },
///     StudioState::DeleteInProgress => { /* ... */ },
///     StudioState::Ready => { /* ... */ },
///     StudioState::UpdateFailed => { /* ... */ },
///     StudioState::UpdateInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `studiostate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StudioState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StudioState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StudioState::NewFeature` is defined.
/// Specifically, when `studiostate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StudioState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StudioState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StudioState::CreateFailed,
            "CREATE_IN_PROGRESS" => StudioState::CreateInProgress,
            "DELETED" => StudioState::Deleted,
            "DELETE_FAILED" => StudioState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StudioState::DeleteInProgress,
            "READY" => StudioState::Ready,
            "UPDATE_FAILED" => StudioState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => StudioState::UpdateInProgress,
            other => StudioState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StudioState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioState::from(s))
    }
}
impl StudioState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioState::CreateFailed => "CREATE_FAILED",
            StudioState::CreateInProgress => "CREATE_IN_PROGRESS",
            StudioState::Deleted => "DELETED",
            StudioState::DeleteFailed => "DELETE_FAILED",
            StudioState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StudioState::Ready => "READY",
            StudioState::UpdateFailed => "UPDATE_FAILED",
            StudioState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            StudioState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StudioState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A new studio user's membership.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NewStudioMember {
    /// <p>The persona.</p>
    #[doc(hidden)]
    pub persona: std::option::Option<crate::model::StudioPersona>,
    /// <p>The principal ID.</p>
    #[doc(hidden)]
    pub principal_id: std::option::Option<std::string::String>,
}
impl NewStudioMember {
    /// <p>The persona.</p>
    pub fn persona(&self) -> std::option::Option<&crate::model::StudioPersona> {
        self.persona.as_ref()
    }
    /// <p>The principal ID.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
}
impl NewStudioMember {
    /// Creates a new builder-style object to manufacture [`NewStudioMember`](crate::model::NewStudioMember).
    pub fn builder() -> crate::model::new_studio_member::Builder {
        crate::model::new_studio_member::Builder::default()
    }
}

/// See [`NewStudioMember`](crate::model::NewStudioMember).
pub mod new_studio_member {

    /// A builder for [`NewStudioMember`](crate::model::NewStudioMember).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) persona: std::option::Option<crate::model::StudioPersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::StudioPersona) -> Self {
            self.persona = Some(input);
            self
        }
        /// <p>The persona.</p>
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::StudioPersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NewStudioMember`](crate::model::NewStudioMember).
        pub fn build(self) -> crate::model::NewStudioMember {
            crate::model::NewStudioMember {
                persona: self.persona,
                principal_id: self.principal_id,
            }
        }
    }
}

/// When writing a match expression against `StudioPersona`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let studiopersona = unimplemented!();
/// match studiopersona {
///     StudioPersona::Administrator => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `studiopersona` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StudioPersona::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StudioPersona::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StudioPersona::NewFeature` is defined.
/// Specifically, when `studiopersona` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StudioPersona::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioPersona {
    #[allow(missing_docs)] // documentation missing in model
    Administrator,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StudioPersona {
    fn from(s: &str) -> Self {
        match s {
            "ADMINISTRATOR" => StudioPersona::Administrator,
            other => StudioPersona::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for StudioPersona {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioPersona::from(s))
    }
}
impl StudioPersona {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioPersona::Administrator => "ADMINISTRATOR",
            StudioPersona::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ADMINISTRATOR"]
    }
}
impl AsRef<str> for StudioPersona {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A studio member is an association of a user from your studio identity source to elevated permissions that they are granted in the studio.</p>
/// <p>When you add a user to your studio using the Nimble Studio console, they are given access to the studio's IAM Identity Center application and are given access to log in to the Nimble Studio portal. These users have the permissions provided by the studio's user IAM role and do not appear in the studio membership collection. Only studio admins appear in studio membership.</p>
/// <p>When you add a user to studio membership with the ADMIN persona, upon logging in to the Nimble Studio portal, they are granted permissions specified by the Studio's Admin IAM role.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StudioMembership {
    /// <p>The ID of the identity store.</p>
    #[doc(hidden)]
    pub identity_store_id: std::option::Option<std::string::String>,
    /// <p>The persona.</p>
    #[doc(hidden)]
    pub persona: std::option::Option<crate::model::StudioPersona>,
    /// <p>The principal ID.</p>
    #[doc(hidden)]
    pub principal_id: std::option::Option<std::string::String>,
    /// <p>The Active Directory Security Identifier for this user, if available.</p>
    #[doc(hidden)]
    pub sid: std::option::Option<std::string::String>,
}
impl StudioMembership {
    /// <p>The ID of the identity store.</p>
    pub fn identity_store_id(&self) -> std::option::Option<&str> {
        self.identity_store_id.as_deref()
    }
    /// <p>The persona.</p>
    pub fn persona(&self) -> std::option::Option<&crate::model::StudioPersona> {
        self.persona.as_ref()
    }
    /// <p>The principal ID.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
    /// <p>The Active Directory Security Identifier for this user, if available.</p>
    pub fn sid(&self) -> std::option::Option<&str> {
        self.sid.as_deref()
    }
}
impl StudioMembership {
    /// Creates a new builder-style object to manufacture [`StudioMembership`](crate::model::StudioMembership).
    pub fn builder() -> crate::model::studio_membership::Builder {
        crate::model::studio_membership::Builder::default()
    }
}

/// See [`StudioMembership`](crate::model::StudioMembership).
pub mod studio_membership {

    /// A builder for [`StudioMembership`](crate::model::StudioMembership).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_store_id: std::option::Option<std::string::String>,
        pub(crate) persona: std::option::Option<crate::model::StudioPersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
        pub(crate) sid: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_store_id = Some(input.into());
            self
        }
        /// <p>The ID of the identity store.</p>
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_store_id = input;
            self
        }
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::StudioPersona) -> Self {
            self.persona = Some(input);
            self
        }
        /// <p>The persona.</p>
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::StudioPersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// <p>The Active Directory Security Identifier for this user, if available.</p>
        pub fn sid(mut self, input: impl Into<std::string::String>) -> Self {
            self.sid = Some(input.into());
            self
        }
        /// <p>The Active Directory Security Identifier for this user, if available.</p>
        pub fn set_sid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sid = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioMembership`](crate::model::StudioMembership).
        pub fn build(self) -> crate::model::StudioMembership {
            crate::model::StudioMembership {
                identity_store_id: self.identity_store_id,
                persona: self.persona,
                principal_id: self.principal_id,
                sid: self.sid,
            }
        }
    }
}

/// <p>A studio component represents a network resource to be used by a studio's users and workflows. A typical studio contains studio components for each of the following: render farm, Active Directory, licensing, and file system.</p>
/// <p>Access to a studio component is managed by specifying security groups for the resource, as well as its endpoint.</p>
/// <p>A studio component also has a set of initialization scripts that are returned by <code>GetLaunchProfileInitialization</code>. These initialization scripts run on streaming sessions when they start. They provide users with flexibility in controlling how the studio resources are configured on a streaming session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioComponent {
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The configuration of the studio component, based on component type.</p>
    #[doc(hidden)]
    pub configuration: std::option::Option<crate::model::StudioComponentConfiguration>,
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that created the studio component.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>A human-readable description for the studio component resource.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The EC2 security groups that control access to the studio component.</p>
    #[doc(hidden)]
    pub ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Initialization scripts for studio components.</p>
    #[doc(hidden)]
    pub initialization_scripts:
        std::option::Option<std::vec::Vec<crate::model::StudioComponentInitializationScript>>,
    /// <p>A friendly name for the studio component resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Parameters for the studio component scripts.</p>
    #[doc(hidden)]
    pub script_parameters:
        std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
    /// <p>The current state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::StudioComponentState>,
    /// <p>The status code.</p>
    #[doc(hidden)]
    pub status_code: std::option::Option<crate::model::StudioComponentStatusCode>,
    /// <p>The status message for the studio component.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    #[doc(hidden)]
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The specific subtype of a studio component.</p>
    #[doc(hidden)]
    pub subtype: std::option::Option<crate::model::StudioComponentSubtype>,
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The type of the studio component.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::StudioComponentType>,
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    #[doc(hidden)]
    pub updated_by: std::option::Option<std::string::String>,
    /// <p>An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.</p>
    #[doc(hidden)]
    pub secure_initialization_role_arn: std::option::Option<std::string::String>,
    /// <p>An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running. </p>
    #[doc(hidden)]
    pub runtime_role_arn: std::option::Option<std::string::String>,
}
impl StudioComponent {
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The configuration of the studio component, based on component type.</p>
    pub fn configuration(
        &self,
    ) -> std::option::Option<&crate::model::StudioComponentConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The user ID of the user that created the studio component.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>A human-readable description for the studio component resource.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The EC2 security groups that control access to the studio component.</p>
    pub fn ec2_security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.ec2_security_group_ids.as_deref()
    }
    /// <p>Initialization scripts for studio components.</p>
    pub fn initialization_scripts(
        &self,
    ) -> std::option::Option<&[crate::model::StudioComponentInitializationScript]> {
        self.initialization_scripts.as_deref()
    }
    /// <p>A friendly name for the studio component resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Parameters for the studio component scripts.</p>
    pub fn script_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::ScriptParameterKeyValue]> {
        self.script_parameters.as_deref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StudioComponentState> {
        self.state.as_ref()
    }
    /// <p>The status code.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::StudioComponentStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the studio component.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The unique identifier for a studio component resource.</p>
    pub fn studio_component_id(&self) -> std::option::Option<&str> {
        self.studio_component_id.as_deref()
    }
    /// <p>The specific subtype of a studio component.</p>
    pub fn subtype(&self) -> std::option::Option<&crate::model::StudioComponentSubtype> {
        self.subtype.as_ref()
    }
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The type of the studio component.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::StudioComponentType> {
        self.r#type.as_ref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub fn updated_by(&self) -> std::option::Option<&str> {
        self.updated_by.as_deref()
    }
    /// <p>An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.</p>
    pub fn secure_initialization_role_arn(&self) -> std::option::Option<&str> {
        self.secure_initialization_role_arn.as_deref()
    }
    /// <p>An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running. </p>
    pub fn runtime_role_arn(&self) -> std::option::Option<&str> {
        self.runtime_role_arn.as_deref()
    }
}
impl std::fmt::Debug for StudioComponent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioComponent");
        formatter.field("arn", &self.arn);
        formatter.field("configuration", &self.configuration);
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("ec2_security_group_ids", &self.ec2_security_group_ids);
        formatter.field("initialization_scripts", &self.initialization_scripts);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("script_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("subtype", &self.subtype);
        formatter.field("tags", &self.tags);
        formatter.field("r#type", &self.r#type);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.field(
            "secure_initialization_role_arn",
            &self.secure_initialization_role_arn,
        );
        formatter.field("runtime_role_arn", &self.runtime_role_arn);
        formatter.finish()
    }
}
impl StudioComponent {
    /// Creates a new builder-style object to manufacture [`StudioComponent`](crate::model::StudioComponent).
    pub fn builder() -> crate::model::studio_component::Builder {
        crate::model::studio_component::Builder::default()
    }
}

/// See [`StudioComponent`](crate::model::StudioComponent).
pub mod studio_component {

    /// A builder for [`StudioComponent`](crate::model::StudioComponent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) configuration: std::option::Option<crate::model::StudioComponentConfiguration>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) initialization_scripts:
            std::option::Option<std::vec::Vec<crate::model::StudioComponentInitializationScript>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) script_parameters:
            std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
        pub(crate) state: std::option::Option<crate::model::StudioComponentState>,
        pub(crate) status_code: std::option::Option<crate::model::StudioComponentStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) subtype: std::option::Option<crate::model::StudioComponentSubtype>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) r#type: std::option::Option<crate::model::StudioComponentType>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
        pub(crate) secure_initialization_role_arn: std::option::Option<std::string::String>,
        pub(crate) runtime_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The configuration of the studio component, based on component type.</p>
        pub fn configuration(mut self, input: crate::model::StudioComponentConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration of the studio component, based on component type.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioComponentConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the studio component.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that created the studio component.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>A human-readable description for the studio component resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A human-readable description for the studio component resource.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `ec2_security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_ec2_security_group_ids`](Self::set_ec2_security_group_ids).
        ///
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn ec2_security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ec2_security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.ec2_security_group_ids = Some(v);
            self
        }
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn set_ec2_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ec2_security_group_ids = input;
            self
        }
        /// Appends an item to `initialization_scripts`.
        ///
        /// To override the contents of this collection use [`set_initialization_scripts`](Self::set_initialization_scripts).
        ///
        /// <p>Initialization scripts for studio components.</p>
        pub fn initialization_scripts(
            mut self,
            input: crate::model::StudioComponentInitializationScript,
        ) -> Self {
            let mut v = self.initialization_scripts.unwrap_or_default();
            v.push(input);
            self.initialization_scripts = Some(v);
            self
        }
        /// <p>Initialization scripts for studio components.</p>
        pub fn set_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::StudioComponentInitializationScript>,
            >,
        ) -> Self {
            self.initialization_scripts = input;
            self
        }
        /// <p>A friendly name for the studio component resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A friendly name for the studio component resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `script_parameters`.
        ///
        /// To override the contents of this collection use [`set_script_parameters`](Self::set_script_parameters).
        ///
        /// <p>Parameters for the studio component scripts.</p>
        pub fn script_parameters(mut self, input: crate::model::ScriptParameterKeyValue) -> Self {
            let mut v = self.script_parameters.unwrap_or_default();
            v.push(input);
            self.script_parameters = Some(v);
            self
        }
        /// <p>Parameters for the studio component scripts.</p>
        pub fn set_script_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
        ) -> Self {
            self.script_parameters = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StudioComponentState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StudioComponentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::StudioComponentStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StudioComponentStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the studio component.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the studio component.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn subtype(mut self, input: crate::model::StudioComponentSubtype) -> Self {
            self.subtype = Some(input);
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn set_subtype(
            mut self,
            input: std::option::Option<crate::model::StudioComponentSubtype>,
        ) -> Self {
            self.subtype = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn r#type(mut self, input: crate::model::StudioComponentType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StudioComponentType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// <p>An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.</p>
        pub fn secure_initialization_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.secure_initialization_role_arn = Some(input.into());
            self
        }
        /// <p>An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.</p>
        pub fn set_secure_initialization_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.secure_initialization_role_arn = input;
            self
        }
        /// <p>An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running. </p>
        pub fn runtime_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.runtime_role_arn = Some(input.into());
            self
        }
        /// <p>An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running. </p>
        pub fn set_runtime_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.runtime_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioComponent`](crate::model::StudioComponent).
        pub fn build(self) -> crate::model::StudioComponent {
            crate::model::StudioComponent {
                arn: self.arn,
                configuration: self.configuration,
                created_at: self.created_at,
                created_by: self.created_by,
                description: self.description,
                ec2_security_group_ids: self.ec2_security_group_ids,
                initialization_scripts: self.initialization_scripts,
                name: self.name,
                script_parameters: self.script_parameters,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                studio_component_id: self.studio_component_id,
                subtype: self.subtype,
                tags: self.tags,
                r#type: self.r#type,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
                secure_initialization_role_arn: self.secure_initialization_role_arn,
                runtime_role_arn: self.runtime_role_arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("arn", &self.arn);
            formatter.field("configuration", &self.configuration);
            formatter.field("created_at", &self.created_at);
            formatter.field("created_by", &self.created_by);
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("ec2_security_group_ids", &self.ec2_security_group_ids);
            formatter.field("initialization_scripts", &self.initialization_scripts);
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("script_parameters", &"*** Sensitive Data Redacted ***");
            formatter.field("state", &self.state);
            formatter.field("status_code", &self.status_code);
            formatter.field("status_message", &self.status_message);
            formatter.field("studio_component_id", &self.studio_component_id);
            formatter.field("subtype", &self.subtype);
            formatter.field("tags", &self.tags);
            formatter.field("r#type", &self.r#type);
            formatter.field("updated_at", &self.updated_at);
            formatter.field("updated_by", &self.updated_by);
            formatter.field(
                "secure_initialization_role_arn",
                &self.secure_initialization_role_arn,
            );
            formatter.field("runtime_role_arn", &self.runtime_role_arn);
            formatter.finish()
        }
    }
}

/// When writing a match expression against `StudioComponentType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let studiocomponenttype = unimplemented!();
/// match studiocomponenttype {
///     StudioComponentType::ActiveDirectory => { /* ... */ },
///     StudioComponentType::ComputeFarm => { /* ... */ },
///     StudioComponentType::Custom => { /* ... */ },
///     StudioComponentType::LicenseService => { /* ... */ },
///     StudioComponentType::SharedFileSystem => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `studiocomponenttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StudioComponentType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StudioComponentType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StudioComponentType::NewFeature` is defined.
/// Specifically, when `studiocomponenttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StudioComponentType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentType {
    #[allow(missing_docs)] // documentation missing in model
    ActiveDirectory,
    #[allow(missing_docs)] // documentation missing in model
    ComputeFarm,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    LicenseService,
    #[allow(missing_docs)] // documentation missing in model
    SharedFileSystem,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StudioComponentType {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_DIRECTORY" => StudioComponentType::ActiveDirectory,
            "COMPUTE_FARM" => StudioComponentType::ComputeFarm,
            "CUSTOM" => StudioComponentType::Custom,
            "LICENSE_SERVICE" => StudioComponentType::LicenseService,
            "SHARED_FILE_SYSTEM" => StudioComponentType::SharedFileSystem,
            other => {
                StudioComponentType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StudioComponentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentType::from(s))
    }
}
impl StudioComponentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentType::ActiveDirectory => "ACTIVE_DIRECTORY",
            StudioComponentType::ComputeFarm => "COMPUTE_FARM",
            StudioComponentType::Custom => "CUSTOM",
            StudioComponentType::LicenseService => "LICENSE_SERVICE",
            StudioComponentType::SharedFileSystem => "SHARED_FILE_SYSTEM",
            StudioComponentType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE_DIRECTORY",
            "COMPUTE_FARM",
            "CUSTOM",
            "LICENSE_SERVICE",
            "SHARED_FILE_SYSTEM",
        ]
    }
}
impl AsRef<str> for StudioComponentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StudioComponentSubtype`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let studiocomponentsubtype = unimplemented!();
/// match studiocomponentsubtype {
///     StudioComponentSubtype::AmazonFsxForLustre => { /* ... */ },
///     StudioComponentSubtype::AmazonFsxForWindows => { /* ... */ },
///     StudioComponentSubtype::AwsManagedMicrosoftAd => { /* ... */ },
///     StudioComponentSubtype::Custom => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `studiocomponentsubtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StudioComponentSubtype::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StudioComponentSubtype::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StudioComponentSubtype::NewFeature` is defined.
/// Specifically, when `studiocomponentsubtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StudioComponentSubtype::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentSubtype {
    #[allow(missing_docs)] // documentation missing in model
    AmazonFsxForLustre,
    #[allow(missing_docs)] // documentation missing in model
    AmazonFsxForWindows,
    #[allow(missing_docs)] // documentation missing in model
    AwsManagedMicrosoftAd,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StudioComponentSubtype {
    fn from(s: &str) -> Self {
        match s {
            "AMAZON_FSX_FOR_LUSTRE" => StudioComponentSubtype::AmazonFsxForLustre,
            "AMAZON_FSX_FOR_WINDOWS" => StudioComponentSubtype::AmazonFsxForWindows,
            "AWS_MANAGED_MICROSOFT_AD" => StudioComponentSubtype::AwsManagedMicrosoftAd,
            "CUSTOM" => StudioComponentSubtype::Custom,
            other => {
                StudioComponentSubtype::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StudioComponentSubtype {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentSubtype::from(s))
    }
}
impl StudioComponentSubtype {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentSubtype::AmazonFsxForLustre => "AMAZON_FSX_FOR_LUSTRE",
            StudioComponentSubtype::AmazonFsxForWindows => "AMAZON_FSX_FOR_WINDOWS",
            StudioComponentSubtype::AwsManagedMicrosoftAd => "AWS_MANAGED_MICROSOFT_AD",
            StudioComponentSubtype::Custom => "CUSTOM",
            StudioComponentSubtype::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AMAZON_FSX_FOR_LUSTRE",
            "AMAZON_FSX_FOR_WINDOWS",
            "AWS_MANAGED_MICROSOFT_AD",
            "CUSTOM",
        ]
    }
}
impl AsRef<str> for StudioComponentSubtype {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StudioComponentStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let studiocomponentstatuscode = unimplemented!();
/// match studiocomponentstatuscode {
///     StudioComponentStatusCode::ActiveDirectoryAlreadyExists => { /* ... */ },
///     StudioComponentStatusCode::EncryptionKeyAccessDenied => { /* ... */ },
///     StudioComponentStatusCode::EncryptionKeyNotFound => { /* ... */ },
///     StudioComponentStatusCode::InternalError => { /* ... */ },
///     StudioComponentStatusCode::StudioComponentCreated => { /* ... */ },
///     StudioComponentStatusCode::StudioComponentCreateInProgress => { /* ... */ },
///     StudioComponentStatusCode::StudioComponentDeleted => { /* ... */ },
///     StudioComponentStatusCode::StudioComponentDeleteInProgress => { /* ... */ },
///     StudioComponentStatusCode::StudioComponentUpdated => { /* ... */ },
///     StudioComponentStatusCode::StudioComponentUpdateInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `studiocomponentstatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StudioComponentStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StudioComponentStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StudioComponentStatusCode::NewFeature` is defined.
/// Specifically, when `studiocomponentstatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StudioComponentStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The current status of the studio component resource.</p>
/// <p>When the resource is in the <code>READY</code> state, the status code signals what the
/// last mutation made to the resource was.</p>
/// <p>When the resource is in a <code>CREATE_FAILED</code>, <code>UPDATE_FAILED</code>, or
/// <code>DELETE_FAILED</code> state, the status code signals what went wrong and why
/// the mutation failed.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    ActiveDirectoryAlreadyExists,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyNotFound,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentCreated,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentUpdated,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentUpdateInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StudioComponentStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_DIRECTORY_ALREADY_EXISTS" => {
                StudioComponentStatusCode::ActiveDirectoryAlreadyExists
            }
            "ENCRYPTION_KEY_ACCESS_DENIED" => StudioComponentStatusCode::EncryptionKeyAccessDenied,
            "ENCRYPTION_KEY_NOT_FOUND" => StudioComponentStatusCode::EncryptionKeyNotFound,
            "INTERNAL_ERROR" => StudioComponentStatusCode::InternalError,
            "STUDIO_COMPONENT_CREATED" => StudioComponentStatusCode::StudioComponentCreated,
            "STUDIO_COMPONENT_CREATE_IN_PROGRESS" => {
                StudioComponentStatusCode::StudioComponentCreateInProgress
            }
            "STUDIO_COMPONENT_DELETED" => StudioComponentStatusCode::StudioComponentDeleted,
            "STUDIO_COMPONENT_DELETE_IN_PROGRESS" => {
                StudioComponentStatusCode::StudioComponentDeleteInProgress
            }
            "STUDIO_COMPONENT_UPDATED" => StudioComponentStatusCode::StudioComponentUpdated,
            "STUDIO_COMPONENT_UPDATE_IN_PROGRESS" => {
                StudioComponentStatusCode::StudioComponentUpdateInProgress
            }
            other => StudioComponentStatusCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for StudioComponentStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentStatusCode::from(s))
    }
}
impl StudioComponentStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentStatusCode::ActiveDirectoryAlreadyExists => {
                "ACTIVE_DIRECTORY_ALREADY_EXISTS"
            }
            StudioComponentStatusCode::EncryptionKeyAccessDenied => "ENCRYPTION_KEY_ACCESS_DENIED",
            StudioComponentStatusCode::EncryptionKeyNotFound => "ENCRYPTION_KEY_NOT_FOUND",
            StudioComponentStatusCode::InternalError => "INTERNAL_ERROR",
            StudioComponentStatusCode::StudioComponentCreated => "STUDIO_COMPONENT_CREATED",
            StudioComponentStatusCode::StudioComponentCreateInProgress => {
                "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
            }
            StudioComponentStatusCode::StudioComponentDeleted => "STUDIO_COMPONENT_DELETED",
            StudioComponentStatusCode::StudioComponentDeleteInProgress => {
                "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
            }
            StudioComponentStatusCode::StudioComponentUpdated => "STUDIO_COMPONENT_UPDATED",
            StudioComponentStatusCode::StudioComponentUpdateInProgress => {
                "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
            }
            StudioComponentStatusCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE_DIRECTORY_ALREADY_EXISTS",
            "ENCRYPTION_KEY_ACCESS_DENIED",
            "ENCRYPTION_KEY_NOT_FOUND",
            "INTERNAL_ERROR",
            "STUDIO_COMPONENT_CREATED",
            "STUDIO_COMPONENT_CREATE_IN_PROGRESS",
            "STUDIO_COMPONENT_DELETED",
            "STUDIO_COMPONENT_DELETE_IN_PROGRESS",
            "STUDIO_COMPONENT_UPDATED",
            "STUDIO_COMPONENT_UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StudioComponentStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StudioComponentState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let studiocomponentstate = unimplemented!();
/// match studiocomponentstate {
///     StudioComponentState::CreateFailed => { /* ... */ },
///     StudioComponentState::CreateInProgress => { /* ... */ },
///     StudioComponentState::Deleted => { /* ... */ },
///     StudioComponentState::DeleteFailed => { /* ... */ },
///     StudioComponentState::DeleteInProgress => { /* ... */ },
///     StudioComponentState::Ready => { /* ... */ },
///     StudioComponentState::UpdateFailed => { /* ... */ },
///     StudioComponentState::UpdateInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `studiocomponentstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StudioComponentState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StudioComponentState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StudioComponentState::NewFeature` is defined.
/// Specifically, when `studiocomponentstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StudioComponentState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The current state of the studio component resource.</p>
/// <p>While a studio component is being created, modified, or deleted, its state will be
/// <code>CREATE_IN_PROGRESS</code>, <code>UPDATE_IN_PROGRESS</code>, or
/// <code>DELETE_IN_PROGRESS</code>.</p>
/// <p>These are called <i>transition states</i>.</p>
/// <p>No modifications may be made to the studio component while it is in a transition
/// state.</p>
/// <p>If creation of the resource fails, the state will change to
/// <code>CREATE_FAILED</code>. The resource <code>StatusCode</code> and
/// <code>StatusMessage</code> will provide more information of why creation failed. The
/// resource in this state will automatically be deleted from your account after a period of
/// time.</p>
/// <p>If updating the resource fails, the state will change to <code>UPDATE_FAILED</code>.
/// The resource <code>StatusCode</code> and <code>StatusMessage</code> will provide more
/// information of why the update failed. The resource will be returned to the state it was
/// in when the update request was invoked.</p>
/// <p>If deleting the resource fails, the state will change to <code>DELETE_FAILED</code>.
/// The resource <code>StatusCode</code> and <code>StatusMessage</code> will provide more
/// information of why the update failed. The resource will be returned to the state it was
/// in when the update request was invoked. After the resource is deleted successfully, it
/// will change to the <code>DELETED</code> state. The resource will no longer count against
/// service quotas and cannot be used or acted upon any futher. It will be removed from your
/// account after a period of time.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StudioComponentState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StudioComponentState::CreateFailed,
            "CREATE_IN_PROGRESS" => StudioComponentState::CreateInProgress,
            "DELETED" => StudioComponentState::Deleted,
            "DELETE_FAILED" => StudioComponentState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StudioComponentState::DeleteInProgress,
            "READY" => StudioComponentState::Ready,
            "UPDATE_FAILED" => StudioComponentState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => StudioComponentState::UpdateInProgress,
            other => {
                StudioComponentState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StudioComponentState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentState::from(s))
    }
}
impl StudioComponentState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentState::CreateFailed => "CREATE_FAILED",
            StudioComponentState::CreateInProgress => "CREATE_IN_PROGRESS",
            StudioComponentState::Deleted => "DELETED",
            StudioComponentState::DeleteFailed => "DELETE_FAILED",
            StudioComponentState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StudioComponentState::Ready => "READY",
            StudioComponentState::UpdateFailed => "UPDATE_FAILED",
            StudioComponentState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            StudioComponentState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StudioComponentState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A parameter for a studio component script, in the form of a key-value pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScriptParameterKeyValue {
    /// <p>A script parameter key.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>A script parameter value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl ScriptParameterKeyValue {
    /// <p>A script parameter key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>A script parameter value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl ScriptParameterKeyValue {
    /// Creates a new builder-style object to manufacture [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue).
    pub fn builder() -> crate::model::script_parameter_key_value::Builder {
        crate::model::script_parameter_key_value::Builder::default()
    }
}

/// See [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue).
pub mod script_parameter_key_value {

    /// A builder for [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A script parameter key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>A script parameter key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>A script parameter value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A script parameter value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue).
        pub fn build(self) -> crate::model::ScriptParameterKeyValue {
            crate::model::ScriptParameterKeyValue {
                key: self.key,
                value: self.value,
            }
        }
    }
}

/// <p>Initialization scripts for studio components.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioComponentInitializationScript {
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    #[doc(hidden)]
    pub launch_profile_protocol_version: std::option::Option<std::string::String>,
    /// <p>The platform of the initialization script, either Windows or Linux.</p>
    #[doc(hidden)]
    pub platform: std::option::Option<crate::model::LaunchProfilePlatform>,
    /// <p>The method to use when running the initialization script.</p>
    #[doc(hidden)]
    pub run_context:
        std::option::Option<crate::model::StudioComponentInitializationScriptRunContext>,
    /// <p>The initialization script.</p>
    #[doc(hidden)]
    pub script: std::option::Option<std::string::String>,
}
impl StudioComponentInitializationScript {
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub fn launch_profile_protocol_version(&self) -> std::option::Option<&str> {
        self.launch_profile_protocol_version.as_deref()
    }
    /// <p>The platform of the initialization script, either Windows or Linux.</p>
    pub fn platform(&self) -> std::option::Option<&crate::model::LaunchProfilePlatform> {
        self.platform.as_ref()
    }
    /// <p>The method to use when running the initialization script.</p>
    pub fn run_context(
        &self,
    ) -> std::option::Option<&crate::model::StudioComponentInitializationScriptRunContext> {
        self.run_context.as_ref()
    }
    /// <p>The initialization script.</p>
    pub fn script(&self) -> std::option::Option<&str> {
        self.script.as_deref()
    }
}
impl std::fmt::Debug for StudioComponentInitializationScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioComponentInitializationScript");
        formatter.field(
            "launch_profile_protocol_version",
            &self.launch_profile_protocol_version,
        );
        formatter.field("platform", &self.platform);
        formatter.field("run_context", &self.run_context);
        formatter.field("script", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl StudioComponentInitializationScript {
    /// Creates a new builder-style object to manufacture [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript).
    pub fn builder() -> crate::model::studio_component_initialization_script::Builder {
        crate::model::studio_component_initialization_script::Builder::default()
    }
}

/// See [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript).
pub mod studio_component_initialization_script {

    /// A builder for [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) launch_profile_protocol_version: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<crate::model::LaunchProfilePlatform>,
        pub(crate) run_context:
            std::option::Option<crate::model::StudioComponentInitializationScriptRunContext>,
        pub(crate) script: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_version(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = Some(input.into());
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn set_launch_profile_protocol_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = input;
            self
        }
        /// <p>The platform of the initialization script, either Windows or Linux.</p>
        pub fn platform(mut self, input: crate::model::LaunchProfilePlatform) -> Self {
            self.platform = Some(input);
            self
        }
        /// <p>The platform of the initialization script, either Windows or Linux.</p>
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePlatform>,
        ) -> Self {
            self.platform = input;
            self
        }
        /// <p>The method to use when running the initialization script.</p>
        pub fn run_context(
            mut self,
            input: crate::model::StudioComponentInitializationScriptRunContext,
        ) -> Self {
            self.run_context = Some(input);
            self
        }
        /// <p>The method to use when running the initialization script.</p>
        pub fn set_run_context(
            mut self,
            input: std::option::Option<crate::model::StudioComponentInitializationScriptRunContext>,
        ) -> Self {
            self.run_context = input;
            self
        }
        /// <p>The initialization script.</p>
        pub fn script(mut self, input: impl Into<std::string::String>) -> Self {
            self.script = Some(input.into());
            self
        }
        /// <p>The initialization script.</p>
        pub fn set_script(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.script = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript).
        pub fn build(self) -> crate::model::StudioComponentInitializationScript {
            crate::model::StudioComponentInitializationScript {
                launch_profile_protocol_version: self.launch_profile_protocol_version,
                platform: self.platform,
                run_context: self.run_context,
                script: self.script,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field(
                "launch_profile_protocol_version",
                &self.launch_profile_protocol_version,
            );
            formatter.field("platform", &self.platform);
            formatter.field("run_context", &self.run_context);
            formatter.field("script", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// When writing a match expression against `StudioComponentInitializationScriptRunContext`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let studiocomponentinitializationscriptruncontext = unimplemented!();
/// match studiocomponentinitializationscriptruncontext {
///     StudioComponentInitializationScriptRunContext::SystemInitialization => { /* ... */ },
///     StudioComponentInitializationScriptRunContext::UserInitialization => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `studiocomponentinitializationscriptruncontext` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StudioComponentInitializationScriptRunContext::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StudioComponentInitializationScriptRunContext::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StudioComponentInitializationScriptRunContext::NewFeature` is defined.
/// Specifically, when `studiocomponentinitializationscriptruncontext` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StudioComponentInitializationScriptRunContext::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentInitializationScriptRunContext {
    #[allow(missing_docs)] // documentation missing in model
    SystemInitialization,
    #[allow(missing_docs)] // documentation missing in model
    UserInitialization,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StudioComponentInitializationScriptRunContext {
    fn from(s: &str) -> Self {
        match s {
            "SYSTEM_INITIALIZATION" => {
                StudioComponentInitializationScriptRunContext::SystemInitialization
            }
            "USER_INITIALIZATION" => {
                StudioComponentInitializationScriptRunContext::UserInitialization
            }
            other => StudioComponentInitializationScriptRunContext::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for StudioComponentInitializationScriptRunContext {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentInitializationScriptRunContext::from(s))
    }
}
impl StudioComponentInitializationScriptRunContext {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentInitializationScriptRunContext::SystemInitialization => {
                "SYSTEM_INITIALIZATION"
            }
            StudioComponentInitializationScriptRunContext::UserInitialization => {
                "USER_INITIALIZATION"
            }
            StudioComponentInitializationScriptRunContext::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SYSTEM_INITIALIZATION", "USER_INITIALIZATION"]
    }
}
impl AsRef<str> for StudioComponentInitializationScriptRunContext {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LaunchProfilePlatform`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let launchprofileplatform = unimplemented!();
/// match launchprofileplatform {
///     LaunchProfilePlatform::Linux => { /* ... */ },
///     LaunchProfilePlatform::Windows => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `launchprofileplatform` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LaunchProfilePlatform::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LaunchProfilePlatform::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LaunchProfilePlatform::NewFeature` is defined.
/// Specifically, when `launchprofileplatform` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LaunchProfilePlatform::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfilePlatform {
    #[allow(missing_docs)] // documentation missing in model
    Linux,
    #[allow(missing_docs)] // documentation missing in model
    Windows,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LaunchProfilePlatform {
    fn from(s: &str) -> Self {
        match s {
            "LINUX" => LaunchProfilePlatform::Linux,
            "WINDOWS" => LaunchProfilePlatform::Windows,
            other => {
                LaunchProfilePlatform::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for LaunchProfilePlatform {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfilePlatform::from(s))
    }
}
impl LaunchProfilePlatform {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfilePlatform::Linux => "LINUX",
            LaunchProfilePlatform::Windows => "WINDOWS",
            LaunchProfilePlatform::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LINUX", "WINDOWS"]
    }
}
impl AsRef<str> for LaunchProfilePlatform {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of the studio component, based on component type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum StudioComponentConfiguration {
    /// <p>The configuration for a Directory Service for Microsoft Active Directory studio resource.</p>
    ActiveDirectoryConfiguration(crate::model::ActiveDirectoryConfiguration),
    /// <p>The configuration for a render farm that is associated with a studio resource.</p>
    ComputeFarmConfiguration(crate::model::ComputeFarmConfiguration),
    /// <p>The configuration for a license service that is associated with a studio resource.</p>
    LicenseServiceConfiguration(crate::model::LicenseServiceConfiguration),
    /// <p>The configuration for a shared file storage system that is associated with a studio resource.</p>
    SharedFileSystemConfiguration(crate::model::SharedFileSystemConfiguration),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl StudioComponentConfiguration {
    /// Tries to convert the enum instance into [`ActiveDirectoryConfiguration`](crate::model::StudioComponentConfiguration::ActiveDirectoryConfiguration), extracting the inner [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_active_directory_configuration(
        &self,
    ) -> std::result::Result<&crate::model::ActiveDirectoryConfiguration, &Self> {
        if let StudioComponentConfiguration::ActiveDirectoryConfiguration(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ActiveDirectoryConfiguration`](crate::model::StudioComponentConfiguration::ActiveDirectoryConfiguration).
    pub fn is_active_directory_configuration(&self) -> bool {
        self.as_active_directory_configuration().is_ok()
    }
    /// Tries to convert the enum instance into [`ComputeFarmConfiguration`](crate::model::StudioComponentConfiguration::ComputeFarmConfiguration), extracting the inner [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_compute_farm_configuration(
        &self,
    ) -> std::result::Result<&crate::model::ComputeFarmConfiguration, &Self> {
        if let StudioComponentConfiguration::ComputeFarmConfiguration(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ComputeFarmConfiguration`](crate::model::StudioComponentConfiguration::ComputeFarmConfiguration).
    pub fn is_compute_farm_configuration(&self) -> bool {
        self.as_compute_farm_configuration().is_ok()
    }
    /// Tries to convert the enum instance into [`LicenseServiceConfiguration`](crate::model::StudioComponentConfiguration::LicenseServiceConfiguration), extracting the inner [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_license_service_configuration(
        &self,
    ) -> std::result::Result<&crate::model::LicenseServiceConfiguration, &Self> {
        if let StudioComponentConfiguration::LicenseServiceConfiguration(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`LicenseServiceConfiguration`](crate::model::StudioComponentConfiguration::LicenseServiceConfiguration).
    pub fn is_license_service_configuration(&self) -> bool {
        self.as_license_service_configuration().is_ok()
    }
    /// Tries to convert the enum instance into [`SharedFileSystemConfiguration`](crate::model::StudioComponentConfiguration::SharedFileSystemConfiguration), extracting the inner [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_shared_file_system_configuration(
        &self,
    ) -> std::result::Result<&crate::model::SharedFileSystemConfiguration, &Self> {
        if let StudioComponentConfiguration::SharedFileSystemConfiguration(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SharedFileSystemConfiguration`](crate::model::StudioComponentConfiguration::SharedFileSystemConfiguration).
    pub fn is_shared_file_system_configuration(&self) -> bool {
        self.as_shared_file_system_configuration().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The configuration for a shared file storage system that is associated with a studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SharedFileSystemConfiguration {
    /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
    #[doc(hidden)]
    pub endpoint: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a file system.</p>
    #[doc(hidden)]
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
    #[doc(hidden)]
    pub linux_mount_point: std::option::Option<std::string::String>,
    /// <p>The name of the file share.</p>
    #[doc(hidden)]
    pub share_name: std::option::Option<std::string::String>,
    /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
    #[doc(hidden)]
    pub windows_mount_drive: std::option::Option<std::string::String>,
}
impl SharedFileSystemConfiguration {
    /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>The unique identifier for a file system.</p>
    pub fn file_system_id(&self) -> std::option::Option<&str> {
        self.file_system_id.as_deref()
    }
    /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
    pub fn linux_mount_point(&self) -> std::option::Option<&str> {
        self.linux_mount_point.as_deref()
    }
    /// <p>The name of the file share.</p>
    pub fn share_name(&self) -> std::option::Option<&str> {
        self.share_name.as_deref()
    }
    /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
    pub fn windows_mount_drive(&self) -> std::option::Option<&str> {
        self.windows_mount_drive.as_deref()
    }
}
impl std::fmt::Debug for SharedFileSystemConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SharedFileSystemConfiguration");
        formatter.field("endpoint", &"*** Sensitive Data Redacted ***");
        formatter.field("file_system_id", &self.file_system_id);
        formatter.field("linux_mount_point", &"*** Sensitive Data Redacted ***");
        formatter.field("share_name", &"*** Sensitive Data Redacted ***");
        formatter.field("windows_mount_drive", &self.windows_mount_drive);
        formatter.finish()
    }
}
impl SharedFileSystemConfiguration {
    /// Creates a new builder-style object to manufacture [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration).
    pub fn builder() -> crate::model::shared_file_system_configuration::Builder {
        crate::model::shared_file_system_configuration::Builder::default()
    }
}

/// See [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration).
pub mod shared_file_system_configuration {

    /// A builder for [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) endpoint: std::option::Option<std::string::String>,
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) linux_mount_point: std::option::Option<std::string::String>,
        pub(crate) share_name: std::option::Option<std::string::String>,
        pub(crate) windows_mount_drive: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>The unique identifier for a file system.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a file system.</p>
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
        pub fn linux_mount_point(mut self, input: impl Into<std::string::String>) -> Self {
            self.linux_mount_point = Some(input.into());
            self
        }
        /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
        pub fn set_linux_mount_point(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.linux_mount_point = input;
            self
        }
        /// <p>The name of the file share.</p>
        pub fn share_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_name = Some(input.into());
            self
        }
        /// <p>The name of the file share.</p>
        pub fn set_share_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.share_name = input;
            self
        }
        /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
        pub fn windows_mount_drive(mut self, input: impl Into<std::string::String>) -> Self {
            self.windows_mount_drive = Some(input.into());
            self
        }
        /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
        pub fn set_windows_mount_drive(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.windows_mount_drive = input;
            self
        }
        /// Consumes the builder and constructs a [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration).
        pub fn build(self) -> crate::model::SharedFileSystemConfiguration {
            crate::model::SharedFileSystemConfiguration {
                endpoint: self.endpoint,
                file_system_id: self.file_system_id,
                linux_mount_point: self.linux_mount_point,
                share_name: self.share_name,
                windows_mount_drive: self.windows_mount_drive,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("endpoint", &"*** Sensitive Data Redacted ***");
            formatter.field("file_system_id", &self.file_system_id);
            formatter.field("linux_mount_point", &"*** Sensitive Data Redacted ***");
            formatter.field("share_name", &"*** Sensitive Data Redacted ***");
            formatter.field("windows_mount_drive", &self.windows_mount_drive);
            formatter.finish()
        }
    }
}

/// <p>The configuration for a license service that is associated with a studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LicenseServiceConfiguration {
    /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
    #[doc(hidden)]
    pub endpoint: std::option::Option<std::string::String>,
}
impl LicenseServiceConfiguration {
    /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
}
impl std::fmt::Debug for LicenseServiceConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LicenseServiceConfiguration");
        formatter.field("endpoint", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl LicenseServiceConfiguration {
    /// Creates a new builder-style object to manufacture [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration).
    pub fn builder() -> crate::model::license_service_configuration::Builder {
        crate::model::license_service_configuration::Builder::default()
    }
}

/// See [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration).
pub mod license_service_configuration {

    /// A builder for [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration).
        pub fn build(self) -> crate::model::LicenseServiceConfiguration {
            crate::model::LicenseServiceConfiguration {
                endpoint: self.endpoint,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("endpoint", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// <p>The configuration for a render farm that is associated with a studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ComputeFarmConfiguration {
    /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
    #[doc(hidden)]
    pub active_directory_user: std::option::Option<std::string::String>,
    /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
    #[doc(hidden)]
    pub endpoint: std::option::Option<std::string::String>,
}
impl ComputeFarmConfiguration {
    /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
    pub fn active_directory_user(&self) -> std::option::Option<&str> {
        self.active_directory_user.as_deref()
    }
    /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
}
impl std::fmt::Debug for ComputeFarmConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComputeFarmConfiguration");
        formatter.field("active_directory_user", &self.active_directory_user);
        formatter.field("endpoint", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl ComputeFarmConfiguration {
    /// Creates a new builder-style object to manufacture [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration).
    pub fn builder() -> crate::model::compute_farm_configuration::Builder {
        crate::model::compute_farm_configuration::Builder::default()
    }
}

/// See [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration).
pub mod compute_farm_configuration {

    /// A builder for [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) active_directory_user: std::option::Option<std::string::String>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
        pub fn active_directory_user(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_directory_user = Some(input.into());
            self
        }
        /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
        pub fn set_active_directory_user(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_directory_user = input;
            self
        }
        /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration).
        pub fn build(self) -> crate::model::ComputeFarmConfiguration {
            crate::model::ComputeFarmConfiguration {
                active_directory_user: self.active_directory_user,
                endpoint: self.endpoint,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("active_directory_user", &self.active_directory_user);
            formatter.field("endpoint", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// <p>The configuration for a Directory Service for Microsoft Active Directory studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActiveDirectoryConfiguration {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    #[doc(hidden)]
    pub computer_attributes:
        std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
    /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.</p>
    #[doc(hidden)]
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
    #[doc(hidden)]
    pub organizational_unit_distinguished_name: std::option::Option<std::string::String>,
}
impl ActiveDirectoryConfiguration {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    pub fn computer_attributes(
        &self,
    ) -> std::option::Option<&[crate::model::ActiveDirectoryComputerAttribute]> {
        self.computer_attributes.as_deref()
    }
    /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.</p>
    pub fn directory_id(&self) -> std::option::Option<&str> {
        self.directory_id.as_deref()
    }
    /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
    pub fn organizational_unit_distinguished_name(&self) -> std::option::Option<&str> {
        self.organizational_unit_distinguished_name.as_deref()
    }
}
impl std::fmt::Debug for ActiveDirectoryConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActiveDirectoryConfiguration");
        formatter.field("computer_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("directory_id", &self.directory_id);
        formatter.field(
            "organizational_unit_distinguished_name",
            &self.organizational_unit_distinguished_name,
        );
        formatter.finish()
    }
}
impl ActiveDirectoryConfiguration {
    /// Creates a new builder-style object to manufacture [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration).
    pub fn builder() -> crate::model::active_directory_configuration::Builder {
        crate::model::active_directory_configuration::Builder::default()
    }
}

/// See [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration).
pub mod active_directory_configuration {

    /// A builder for [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) computer_attributes:
            std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) organizational_unit_distinguished_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `computer_attributes`.
        ///
        /// To override the contents of this collection use [`set_computer_attributes`](Self::set_computer_attributes).
        ///
        /// <p>A collection of custom attributes for an Active Directory computer.</p>
        pub fn computer_attributes(
            mut self,
            input: crate::model::ActiveDirectoryComputerAttribute,
        ) -> Self {
            let mut v = self.computer_attributes.unwrap_or_default();
            v.push(input);
            self.computer_attributes = Some(v);
            self
        }
        /// <p>A collection of custom attributes for an Active Directory computer.</p>
        pub fn set_computer_attributes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>,
            >,
        ) -> Self {
            self.computer_attributes = input;
            self
        }
        /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.</p>
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
        pub fn organizational_unit_distinguished_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = Some(input.into());
            self
        }
        /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
        pub fn set_organizational_unit_distinguished_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration).
        pub fn build(self) -> crate::model::ActiveDirectoryConfiguration {
            crate::model::ActiveDirectoryConfiguration {
                computer_attributes: self.computer_attributes,
                directory_id: self.directory_id,
                organizational_unit_distinguished_name: self.organizational_unit_distinguished_name,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("computer_attributes", &"*** Sensitive Data Redacted ***");
            formatter.field("directory_id", &self.directory_id);
            formatter.field(
                "organizational_unit_distinguished_name",
                &self.organizational_unit_distinguished_name,
            );
            formatter.finish()
        }
    }
}

/// <p>An LDAP attribute of an Active Directory computer account, in the form of a name:value pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActiveDirectoryComputerAttribute {
    /// <p>The name for the LDAP attribute.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The value for the LDAP attribute.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl ActiveDirectoryComputerAttribute {
    /// <p>The name for the LDAP attribute.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value for the LDAP attribute.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl ActiveDirectoryComputerAttribute {
    /// Creates a new builder-style object to manufacture [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute).
    pub fn builder() -> crate::model::active_directory_computer_attribute::Builder {
        crate::model::active_directory_computer_attribute::Builder::default()
    }
}

/// See [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute).
pub mod active_directory_computer_attribute {

    /// A builder for [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name for the LDAP attribute.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the LDAP attribute.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value for the LDAP attribute.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for the LDAP attribute.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute).
        pub fn build(self) -> crate::model::ActiveDirectoryComputerAttribute {
            crate::model::ActiveDirectoryComputerAttribute {
                name: self.name,
                value: self.value,
            }
        }
    }
}

/// <p>A streaming session is a virtual workstation created using a particular launch profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamingSession {
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that created the streaming session.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The EC2 Instance type used for the streaming session.</p>
    #[doc(hidden)]
    pub ec2_instance_type: std::option::Option<std::string::String>,
    /// <p>The ID of the launch profile used to control access from the streaming session.</p>
    #[doc(hidden)]
    pub launch_profile_id: std::option::Option<std::string::String>,
    /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
    #[doc(hidden)]
    pub owned_by: std::option::Option<std::string::String>,
    /// <p>The session ID.</p>
    #[doc(hidden)]
    pub session_id: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::StreamingSessionState>,
    /// <p>The status code.</p>
    #[doc(hidden)]
    pub status_code: std::option::Option<crate::model::StreamingSessionStatusCode>,
    /// <p>The status message for the streaming session.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The ID of the streaming image.</p>
    #[doc(hidden)]
    pub streaming_image_id: std::option::Option<std::string::String>,
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
    #[doc(hidden)]
    pub terminate_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    #[doc(hidden)]
    pub updated_by: std::option::Option<std::string::String>,
    /// <p>The time the session entered <code>STOP_IN_PROGRESS</code> state.</p>
    #[doc(hidden)]
    pub stopped_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that stopped the streaming session.</p>
    #[doc(hidden)]
    pub stopped_by: std::option::Option<std::string::String>,
    /// <p>The time the session entered <code>START_IN_PROGRESS</code> state.</p>
    #[doc(hidden)]
    pub started_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that started the streaming session.</p>
    #[doc(hidden)]
    pub started_by: std::option::Option<std::string::String>,
    /// <p>The time the streaming session will automatically be stopped if the user doesn’t stop the session themselves. </p>
    #[doc(hidden)]
    pub stop_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The backup ID used to restore a streaming session.</p>
    #[doc(hidden)]
    pub started_from_backup_id: std::option::Option<std::string::String>,
    /// <p>Shows the current backup setting of the session.</p>
    #[doc(hidden)]
    pub backup_mode: std::option::Option<crate::model::SessionBackupMode>,
    /// <p>The maximum number of backups of a streaming session that you can have. When the maximum number of backups is reached, the oldest backup is deleted.</p>
    #[doc(hidden)]
    pub max_backups_to_retain: i32,
    /// <p>Determine if an EBS volume created from this streaming session will be backed up.</p>
    #[doc(hidden)]
    pub volume_retention_mode: std::option::Option<crate::model::VolumeRetentionMode>,
    /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
    #[doc(hidden)]
    pub session_persistence_mode: std::option::Option<crate::model::SessionPersistenceMode>,
    /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
    #[doc(hidden)]
    pub volume_configuration: std::option::Option<crate::model::VolumeConfiguration>,
    /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
    /// <ul>
    /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
    /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
    /// </ul>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
    #[doc(hidden)]
    pub automatic_termination_mode: std::option::Option<crate::model::AutomaticTerminationMode>,
}
impl StreamingSession {
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The user ID of the user that created the streaming session.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The EC2 Instance type used for the streaming session.</p>
    pub fn ec2_instance_type(&self) -> std::option::Option<&str> {
        self.ec2_instance_type.as_deref()
    }
    /// <p>The ID of the launch profile used to control access from the streaming session.</p>
    pub fn launch_profile_id(&self) -> std::option::Option<&str> {
        self.launch_profile_id.as_deref()
    }
    /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
    pub fn owned_by(&self) -> std::option::Option<&str> {
        self.owned_by.as_deref()
    }
    /// <p>The session ID.</p>
    pub fn session_id(&self) -> std::option::Option<&str> {
        self.session_id.as_deref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StreamingSessionState> {
        self.state.as_ref()
    }
    /// <p>The status code.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::StreamingSessionStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the streaming session.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The ID of the streaming image.</p>
    pub fn streaming_image_id(&self) -> std::option::Option<&str> {
        self.streaming_image_id.as_deref()
    }
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
    pub fn terminate_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.terminate_at.as_ref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub fn updated_by(&self) -> std::option::Option<&str> {
        self.updated_by.as_deref()
    }
    /// <p>The time the session entered <code>STOP_IN_PROGRESS</code> state.</p>
    pub fn stopped_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.stopped_at.as_ref()
    }
    /// <p>The user ID of the user that stopped the streaming session.</p>
    pub fn stopped_by(&self) -> std::option::Option<&str> {
        self.stopped_by.as_deref()
    }
    /// <p>The time the session entered <code>START_IN_PROGRESS</code> state.</p>
    pub fn started_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_at.as_ref()
    }
    /// <p>The user ID of the user that started the streaming session.</p>
    pub fn started_by(&self) -> std::option::Option<&str> {
        self.started_by.as_deref()
    }
    /// <p>The time the streaming session will automatically be stopped if the user doesn’t stop the session themselves. </p>
    pub fn stop_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.stop_at.as_ref()
    }
    /// <p>The backup ID used to restore a streaming session.</p>
    pub fn started_from_backup_id(&self) -> std::option::Option<&str> {
        self.started_from_backup_id.as_deref()
    }
    /// <p>Shows the current backup setting of the session.</p>
    pub fn backup_mode(&self) -> std::option::Option<&crate::model::SessionBackupMode> {
        self.backup_mode.as_ref()
    }
    /// <p>The maximum number of backups of a streaming session that you can have. When the maximum number of backups is reached, the oldest backup is deleted.</p>
    pub fn max_backups_to_retain(&self) -> i32 {
        self.max_backups_to_retain
    }
    /// <p>Determine if an EBS volume created from this streaming session will be backed up.</p>
    pub fn volume_retention_mode(&self) -> std::option::Option<&crate::model::VolumeRetentionMode> {
        self.volume_retention_mode.as_ref()
    }
    /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
    pub fn session_persistence_mode(
        &self,
    ) -> std::option::Option<&crate::model::SessionPersistenceMode> {
        self.session_persistence_mode.as_ref()
    }
    /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
    pub fn volume_configuration(&self) -> std::option::Option<&crate::model::VolumeConfiguration> {
        self.volume_configuration.as_ref()
    }
    /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
    /// <ul>
    /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
    /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
    /// </ul>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
    pub fn automatic_termination_mode(
        &self,
    ) -> std::option::Option<&crate::model::AutomaticTerminationMode> {
        self.automatic_termination_mode.as_ref()
    }
}
impl StreamingSession {
    /// Creates a new builder-style object to manufacture [`StreamingSession`](crate::model::StreamingSession).
    pub fn builder() -> crate::model::streaming_session::Builder {
        crate::model::streaming_session::Builder::default()
    }
}

/// See [`StreamingSession`](crate::model::StreamingSession).
pub mod streaming_session {

    /// A builder for [`StreamingSession`](crate::model::StreamingSession).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) ec2_instance_type: std::option::Option<std::string::String>,
        pub(crate) launch_profile_id: std::option::Option<std::string::String>,
        pub(crate) owned_by: std::option::Option<std::string::String>,
        pub(crate) session_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StreamingSessionState>,
        pub(crate) status_code: std::option::Option<crate::model::StreamingSessionStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) streaming_image_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) terminate_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
        pub(crate) stopped_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) stopped_by: std::option::Option<std::string::String>,
        pub(crate) started_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) started_by: std::option::Option<std::string::String>,
        pub(crate) stop_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) started_from_backup_id: std::option::Option<std::string::String>,
        pub(crate) backup_mode: std::option::Option<crate::model::SessionBackupMode>,
        pub(crate) max_backups_to_retain: std::option::Option<i32>,
        pub(crate) volume_retention_mode: std::option::Option<crate::model::VolumeRetentionMode>,
        pub(crate) session_persistence_mode:
            std::option::Option<crate::model::SessionPersistenceMode>,
        pub(crate) volume_configuration: std::option::Option<crate::model::VolumeConfiguration>,
        pub(crate) automatic_termination_mode:
            std::option::Option<crate::model::AutomaticTerminationMode>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the streaming session.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that created the streaming session.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The EC2 Instance type used for the streaming session.</p>
        pub fn ec2_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_instance_type = Some(input.into());
            self
        }
        /// <p>The EC2 Instance type used for the streaming session.</p>
        pub fn set_ec2_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ec2_instance_type = input;
            self
        }
        /// <p>The ID of the launch profile used to control access from the streaming session.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_profile_id = Some(input.into());
            self
        }
        /// <p>The ID of the launch profile used to control access from the streaming session.</p>
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_id = input;
            self
        }
        /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
        pub fn owned_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.owned_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
        pub fn set_owned_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owned_by = input;
            self
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_id = Some(input.into());
            self
        }
        /// <p>The session ID.</p>
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.session_id = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StreamingSessionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::StreamingSessionStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the streaming session.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the streaming session.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn streaming_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.streaming_image_id = Some(input.into());
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.streaming_image_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
        pub fn terminate_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.terminate_at = Some(input);
            self
        }
        /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
        pub fn set_terminate_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.terminate_at = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// <p>The time the session entered <code>STOP_IN_PROGRESS</code> state.</p>
        pub fn stopped_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.stopped_at = Some(input);
            self
        }
        /// <p>The time the session entered <code>STOP_IN_PROGRESS</code> state.</p>
        pub fn set_stopped_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.stopped_at = input;
            self
        }
        /// <p>The user ID of the user that stopped the streaming session.</p>
        pub fn stopped_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.stopped_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that stopped the streaming session.</p>
        pub fn set_stopped_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stopped_by = input;
            self
        }
        /// <p>The time the session entered <code>START_IN_PROGRESS</code> state.</p>
        pub fn started_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_at = Some(input);
            self
        }
        /// <p>The time the session entered <code>START_IN_PROGRESS</code> state.</p>
        pub fn set_started_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_at = input;
            self
        }
        /// <p>The user ID of the user that started the streaming session.</p>
        pub fn started_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.started_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that started the streaming session.</p>
        pub fn set_started_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.started_by = input;
            self
        }
        /// <p>The time the streaming session will automatically be stopped if the user doesn’t stop the session themselves. </p>
        pub fn stop_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.stop_at = Some(input);
            self
        }
        /// <p>The time the streaming session will automatically be stopped if the user doesn’t stop the session themselves. </p>
        pub fn set_stop_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.stop_at = input;
            self
        }
        /// <p>The backup ID used to restore a streaming session.</p>
        pub fn started_from_backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.started_from_backup_id = Some(input.into());
            self
        }
        /// <p>The backup ID used to restore a streaming session.</p>
        pub fn set_started_from_backup_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.started_from_backup_id = input;
            self
        }
        /// <p>Shows the current backup setting of the session.</p>
        pub fn backup_mode(mut self, input: crate::model::SessionBackupMode) -> Self {
            self.backup_mode = Some(input);
            self
        }
        /// <p>Shows the current backup setting of the session.</p>
        pub fn set_backup_mode(
            mut self,
            input: std::option::Option<crate::model::SessionBackupMode>,
        ) -> Self {
            self.backup_mode = input;
            self
        }
        /// <p>The maximum number of backups of a streaming session that you can have. When the maximum number of backups is reached, the oldest backup is deleted.</p>
        pub fn max_backups_to_retain(mut self, input: i32) -> Self {
            self.max_backups_to_retain = Some(input);
            self
        }
        /// <p>The maximum number of backups of a streaming session that you can have. When the maximum number of backups is reached, the oldest backup is deleted.</p>
        pub fn set_max_backups_to_retain(mut self, input: std::option::Option<i32>) -> Self {
            self.max_backups_to_retain = input;
            self
        }
        /// <p>Determine if an EBS volume created from this streaming session will be backed up.</p>
        pub fn volume_retention_mode(mut self, input: crate::model::VolumeRetentionMode) -> Self {
            self.volume_retention_mode = Some(input);
            self
        }
        /// <p>Determine if an EBS volume created from this streaming session will be backed up.</p>
        pub fn set_volume_retention_mode(
            mut self,
            input: std::option::Option<crate::model::VolumeRetentionMode>,
        ) -> Self {
            self.volume_retention_mode = input;
            self
        }
        /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
        pub fn session_persistence_mode(
            mut self,
            input: crate::model::SessionPersistenceMode,
        ) -> Self {
            self.session_persistence_mode = Some(input);
            self
        }
        /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
        pub fn set_session_persistence_mode(
            mut self,
            input: std::option::Option<crate::model::SessionPersistenceMode>,
        ) -> Self {
            self.session_persistence_mode = input;
            self
        }
        /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
        pub fn volume_configuration(mut self, input: crate::model::VolumeConfiguration) -> Self {
            self.volume_configuration = Some(input);
            self
        }
        /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
        pub fn set_volume_configuration(
            mut self,
            input: std::option::Option<crate::model::VolumeConfiguration>,
        ) -> Self {
            self.volume_configuration = input;
            self
        }
        /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
        /// <ul>
        /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
        /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
        /// </ul>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
        pub fn automatic_termination_mode(
            mut self,
            input: crate::model::AutomaticTerminationMode,
        ) -> Self {
            self.automatic_termination_mode = Some(input);
            self
        }
        /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
        /// <ul>
        /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
        /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
        /// </ul>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
        pub fn set_automatic_termination_mode(
            mut self,
            input: std::option::Option<crate::model::AutomaticTerminationMode>,
        ) -> Self {
            self.automatic_termination_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingSession`](crate::model::StreamingSession).
        pub fn build(self) -> crate::model::StreamingSession {
            crate::model::StreamingSession {
                arn: self.arn,
                created_at: self.created_at,
                created_by: self.created_by,
                ec2_instance_type: self.ec2_instance_type,
                launch_profile_id: self.launch_profile_id,
                owned_by: self.owned_by,
                session_id: self.session_id,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                streaming_image_id: self.streaming_image_id,
                tags: self.tags,
                terminate_at: self.terminate_at,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
                stopped_at: self.stopped_at,
                stopped_by: self.stopped_by,
                started_at: self.started_at,
                started_by: self.started_by,
                stop_at: self.stop_at,
                started_from_backup_id: self.started_from_backup_id,
                backup_mode: self.backup_mode,
                max_backups_to_retain: self.max_backups_to_retain.unwrap_or_default(),
                volume_retention_mode: self.volume_retention_mode,
                session_persistence_mode: self.session_persistence_mode,
                volume_configuration: self.volume_configuration,
                automatic_termination_mode: self.automatic_termination_mode,
            }
        }
    }
}

/// When writing a match expression against `AutomaticTerminationMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let automaticterminationmode = unimplemented!();
/// match automaticterminationmode {
///     AutomaticTerminationMode::Activated => { /* ... */ },
///     AutomaticTerminationMode::Deactivated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `automaticterminationmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AutomaticTerminationMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AutomaticTerminationMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AutomaticTerminationMode::NewFeature` is defined.
/// Specifically, when `automaticterminationmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AutomaticTerminationMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AutomaticTerminationMode {
    #[allow(missing_docs)] // documentation missing in model
    Activated,
    #[allow(missing_docs)] // documentation missing in model
    Deactivated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AutomaticTerminationMode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVATED" => AutomaticTerminationMode::Activated,
            "DEACTIVATED" => AutomaticTerminationMode::Deactivated,
            other => AutomaticTerminationMode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for AutomaticTerminationMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AutomaticTerminationMode::from(s))
    }
}
impl AutomaticTerminationMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AutomaticTerminationMode::Activated => "ACTIVATED",
            AutomaticTerminationMode::Deactivated => "DEACTIVATED",
            AutomaticTerminationMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVATED", "DEACTIVATED"]
    }
}
impl AsRef<str> for AutomaticTerminationMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
/// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct VolumeConfiguration {
    /// <p>The size of the root volume that is attached to the streaming session. The root volume size is measured in GiBs.</p>
    #[doc(hidden)]
    pub size: std::option::Option<i32>,
    /// <p>The throughput to provision for the root volume that is attached to the streaming session. The throughput is measured in MiB/s.</p>
    #[doc(hidden)]
    pub throughput: std::option::Option<i32>,
    /// <p>The number of I/O operations per second for the root volume that is attached to streaming session.</p>
    #[doc(hidden)]
    pub iops: std::option::Option<i32>,
}
impl VolumeConfiguration {
    /// <p>The size of the root volume that is attached to the streaming session. The root volume size is measured in GiBs.</p>
    pub fn size(&self) -> std::option::Option<i32> {
        self.size
    }
    /// <p>The throughput to provision for the root volume that is attached to the streaming session. The throughput is measured in MiB/s.</p>
    pub fn throughput(&self) -> std::option::Option<i32> {
        self.throughput
    }
    /// <p>The number of I/O operations per second for the root volume that is attached to streaming session.</p>
    pub fn iops(&self) -> std::option::Option<i32> {
        self.iops
    }
}
impl VolumeConfiguration {
    /// Creates a new builder-style object to manufacture [`VolumeConfiguration`](crate::model::VolumeConfiguration).
    pub fn builder() -> crate::model::volume_configuration::Builder {
        crate::model::volume_configuration::Builder::default()
    }
}

/// See [`VolumeConfiguration`](crate::model::VolumeConfiguration).
pub mod volume_configuration {

    /// A builder for [`VolumeConfiguration`](crate::model::VolumeConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) size: std::option::Option<i32>,
        pub(crate) throughput: std::option::Option<i32>,
        pub(crate) iops: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The size of the root volume that is attached to the streaming session. The root volume size is measured in GiBs.</p>
        pub fn size(mut self, input: i32) -> Self {
            self.size = Some(input);
            self
        }
        /// <p>The size of the root volume that is attached to the streaming session. The root volume size is measured in GiBs.</p>
        pub fn set_size(mut self, input: std::option::Option<i32>) -> Self {
            self.size = input;
            self
        }
        /// <p>The throughput to provision for the root volume that is attached to the streaming session. The throughput is measured in MiB/s.</p>
        pub fn throughput(mut self, input: i32) -> Self {
            self.throughput = Some(input);
            self
        }
        /// <p>The throughput to provision for the root volume that is attached to the streaming session. The throughput is measured in MiB/s.</p>
        pub fn set_throughput(mut self, input: std::option::Option<i32>) -> Self {
            self.throughput = input;
            self
        }
        /// <p>The number of I/O operations per second for the root volume that is attached to streaming session.</p>
        pub fn iops(mut self, input: i32) -> Self {
            self.iops = Some(input);
            self
        }
        /// <p>The number of I/O operations per second for the root volume that is attached to streaming session.</p>
        pub fn set_iops(mut self, input: std::option::Option<i32>) -> Self {
            self.iops = input;
            self
        }
        /// Consumes the builder and constructs a [`VolumeConfiguration`](crate::model::VolumeConfiguration).
        pub fn build(self) -> crate::model::VolumeConfiguration {
            crate::model::VolumeConfiguration {
                size: self.size,
                throughput: self.throughput,
                iops: self.iops,
            }
        }
    }
}

/// When writing a match expression against `SessionPersistenceMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sessionpersistencemode = unimplemented!();
/// match sessionpersistencemode {
///     SessionPersistenceMode::Activated => { /* ... */ },
///     SessionPersistenceMode::Deactivated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sessionpersistencemode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SessionPersistenceMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SessionPersistenceMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SessionPersistenceMode::NewFeature` is defined.
/// Specifically, when `sessionpersistencemode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SessionPersistenceMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SessionPersistenceMode {
    #[allow(missing_docs)] // documentation missing in model
    Activated,
    #[allow(missing_docs)] // documentation missing in model
    Deactivated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SessionPersistenceMode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVATED" => SessionPersistenceMode::Activated,
            "DEACTIVATED" => SessionPersistenceMode::Deactivated,
            other => {
                SessionPersistenceMode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SessionPersistenceMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SessionPersistenceMode::from(s))
    }
}
impl SessionPersistenceMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SessionPersistenceMode::Activated => "ACTIVATED",
            SessionPersistenceMode::Deactivated => "DEACTIVATED",
            SessionPersistenceMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVATED", "DEACTIVATED"]
    }
}
impl AsRef<str> for SessionPersistenceMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `VolumeRetentionMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let volumeretentionmode = unimplemented!();
/// match volumeretentionmode {
///     VolumeRetentionMode::Delete => { /* ... */ },
///     VolumeRetentionMode::Retain => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `volumeretentionmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `VolumeRetentionMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `VolumeRetentionMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `VolumeRetentionMode::NewFeature` is defined.
/// Specifically, when `volumeretentionmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `VolumeRetentionMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum VolumeRetentionMode {
    #[allow(missing_docs)] // documentation missing in model
    Delete,
    #[allow(missing_docs)] // documentation missing in model
    Retain,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for VolumeRetentionMode {
    fn from(s: &str) -> Self {
        match s {
            "DELETE" => VolumeRetentionMode::Delete,
            "RETAIN" => VolumeRetentionMode::Retain,
            other => {
                VolumeRetentionMode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for VolumeRetentionMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(VolumeRetentionMode::from(s))
    }
}
impl VolumeRetentionMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            VolumeRetentionMode::Delete => "DELETE",
            VolumeRetentionMode::Retain => "RETAIN",
            VolumeRetentionMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELETE", "RETAIN"]
    }
}
impl AsRef<str> for VolumeRetentionMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SessionBackupMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let sessionbackupmode = unimplemented!();
/// match sessionbackupmode {
///     SessionBackupMode::Automatic => { /* ... */ },
///     SessionBackupMode::Deactivated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `sessionbackupmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SessionBackupMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SessionBackupMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SessionBackupMode::NewFeature` is defined.
/// Specifically, when `sessionbackupmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SessionBackupMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SessionBackupMode {
    #[allow(missing_docs)] // documentation missing in model
    Automatic,
    #[allow(missing_docs)] // documentation missing in model
    Deactivated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SessionBackupMode {
    fn from(s: &str) -> Self {
        match s {
            "AUTOMATIC" => SessionBackupMode::Automatic,
            "DEACTIVATED" => SessionBackupMode::Deactivated,
            other => {
                SessionBackupMode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SessionBackupMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SessionBackupMode::from(s))
    }
}
impl SessionBackupMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SessionBackupMode::Automatic => "AUTOMATIC",
            SessionBackupMode::Deactivated => "DEACTIVATED",
            SessionBackupMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AUTOMATIC", "DEACTIVATED"]
    }
}
impl AsRef<str> for SessionBackupMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StreamingSessionStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streamingsessionstatuscode = unimplemented!();
/// match streamingsessionstatuscode {
///     StreamingSessionStatusCode::ActiveDirectoryDomainJoinError => { /* ... */ },
///     StreamingSessionStatusCode::AmiValidationError => { /* ... */ },
///     StreamingSessionStatusCode::DecryptStreamingImageError => { /* ... */ },
///     StreamingSessionStatusCode::InitializationScriptError => { /* ... */ },
///     StreamingSessionStatusCode::InsufficientCapacity => { /* ... */ },
///     StreamingSessionStatusCode::InternalError => { /* ... */ },
///     StreamingSessionStatusCode::NetworkConnectionError => { /* ... */ },
///     StreamingSessionStatusCode::NetworkInterfaceError => { /* ... */ },
///     StreamingSessionStatusCode::StreamingSessionCreateInProgress => { /* ... */ },
///     StreamingSessionStatusCode::StreamingSessionDeleted => { /* ... */ },
///     StreamingSessionStatusCode::StreamingSessionDeleteInProgress => { /* ... */ },
///     StreamingSessionStatusCode::StreamingSessionReady => { /* ... */ },
///     StreamingSessionStatusCode::StreamingSessionStarted => { /* ... */ },
///     StreamingSessionStatusCode::StreamingSessionStartInProgress => { /* ... */ },
///     StreamingSessionStatusCode::StreamingSessionStopped => { /* ... */ },
///     StreamingSessionStatusCode::StreamingSessionStopInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streamingsessionstatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingSessionStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingSessionStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingSessionStatusCode::NewFeature` is defined.
/// Specifically, when `streamingsessionstatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingSessionStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    ActiveDirectoryDomainJoinError,
    #[allow(missing_docs)] // documentation missing in model
    AmiValidationError,
    #[allow(missing_docs)] // documentation missing in model
    DecryptStreamingImageError,
    #[allow(missing_docs)] // documentation missing in model
    InitializationScriptError,
    #[allow(missing_docs)] // documentation missing in model
    InsufficientCapacity,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    NetworkConnectionError,
    #[allow(missing_docs)] // documentation missing in model
    NetworkInterfaceError,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionReady,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionStarted,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionStartInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionStopped,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionStopInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingSessionStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR" => {
                StreamingSessionStatusCode::ActiveDirectoryDomainJoinError
            }
            "AMI_VALIDATION_ERROR" => StreamingSessionStatusCode::AmiValidationError,
            "DECRYPT_STREAMING_IMAGE_ERROR" => {
                StreamingSessionStatusCode::DecryptStreamingImageError
            }
            "INITIALIZATION_SCRIPT_ERROR" => StreamingSessionStatusCode::InitializationScriptError,
            "INSUFFICIENT_CAPACITY" => StreamingSessionStatusCode::InsufficientCapacity,
            "INTERNAL_ERROR" => StreamingSessionStatusCode::InternalError,
            "NETWORK_CONNECTION_ERROR" => StreamingSessionStatusCode::NetworkConnectionError,
            "NETWORK_INTERFACE_ERROR" => StreamingSessionStatusCode::NetworkInterfaceError,
            "STREAMING_SESSION_CREATE_IN_PROGRESS" => {
                StreamingSessionStatusCode::StreamingSessionCreateInProgress
            }
            "STREAMING_SESSION_DELETED" => StreamingSessionStatusCode::StreamingSessionDeleted,
            "STREAMING_SESSION_DELETE_IN_PROGRESS" => {
                StreamingSessionStatusCode::StreamingSessionDeleteInProgress
            }
            "STREAMING_SESSION_READY" => StreamingSessionStatusCode::StreamingSessionReady,
            "STREAMING_SESSION_STARTED" => StreamingSessionStatusCode::StreamingSessionStarted,
            "STREAMING_SESSION_START_IN_PROGRESS" => {
                StreamingSessionStatusCode::StreamingSessionStartInProgress
            }
            "STREAMING_SESSION_STOPPED" => StreamingSessionStatusCode::StreamingSessionStopped,
            "STREAMING_SESSION_STOP_IN_PROGRESS" => {
                StreamingSessionStatusCode::StreamingSessionStopInProgress
            }
            other => StreamingSessionStatusCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for StreamingSessionStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStatusCode::from(s))
    }
}
impl StreamingSessionStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStatusCode::ActiveDirectoryDomainJoinError => {
                "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
            }
            StreamingSessionStatusCode::AmiValidationError => "AMI_VALIDATION_ERROR",
            StreamingSessionStatusCode::DecryptStreamingImageError => {
                "DECRYPT_STREAMING_IMAGE_ERROR"
            }
            StreamingSessionStatusCode::InitializationScriptError => "INITIALIZATION_SCRIPT_ERROR",
            StreamingSessionStatusCode::InsufficientCapacity => "INSUFFICIENT_CAPACITY",
            StreamingSessionStatusCode::InternalError => "INTERNAL_ERROR",
            StreamingSessionStatusCode::NetworkConnectionError => "NETWORK_CONNECTION_ERROR",
            StreamingSessionStatusCode::NetworkInterfaceError => "NETWORK_INTERFACE_ERROR",
            StreamingSessionStatusCode::StreamingSessionCreateInProgress => {
                "STREAMING_SESSION_CREATE_IN_PROGRESS"
            }
            StreamingSessionStatusCode::StreamingSessionDeleted => "STREAMING_SESSION_DELETED",
            StreamingSessionStatusCode::StreamingSessionDeleteInProgress => {
                "STREAMING_SESSION_DELETE_IN_PROGRESS"
            }
            StreamingSessionStatusCode::StreamingSessionReady => "STREAMING_SESSION_READY",
            StreamingSessionStatusCode::StreamingSessionStarted => "STREAMING_SESSION_STARTED",
            StreamingSessionStatusCode::StreamingSessionStartInProgress => {
                "STREAMING_SESSION_START_IN_PROGRESS"
            }
            StreamingSessionStatusCode::StreamingSessionStopped => "STREAMING_SESSION_STOPPED",
            StreamingSessionStatusCode::StreamingSessionStopInProgress => {
                "STREAMING_SESSION_STOP_IN_PROGRESS"
            }
            StreamingSessionStatusCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR",
            "AMI_VALIDATION_ERROR",
            "DECRYPT_STREAMING_IMAGE_ERROR",
            "INITIALIZATION_SCRIPT_ERROR",
            "INSUFFICIENT_CAPACITY",
            "INTERNAL_ERROR",
            "NETWORK_CONNECTION_ERROR",
            "NETWORK_INTERFACE_ERROR",
            "STREAMING_SESSION_CREATE_IN_PROGRESS",
            "STREAMING_SESSION_DELETED",
            "STREAMING_SESSION_DELETE_IN_PROGRESS",
            "STREAMING_SESSION_READY",
            "STREAMING_SESSION_STARTED",
            "STREAMING_SESSION_START_IN_PROGRESS",
            "STREAMING_SESSION_STOPPED",
            "STREAMING_SESSION_STOP_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StreamingSessionStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StreamingSessionState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streamingsessionstate = unimplemented!();
/// match streamingsessionstate {
///     StreamingSessionState::CreateFailed => { /* ... */ },
///     StreamingSessionState::CreateInProgress => { /* ... */ },
///     StreamingSessionState::Deleted => { /* ... */ },
///     StreamingSessionState::DeleteFailed => { /* ... */ },
///     StreamingSessionState::DeleteInProgress => { /* ... */ },
///     StreamingSessionState::Ready => { /* ... */ },
///     StreamingSessionState::StartFailed => { /* ... */ },
///     StreamingSessionState::StartInProgress => { /* ... */ },
///     StreamingSessionState::Stopped => { /* ... */ },
///     StreamingSessionState::StopFailed => { /* ... */ },
///     StreamingSessionState::StopInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streamingsessionstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingSessionState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingSessionState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingSessionState::NewFeature` is defined.
/// Specifically, when `streamingsessionstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingSessionState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The streaming session state.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    StartFailed,
    #[allow(missing_docs)] // documentation missing in model
    StartInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    StopFailed,
    #[allow(missing_docs)] // documentation missing in model
    StopInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingSessionState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StreamingSessionState::CreateFailed,
            "CREATE_IN_PROGRESS" => StreamingSessionState::CreateInProgress,
            "DELETED" => StreamingSessionState::Deleted,
            "DELETE_FAILED" => StreamingSessionState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StreamingSessionState::DeleteInProgress,
            "READY" => StreamingSessionState::Ready,
            "START_FAILED" => StreamingSessionState::StartFailed,
            "START_IN_PROGRESS" => StreamingSessionState::StartInProgress,
            "STOPPED" => StreamingSessionState::Stopped,
            "STOP_FAILED" => StreamingSessionState::StopFailed,
            "STOP_IN_PROGRESS" => StreamingSessionState::StopInProgress,
            other => {
                StreamingSessionState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StreamingSessionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionState::from(s))
    }
}
impl StreamingSessionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionState::CreateFailed => "CREATE_FAILED",
            StreamingSessionState::CreateInProgress => "CREATE_IN_PROGRESS",
            StreamingSessionState::Deleted => "DELETED",
            StreamingSessionState::DeleteFailed => "DELETE_FAILED",
            StreamingSessionState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StreamingSessionState::Ready => "READY",
            StreamingSessionState::StartFailed => "START_FAILED",
            StreamingSessionState::StartInProgress => "START_IN_PROGRESS",
            StreamingSessionState::Stopped => "STOPPED",
            StreamingSessionState::StopFailed => "STOP_FAILED",
            StreamingSessionState::StopInProgress => "STOP_IN_PROGRESS",
            StreamingSessionState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "START_FAILED",
            "START_IN_PROGRESS",
            "STOPPED",
            "STOP_FAILED",
            "STOP_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StreamingSessionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A stream is an active connection to a streaming session, enabling a studio user to control the streaming session using a compatible client. Streaming session streams are compatible with the NICE DCV web client, included in the Nimble Studio portal, or the NICE DCV desktop client.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingSessionStream {
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that created the streaming session stream.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The ISO timestamp in seconds for when the resource expires.</p>
    #[doc(hidden)]
    pub expires_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
    #[doc(hidden)]
    pub owned_by: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::StreamingSessionStreamState>,
    /// <p>The streaming session stream status code.</p>
    #[doc(hidden)]
    pub status_code: std::option::Option<crate::model::StreamingSessionStreamStatusCode>,
    /// <p>The stream ID.</p>
    #[doc(hidden)]
    pub stream_id: std::option::Option<std::string::String>,
    /// <p>The URL to connect to this stream using the DCV client.</p>
    #[doc(hidden)]
    pub url: std::option::Option<std::string::String>,
}
impl StreamingSessionStream {
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The user ID of the user that created the streaming session stream.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The ISO timestamp in seconds for when the resource expires.</p>
    pub fn expires_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expires_at.as_ref()
    }
    /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
    pub fn owned_by(&self) -> std::option::Option<&str> {
        self.owned_by.as_deref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StreamingSessionStreamState> {
        self.state.as_ref()
    }
    /// <p>The streaming session stream status code.</p>
    pub fn status_code(
        &self,
    ) -> std::option::Option<&crate::model::StreamingSessionStreamStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The stream ID.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
    /// <p>The URL to connect to this stream using the DCV client.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
}
impl std::fmt::Debug for StreamingSessionStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingSessionStream");
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("expires_at", &self.expires_at);
        formatter.field("owned_by", &self.owned_by);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("stream_id", &self.stream_id);
        formatter.field("url", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl StreamingSessionStream {
    /// Creates a new builder-style object to manufacture [`StreamingSessionStream`](crate::model::StreamingSessionStream).
    pub fn builder() -> crate::model::streaming_session_stream::Builder {
        crate::model::streaming_session_stream::Builder::default()
    }
}

/// See [`StreamingSessionStream`](crate::model::StreamingSessionStream).
pub mod streaming_session_stream {

    /// A builder for [`StreamingSessionStream`](crate::model::StreamingSessionStream).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) expires_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) owned_by: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StreamingSessionStreamState>,
        pub(crate) status_code: std::option::Option<crate::model::StreamingSessionStreamStatusCode>,
        pub(crate) stream_id: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the streaming session stream.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that created the streaming session stream.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource expires.</p>
        pub fn expires_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expires_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource expires.</p>
        pub fn set_expires_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expires_at = input;
            self
        }
        /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
        pub fn owned_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.owned_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
        pub fn set_owned_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owned_by = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StreamingSessionStreamState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStreamState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The streaming session stream status code.</p>
        pub fn status_code(
            mut self,
            input: crate::model::StreamingSessionStreamStatusCode,
        ) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The streaming session stream status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStreamStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>The stream ID.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// <p>The URL to connect to this stream using the DCV client.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL to connect to this stream using the DCV client.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingSessionStream`](crate::model::StreamingSessionStream).
        pub fn build(self) -> crate::model::StreamingSessionStream {
            crate::model::StreamingSessionStream {
                created_at: self.created_at,
                created_by: self.created_by,
                expires_at: self.expires_at,
                owned_by: self.owned_by,
                state: self.state,
                status_code: self.status_code,
                stream_id: self.stream_id,
                url: self.url,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("created_at", &self.created_at);
            formatter.field("created_by", &self.created_by);
            formatter.field("expires_at", &self.expires_at);
            formatter.field("owned_by", &self.owned_by);
            formatter.field("state", &self.state);
            formatter.field("status_code", &self.status_code);
            formatter.field("stream_id", &self.stream_id);
            formatter.field("url", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// When writing a match expression against `StreamingSessionStreamStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streamingsessionstreamstatuscode = unimplemented!();
/// match streamingsessionstreamstatuscode {
///     StreamingSessionStreamStatusCode::InternalError => { /* ... */ },
///     StreamingSessionStreamStatusCode::NetworkConnectionError => { /* ... */ },
///     StreamingSessionStreamStatusCode::StreamCreateInProgress => { /* ... */ },
///     StreamingSessionStreamStatusCode::StreamDeleted => { /* ... */ },
///     StreamingSessionStreamStatusCode::StreamDeleteInProgress => { /* ... */ },
///     StreamingSessionStreamStatusCode::StreamReady => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streamingsessionstreamstatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingSessionStreamStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingSessionStreamStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingSessionStreamStatusCode::NewFeature` is defined.
/// Specifically, when `streamingsessionstreamstatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingSessionStreamStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStreamStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    NetworkConnectionError,
    #[allow(missing_docs)] // documentation missing in model
    StreamCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StreamDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamReady,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingSessionStreamStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_ERROR" => StreamingSessionStreamStatusCode::InternalError,
            "NETWORK_CONNECTION_ERROR" => StreamingSessionStreamStatusCode::NetworkConnectionError,
            "STREAM_CREATE_IN_PROGRESS" => StreamingSessionStreamStatusCode::StreamCreateInProgress,
            "STREAM_DELETED" => StreamingSessionStreamStatusCode::StreamDeleted,
            "STREAM_DELETE_IN_PROGRESS" => StreamingSessionStreamStatusCode::StreamDeleteInProgress,
            "STREAM_READY" => StreamingSessionStreamStatusCode::StreamReady,
            other => StreamingSessionStreamStatusCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for StreamingSessionStreamStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStreamStatusCode::from(s))
    }
}
impl StreamingSessionStreamStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStreamStatusCode::InternalError => "INTERNAL_ERROR",
            StreamingSessionStreamStatusCode::NetworkConnectionError => "NETWORK_CONNECTION_ERROR",
            StreamingSessionStreamStatusCode::StreamCreateInProgress => "STREAM_CREATE_IN_PROGRESS",
            StreamingSessionStreamStatusCode::StreamDeleted => "STREAM_DELETED",
            StreamingSessionStreamStatusCode::StreamDeleteInProgress => "STREAM_DELETE_IN_PROGRESS",
            StreamingSessionStreamStatusCode::StreamReady => "STREAM_READY",
            StreamingSessionStreamStatusCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "INTERNAL_ERROR",
            "NETWORK_CONNECTION_ERROR",
            "STREAM_CREATE_IN_PROGRESS",
            "STREAM_DELETED",
            "STREAM_DELETE_IN_PROGRESS",
            "STREAM_READY",
        ]
    }
}
impl AsRef<str> for StreamingSessionStreamStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StreamingSessionStreamState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streamingsessionstreamstate = unimplemented!();
/// match streamingsessionstreamstate {
///     StreamingSessionStreamState::CreateFailed => { /* ... */ },
///     StreamingSessionStreamState::CreateInProgress => { /* ... */ },
///     StreamingSessionStreamState::Deleted => { /* ... */ },
///     StreamingSessionStreamState::DeleteFailed => { /* ... */ },
///     StreamingSessionStreamState::DeleteInProgress => { /* ... */ },
///     StreamingSessionStreamState::Ready => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streamingsessionstreamstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingSessionStreamState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingSessionStreamState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingSessionStreamState::NewFeature` is defined.
/// Specifically, when `streamingsessionstreamstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingSessionStreamState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStreamState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingSessionStreamState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StreamingSessionStreamState::CreateFailed,
            "CREATE_IN_PROGRESS" => StreamingSessionStreamState::CreateInProgress,
            "DELETED" => StreamingSessionStreamState::Deleted,
            "DELETE_FAILED" => StreamingSessionStreamState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StreamingSessionStreamState::DeleteInProgress,
            "READY" => StreamingSessionStreamState::Ready,
            other => StreamingSessionStreamState::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for StreamingSessionStreamState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStreamState::from(s))
    }
}
impl StreamingSessionStreamState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStreamState::CreateFailed => "CREATE_FAILED",
            StreamingSessionStreamState::CreateInProgress => "CREATE_IN_PROGRESS",
            StreamingSessionStreamState::Deleted => "DELETED",
            StreamingSessionStreamState::DeleteFailed => "DELETE_FAILED",
            StreamingSessionStreamState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StreamingSessionStreamState::Ready => "READY",
            StreamingSessionStreamState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
        ]
    }
}
impl AsRef<str> for StreamingSessionStreamState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StreamingInstanceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streaminginstancetype = unimplemented!();
/// match streaminginstancetype {
///     StreamingInstanceType::G34xlarge => { /* ... */ },
///     StreamingInstanceType::G3sXlarge => { /* ... */ },
///     StreamingInstanceType::G4dn12xlarge => { /* ... */ },
///     StreamingInstanceType::G4dn16xlarge => { /* ... */ },
///     StreamingInstanceType::G4dn2xlarge => { /* ... */ },
///     StreamingInstanceType::G4dn4xlarge => { /* ... */ },
///     StreamingInstanceType::G4dn8xlarge => { /* ... */ },
///     StreamingInstanceType::G4dnXlarge => { /* ... */ },
///     StreamingInstanceType::G516xlarge => { /* ... */ },
///     StreamingInstanceType::G52xlarge => { /* ... */ },
///     StreamingInstanceType::G54xlarge => { /* ... */ },
///     StreamingInstanceType::G58xlarge => { /* ... */ },
///     StreamingInstanceType::G5Xlarge => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streaminginstancetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingInstanceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingInstanceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingInstanceType::NewFeature` is defined.
/// Specifically, when `streaminginstancetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingInstanceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    G34xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G3sXlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dn12xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dn16xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dn2xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dn4xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dn8xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dnXlarge,
    #[allow(missing_docs)] // documentation missing in model
    G516xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G52xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G54xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G58xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G5Xlarge,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "g3.4xlarge" => StreamingInstanceType::G34xlarge,
            "g3s.xlarge" => StreamingInstanceType::G3sXlarge,
            "g4dn.12xlarge" => StreamingInstanceType::G4dn12xlarge,
            "g4dn.16xlarge" => StreamingInstanceType::G4dn16xlarge,
            "g4dn.2xlarge" => StreamingInstanceType::G4dn2xlarge,
            "g4dn.4xlarge" => StreamingInstanceType::G4dn4xlarge,
            "g4dn.8xlarge" => StreamingInstanceType::G4dn8xlarge,
            "g4dn.xlarge" => StreamingInstanceType::G4dnXlarge,
            "g5.16xlarge" => StreamingInstanceType::G516xlarge,
            "g5.2xlarge" => StreamingInstanceType::G52xlarge,
            "g5.4xlarge" => StreamingInstanceType::G54xlarge,
            "g5.8xlarge" => StreamingInstanceType::G58xlarge,
            "g5.xlarge" => StreamingInstanceType::G5Xlarge,
            other => {
                StreamingInstanceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StreamingInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingInstanceType::from(s))
    }
}
impl StreamingInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingInstanceType::G34xlarge => "g3.4xlarge",
            StreamingInstanceType::G3sXlarge => "g3s.xlarge",
            StreamingInstanceType::G4dn12xlarge => "g4dn.12xlarge",
            StreamingInstanceType::G4dn16xlarge => "g4dn.16xlarge",
            StreamingInstanceType::G4dn2xlarge => "g4dn.2xlarge",
            StreamingInstanceType::G4dn4xlarge => "g4dn.4xlarge",
            StreamingInstanceType::G4dn8xlarge => "g4dn.8xlarge",
            StreamingInstanceType::G4dnXlarge => "g4dn.xlarge",
            StreamingInstanceType::G516xlarge => "g5.16xlarge",
            StreamingInstanceType::G52xlarge => "g5.2xlarge",
            StreamingInstanceType::G54xlarge => "g5.4xlarge",
            StreamingInstanceType::G58xlarge => "g5.8xlarge",
            StreamingInstanceType::G5Xlarge => "g5.xlarge",
            StreamingInstanceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "g3.4xlarge",
            "g3s.xlarge",
            "g4dn.12xlarge",
            "g4dn.16xlarge",
            "g4dn.2xlarge",
            "g4dn.4xlarge",
            "g4dn.8xlarge",
            "g4dn.xlarge",
            "g5.16xlarge",
            "g5.2xlarge",
            "g5.4xlarge",
            "g5.8xlarge",
            "g5.xlarge",
        ]
    }
}
impl AsRef<str> for StreamingInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about the streaming session backup.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamingSessionBackup {
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ISO timestamp in for when the resource was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The ID of the launch profile which allowed the backups for the streaming session.</p>
    #[doc(hidden)]
    pub launch_profile_id: std::option::Option<std::string::String>,
    /// <p>The user ID of the user that owns the streaming session.</p>
    #[doc(hidden)]
    pub owned_by: std::option::Option<std::string::String>,
    /// <p>The streaming session ID for the <code>StreamingSessionBackup</code>.</p>
    #[doc(hidden)]
    pub session_id: std::option::Option<std::string::String>,
    /// <p>The streaming session state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::StreamingSessionState>,
    /// <p>The status code.</p>
    #[doc(hidden)]
    pub status_code: std::option::Option<crate::model::StreamingSessionStatusCode>,
    /// <p>The status message for the streaming session backup.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The ID of the backup.</p>
    #[doc(hidden)]
    pub backup_id: std::option::Option<std::string::String>,
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl StreamingSessionBackup {
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ISO timestamp in for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The ID of the launch profile which allowed the backups for the streaming session.</p>
    pub fn launch_profile_id(&self) -> std::option::Option<&str> {
        self.launch_profile_id.as_deref()
    }
    /// <p>The user ID of the user that owns the streaming session.</p>
    pub fn owned_by(&self) -> std::option::Option<&str> {
        self.owned_by.as_deref()
    }
    /// <p>The streaming session ID for the <code>StreamingSessionBackup</code>.</p>
    pub fn session_id(&self) -> std::option::Option<&str> {
        self.session_id.as_deref()
    }
    /// <p>The streaming session state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StreamingSessionState> {
        self.state.as_ref()
    }
    /// <p>The status code.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::StreamingSessionStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the streaming session backup.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The ID of the backup.</p>
    pub fn backup_id(&self) -> std::option::Option<&str> {
        self.backup_id.as_deref()
    }
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl StreamingSessionBackup {
    /// Creates a new builder-style object to manufacture [`StreamingSessionBackup`](crate::model::StreamingSessionBackup).
    pub fn builder() -> crate::model::streaming_session_backup::Builder {
        crate::model::streaming_session_backup::Builder::default()
    }
}

/// See [`StreamingSessionBackup`](crate::model::StreamingSessionBackup).
pub mod streaming_session_backup {

    /// A builder for [`StreamingSessionBackup`](crate::model::StreamingSessionBackup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) launch_profile_id: std::option::Option<std::string::String>,
        pub(crate) owned_by: std::option::Option<std::string::String>,
        pub(crate) session_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StreamingSessionState>,
        pub(crate) status_code: std::option::Option<crate::model::StreamingSessionStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) backup_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ISO timestamp in for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The ID of the launch profile which allowed the backups for the streaming session.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_profile_id = Some(input.into());
            self
        }
        /// <p>The ID of the launch profile which allowed the backups for the streaming session.</p>
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_id = input;
            self
        }
        /// <p>The user ID of the user that owns the streaming session.</p>
        pub fn owned_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.owned_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that owns the streaming session.</p>
        pub fn set_owned_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owned_by = input;
            self
        }
        /// <p>The streaming session ID for the <code>StreamingSessionBackup</code>.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_id = Some(input.into());
            self
        }
        /// <p>The streaming session ID for the <code>StreamingSessionBackup</code>.</p>
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.session_id = input;
            self
        }
        /// <p>The streaming session state.</p>
        pub fn state(mut self, input: crate::model::StreamingSessionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The streaming session state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::StreamingSessionStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the streaming session backup.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the streaming session backup.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The ID of the backup.</p>
        pub fn backup_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.backup_id = Some(input.into());
            self
        }
        /// <p>The ID of the backup.</p>
        pub fn set_backup_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.backup_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingSessionBackup`](crate::model::StreamingSessionBackup).
        pub fn build(self) -> crate::model::StreamingSessionBackup {
            crate::model::StreamingSessionBackup {
                arn: self.arn,
                created_at: self.created_at,
                launch_profile_id: self.launch_profile_id,
                owned_by: self.owned_by,
                session_id: self.session_id,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                backup_id: self.backup_id,
                tags: self.tags,
            }
        }
    }
}

/// <p>Represents a streaming image resource.</p>
/// <p>Streaming images are used by studio users to select which operating system and software they want to use in a Nimble Studio streaming session.</p>
/// <p>Amazon provides a number of streaming images that include popular 3rd-party software.</p>
/// <p>You can create your own streaming images using an Amazon EC2 machine image that you create for this purpose. You can also include software that your users require.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingImage {
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>A human-readable description of the streaming image.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
    #[doc(hidden)]
    pub ec2_image_id: std::option::Option<std::string::String>,
    /// <p>The encryption configuration.</p>
    #[doc(hidden)]
    pub encryption_configuration:
        std::option::Option<crate::model::StreamingImageEncryptionConfiguration>,
    /// <p>The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.</p>
    #[doc(hidden)]
    pub eula_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A friendly name for a streaming image resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The owner of the streaming image, either the <code>studioId</code> that contains the streaming image, or <code>amazon</code> for images that are provided by Amazon Nimble Studio.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The platform of the streaming image, either Windows or Linux.</p>
    #[doc(hidden)]
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::StreamingImageState>,
    /// <p>The status code.</p>
    #[doc(hidden)]
    pub status_code: std::option::Option<crate::model::StreamingImageStatusCode>,
    /// <p>The status message for the streaming image.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The ID of the streaming image.</p>
    #[doc(hidden)]
    pub streaming_image_id: std::option::Option<std::string::String>,
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl StreamingImage {
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A human-readable description of the streaming image.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
    pub fn ec2_image_id(&self) -> std::option::Option<&str> {
        self.ec2_image_id.as_deref()
    }
    /// <p>The encryption configuration.</p>
    pub fn encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::StreamingImageEncryptionConfiguration> {
        self.encryption_configuration.as_ref()
    }
    /// <p>The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.</p>
    pub fn eula_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.eula_ids.as_deref()
    }
    /// <p>A friendly name for a streaming image resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The owner of the streaming image, either the <code>studioId</code> that contains the streaming image, or <code>amazon</code> for images that are provided by Amazon Nimble Studio.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The platform of the streaming image, either Windows or Linux.</p>
    pub fn platform(&self) -> std::option::Option<&str> {
        self.platform.as_deref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StreamingImageState> {
        self.state.as_ref()
    }
    /// <p>The status code.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::StreamingImageStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the streaming image.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The ID of the streaming image.</p>
    pub fn streaming_image_id(&self) -> std::option::Option<&str> {
        self.streaming_image_id.as_deref()
    }
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for StreamingImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingImage");
        formatter.field("arn", &self.arn);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("ec2_image_id", &self.ec2_image_id);
        formatter.field("encryption_configuration", &self.encryption_configuration);
        formatter.field("eula_ids", &self.eula_ids);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("owner", &self.owner);
        formatter.field("platform", &self.platform);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("streaming_image_id", &self.streaming_image_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
impl StreamingImage {
    /// Creates a new builder-style object to manufacture [`StreamingImage`](crate::model::StreamingImage).
    pub fn builder() -> crate::model::streaming_image::Builder {
        crate::model::streaming_image::Builder::default()
    }
}

/// See [`StreamingImage`](crate::model::StreamingImage).
pub mod streaming_image {

    /// A builder for [`StreamingImage`](crate::model::StreamingImage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ec2_image_id: std::option::Option<std::string::String>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::StreamingImageEncryptionConfiguration>,
        pub(crate) eula_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StreamingImageState>,
        pub(crate) status_code: std::option::Option<crate::model::StreamingImageStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) streaming_image_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A human-readable description of the streaming image.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A human-readable description of the streaming image.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
        pub fn ec2_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_image_id = Some(input.into());
            self
        }
        /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
        pub fn set_ec2_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ec2_image_id = input;
            self
        }
        /// <p>The encryption configuration.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::StreamingImageEncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        /// <p>The encryption configuration.</p>
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamingImageEncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        /// Appends an item to `eula_ids`.
        ///
        /// To override the contents of this collection use [`set_eula_ids`](Self::set_eula_ids).
        ///
        /// <p>The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.</p>
        pub fn eula_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.eula_ids.unwrap_or_default();
            v.push(input.into());
            self.eula_ids = Some(v);
            self
        }
        /// <p>The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.</p>
        pub fn set_eula_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.eula_ids = input;
            self
        }
        /// <p>A friendly name for a streaming image resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A friendly name for a streaming image resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The owner of the streaming image, either the <code>studioId</code> that contains the streaming image, or <code>amazon</code> for images that are provided by Amazon Nimble Studio.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The owner of the streaming image, either the <code>studioId</code> that contains the streaming image, or <code>amazon</code> for images that are provided by Amazon Nimble Studio.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The platform of the streaming image, either Windows or Linux.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The platform of the streaming image, either Windows or Linux.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StreamingImageState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StreamingImageState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::StreamingImageStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StreamingImageStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the streaming image.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the streaming image.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn streaming_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.streaming_image_id = Some(input.into());
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.streaming_image_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingImage`](crate::model::StreamingImage).
        pub fn build(self) -> crate::model::StreamingImage {
            crate::model::StreamingImage {
                arn: self.arn,
                description: self.description,
                ec2_image_id: self.ec2_image_id,
                encryption_configuration: self.encryption_configuration,
                eula_ids: self.eula_ids,
                name: self.name,
                owner: self.owner,
                platform: self.platform,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                streaming_image_id: self.streaming_image_id,
                tags: self.tags,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("arn", &self.arn);
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("ec2_image_id", &self.ec2_image_id);
            formatter.field("encryption_configuration", &self.encryption_configuration);
            formatter.field("eula_ids", &self.eula_ids);
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("owner", &self.owner);
            formatter.field("platform", &self.platform);
            formatter.field("state", &self.state);
            formatter.field("status_code", &self.status_code);
            formatter.field("status_message", &self.status_message);
            formatter.field("streaming_image_id", &self.streaming_image_id);
            formatter.field("tags", &self.tags);
            formatter.finish()
        }
    }
}

/// When writing a match expression against `StreamingImageStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streamingimagestatuscode = unimplemented!();
/// match streamingimagestatuscode {
///     StreamingImageStatusCode::AccessDenied => { /* ... */ },
///     StreamingImageStatusCode::InternalError => { /* ... */ },
///     StreamingImageStatusCode::StreamingImageCreateInProgress => { /* ... */ },
///     StreamingImageStatusCode::StreamingImageDeleted => { /* ... */ },
///     StreamingImageStatusCode::StreamingImageDeleteInProgress => { /* ... */ },
///     StreamingImageStatusCode::StreamingImageReady => { /* ... */ },
///     StreamingImageStatusCode::StreamingImageUpdateInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streamingimagestatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingImageStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingImageStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingImageStatusCode::NewFeature` is defined.
/// Specifically, when `streamingimagestatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingImageStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The status code.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingImageStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageReady,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageUpdateInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingImageStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED" => StreamingImageStatusCode::AccessDenied,
            "INTERNAL_ERROR" => StreamingImageStatusCode::InternalError,
            "STREAMING_IMAGE_CREATE_IN_PROGRESS" => {
                StreamingImageStatusCode::StreamingImageCreateInProgress
            }
            "STREAMING_IMAGE_DELETED" => StreamingImageStatusCode::StreamingImageDeleted,
            "STREAMING_IMAGE_DELETE_IN_PROGRESS" => {
                StreamingImageStatusCode::StreamingImageDeleteInProgress
            }
            "STREAMING_IMAGE_READY" => StreamingImageStatusCode::StreamingImageReady,
            "STREAMING_IMAGE_UPDATE_IN_PROGRESS" => {
                StreamingImageStatusCode::StreamingImageUpdateInProgress
            }
            other => StreamingImageStatusCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for StreamingImageStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingImageStatusCode::from(s))
    }
}
impl StreamingImageStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingImageStatusCode::AccessDenied => "ACCESS_DENIED",
            StreamingImageStatusCode::InternalError => "INTERNAL_ERROR",
            StreamingImageStatusCode::StreamingImageCreateInProgress => {
                "STREAMING_IMAGE_CREATE_IN_PROGRESS"
            }
            StreamingImageStatusCode::StreamingImageDeleted => "STREAMING_IMAGE_DELETED",
            StreamingImageStatusCode::StreamingImageDeleteInProgress => {
                "STREAMING_IMAGE_DELETE_IN_PROGRESS"
            }
            StreamingImageStatusCode::StreamingImageReady => "STREAMING_IMAGE_READY",
            StreamingImageStatusCode::StreamingImageUpdateInProgress => {
                "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
            }
            StreamingImageStatusCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED",
            "INTERNAL_ERROR",
            "STREAMING_IMAGE_CREATE_IN_PROGRESS",
            "STREAMING_IMAGE_DELETED",
            "STREAMING_IMAGE_DELETE_IN_PROGRESS",
            "STREAMING_IMAGE_READY",
            "STREAMING_IMAGE_UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StreamingImageStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `StreamingImageState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streamingimagestate = unimplemented!();
/// match streamingimagestate {
///     StreamingImageState::CreateFailed => { /* ... */ },
///     StreamingImageState::CreateInProgress => { /* ... */ },
///     StreamingImageState::Deleted => { /* ... */ },
///     StreamingImageState::DeleteFailed => { /* ... */ },
///     StreamingImageState::DeleteInProgress => { /* ... */ },
///     StreamingImageState::Ready => { /* ... */ },
///     StreamingImageState::UpdateFailed => { /* ... */ },
///     StreamingImageState::UpdateInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streamingimagestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingImageState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingImageState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingImageState::NewFeature` is defined.
/// Specifically, when `streamingimagestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingImageState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingImageState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingImageState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StreamingImageState::CreateFailed,
            "CREATE_IN_PROGRESS" => StreamingImageState::CreateInProgress,
            "DELETED" => StreamingImageState::Deleted,
            "DELETE_FAILED" => StreamingImageState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StreamingImageState::DeleteInProgress,
            "READY" => StreamingImageState::Ready,
            "UPDATE_FAILED" => StreamingImageState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => StreamingImageState::UpdateInProgress,
            other => {
                StreamingImageState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StreamingImageState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingImageState::from(s))
    }
}
impl StreamingImageState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingImageState::CreateFailed => "CREATE_FAILED",
            StreamingImageState::CreateInProgress => "CREATE_IN_PROGRESS",
            StreamingImageState::Deleted => "DELETED",
            StreamingImageState::DeleteFailed => "DELETE_FAILED",
            StreamingImageState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StreamingImageState::Ready => "READY",
            StreamingImageState::UpdateFailed => "UPDATE_FAILED",
            StreamingImageState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            StreamingImageState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StreamingImageState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies how a streaming image is encrypted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamingImageEncryptionConfiguration {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    #[doc(hidden)]
    pub key_arn: std::option::Option<std::string::String>,
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    #[doc(hidden)]
    pub key_type: std::option::Option<crate::model::StreamingImageEncryptionConfigurationKeyType>,
}
impl StreamingImageEncryptionConfiguration {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    pub fn key_arn(&self) -> std::option::Option<&str> {
        self.key_arn.as_deref()
    }
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    pub fn key_type(
        &self,
    ) -> std::option::Option<&crate::model::StreamingImageEncryptionConfigurationKeyType> {
        self.key_type.as_ref()
    }
}
impl StreamingImageEncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration).
    pub fn builder() -> crate::model::streaming_image_encryption_configuration::Builder {
        crate::model::streaming_image_encryption_configuration::Builder::default()
    }
}

/// See [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration).
pub mod streaming_image_encryption_configuration {

    /// A builder for [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_arn: std::option::Option<std::string::String>,
        pub(crate) key_type:
            std::option::Option<crate::model::StreamingImageEncryptionConfigurationKeyType>,
    }
    impl Builder {
        /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        pub fn key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_arn = Some(input.into());
            self
        }
        /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        pub fn set_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_arn = input;
            self
        }
        /// <p>The type of KMS key that is used to encrypt studio data.</p>
        pub fn key_type(
            mut self,
            input: crate::model::StreamingImageEncryptionConfigurationKeyType,
        ) -> Self {
            self.key_type = Some(input);
            self
        }
        /// <p>The type of KMS key that is used to encrypt studio data.</p>
        pub fn set_key_type(
            mut self,
            input: std::option::Option<crate::model::StreamingImageEncryptionConfigurationKeyType>,
        ) -> Self {
            self.key_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration).
        pub fn build(self) -> crate::model::StreamingImageEncryptionConfiguration {
            crate::model::StreamingImageEncryptionConfiguration {
                key_arn: self.key_arn,
                key_type: self.key_type,
            }
        }
    }
}

/// When writing a match expression against `StreamingImageEncryptionConfigurationKeyType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streamingimageencryptionconfigurationkeytype = unimplemented!();
/// match streamingimageencryptionconfigurationkeytype {
///     StreamingImageEncryptionConfigurationKeyType::CustomerManagedKey => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streamingimageencryptionconfigurationkeytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingImageEncryptionConfigurationKeyType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingImageEncryptionConfigurationKeyType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingImageEncryptionConfigurationKeyType::NewFeature` is defined.
/// Specifically, when `streamingimageencryptionconfigurationkeytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingImageEncryptionConfigurationKeyType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingImageEncryptionConfigurationKeyType {
    #[allow(missing_docs)] // documentation missing in model
    CustomerManagedKey,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingImageEncryptionConfigurationKeyType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOMER_MANAGED_KEY" => {
                StreamingImageEncryptionConfigurationKeyType::CustomerManagedKey
            }
            other => StreamingImageEncryptionConfigurationKeyType::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for StreamingImageEncryptionConfigurationKeyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingImageEncryptionConfigurationKeyType::from(s))
    }
}
impl StreamingImageEncryptionConfigurationKeyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingImageEncryptionConfigurationKeyType::CustomerManagedKey => {
                "CUSTOMER_MANAGED_KEY"
            }
            StreamingImageEncryptionConfigurationKeyType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CUSTOMER_MANAGED_KEY"]
    }
}
impl AsRef<str> for StreamingImageEncryptionConfigurationKeyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Studio admins can use launch profile membership to delegate launch profile access to studio users in the Nimble Studio portal without writing or maintaining complex IAM policies. A launch profile member is a user association from your studio identity source who is granted permissions to a launch profile.</p>
/// <p>A launch profile member (type USER) provides the following permissions to that launch profile:</p>
/// <ul>
/// <li> <p>GetLaunchProfile</p> </li>
/// <li> <p>GetLaunchProfileInitialization</p> </li>
/// <li> <p>GetLaunchProfileMembers</p> </li>
/// <li> <p>GetLaunchProfileMember</p> </li>
/// <li> <p>CreateStreamingSession</p> </li>
/// <li> <p>GetLaunchProfileDetails</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LaunchProfileMembership {
    /// <p>The ID of the identity store.</p>
    #[doc(hidden)]
    pub identity_store_id: std::option::Option<std::string::String>,
    /// <p>The persona.</p>
    #[doc(hidden)]
    pub persona: std::option::Option<crate::model::LaunchProfilePersona>,
    /// <p>The principal ID.</p>
    #[doc(hidden)]
    pub principal_id: std::option::Option<std::string::String>,
    /// <p>The Active Directory Security Identifier for this user, if available.</p>
    #[doc(hidden)]
    pub sid: std::option::Option<std::string::String>,
}
impl LaunchProfileMembership {
    /// <p>The ID of the identity store.</p>
    pub fn identity_store_id(&self) -> std::option::Option<&str> {
        self.identity_store_id.as_deref()
    }
    /// <p>The persona.</p>
    pub fn persona(&self) -> std::option::Option<&crate::model::LaunchProfilePersona> {
        self.persona.as_ref()
    }
    /// <p>The principal ID.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
    /// <p>The Active Directory Security Identifier for this user, if available.</p>
    pub fn sid(&self) -> std::option::Option<&str> {
        self.sid.as_deref()
    }
}
impl LaunchProfileMembership {
    /// Creates a new builder-style object to manufacture [`LaunchProfileMembership`](crate::model::LaunchProfileMembership).
    pub fn builder() -> crate::model::launch_profile_membership::Builder {
        crate::model::launch_profile_membership::Builder::default()
    }
}

/// See [`LaunchProfileMembership`](crate::model::LaunchProfileMembership).
pub mod launch_profile_membership {

    /// A builder for [`LaunchProfileMembership`](crate::model::LaunchProfileMembership).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_store_id: std::option::Option<std::string::String>,
        pub(crate) persona: std::option::Option<crate::model::LaunchProfilePersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
        pub(crate) sid: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_store_id = Some(input.into());
            self
        }
        /// <p>The ID of the identity store.</p>
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_store_id = input;
            self
        }
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::LaunchProfilePersona) -> Self {
            self.persona = Some(input);
            self
        }
        /// <p>The persona.</p>
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// <p>The Active Directory Security Identifier for this user, if available.</p>
        pub fn sid(mut self, input: impl Into<std::string::String>) -> Self {
            self.sid = Some(input.into());
            self
        }
        /// <p>The Active Directory Security Identifier for this user, if available.</p>
        pub fn set_sid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sid = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileMembership`](crate::model::LaunchProfileMembership).
        pub fn build(self) -> crate::model::LaunchProfileMembership {
            crate::model::LaunchProfileMembership {
                identity_store_id: self.identity_store_id,
                persona: self.persona,
                principal_id: self.principal_id,
                sid: self.sid,
            }
        }
    }
}

/// When writing a match expression against `LaunchProfilePersona`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let launchprofilepersona = unimplemented!();
/// match launchprofilepersona {
///     LaunchProfilePersona::User => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `launchprofilepersona` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LaunchProfilePersona::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LaunchProfilePersona::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LaunchProfilePersona::NewFeature` is defined.
/// Specifically, when `launchprofilepersona` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LaunchProfilePersona::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfilePersona {
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LaunchProfilePersona {
    fn from(s: &str) -> Self {
        match s {
            "USER" => LaunchProfilePersona::User,
            other => {
                LaunchProfilePersona::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for LaunchProfilePersona {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfilePersona::from(s))
    }
}
impl LaunchProfilePersona {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfilePersona::User => "USER",
            LaunchProfilePersona::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["USER"]
    }
}
impl AsRef<str> for LaunchProfilePersona {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A new member that is added to a launch profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NewLaunchProfileMember {
    /// <p>The persona.</p>
    #[doc(hidden)]
    pub persona: std::option::Option<crate::model::LaunchProfilePersona>,
    /// <p>The principal ID.</p>
    #[doc(hidden)]
    pub principal_id: std::option::Option<std::string::String>,
}
impl NewLaunchProfileMember {
    /// <p>The persona.</p>
    pub fn persona(&self) -> std::option::Option<&crate::model::LaunchProfilePersona> {
        self.persona.as_ref()
    }
    /// <p>The principal ID.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
}
impl NewLaunchProfileMember {
    /// Creates a new builder-style object to manufacture [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember).
    pub fn builder() -> crate::model::new_launch_profile_member::Builder {
        crate::model::new_launch_profile_member::Builder::default()
    }
}

/// See [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember).
pub mod new_launch_profile_member {

    /// A builder for [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) persona: std::option::Option<crate::model::LaunchProfilePersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::LaunchProfilePersona) -> Self {
            self.persona = Some(input);
            self
        }
        /// <p>The persona.</p>
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember).
        pub fn build(self) -> crate::model::NewLaunchProfileMember {
            crate::model::NewLaunchProfileMember {
                persona: self.persona,
                principal_id: self.principal_id,
            }
        }
    }
}

/// <p>A launch profile initialization contains information required for a workstation or server to connect to a launch profile.</p>
/// <p>This includes scripts, endpoints, security groups, subnets, and other configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileInitialization {
    /// <p>A <code>LaunchProfileInitializationActiveDirectory</code> resource.</p>
    #[doc(hidden)]
    pub active_directory:
        std::option::Option<crate::model::LaunchProfileInitializationActiveDirectory>,
    /// <p>The EC2 security groups that control access to the studio component.</p>
    #[doc(hidden)]
    pub ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the launch profile used to control access from the streaming session.</p>
    #[doc(hidden)]
    pub launch_profile_id: std::option::Option<std::string::String>,
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    #[doc(hidden)]
    pub launch_profile_protocol_version: std::option::Option<std::string::String>,
    /// <p>The launch purpose.</p>
    #[doc(hidden)]
    pub launch_purpose: std::option::Option<std::string::String>,
    /// <p>The name for the launch profile.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The platform of the launch platform, either Windows or Linux.</p>
    #[doc(hidden)]
    pub platform: std::option::Option<crate::model::LaunchProfilePlatform>,
    /// <p>The system initializtion scripts.</p>
    #[doc(hidden)]
    pub system_initialization_scripts:
        std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
    /// <p>The user initializtion scripts.</p>
    #[doc(hidden)]
    pub user_initialization_scripts:
        std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
}
impl LaunchProfileInitialization {
    /// <p>A <code>LaunchProfileInitializationActiveDirectory</code> resource.</p>
    pub fn active_directory(
        &self,
    ) -> std::option::Option<&crate::model::LaunchProfileInitializationActiveDirectory> {
        self.active_directory.as_ref()
    }
    /// <p>The EC2 security groups that control access to the studio component.</p>
    pub fn ec2_security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.ec2_security_group_ids.as_deref()
    }
    /// <p>The ID of the launch profile used to control access from the streaming session.</p>
    pub fn launch_profile_id(&self) -> std::option::Option<&str> {
        self.launch_profile_id.as_deref()
    }
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub fn launch_profile_protocol_version(&self) -> std::option::Option<&str> {
        self.launch_profile_protocol_version.as_deref()
    }
    /// <p>The launch purpose.</p>
    pub fn launch_purpose(&self) -> std::option::Option<&str> {
        self.launch_purpose.as_deref()
    }
    /// <p>The name for the launch profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The platform of the launch platform, either Windows or Linux.</p>
    pub fn platform(&self) -> std::option::Option<&crate::model::LaunchProfilePlatform> {
        self.platform.as_ref()
    }
    /// <p>The system initializtion scripts.</p>
    pub fn system_initialization_scripts(
        &self,
    ) -> std::option::Option<&[crate::model::LaunchProfileInitializationScript]> {
        self.system_initialization_scripts.as_deref()
    }
    /// <p>The user initializtion scripts.</p>
    pub fn user_initialization_scripts(
        &self,
    ) -> std::option::Option<&[crate::model::LaunchProfileInitializationScript]> {
        self.user_initialization_scripts.as_deref()
    }
}
impl std::fmt::Debug for LaunchProfileInitialization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileInitialization");
        formatter.field("active_directory", &self.active_directory);
        formatter.field("ec2_security_group_ids", &self.ec2_security_group_ids);
        formatter.field("launch_profile_id", &self.launch_profile_id);
        formatter.field(
            "launch_profile_protocol_version",
            &self.launch_profile_protocol_version,
        );
        formatter.field("launch_purpose", &self.launch_purpose);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("platform", &self.platform);
        formatter.field(
            "system_initialization_scripts",
            &self.system_initialization_scripts,
        );
        formatter.field(
            "user_initialization_scripts",
            &self.user_initialization_scripts,
        );
        formatter.finish()
    }
}
impl LaunchProfileInitialization {
    /// Creates a new builder-style object to manufacture [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization).
    pub fn builder() -> crate::model::launch_profile_initialization::Builder {
        crate::model::launch_profile_initialization::Builder::default()
    }
}

/// See [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization).
pub mod launch_profile_initialization {

    /// A builder for [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) active_directory:
            std::option::Option<crate::model::LaunchProfileInitializationActiveDirectory>,
        pub(crate) ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) launch_profile_id: std::option::Option<std::string::String>,
        pub(crate) launch_profile_protocol_version: std::option::Option<std::string::String>,
        pub(crate) launch_purpose: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<crate::model::LaunchProfilePlatform>,
        pub(crate) system_initialization_scripts:
            std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
        pub(crate) user_initialization_scripts:
            std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
    }
    impl Builder {
        /// <p>A <code>LaunchProfileInitializationActiveDirectory</code> resource.</p>
        pub fn active_directory(
            mut self,
            input: crate::model::LaunchProfileInitializationActiveDirectory,
        ) -> Self {
            self.active_directory = Some(input);
            self
        }
        /// <p>A <code>LaunchProfileInitializationActiveDirectory</code> resource.</p>
        pub fn set_active_directory(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileInitializationActiveDirectory>,
        ) -> Self {
            self.active_directory = input;
            self
        }
        /// Appends an item to `ec2_security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_ec2_security_group_ids`](Self::set_ec2_security_group_ids).
        ///
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn ec2_security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ec2_security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.ec2_security_group_ids = Some(v);
            self
        }
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn set_ec2_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ec2_security_group_ids = input;
            self
        }
        /// <p>The ID of the launch profile used to control access from the streaming session.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_profile_id = Some(input.into());
            self
        }
        /// <p>The ID of the launch profile used to control access from the streaming session.</p>
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_id = input;
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_version(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = Some(input.into());
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn set_launch_profile_protocol_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = input;
            self
        }
        /// <p>The launch purpose.</p>
        pub fn launch_purpose(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_purpose = Some(input.into());
            self
        }
        /// <p>The launch purpose.</p>
        pub fn set_launch_purpose(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_purpose = input;
            self
        }
        /// <p>The name for the launch profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the launch profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The platform of the launch platform, either Windows or Linux.</p>
        pub fn platform(mut self, input: crate::model::LaunchProfilePlatform) -> Self {
            self.platform = Some(input);
            self
        }
        /// <p>The platform of the launch platform, either Windows or Linux.</p>
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePlatform>,
        ) -> Self {
            self.platform = input;
            self
        }
        /// Appends an item to `system_initialization_scripts`.
        ///
        /// To override the contents of this collection use [`set_system_initialization_scripts`](Self::set_system_initialization_scripts).
        ///
        /// <p>The system initializtion scripts.</p>
        pub fn system_initialization_scripts(
            mut self,
            input: crate::model::LaunchProfileInitializationScript,
        ) -> Self {
            let mut v = self.system_initialization_scripts.unwrap_or_default();
            v.push(input);
            self.system_initialization_scripts = Some(v);
            self
        }
        /// <p>The system initializtion scripts.</p>
        pub fn set_system_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchProfileInitializationScript>,
            >,
        ) -> Self {
            self.system_initialization_scripts = input;
            self
        }
        /// Appends an item to `user_initialization_scripts`.
        ///
        /// To override the contents of this collection use [`set_user_initialization_scripts`](Self::set_user_initialization_scripts).
        ///
        /// <p>The user initializtion scripts.</p>
        pub fn user_initialization_scripts(
            mut self,
            input: crate::model::LaunchProfileInitializationScript,
        ) -> Self {
            let mut v = self.user_initialization_scripts.unwrap_or_default();
            v.push(input);
            self.user_initialization_scripts = Some(v);
            self
        }
        /// <p>The user initializtion scripts.</p>
        pub fn set_user_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchProfileInitializationScript>,
            >,
        ) -> Self {
            self.user_initialization_scripts = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization).
        pub fn build(self) -> crate::model::LaunchProfileInitialization {
            crate::model::LaunchProfileInitialization {
                active_directory: self.active_directory,
                ec2_security_group_ids: self.ec2_security_group_ids,
                launch_profile_id: self.launch_profile_id,
                launch_profile_protocol_version: self.launch_profile_protocol_version,
                launch_purpose: self.launch_purpose,
                name: self.name,
                platform: self.platform,
                system_initialization_scripts: self.system_initialization_scripts,
                user_initialization_scripts: self.user_initialization_scripts,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("active_directory", &self.active_directory);
            formatter.field("ec2_security_group_ids", &self.ec2_security_group_ids);
            formatter.field("launch_profile_id", &self.launch_profile_id);
            formatter.field(
                "launch_profile_protocol_version",
                &self.launch_profile_protocol_version,
            );
            formatter.field("launch_purpose", &self.launch_purpose);
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("platform", &self.platform);
            formatter.field(
                "system_initialization_scripts",
                &self.system_initialization_scripts,
            );
            formatter.field(
                "user_initialization_scripts",
                &self.user_initialization_scripts,
            );
            formatter.finish()
        }
    }
}

/// <p>The launch profile initialization script is used when start streaming session runs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileInitializationScript {
    /// <p>The initialization script.</p>
    #[doc(hidden)]
    pub script: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    #[doc(hidden)]
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The name for the studio component.</p>
    #[doc(hidden)]
    pub studio_component_name: std::option::Option<std::string::String>,
    /// <p>An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.</p>
    #[doc(hidden)]
    pub secure_initialization_role_arn: std::option::Option<std::string::String>,
    /// <p>An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running. </p>
    #[doc(hidden)]
    pub runtime_role_arn: std::option::Option<std::string::String>,
}
impl LaunchProfileInitializationScript {
    /// <p>The initialization script.</p>
    pub fn script(&self) -> std::option::Option<&str> {
        self.script.as_deref()
    }
    /// <p>The unique identifier for a studio component resource.</p>
    pub fn studio_component_id(&self) -> std::option::Option<&str> {
        self.studio_component_id.as_deref()
    }
    /// <p>The name for the studio component.</p>
    pub fn studio_component_name(&self) -> std::option::Option<&str> {
        self.studio_component_name.as_deref()
    }
    /// <p>An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.</p>
    pub fn secure_initialization_role_arn(&self) -> std::option::Option<&str> {
        self.secure_initialization_role_arn.as_deref()
    }
    /// <p>An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running. </p>
    pub fn runtime_role_arn(&self) -> std::option::Option<&str> {
        self.runtime_role_arn.as_deref()
    }
}
impl std::fmt::Debug for LaunchProfileInitializationScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileInitializationScript");
        formatter.field("script", &"*** Sensitive Data Redacted ***");
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("studio_component_name", &"*** Sensitive Data Redacted ***");
        formatter.field(
            "secure_initialization_role_arn",
            &self.secure_initialization_role_arn,
        );
        formatter.field("runtime_role_arn", &self.runtime_role_arn);
        formatter.finish()
    }
}
impl LaunchProfileInitializationScript {
    /// Creates a new builder-style object to manufacture [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript).
    pub fn builder() -> crate::model::launch_profile_initialization_script::Builder {
        crate::model::launch_profile_initialization_script::Builder::default()
    }
}

/// See [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript).
pub mod launch_profile_initialization_script {

    /// A builder for [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) script: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) studio_component_name: std::option::Option<std::string::String>,
        pub(crate) secure_initialization_role_arn: std::option::Option<std::string::String>,
        pub(crate) runtime_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The initialization script.</p>
        pub fn script(mut self, input: impl Into<std::string::String>) -> Self {
            self.script = Some(input.into());
            self
        }
        /// <p>The initialization script.</p>
        pub fn set_script(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.script = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn studio_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_name = Some(input.into());
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn set_studio_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_name = input;
            self
        }
        /// <p>An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.</p>
        pub fn secure_initialization_role_arn(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.secure_initialization_role_arn = Some(input.into());
            self
        }
        /// <p>An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.</p>
        pub fn set_secure_initialization_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.secure_initialization_role_arn = input;
            self
        }
        /// <p>An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running. </p>
        pub fn runtime_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.runtime_role_arn = Some(input.into());
            self
        }
        /// <p>An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running. </p>
        pub fn set_runtime_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.runtime_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript).
        pub fn build(self) -> crate::model::LaunchProfileInitializationScript {
            crate::model::LaunchProfileInitializationScript {
                script: self.script,
                studio_component_id: self.studio_component_id,
                studio_component_name: self.studio_component_name,
                secure_initialization_role_arn: self.secure_initialization_role_arn,
                runtime_role_arn: self.runtime_role_arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("script", &"*** Sensitive Data Redacted ***");
            formatter.field("studio_component_id", &self.studio_component_id);
            formatter.field("studio_component_name", &"*** Sensitive Data Redacted ***");
            formatter.field(
                "secure_initialization_role_arn",
                &self.secure_initialization_role_arn,
            );
            formatter.field("runtime_role_arn", &self.runtime_role_arn);
            formatter.finish()
        }
    }
}

/// <p>The launch profile initialization Active Directory contains information required for the launch profile to connect to the Active Directory.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileInitializationActiveDirectory {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    #[doc(hidden)]
    pub computer_attributes:
        std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
    /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.</p>
    #[doc(hidden)]
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The directory name.</p>
    #[doc(hidden)]
    pub directory_name: std::option::Option<std::string::String>,
    /// <p>The DNS IP address.</p>
    #[doc(hidden)]
    pub dns_ip_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name for the organizational unit distinguished name.</p>
    #[doc(hidden)]
    pub organizational_unit_distinguished_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    #[doc(hidden)]
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The name for the studio component.</p>
    #[doc(hidden)]
    pub studio_component_name: std::option::Option<std::string::String>,
}
impl LaunchProfileInitializationActiveDirectory {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    pub fn computer_attributes(
        &self,
    ) -> std::option::Option<&[crate::model::ActiveDirectoryComputerAttribute]> {
        self.computer_attributes.as_deref()
    }
    /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.</p>
    pub fn directory_id(&self) -> std::option::Option<&str> {
        self.directory_id.as_deref()
    }
    /// <p>The directory name.</p>
    pub fn directory_name(&self) -> std::option::Option<&str> {
        self.directory_name.as_deref()
    }
    /// <p>The DNS IP address.</p>
    pub fn dns_ip_addresses(&self) -> std::option::Option<&[std::string::String]> {
        self.dns_ip_addresses.as_deref()
    }
    /// <p>The name for the organizational unit distinguished name.</p>
    pub fn organizational_unit_distinguished_name(&self) -> std::option::Option<&str> {
        self.organizational_unit_distinguished_name.as_deref()
    }
    /// <p>The unique identifier for a studio component resource.</p>
    pub fn studio_component_id(&self) -> std::option::Option<&str> {
        self.studio_component_id.as_deref()
    }
    /// <p>The name for the studio component.</p>
    pub fn studio_component_name(&self) -> std::option::Option<&str> {
        self.studio_component_name.as_deref()
    }
}
impl std::fmt::Debug for LaunchProfileInitializationActiveDirectory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileInitializationActiveDirectory");
        formatter.field("computer_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("directory_id", &self.directory_id);
        formatter.field("directory_name", &self.directory_name);
        formatter.field("dns_ip_addresses", &self.dns_ip_addresses);
        formatter.field(
            "organizational_unit_distinguished_name",
            &self.organizational_unit_distinguished_name,
        );
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("studio_component_name", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl LaunchProfileInitializationActiveDirectory {
    /// Creates a new builder-style object to manufacture [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory).
    pub fn builder() -> crate::model::launch_profile_initialization_active_directory::Builder {
        crate::model::launch_profile_initialization_active_directory::Builder::default()
    }
}

/// See [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory).
pub mod launch_profile_initialization_active_directory {

    /// A builder for [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) computer_attributes:
            std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) directory_name: std::option::Option<std::string::String>,
        pub(crate) dns_ip_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) organizational_unit_distinguished_name: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) studio_component_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `computer_attributes`.
        ///
        /// To override the contents of this collection use [`set_computer_attributes`](Self::set_computer_attributes).
        ///
        /// <p>A collection of custom attributes for an Active Directory computer.</p>
        pub fn computer_attributes(
            mut self,
            input: crate::model::ActiveDirectoryComputerAttribute,
        ) -> Self {
            let mut v = self.computer_attributes.unwrap_or_default();
            v.push(input);
            self.computer_attributes = Some(v);
            self
        }
        /// <p>A collection of custom attributes for an Active Directory computer.</p>
        pub fn set_computer_attributes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>,
            >,
        ) -> Self {
            self.computer_attributes = input;
            self
        }
        /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.</p>
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>The directory name.</p>
        pub fn directory_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_name = Some(input.into());
            self
        }
        /// <p>The directory name.</p>
        pub fn set_directory_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_name = input;
            self
        }
        /// Appends an item to `dns_ip_addresses`.
        ///
        /// To override the contents of this collection use [`set_dns_ip_addresses`](Self::set_dns_ip_addresses).
        ///
        /// <p>The DNS IP address.</p>
        pub fn dns_ip_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dns_ip_addresses.unwrap_or_default();
            v.push(input.into());
            self.dns_ip_addresses = Some(v);
            self
        }
        /// <p>The DNS IP address.</p>
        pub fn set_dns_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dns_ip_addresses = input;
            self
        }
        /// <p>The name for the organizational unit distinguished name.</p>
        pub fn organizational_unit_distinguished_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = Some(input.into());
            self
        }
        /// <p>The name for the organizational unit distinguished name.</p>
        pub fn set_organizational_unit_distinguished_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn studio_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_name = Some(input.into());
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn set_studio_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_name = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory).
        pub fn build(self) -> crate::model::LaunchProfileInitializationActiveDirectory {
            crate::model::LaunchProfileInitializationActiveDirectory {
                computer_attributes: self.computer_attributes,
                directory_id: self.directory_id,
                directory_name: self.directory_name,
                dns_ip_addresses: self.dns_ip_addresses,
                organizational_unit_distinguished_name: self.organizational_unit_distinguished_name,
                studio_component_id: self.studio_component_id,
                studio_component_name: self.studio_component_name,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("computer_attributes", &"*** Sensitive Data Redacted ***");
            formatter.field("directory_id", &self.directory_id);
            formatter.field("directory_name", &self.directory_name);
            formatter.field("dns_ip_addresses", &self.dns_ip_addresses);
            formatter.field(
                "organizational_unit_distinguished_name",
                &self.organizational_unit_distinguished_name,
            );
            formatter.field("studio_component_id", &self.studio_component_id);
            formatter.field("studio_component_name", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// <p>The studio component's summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioComponentSummary {
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that created the studio component.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The description.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The name for the studio component.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    #[doc(hidden)]
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The specific subtype of a studio component.</p>
    #[doc(hidden)]
    pub subtype: std::option::Option<crate::model::StudioComponentSubtype>,
    /// <p>The type of the studio component.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::StudioComponentType>,
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    #[doc(hidden)]
    pub updated_by: std::option::Option<std::string::String>,
}
impl StudioComponentSummary {
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The user ID of the user that created the studio component.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name for the studio component.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The unique identifier for a studio component resource.</p>
    pub fn studio_component_id(&self) -> std::option::Option<&str> {
        self.studio_component_id.as_deref()
    }
    /// <p>The specific subtype of a studio component.</p>
    pub fn subtype(&self) -> std::option::Option<&crate::model::StudioComponentSubtype> {
        self.subtype.as_ref()
    }
    /// <p>The type of the studio component.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::StudioComponentType> {
        self.r#type.as_ref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub fn updated_by(&self) -> std::option::Option<&str> {
        self.updated_by.as_deref()
    }
}
impl std::fmt::Debug for StudioComponentSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioComponentSummary");
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("subtype", &self.subtype);
        formatter.field("r#type", &self.r#type);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.finish()
    }
}
impl StudioComponentSummary {
    /// Creates a new builder-style object to manufacture [`StudioComponentSummary`](crate::model::StudioComponentSummary).
    pub fn builder() -> crate::model::studio_component_summary::Builder {
        crate::model::studio_component_summary::Builder::default()
    }
}

/// See [`StudioComponentSummary`](crate::model::StudioComponentSummary).
pub mod studio_component_summary {

    /// A builder for [`StudioComponentSummary`](crate::model::StudioComponentSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) subtype: std::option::Option<crate::model::StudioComponentSubtype>,
        pub(crate) r#type: std::option::Option<crate::model::StudioComponentType>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the studio component.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that created the studio component.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn subtype(mut self, input: crate::model::StudioComponentSubtype) -> Self {
            self.subtype = Some(input);
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn set_subtype(
            mut self,
            input: std::option::Option<crate::model::StudioComponentSubtype>,
        ) -> Self {
            self.subtype = input;
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn r#type(mut self, input: crate::model::StudioComponentType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StudioComponentType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioComponentSummary`](crate::model::StudioComponentSummary).
        pub fn build(self) -> crate::model::StudioComponentSummary {
            crate::model::StudioComponentSummary {
                created_at: self.created_at,
                created_by: self.created_by,
                description: self.description,
                name: self.name,
                studio_component_id: self.studio_component_id,
                subtype: self.subtype,
                r#type: self.r#type,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("created_at", &self.created_at);
            formatter.field("created_by", &self.created_by);
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("studio_component_id", &self.studio_component_id);
            formatter.field("subtype", &self.subtype);
            formatter.field("r#type", &self.r#type);
            formatter.field("updated_at", &self.updated_at);
            formatter.field("updated_by", &self.updated_by);
            formatter.finish()
        }
    }
}

/// <p>A launch profile controls your artist workforce’s access to studio components, like compute farms, shared file systems, managed file systems, and license server configurations, as well as instance types and Amazon Machine Images (AMIs). </p>
/// <p>Studio administrators create launch profiles in the Nimble Studio console. Artists can use their launch profiles to launch an instance from the Nimble Studio portal. Each user’s launch profile defines how they can launch a streaming session. By default, studio admins can use all launch profiles.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfile {
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that created the launch profile.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>A human-readable description of the launch profile.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Unique identifiers for a collection of EC2 subnets.</p>
    #[doc(hidden)]
    pub ec2_subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The ID of the launch profile used to control access from the streaming session.</p>
    #[doc(hidden)]
    pub launch_profile_id: std::option::Option<std::string::String>,
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    #[doc(hidden)]
    pub launch_profile_protocol_versions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A friendly name for the launch profile.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::LaunchProfileState>,
    /// <p>The status code.</p>
    #[doc(hidden)]
    pub status_code: std::option::Option<crate::model::LaunchProfileStatusCode>,
    /// <p>The status message for the launch profile.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
    /// <p>A configuration for a streaming session.</p>
    #[doc(hidden)]
    pub stream_configuration: std::option::Option<crate::model::StreamConfiguration>,
    /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
    #[doc(hidden)]
    pub studio_component_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    #[doc(hidden)]
    pub updated_by: std::option::Option<std::string::String>,
    /// <p>The list of the latest validation results.</p>
    #[doc(hidden)]
    pub validation_results: std::option::Option<std::vec::Vec<crate::model::ValidationResult>>,
}
impl LaunchProfile {
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The user ID of the user that created the launch profile.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>A human-readable description of the launch profile.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Unique identifiers for a collection of EC2 subnets.</p>
    pub fn ec2_subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.ec2_subnet_ids.as_deref()
    }
    /// <p>The ID of the launch profile used to control access from the streaming session.</p>
    pub fn launch_profile_id(&self) -> std::option::Option<&str> {
        self.launch_profile_id.as_deref()
    }
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub fn launch_profile_protocol_versions(&self) -> std::option::Option<&[std::string::String]> {
        self.launch_profile_protocol_versions.as_deref()
    }
    /// <p>A friendly name for the launch profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::LaunchProfileState> {
        self.state.as_ref()
    }
    /// <p>The status code.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::LaunchProfileStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the launch profile.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>A configuration for a streaming session.</p>
    pub fn stream_configuration(&self) -> std::option::Option<&crate::model::StreamConfiguration> {
        self.stream_configuration.as_ref()
    }
    /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
    pub fn studio_component_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.studio_component_ids.as_deref()
    }
    /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub fn updated_by(&self) -> std::option::Option<&str> {
        self.updated_by.as_deref()
    }
    /// <p>The list of the latest validation results.</p>
    pub fn validation_results(&self) -> std::option::Option<&[crate::model::ValidationResult]> {
        self.validation_results.as_deref()
    }
}
impl std::fmt::Debug for LaunchProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfile");
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("ec2_subnet_ids", &self.ec2_subnet_ids);
        formatter.field("launch_profile_id", &self.launch_profile_id);
        formatter.field(
            "launch_profile_protocol_versions",
            &self.launch_profile_protocol_versions,
        );
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("stream_configuration", &self.stream_configuration);
        formatter.field("studio_component_ids", &self.studio_component_ids);
        formatter.field("tags", &self.tags);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.field("validation_results", &self.validation_results);
        formatter.finish()
    }
}
impl LaunchProfile {
    /// Creates a new builder-style object to manufacture [`LaunchProfile`](crate::model::LaunchProfile).
    pub fn builder() -> crate::model::launch_profile::Builder {
        crate::model::launch_profile::Builder::default()
    }
}

/// See [`LaunchProfile`](crate::model::LaunchProfile).
pub mod launch_profile {

    /// A builder for [`LaunchProfile`](crate::model::LaunchProfile).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ec2_subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) launch_profile_id: std::option::Option<std::string::String>,
        pub(crate) launch_profile_protocol_versions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::LaunchProfileState>,
        pub(crate) status_code: std::option::Option<crate::model::LaunchProfileStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) stream_configuration: std::option::Option<crate::model::StreamConfiguration>,
        pub(crate) studio_component_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
        pub(crate) validation_results:
            std::option::Option<std::vec::Vec<crate::model::ValidationResult>>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the launch profile.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that created the launch profile.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>A human-readable description of the launch profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A human-readable description of the launch profile.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `ec2_subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_ec2_subnet_ids`](Self::set_ec2_subnet_ids).
        ///
        /// <p>Unique identifiers for a collection of EC2 subnets.</p>
        pub fn ec2_subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ec2_subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.ec2_subnet_ids = Some(v);
            self
        }
        /// <p>Unique identifiers for a collection of EC2 subnets.</p>
        pub fn set_ec2_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ec2_subnet_ids = input;
            self
        }
        /// <p>The ID of the launch profile used to control access from the streaming session.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_profile_id = Some(input.into());
            self
        }
        /// <p>The ID of the launch profile used to control access from the streaming session.</p>
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_id = input;
            self
        }
        /// Appends an item to `launch_profile_protocol_versions`.
        ///
        /// To override the contents of this collection use [`set_launch_profile_protocol_versions`](Self::set_launch_profile_protocol_versions).
        ///
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_versions(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.launch_profile_protocol_versions.unwrap_or_default();
            v.push(input.into());
            self.launch_profile_protocol_versions = Some(v);
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn set_launch_profile_protocol_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.launch_profile_protocol_versions = input;
            self
        }
        /// <p>A friendly name for the launch profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A friendly name for the launch profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::LaunchProfileState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::LaunchProfileStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the launch profile.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the launch profile.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>A configuration for a streaming session.</p>
        pub fn stream_configuration(mut self, input: crate::model::StreamConfiguration) -> Self {
            self.stream_configuration = Some(input);
            self
        }
        /// <p>A configuration for a streaming session.</p>
        pub fn set_stream_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamConfiguration>,
        ) -> Self {
            self.stream_configuration = input;
            self
        }
        /// Appends an item to `studio_component_ids`.
        ///
        /// To override the contents of this collection use [`set_studio_component_ids`](Self::set_studio_component_ids).
        ///
        /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
        pub fn studio_component_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.studio_component_ids.unwrap_or_default();
            v.push(input.into());
            self.studio_component_ids = Some(v);
            self
        }
        /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
        pub fn set_studio_component_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.studio_component_ids = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key-value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// Appends an item to `validation_results`.
        ///
        /// To override the contents of this collection use [`set_validation_results`](Self::set_validation_results).
        ///
        /// <p>The list of the latest validation results.</p>
        pub fn validation_results(mut self, input: crate::model::ValidationResult) -> Self {
            let mut v = self.validation_results.unwrap_or_default();
            v.push(input);
            self.validation_results = Some(v);
            self
        }
        /// <p>The list of the latest validation results.</p>
        pub fn set_validation_results(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ValidationResult>>,
        ) -> Self {
            self.validation_results = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfile`](crate::model::LaunchProfile).
        pub fn build(self) -> crate::model::LaunchProfile {
            crate::model::LaunchProfile {
                arn: self.arn,
                created_at: self.created_at,
                created_by: self.created_by,
                description: self.description,
                ec2_subnet_ids: self.ec2_subnet_ids,
                launch_profile_id: self.launch_profile_id,
                launch_profile_protocol_versions: self.launch_profile_protocol_versions,
                name: self.name,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                stream_configuration: self.stream_configuration,
                studio_component_ids: self.studio_component_ids,
                tags: self.tags,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
                validation_results: self.validation_results,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("arn", &self.arn);
            formatter.field("created_at", &self.created_at);
            formatter.field("created_by", &self.created_by);
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("ec2_subnet_ids", &self.ec2_subnet_ids);
            formatter.field("launch_profile_id", &self.launch_profile_id);
            formatter.field(
                "launch_profile_protocol_versions",
                &self.launch_profile_protocol_versions,
            );
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("state", &self.state);
            formatter.field("status_code", &self.status_code);
            formatter.field("status_message", &self.status_message);
            formatter.field("stream_configuration", &self.stream_configuration);
            formatter.field("studio_component_ids", &self.studio_component_ids);
            formatter.field("tags", &self.tags);
            formatter.field("updated_at", &self.updated_at);
            formatter.field("updated_by", &self.updated_by);
            formatter.field("validation_results", &self.validation_results);
            formatter.finish()
        }
    }
}

/// <p>The launch profile validation result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ValidationResult {
    /// <p>The type of the validation result.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::LaunchProfileValidationType>,
    /// <p>The current state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::LaunchProfileValidationState>,
    /// <p>The status code. This will contain the failure reason if the state is <code>VALIDATION_FAILED</code>.</p>
    #[doc(hidden)]
    pub status_code: std::option::Option<crate::model::LaunchProfileValidationStatusCode>,
    /// <p>The status message for the validation result.</p>
    #[doc(hidden)]
    pub status_message: std::option::Option<std::string::String>,
}
impl ValidationResult {
    /// <p>The type of the validation result.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::LaunchProfileValidationType> {
        self.r#type.as_ref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::LaunchProfileValidationState> {
        self.state.as_ref()
    }
    /// <p>The status code. This will contain the failure reason if the state is <code>VALIDATION_FAILED</code>.</p>
    pub fn status_code(
        &self,
    ) -> std::option::Option<&crate::model::LaunchProfileValidationStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the validation result.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
impl ValidationResult {
    /// Creates a new builder-style object to manufacture [`ValidationResult`](crate::model::ValidationResult).
    pub fn builder() -> crate::model::validation_result::Builder {
        crate::model::validation_result::Builder::default()
    }
}

/// See [`ValidationResult`](crate::model::ValidationResult).
pub mod validation_result {

    /// A builder for [`ValidationResult`](crate::model::ValidationResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::LaunchProfileValidationType>,
        pub(crate) state: std::option::Option<crate::model::LaunchProfileValidationState>,
        pub(crate) status_code:
            std::option::Option<crate::model::LaunchProfileValidationStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the validation result.</p>
        pub fn r#type(mut self, input: crate::model::LaunchProfileValidationType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the validation result.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileValidationType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::LaunchProfileValidationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileValidationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code. This will contain the failure reason if the state is <code>VALIDATION_FAILED</code>.</p>
        pub fn status_code(
            mut self,
            input: crate::model::LaunchProfileValidationStatusCode,
        ) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code. This will contain the failure reason if the state is <code>VALIDATION_FAILED</code>.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileValidationStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the validation result.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the validation result.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationResult`](crate::model::ValidationResult).
        pub fn build(self) -> crate::model::ValidationResult {
            crate::model::ValidationResult {
                r#type: self.r#type,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
            }
        }
    }
}

/// When writing a match expression against `LaunchProfileValidationStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let launchprofilevalidationstatuscode = unimplemented!();
/// match launchprofilevalidationstatuscode {
///     LaunchProfileValidationStatusCode::ValidationFailedInternalServerError => { /* ... */ },
///     LaunchProfileValidationStatusCode::ValidationFailedInvalidActiveDirectory => { /* ... */ },
///     LaunchProfileValidationStatusCode::ValidationFailedInvalidSecurityGroupAssociation => { /* ... */ },
///     LaunchProfileValidationStatusCode::ValidationFailedInvalidSubnetRouteTableAssociation => { /* ... */ },
///     LaunchProfileValidationStatusCode::ValidationFailedSubnetNotFound => { /* ... */ },
///     LaunchProfileValidationStatusCode::ValidationFailedUnauthorized => { /* ... */ },
///     LaunchProfileValidationStatusCode::ValidationInProgress => { /* ... */ },
///     LaunchProfileValidationStatusCode::ValidationNotStarted => { /* ... */ },
///     LaunchProfileValidationStatusCode::ValidationSuccess => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `launchprofilevalidationstatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LaunchProfileValidationStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LaunchProfileValidationStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LaunchProfileValidationStatusCode::NewFeature` is defined.
/// Specifically, when `launchprofilevalidationstatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LaunchProfileValidationStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileValidationStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedInternalServerError,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedInvalidActiveDirectory,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedInvalidSecurityGroupAssociation,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedInvalidSubnetRouteTableAssociation,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedSubnetNotFound,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedUnauthorized,
    #[allow(missing_docs)] // documentation missing in model
    ValidationInProgress,
    #[allow(missing_docs)] // documentation missing in model
    ValidationNotStarted,
    #[allow(missing_docs)] // documentation missing in model
    ValidationSuccess,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LaunchProfileValidationStatusCode {
    fn from(s: &str) -> Self {
        match s {
                        "VALIDATION_FAILED_INTERNAL_SERVER_ERROR" => LaunchProfileValidationStatusCode::ValidationFailedInternalServerError,
"VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY" => LaunchProfileValidationStatusCode::ValidationFailedInvalidActiveDirectory,
"VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION" => LaunchProfileValidationStatusCode::ValidationFailedInvalidSecurityGroupAssociation,
"VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION" => LaunchProfileValidationStatusCode::ValidationFailedInvalidSubnetRouteTableAssociation,
"VALIDATION_FAILED_SUBNET_NOT_FOUND" => LaunchProfileValidationStatusCode::ValidationFailedSubnetNotFound,
"VALIDATION_FAILED_UNAUTHORIZED" => LaunchProfileValidationStatusCode::ValidationFailedUnauthorized,
"VALIDATION_IN_PROGRESS" => LaunchProfileValidationStatusCode::ValidationInProgress,
"VALIDATION_NOT_STARTED" => LaunchProfileValidationStatusCode::ValidationNotStarted,
"VALIDATION_SUCCESS" => LaunchProfileValidationStatusCode::ValidationSuccess,
other => LaunchProfileValidationStatusCode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
                    }
    }
}
impl std::str::FromStr for LaunchProfileValidationStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileValidationStatusCode::from(s))
    }
}
impl LaunchProfileValidationStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
    LaunchProfileValidationStatusCode::ValidationFailedInternalServerError => "VALIDATION_FAILED_INTERNAL_SERVER_ERROR",
    LaunchProfileValidationStatusCode::ValidationFailedInvalidActiveDirectory => "VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY",
    LaunchProfileValidationStatusCode::ValidationFailedInvalidSecurityGroupAssociation => "VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION",
    LaunchProfileValidationStatusCode::ValidationFailedInvalidSubnetRouteTableAssociation => "VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION",
    LaunchProfileValidationStatusCode::ValidationFailedSubnetNotFound => "VALIDATION_FAILED_SUBNET_NOT_FOUND",
    LaunchProfileValidationStatusCode::ValidationFailedUnauthorized => "VALIDATION_FAILED_UNAUTHORIZED",
    LaunchProfileValidationStatusCode::ValidationInProgress => "VALIDATION_IN_PROGRESS",
    LaunchProfileValidationStatusCode::ValidationNotStarted => "VALIDATION_NOT_STARTED",
    LaunchProfileValidationStatusCode::ValidationSuccess => "VALIDATION_SUCCESS",
    LaunchProfileValidationStatusCode::Unknown(value) => value.as_str()
}
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "VALIDATION_FAILED_INTERNAL_SERVER_ERROR",
            "VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY",
            "VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION",
            "VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION",
            "VALIDATION_FAILED_SUBNET_NOT_FOUND",
            "VALIDATION_FAILED_UNAUTHORIZED",
            "VALIDATION_IN_PROGRESS",
            "VALIDATION_NOT_STARTED",
            "VALIDATION_SUCCESS",
        ]
    }
}
impl AsRef<str> for LaunchProfileValidationStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LaunchProfileValidationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let launchprofilevalidationstate = unimplemented!();
/// match launchprofilevalidationstate {
///     LaunchProfileValidationState::ValidationFailed => { /* ... */ },
///     LaunchProfileValidationState::ValidationFailedInternalServerError => { /* ... */ },
///     LaunchProfileValidationState::ValidationInProgress => { /* ... */ },
///     LaunchProfileValidationState::ValidationNotStarted => { /* ... */ },
///     LaunchProfileValidationState::ValidationSuccess => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `launchprofilevalidationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LaunchProfileValidationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LaunchProfileValidationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LaunchProfileValidationState::NewFeature` is defined.
/// Specifically, when `launchprofilevalidationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LaunchProfileValidationState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileValidationState {
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedInternalServerError,
    #[allow(missing_docs)] // documentation missing in model
    ValidationInProgress,
    #[allow(missing_docs)] // documentation missing in model
    ValidationNotStarted,
    #[allow(missing_docs)] // documentation missing in model
    ValidationSuccess,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LaunchProfileValidationState {
    fn from(s: &str) -> Self {
        match s {
            "VALIDATION_FAILED" => LaunchProfileValidationState::ValidationFailed,
            "VALIDATION_FAILED_INTERNAL_SERVER_ERROR" => {
                LaunchProfileValidationState::ValidationFailedInternalServerError
            }
            "VALIDATION_IN_PROGRESS" => LaunchProfileValidationState::ValidationInProgress,
            "VALIDATION_NOT_STARTED" => LaunchProfileValidationState::ValidationNotStarted,
            "VALIDATION_SUCCESS" => LaunchProfileValidationState::ValidationSuccess,
            other => LaunchProfileValidationState::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for LaunchProfileValidationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileValidationState::from(s))
    }
}
impl LaunchProfileValidationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileValidationState::ValidationFailed => "VALIDATION_FAILED",
            LaunchProfileValidationState::ValidationFailedInternalServerError => {
                "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
            }
            LaunchProfileValidationState::ValidationInProgress => "VALIDATION_IN_PROGRESS",
            LaunchProfileValidationState::ValidationNotStarted => "VALIDATION_NOT_STARTED",
            LaunchProfileValidationState::ValidationSuccess => "VALIDATION_SUCCESS",
            LaunchProfileValidationState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "VALIDATION_FAILED",
            "VALIDATION_FAILED_INTERNAL_SERVER_ERROR",
            "VALIDATION_IN_PROGRESS",
            "VALIDATION_NOT_STARTED",
            "VALIDATION_SUCCESS",
        ]
    }
}
impl AsRef<str> for LaunchProfileValidationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LaunchProfileValidationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let launchprofilevalidationtype = unimplemented!();
/// match launchprofilevalidationtype {
///     LaunchProfileValidationType::ValidateActiveDirectoryStudioComponent => { /* ... */ },
///     LaunchProfileValidationType::ValidateNetworkAclAssociation => { /* ... */ },
///     LaunchProfileValidationType::ValidateSecurityGroupAssociation => { /* ... */ },
///     LaunchProfileValidationType::ValidateSubnetAssociation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `launchprofilevalidationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LaunchProfileValidationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LaunchProfileValidationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LaunchProfileValidationType::NewFeature` is defined.
/// Specifically, when `launchprofilevalidationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LaunchProfileValidationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileValidationType {
    #[allow(missing_docs)] // documentation missing in model
    ValidateActiveDirectoryStudioComponent,
    #[allow(missing_docs)] // documentation missing in model
    ValidateNetworkAclAssociation,
    #[allow(missing_docs)] // documentation missing in model
    ValidateSecurityGroupAssociation,
    #[allow(missing_docs)] // documentation missing in model
    ValidateSubnetAssociation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LaunchProfileValidationType {
    fn from(s: &str) -> Self {
        match s {
            "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT" => {
                LaunchProfileValidationType::ValidateActiveDirectoryStudioComponent
            }
            "VALIDATE_NETWORK_ACL_ASSOCIATION" => {
                LaunchProfileValidationType::ValidateNetworkAclAssociation
            }
            "VALIDATE_SECURITY_GROUP_ASSOCIATION" => {
                LaunchProfileValidationType::ValidateSecurityGroupAssociation
            }
            "VALIDATE_SUBNET_ASSOCIATION" => LaunchProfileValidationType::ValidateSubnetAssociation,
            other => LaunchProfileValidationType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for LaunchProfileValidationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileValidationType::from(s))
    }
}
impl LaunchProfileValidationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileValidationType::ValidateActiveDirectoryStudioComponent => {
                "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT"
            }
            LaunchProfileValidationType::ValidateNetworkAclAssociation => {
                "VALIDATE_NETWORK_ACL_ASSOCIATION"
            }
            LaunchProfileValidationType::ValidateSecurityGroupAssociation => {
                "VALIDATE_SECURITY_GROUP_ASSOCIATION"
            }
            LaunchProfileValidationType::ValidateSubnetAssociation => "VALIDATE_SUBNET_ASSOCIATION",
            LaunchProfileValidationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT",
            "VALIDATE_NETWORK_ACL_ASSOCIATION",
            "VALIDATE_SECURITY_GROUP_ASSOCIATION",
            "VALIDATE_SUBNET_ASSOCIATION",
        ]
    }
}
impl AsRef<str> for LaunchProfileValidationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A configuration for a streaming session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamConfiguration {
    /// <p>Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    #[doc(hidden)]
    pub clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    #[doc(hidden)]
    pub ec2_instance_types: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
    /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
    #[doc(hidden)]
    pub max_session_length_in_minutes: std::option::Option<i32>,
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    #[doc(hidden)]
    pub streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is 5760.</p>
    /// <p>This field is allowed only when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is <code>ACTIVATED</code>.</p>
    /// <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated (instead of <code>STOPPED</code>).</p>
    /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped (instead of terminated).</p>
    #[doc(hidden)]
    pub max_stopped_session_length_in_minutes: i32,
    /// <p>The upload storage for a streaming session.</p>
    #[doc(hidden)]
    pub session_storage: std::option::Option<crate::model::StreamConfigurationSessionStorage>,
    /// <p>Information about the streaming session backup.</p>
    #[doc(hidden)]
    pub session_backup: std::option::Option<crate::model::StreamConfigurationSessionBackup>,
    /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
    #[doc(hidden)]
    pub session_persistence_mode: std::option::Option<crate::model::SessionPersistenceMode>,
    /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
    #[doc(hidden)]
    pub volume_configuration: std::option::Option<crate::model::VolumeConfiguration>,
    /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
    /// <ul>
    /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
    /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
    /// </ul>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
    #[doc(hidden)]
    pub automatic_termination_mode: std::option::Option<crate::model::AutomaticTerminationMode>,
}
impl StreamConfiguration {
    /// <p>Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    pub fn clipboard_mode(&self) -> std::option::Option<&crate::model::StreamingClipboardMode> {
        self.clipboard_mode.as_ref()
    }
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    pub fn ec2_instance_types(
        &self,
    ) -> std::option::Option<&[crate::model::StreamingInstanceType]> {
        self.ec2_instance_types.as_deref()
    }
    /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
    pub fn max_session_length_in_minutes(&self) -> std::option::Option<i32> {
        self.max_session_length_in_minutes
    }
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    pub fn streaming_image_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.streaming_image_ids.as_deref()
    }
    /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is 5760.</p>
    /// <p>This field is allowed only when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is <code>ACTIVATED</code>.</p>
    /// <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated (instead of <code>STOPPED</code>).</p>
    /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped (instead of terminated).</p>
    pub fn max_stopped_session_length_in_minutes(&self) -> i32 {
        self.max_stopped_session_length_in_minutes
    }
    /// <p>The upload storage for a streaming session.</p>
    pub fn session_storage(
        &self,
    ) -> std::option::Option<&crate::model::StreamConfigurationSessionStorage> {
        self.session_storage.as_ref()
    }
    /// <p>Information about the streaming session backup.</p>
    pub fn session_backup(
        &self,
    ) -> std::option::Option<&crate::model::StreamConfigurationSessionBackup> {
        self.session_backup.as_ref()
    }
    /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
    pub fn session_persistence_mode(
        &self,
    ) -> std::option::Option<&crate::model::SessionPersistenceMode> {
        self.session_persistence_mode.as_ref()
    }
    /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
    pub fn volume_configuration(&self) -> std::option::Option<&crate::model::VolumeConfiguration> {
        self.volume_configuration.as_ref()
    }
    /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
    /// <ul>
    /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
    /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
    /// </ul>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
    pub fn automatic_termination_mode(
        &self,
    ) -> std::option::Option<&crate::model::AutomaticTerminationMode> {
        self.automatic_termination_mode.as_ref()
    }
}
impl StreamConfiguration {
    /// Creates a new builder-style object to manufacture [`StreamConfiguration`](crate::model::StreamConfiguration).
    pub fn builder() -> crate::model::stream_configuration::Builder {
        crate::model::stream_configuration::Builder::default()
    }
}

/// See [`StreamConfiguration`](crate::model::StreamConfiguration).
pub mod stream_configuration {

    /// A builder for [`StreamConfiguration`](crate::model::StreamConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
        pub(crate) ec2_instance_types:
            std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        pub(crate) max_session_length_in_minutes: std::option::Option<i32>,
        pub(crate) streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_stopped_session_length_in_minutes: std::option::Option<i32>,
        pub(crate) session_storage:
            std::option::Option<crate::model::StreamConfigurationSessionStorage>,
        pub(crate) session_backup:
            std::option::Option<crate::model::StreamConfigurationSessionBackup>,
        pub(crate) session_persistence_mode:
            std::option::Option<crate::model::SessionPersistenceMode>,
        pub(crate) volume_configuration: std::option::Option<crate::model::VolumeConfiguration>,
        pub(crate) automatic_termination_mode:
            std::option::Option<crate::model::AutomaticTerminationMode>,
    }
    impl Builder {
        /// <p>Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
        pub fn clipboard_mode(mut self, input: crate::model::StreamingClipboardMode) -> Self {
            self.clipboard_mode = Some(input);
            self
        }
        /// <p>Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
        pub fn set_clipboard_mode(
            mut self,
            input: std::option::Option<crate::model::StreamingClipboardMode>,
        ) -> Self {
            self.clipboard_mode = input;
            self
        }
        /// Appends an item to `ec2_instance_types`.
        ///
        /// To override the contents of this collection use [`set_ec2_instance_types`](Self::set_ec2_instance_types).
        ///
        /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
        pub fn ec2_instance_types(mut self, input: crate::model::StreamingInstanceType) -> Self {
            let mut v = self.ec2_instance_types.unwrap_or_default();
            v.push(input);
            self.ec2_instance_types = Some(v);
            self
        }
        /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
        pub fn set_ec2_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        ) -> Self {
            self.ec2_instance_types = input;
            self
        }
        /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
        pub fn max_session_length_in_minutes(mut self, input: i32) -> Self {
            self.max_session_length_in_minutes = Some(input);
            self
        }
        /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
        pub fn set_max_session_length_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_session_length_in_minutes = input;
            self
        }
        /// Appends an item to `streaming_image_ids`.
        ///
        /// To override the contents of this collection use [`set_streaming_image_ids`](Self::set_streaming_image_ids).
        ///
        /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
        pub fn streaming_image_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.streaming_image_ids.unwrap_or_default();
            v.push(input.into());
            self.streaming_image_ids = Some(v);
            self
        }
        /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
        pub fn set_streaming_image_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.streaming_image_ids = input;
            self
        }
        /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is 5760.</p>
        /// <p>This field is allowed only when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is <code>ACTIVATED</code>.</p>
        /// <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated (instead of <code>STOPPED</code>).</p>
        /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped (instead of terminated).</p>
        pub fn max_stopped_session_length_in_minutes(mut self, input: i32) -> Self {
            self.max_stopped_session_length_in_minutes = Some(input);
            self
        }
        /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is 5760.</p>
        /// <p>This field is allowed only when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is <code>ACTIVATED</code>.</p>
        /// <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated (instead of <code>STOPPED</code>).</p>
        /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped (instead of terminated).</p>
        pub fn set_max_stopped_session_length_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_stopped_session_length_in_minutes = input;
            self
        }
        /// <p>The upload storage for a streaming session.</p>
        pub fn session_storage(
            mut self,
            input: crate::model::StreamConfigurationSessionStorage,
        ) -> Self {
            self.session_storage = Some(input);
            self
        }
        /// <p>The upload storage for a streaming session.</p>
        pub fn set_session_storage(
            mut self,
            input: std::option::Option<crate::model::StreamConfigurationSessionStorage>,
        ) -> Self {
            self.session_storage = input;
            self
        }
        /// <p>Information about the streaming session backup.</p>
        pub fn session_backup(
            mut self,
            input: crate::model::StreamConfigurationSessionBackup,
        ) -> Self {
            self.session_backup = Some(input);
            self
        }
        /// <p>Information about the streaming session backup.</p>
        pub fn set_session_backup(
            mut self,
            input: std::option::Option<crate::model::StreamConfigurationSessionBackup>,
        ) -> Self {
            self.session_backup = input;
            self
        }
        /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
        pub fn session_persistence_mode(
            mut self,
            input: crate::model::SessionPersistenceMode,
        ) -> Self {
            self.session_persistence_mode = Some(input);
            self
        }
        /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
        pub fn set_session_persistence_mode(
            mut self,
            input: std::option::Option<crate::model::SessionPersistenceMode>,
        ) -> Self {
            self.session_persistence_mode = input;
            self
        }
        /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
        pub fn volume_configuration(mut self, input: crate::model::VolumeConfiguration) -> Self {
            self.volume_configuration = Some(input);
            self
        }
        /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
        pub fn set_volume_configuration(
            mut self,
            input: std::option::Option<crate::model::VolumeConfiguration>,
        ) -> Self {
            self.volume_configuration = input;
            self
        }
        /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
        /// <ul>
        /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
        /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
        /// </ul>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
        pub fn automatic_termination_mode(
            mut self,
            input: crate::model::AutomaticTerminationMode,
        ) -> Self {
            self.automatic_termination_mode = Some(input);
            self
        }
        /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
        /// <ul>
        /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
        /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
        /// </ul>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
        pub fn set_automatic_termination_mode(
            mut self,
            input: std::option::Option<crate::model::AutomaticTerminationMode>,
        ) -> Self {
            self.automatic_termination_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamConfiguration`](crate::model::StreamConfiguration).
        pub fn build(self) -> crate::model::StreamConfiguration {
            crate::model::StreamConfiguration {
                clipboard_mode: self.clipboard_mode,
                ec2_instance_types: self.ec2_instance_types,
                max_session_length_in_minutes: self.max_session_length_in_minutes,
                streaming_image_ids: self.streaming_image_ids,
                max_stopped_session_length_in_minutes: self
                    .max_stopped_session_length_in_minutes
                    .unwrap_or_default(),
                session_storage: self.session_storage,
                session_backup: self.session_backup,
                session_persistence_mode: self.session_persistence_mode,
                volume_configuration: self.volume_configuration,
                automatic_termination_mode: self.automatic_termination_mode,
            }
        }
    }
}

/// <p>Configures how streaming sessions are backed up when launched from this launch profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamConfigurationSessionBackup {
    /// <p>Specifies how artists sessions are backed up.</p>
    /// <p>Configures backups for streaming sessions launched with this launch profile. The default value is <code>DEACTIVATED</code>, which means that backups are deactivated. To allow backups, set this value to <code>AUTOMATIC</code>.</p>
    #[doc(hidden)]
    pub mode: std::option::Option<crate::model::SessionBackupMode>,
    /// <p>The maximum number of backups that each streaming session created from this launch profile can have.</p>
    #[doc(hidden)]
    pub max_backups_to_retain: i32,
}
impl StreamConfigurationSessionBackup {
    /// <p>Specifies how artists sessions are backed up.</p>
    /// <p>Configures backups for streaming sessions launched with this launch profile. The default value is <code>DEACTIVATED</code>, which means that backups are deactivated. To allow backups, set this value to <code>AUTOMATIC</code>.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::SessionBackupMode> {
        self.mode.as_ref()
    }
    /// <p>The maximum number of backups that each streaming session created from this launch profile can have.</p>
    pub fn max_backups_to_retain(&self) -> i32 {
        self.max_backups_to_retain
    }
}
impl StreamConfigurationSessionBackup {
    /// Creates a new builder-style object to manufacture [`StreamConfigurationSessionBackup`](crate::model::StreamConfigurationSessionBackup).
    pub fn builder() -> crate::model::stream_configuration_session_backup::Builder {
        crate::model::stream_configuration_session_backup::Builder::default()
    }
}

/// See [`StreamConfigurationSessionBackup`](crate::model::StreamConfigurationSessionBackup).
pub mod stream_configuration_session_backup {

    /// A builder for [`StreamConfigurationSessionBackup`](crate::model::StreamConfigurationSessionBackup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mode: std::option::Option<crate::model::SessionBackupMode>,
        pub(crate) max_backups_to_retain: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Specifies how artists sessions are backed up.</p>
        /// <p>Configures backups for streaming sessions launched with this launch profile. The default value is <code>DEACTIVATED</code>, which means that backups are deactivated. To allow backups, set this value to <code>AUTOMATIC</code>.</p>
        pub fn mode(mut self, input: crate::model::SessionBackupMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>Specifies how artists sessions are backed up.</p>
        /// <p>Configures backups for streaming sessions launched with this launch profile. The default value is <code>DEACTIVATED</code>, which means that backups are deactivated. To allow backups, set this value to <code>AUTOMATIC</code>.</p>
        pub fn set_mode(
            mut self,
            input: std::option::Option<crate::model::SessionBackupMode>,
        ) -> Self {
            self.mode = input;
            self
        }
        /// <p>The maximum number of backups that each streaming session created from this launch profile can have.</p>
        pub fn max_backups_to_retain(mut self, input: i32) -> Self {
            self.max_backups_to_retain = Some(input);
            self
        }
        /// <p>The maximum number of backups that each streaming session created from this launch profile can have.</p>
        pub fn set_max_backups_to_retain(mut self, input: std::option::Option<i32>) -> Self {
            self.max_backups_to_retain = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamConfigurationSessionBackup`](crate::model::StreamConfigurationSessionBackup).
        pub fn build(self) -> crate::model::StreamConfigurationSessionBackup {
            crate::model::StreamConfigurationSessionBackup {
                mode: self.mode,
                max_backups_to_retain: self.max_backups_to_retain.unwrap_or_default(),
            }
        }
    }
}

/// <p>The configuration for a streaming session’s upload storage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamConfigurationSessionStorage {
    /// <p>The configuration for the upload storage root of the streaming session.</p>
    #[doc(hidden)]
    pub root: std::option::Option<crate::model::StreamingSessionStorageRoot>,
    /// <p>Allows artists to upload files to their workstations. The only valid option is <code>UPLOAD</code>.</p>
    #[doc(hidden)]
    pub mode: std::option::Option<std::vec::Vec<crate::model::StreamingSessionStorageMode>>,
}
impl StreamConfigurationSessionStorage {
    /// <p>The configuration for the upload storage root of the streaming session.</p>
    pub fn root(&self) -> std::option::Option<&crate::model::StreamingSessionStorageRoot> {
        self.root.as_ref()
    }
    /// <p>Allows artists to upload files to their workstations. The only valid option is <code>UPLOAD</code>.</p>
    pub fn mode(&self) -> std::option::Option<&[crate::model::StreamingSessionStorageMode]> {
        self.mode.as_deref()
    }
}
impl StreamConfigurationSessionStorage {
    /// Creates a new builder-style object to manufacture [`StreamConfigurationSessionStorage`](crate::model::StreamConfigurationSessionStorage).
    pub fn builder() -> crate::model::stream_configuration_session_storage::Builder {
        crate::model::stream_configuration_session_storage::Builder::default()
    }
}

/// See [`StreamConfigurationSessionStorage`](crate::model::StreamConfigurationSessionStorage).
pub mod stream_configuration_session_storage {

    /// A builder for [`StreamConfigurationSessionStorage`](crate::model::StreamConfigurationSessionStorage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) root: std::option::Option<crate::model::StreamingSessionStorageRoot>,
        pub(crate) mode:
            std::option::Option<std::vec::Vec<crate::model::StreamingSessionStorageMode>>,
    }
    impl Builder {
        /// <p>The configuration for the upload storage root of the streaming session.</p>
        pub fn root(mut self, input: crate::model::StreamingSessionStorageRoot) -> Self {
            self.root = Some(input);
            self
        }
        /// <p>The configuration for the upload storage root of the streaming session.</p>
        pub fn set_root(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStorageRoot>,
        ) -> Self {
            self.root = input;
            self
        }
        /// Appends an item to `mode`.
        ///
        /// To override the contents of this collection use [`set_mode`](Self::set_mode).
        ///
        /// <p>Allows artists to upload files to their workstations. The only valid option is <code>UPLOAD</code>.</p>
        pub fn mode(mut self, input: crate::model::StreamingSessionStorageMode) -> Self {
            let mut v = self.mode.unwrap_or_default();
            v.push(input);
            self.mode = Some(v);
            self
        }
        /// <p>Allows artists to upload files to their workstations. The only valid option is <code>UPLOAD</code>.</p>
        pub fn set_mode(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamingSessionStorageMode>>,
        ) -> Self {
            self.mode = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamConfigurationSessionStorage`](crate::model::StreamConfigurationSessionStorage).
        pub fn build(self) -> crate::model::StreamConfigurationSessionStorage {
            crate::model::StreamConfigurationSessionStorage {
                root: self.root,
                mode: self.mode,
            }
        }
    }
}

/// When writing a match expression against `StreamingSessionStorageMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streamingsessionstoragemode = unimplemented!();
/// match streamingsessionstoragemode {
///     StreamingSessionStorageMode::Upload => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streamingsessionstoragemode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingSessionStorageMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingSessionStorageMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingSessionStorageMode::NewFeature` is defined.
/// Specifically, when `streamingsessionstoragemode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingSessionStorageMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStorageMode {
    #[allow(missing_docs)] // documentation missing in model
    Upload,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingSessionStorageMode {
    fn from(s: &str) -> Self {
        match s {
            "UPLOAD" => StreamingSessionStorageMode::Upload,
            other => StreamingSessionStorageMode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for StreamingSessionStorageMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStorageMode::from(s))
    }
}
impl StreamingSessionStorageMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStorageMode::Upload => "UPLOAD",
            StreamingSessionStorageMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["UPLOAD"]
    }
}
impl AsRef<str> for StreamingSessionStorageMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The upload storage root location (folder) on streaming workstations where files are uploaded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingSessionStorageRoot {
    /// <p>The folder path in Linux workstations where files are uploaded.</p>
    #[doc(hidden)]
    pub linux: std::option::Option<std::string::String>,
    /// <p>The folder path in Windows workstations where files are uploaded.</p>
    #[doc(hidden)]
    pub windows: std::option::Option<std::string::String>,
}
impl StreamingSessionStorageRoot {
    /// <p>The folder path in Linux workstations where files are uploaded.</p>
    pub fn linux(&self) -> std::option::Option<&str> {
        self.linux.as_deref()
    }
    /// <p>The folder path in Windows workstations where files are uploaded.</p>
    pub fn windows(&self) -> std::option::Option<&str> {
        self.windows.as_deref()
    }
}
impl std::fmt::Debug for StreamingSessionStorageRoot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingSessionStorageRoot");
        formatter.field("linux", &"*** Sensitive Data Redacted ***");
        formatter.field("windows", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl StreamingSessionStorageRoot {
    /// Creates a new builder-style object to manufacture [`StreamingSessionStorageRoot`](crate::model::StreamingSessionStorageRoot).
    pub fn builder() -> crate::model::streaming_session_storage_root::Builder {
        crate::model::streaming_session_storage_root::Builder::default()
    }
}

/// See [`StreamingSessionStorageRoot`](crate::model::StreamingSessionStorageRoot).
pub mod streaming_session_storage_root {

    /// A builder for [`StreamingSessionStorageRoot`](crate::model::StreamingSessionStorageRoot).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) linux: std::option::Option<std::string::String>,
        pub(crate) windows: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The folder path in Linux workstations where files are uploaded.</p>
        pub fn linux(mut self, input: impl Into<std::string::String>) -> Self {
            self.linux = Some(input.into());
            self
        }
        /// <p>The folder path in Linux workstations where files are uploaded.</p>
        pub fn set_linux(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.linux = input;
            self
        }
        /// <p>The folder path in Windows workstations where files are uploaded.</p>
        pub fn windows(mut self, input: impl Into<std::string::String>) -> Self {
            self.windows = Some(input.into());
            self
        }
        /// <p>The folder path in Windows workstations where files are uploaded.</p>
        pub fn set_windows(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.windows = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingSessionStorageRoot`](crate::model::StreamingSessionStorageRoot).
        pub fn build(self) -> crate::model::StreamingSessionStorageRoot {
            crate::model::StreamingSessionStorageRoot {
                linux: self.linux,
                windows: self.windows,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("linux", &"*** Sensitive Data Redacted ***");
            formatter.field("windows", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// When writing a match expression against `StreamingClipboardMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let streamingclipboardmode = unimplemented!();
/// match streamingclipboardmode {
///     StreamingClipboardMode::Disabled => { /* ... */ },
///     StreamingClipboardMode::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `streamingclipboardmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StreamingClipboardMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StreamingClipboardMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StreamingClipboardMode::NewFeature` is defined.
/// Specifically, when `streamingclipboardmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StreamingClipboardMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingClipboardMode {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StreamingClipboardMode {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => StreamingClipboardMode::Disabled,
            "ENABLED" => StreamingClipboardMode::Enabled,
            other => {
                StreamingClipboardMode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for StreamingClipboardMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingClipboardMode::from(s))
    }
}
impl StreamingClipboardMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingClipboardMode::Disabled => "DISABLED",
            StreamingClipboardMode::Enabled => "ENABLED",
            StreamingClipboardMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for StreamingClipboardMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LaunchProfileStatusCode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let launchprofilestatuscode = unimplemented!();
/// match launchprofilestatuscode {
///     LaunchProfileStatusCode::EncryptionKeyAccessDenied => { /* ... */ },
///     LaunchProfileStatusCode::EncryptionKeyNotFound => { /* ... */ },
///     LaunchProfileStatusCode::InternalError => { /* ... */ },
///     LaunchProfileStatusCode::InvalidInstanceTypesProvided => { /* ... */ },
///     LaunchProfileStatusCode::InvalidSubnetsCombination => { /* ... */ },
///     LaunchProfileStatusCode::InvalidSubnetsProvided => { /* ... */ },
///     LaunchProfileStatusCode::LaunchProfileCreated => { /* ... */ },
///     LaunchProfileStatusCode::LaunchProfileCreateInProgress => { /* ... */ },
///     LaunchProfileStatusCode::LaunchProfileDeleted => { /* ... */ },
///     LaunchProfileStatusCode::LaunchProfileDeleteInProgress => { /* ... */ },
///     LaunchProfileStatusCode::LaunchProfileUpdated => { /* ... */ },
///     LaunchProfileStatusCode::LaunchProfileUpdateInProgress => { /* ... */ },
///     LaunchProfileStatusCode::LaunchProfileWithStreamSessionsNotDeleted => { /* ... */ },
///     LaunchProfileStatusCode::StreamingImageNotFound => { /* ... */ },
///     LaunchProfileStatusCode::StreamingImageNotReady => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `launchprofilestatuscode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LaunchProfileStatusCode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LaunchProfileStatusCode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LaunchProfileStatusCode::NewFeature` is defined.
/// Specifically, when `launchprofilestatuscode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LaunchProfileStatusCode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyNotFound,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidInstanceTypesProvided,
    #[allow(missing_docs)] // documentation missing in model
    InvalidSubnetsCombination,
    #[allow(missing_docs)] // documentation missing in model
    InvalidSubnetsProvided,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileCreated,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileDeleted,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileUpdated,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileUpdateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileWithStreamSessionsNotDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageNotFound,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageNotReady,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LaunchProfileStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ENCRYPTION_KEY_ACCESS_DENIED" => LaunchProfileStatusCode::EncryptionKeyAccessDenied,
            "ENCRYPTION_KEY_NOT_FOUND" => LaunchProfileStatusCode::EncryptionKeyNotFound,
            "INTERNAL_ERROR" => LaunchProfileStatusCode::InternalError,
            "INVALID_INSTANCE_TYPES_PROVIDED" => {
                LaunchProfileStatusCode::InvalidInstanceTypesProvided
            }
            "INVALID_SUBNETS_COMBINATION" => LaunchProfileStatusCode::InvalidSubnetsCombination,
            "INVALID_SUBNETS_PROVIDED" => LaunchProfileStatusCode::InvalidSubnetsProvided,
            "LAUNCH_PROFILE_CREATED" => LaunchProfileStatusCode::LaunchProfileCreated,
            "LAUNCH_PROFILE_CREATE_IN_PROGRESS" => {
                LaunchProfileStatusCode::LaunchProfileCreateInProgress
            }
            "LAUNCH_PROFILE_DELETED" => LaunchProfileStatusCode::LaunchProfileDeleted,
            "LAUNCH_PROFILE_DELETE_IN_PROGRESS" => {
                LaunchProfileStatusCode::LaunchProfileDeleteInProgress
            }
            "LAUNCH_PROFILE_UPDATED" => LaunchProfileStatusCode::LaunchProfileUpdated,
            "LAUNCH_PROFILE_UPDATE_IN_PROGRESS" => {
                LaunchProfileStatusCode::LaunchProfileUpdateInProgress
            }
            "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED" => {
                LaunchProfileStatusCode::LaunchProfileWithStreamSessionsNotDeleted
            }
            "STREAMING_IMAGE_NOT_FOUND" => LaunchProfileStatusCode::StreamingImageNotFound,
            "STREAMING_IMAGE_NOT_READY" => LaunchProfileStatusCode::StreamingImageNotReady,
            other => LaunchProfileStatusCode::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for LaunchProfileStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileStatusCode::from(s))
    }
}
impl LaunchProfileStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileStatusCode::EncryptionKeyAccessDenied => "ENCRYPTION_KEY_ACCESS_DENIED",
            LaunchProfileStatusCode::EncryptionKeyNotFound => "ENCRYPTION_KEY_NOT_FOUND",
            LaunchProfileStatusCode::InternalError => "INTERNAL_ERROR",
            LaunchProfileStatusCode::InvalidInstanceTypesProvided => {
                "INVALID_INSTANCE_TYPES_PROVIDED"
            }
            LaunchProfileStatusCode::InvalidSubnetsCombination => "INVALID_SUBNETS_COMBINATION",
            LaunchProfileStatusCode::InvalidSubnetsProvided => "INVALID_SUBNETS_PROVIDED",
            LaunchProfileStatusCode::LaunchProfileCreated => "LAUNCH_PROFILE_CREATED",
            LaunchProfileStatusCode::LaunchProfileCreateInProgress => {
                "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
            }
            LaunchProfileStatusCode::LaunchProfileDeleted => "LAUNCH_PROFILE_DELETED",
            LaunchProfileStatusCode::LaunchProfileDeleteInProgress => {
                "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
            }
            LaunchProfileStatusCode::LaunchProfileUpdated => "LAUNCH_PROFILE_UPDATED",
            LaunchProfileStatusCode::LaunchProfileUpdateInProgress => {
                "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
            }
            LaunchProfileStatusCode::LaunchProfileWithStreamSessionsNotDeleted => {
                "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
            }
            LaunchProfileStatusCode::StreamingImageNotFound => "STREAMING_IMAGE_NOT_FOUND",
            LaunchProfileStatusCode::StreamingImageNotReady => "STREAMING_IMAGE_NOT_READY",
            LaunchProfileStatusCode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ENCRYPTION_KEY_ACCESS_DENIED",
            "ENCRYPTION_KEY_NOT_FOUND",
            "INTERNAL_ERROR",
            "INVALID_INSTANCE_TYPES_PROVIDED",
            "INVALID_SUBNETS_COMBINATION",
            "INVALID_SUBNETS_PROVIDED",
            "LAUNCH_PROFILE_CREATED",
            "LAUNCH_PROFILE_CREATE_IN_PROGRESS",
            "LAUNCH_PROFILE_DELETED",
            "LAUNCH_PROFILE_DELETE_IN_PROGRESS",
            "LAUNCH_PROFILE_UPDATED",
            "LAUNCH_PROFILE_UPDATE_IN_PROGRESS",
            "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED",
            "STREAMING_IMAGE_NOT_FOUND",
            "STREAMING_IMAGE_NOT_READY",
        ]
    }
}
impl AsRef<str> for LaunchProfileStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LaunchProfileState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let launchprofilestate = unimplemented!();
/// match launchprofilestate {
///     LaunchProfileState::CreateFailed => { /* ... */ },
///     LaunchProfileState::CreateInProgress => { /* ... */ },
///     LaunchProfileState::Deleted => { /* ... */ },
///     LaunchProfileState::DeleteFailed => { /* ... */ },
///     LaunchProfileState::DeleteInProgress => { /* ... */ },
///     LaunchProfileState::Ready => { /* ... */ },
///     LaunchProfileState::UpdateFailed => { /* ... */ },
///     LaunchProfileState::UpdateInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `launchprofilestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LaunchProfileState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LaunchProfileState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LaunchProfileState::NewFeature` is defined.
/// Specifically, when `launchprofilestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LaunchProfileState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LaunchProfileState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => LaunchProfileState::CreateFailed,
            "CREATE_IN_PROGRESS" => LaunchProfileState::CreateInProgress,
            "DELETED" => LaunchProfileState::Deleted,
            "DELETE_FAILED" => LaunchProfileState::DeleteFailed,
            "DELETE_IN_PROGRESS" => LaunchProfileState::DeleteInProgress,
            "READY" => LaunchProfileState::Ready,
            "UPDATE_FAILED" => LaunchProfileState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => LaunchProfileState::UpdateInProgress,
            other => {
                LaunchProfileState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for LaunchProfileState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileState::from(s))
    }
}
impl LaunchProfileState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileState::CreateFailed => "CREATE_FAILED",
            LaunchProfileState::CreateInProgress => "CREATE_IN_PROGRESS",
            LaunchProfileState::Deleted => "DELETED",
            LaunchProfileState::DeleteFailed => "DELETE_FAILED",
            LaunchProfileState::DeleteInProgress => "DELETE_IN_PROGRESS",
            LaunchProfileState::Ready => "READY",
            LaunchProfileState::UpdateFailed => "UPDATE_FAILED",
            LaunchProfileState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            LaunchProfileState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for LaunchProfileState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for streaming workstations created using this launch profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StreamConfigurationCreate {
    /// <p>Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    #[doc(hidden)]
    pub clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    #[doc(hidden)]
    pub ec2_instance_types: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
    /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
    #[doc(hidden)]
    pub max_session_length_in_minutes: std::option::Option<i32>,
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    #[doc(hidden)]
    pub streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is 5760.</p>
    /// <p>This field is allowed only when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is <code>ACTIVATED</code>.</p>
    /// <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated (instead of <code>STOPPED</code>).</p>
    /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped (instead of terminated).</p>
    #[doc(hidden)]
    pub max_stopped_session_length_in_minutes: i32,
    /// <p>The upload storage for a streaming workstation that is created using this launch profile.</p>
    #[doc(hidden)]
    pub session_storage: std::option::Option<crate::model::StreamConfigurationSessionStorage>,
    /// <p>Configures how streaming sessions are backed up when launched from this launch profile.</p>
    #[doc(hidden)]
    pub session_backup: std::option::Option<crate::model::StreamConfigurationSessionBackup>,
    /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
    #[doc(hidden)]
    pub session_persistence_mode: std::option::Option<crate::model::SessionPersistenceMode>,
    /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
    #[doc(hidden)]
    pub volume_configuration: std::option::Option<crate::model::VolumeConfiguration>,
    /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
    /// <ul>
    /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
    /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
    /// </ul>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
    #[doc(hidden)]
    pub automatic_termination_mode: std::option::Option<crate::model::AutomaticTerminationMode>,
}
impl StreamConfigurationCreate {
    /// <p>Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    pub fn clipboard_mode(&self) -> std::option::Option<&crate::model::StreamingClipboardMode> {
        self.clipboard_mode.as_ref()
    }
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    pub fn ec2_instance_types(
        &self,
    ) -> std::option::Option<&[crate::model::StreamingInstanceType]> {
        self.ec2_instance_types.as_deref()
    }
    /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
    pub fn max_session_length_in_minutes(&self) -> std::option::Option<i32> {
        self.max_session_length_in_minutes
    }
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    pub fn streaming_image_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.streaming_image_ids.as_deref()
    }
    /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is 5760.</p>
    /// <p>This field is allowed only when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is <code>ACTIVATED</code>.</p>
    /// <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated (instead of <code>STOPPED</code>).</p>
    /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped (instead of terminated).</p>
    pub fn max_stopped_session_length_in_minutes(&self) -> i32 {
        self.max_stopped_session_length_in_minutes
    }
    /// <p>The upload storage for a streaming workstation that is created using this launch profile.</p>
    pub fn session_storage(
        &self,
    ) -> std::option::Option<&crate::model::StreamConfigurationSessionStorage> {
        self.session_storage.as_ref()
    }
    /// <p>Configures how streaming sessions are backed up when launched from this launch profile.</p>
    pub fn session_backup(
        &self,
    ) -> std::option::Option<&crate::model::StreamConfigurationSessionBackup> {
        self.session_backup.as_ref()
    }
    /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
    pub fn session_persistence_mode(
        &self,
    ) -> std::option::Option<&crate::model::SessionPersistenceMode> {
        self.session_persistence_mode.as_ref()
    }
    /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
    pub fn volume_configuration(&self) -> std::option::Option<&crate::model::VolumeConfiguration> {
        self.volume_configuration.as_ref()
    }
    /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
    /// <ul>
    /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
    /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
    /// </ul>
    /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
    pub fn automatic_termination_mode(
        &self,
    ) -> std::option::Option<&crate::model::AutomaticTerminationMode> {
        self.automatic_termination_mode.as_ref()
    }
}
impl StreamConfigurationCreate {
    /// Creates a new builder-style object to manufacture [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate).
    pub fn builder() -> crate::model::stream_configuration_create::Builder {
        crate::model::stream_configuration_create::Builder::default()
    }
}

/// See [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate).
pub mod stream_configuration_create {

    /// A builder for [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
        pub(crate) ec2_instance_types:
            std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        pub(crate) max_session_length_in_minutes: std::option::Option<i32>,
        pub(crate) streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_stopped_session_length_in_minutes: std::option::Option<i32>,
        pub(crate) session_storage:
            std::option::Option<crate::model::StreamConfigurationSessionStorage>,
        pub(crate) session_backup:
            std::option::Option<crate::model::StreamConfigurationSessionBackup>,
        pub(crate) session_persistence_mode:
            std::option::Option<crate::model::SessionPersistenceMode>,
        pub(crate) volume_configuration: std::option::Option<crate::model::VolumeConfiguration>,
        pub(crate) automatic_termination_mode:
            std::option::Option<crate::model::AutomaticTerminationMode>,
    }
    impl Builder {
        /// <p>Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
        pub fn clipboard_mode(mut self, input: crate::model::StreamingClipboardMode) -> Self {
            self.clipboard_mode = Some(input);
            self
        }
        /// <p>Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
        pub fn set_clipboard_mode(
            mut self,
            input: std::option::Option<crate::model::StreamingClipboardMode>,
        ) -> Self {
            self.clipboard_mode = input;
            self
        }
        /// Appends an item to `ec2_instance_types`.
        ///
        /// To override the contents of this collection use [`set_ec2_instance_types`](Self::set_ec2_instance_types).
        ///
        /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
        pub fn ec2_instance_types(mut self, input: crate::model::StreamingInstanceType) -> Self {
            let mut v = self.ec2_instance_types.unwrap_or_default();
            v.push(input);
            self.ec2_instance_types = Some(v);
            self
        }
        /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
        pub fn set_ec2_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        ) -> Self {
            self.ec2_instance_types = input;
            self
        }
        /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
        pub fn max_session_length_in_minutes(mut self, input: i32) -> Self {
            self.max_session_length_in_minutes = Some(input);
            self
        }
        /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
        pub fn set_max_session_length_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_session_length_in_minutes = input;
            self
        }
        /// Appends an item to `streaming_image_ids`.
        ///
        /// To override the contents of this collection use [`set_streaming_image_ids`](Self::set_streaming_image_ids).
        ///
        /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
        pub fn streaming_image_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.streaming_image_ids.unwrap_or_default();
            v.push(input.into());
            self.streaming_image_ids = Some(v);
            self
        }
        /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
        pub fn set_streaming_image_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.streaming_image_ids = input;
            self
        }
        /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is 5760.</p>
        /// <p>This field is allowed only when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is <code>ACTIVATED</code>.</p>
        /// <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated (instead of <code>STOPPED</code>).</p>
        /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped (instead of terminated).</p>
        pub fn max_stopped_session_length_in_minutes(mut self, input: i32) -> Self {
            self.max_stopped_session_length_in_minutes = Some(input);
            self
        }
        /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is 5760.</p>
        /// <p>This field is allowed only when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is <code>ACTIVATED</code>.</p>
        /// <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated (instead of <code>STOPPED</code>).</p>
        /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state. If the time that a session stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped (instead of terminated).</p>
        pub fn set_max_stopped_session_length_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_stopped_session_length_in_minutes = input;
            self
        }
        /// <p>The upload storage for a streaming workstation that is created using this launch profile.</p>
        pub fn session_storage(
            mut self,
            input: crate::model::StreamConfigurationSessionStorage,
        ) -> Self {
            self.session_storage = Some(input);
            self
        }
        /// <p>The upload storage for a streaming workstation that is created using this launch profile.</p>
        pub fn set_session_storage(
            mut self,
            input: std::option::Option<crate::model::StreamConfigurationSessionStorage>,
        ) -> Self {
            self.session_storage = input;
            self
        }
        /// <p>Configures how streaming sessions are backed up when launched from this launch profile.</p>
        pub fn session_backup(
            mut self,
            input: crate::model::StreamConfigurationSessionBackup,
        ) -> Self {
            self.session_backup = Some(input);
            self
        }
        /// <p>Configures how streaming sessions are backed up when launched from this launch profile.</p>
        pub fn set_session_backup(
            mut self,
            input: std::option::Option<crate::model::StreamConfigurationSessionBackup>,
        ) -> Self {
            self.session_backup = input;
            self
        }
        /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
        pub fn session_persistence_mode(
            mut self,
            input: crate::model::SessionPersistenceMode,
        ) -> Self {
            self.session_persistence_mode = Some(input);
            self
        }
        /// <p>Determine if a streaming session created from this launch profile can configure persistent storage. This means that <code>volumeConfiguration</code> and <code>automaticTerminationMode</code> are configured.</p>
        pub fn set_session_persistence_mode(
            mut self,
            input: std::option::Option<crate::model::SessionPersistenceMode>,
        ) -> Self {
            self.session_persistence_mode = input;
            self
        }
        /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
        pub fn volume_configuration(mut self, input: crate::model::VolumeConfiguration) -> Self {
            self.volume_configuration = Some(input);
            self
        }
        /// <p>Custom volume configuration for the root volumes that are attached to streaming sessions.</p>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>.</p>
        pub fn set_volume_configuration(
            mut self,
            input: std::option::Option<crate::model::VolumeConfiguration>,
        ) -> Self {
            self.volume_configuration = input;
            self
        }
        /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
        /// <ul>
        /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
        /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
        /// </ul>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
        pub fn automatic_termination_mode(
            mut self,
            input: crate::model::AutomaticTerminationMode,
        ) -> Self {
            self.automatic_termination_mode = Some(input);
            self
        }
        /// <p>Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a <code>STOPPED</code> state.</p>
        /// <ul>
        /// <li> <p>When <code>ACTIVATED</code>, the streaming session is scheduled for termination after being in the <code>STOPPED</code> state for the time specified in <code>maxStoppedSessionLengthInMinutes</code>.</p> </li>
        /// <li> <p>When <code>DEACTIVATED</code>, the streaming session can remain in the <code>STOPPED</code> state indefinitely.</p> </li>
        /// </ul>
        /// <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is <code>ACTIVATED</code>. When allowed, the default value for this parameter is <code>DEACTIVATED</code>.</p>
        pub fn set_automatic_termination_mode(
            mut self,
            input: std::option::Option<crate::model::AutomaticTerminationMode>,
        ) -> Self {
            self.automatic_termination_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate).
        pub fn build(self) -> crate::model::StreamConfigurationCreate {
            crate::model::StreamConfigurationCreate {
                clipboard_mode: self.clipboard_mode,
                ec2_instance_types: self.ec2_instance_types,
                max_session_length_in_minutes: self.max_session_length_in_minutes,
                streaming_image_ids: self.streaming_image_ids,
                max_stopped_session_length_in_minutes: self
                    .max_stopped_session_length_in_minutes
                    .unwrap_or_default(),
                session_storage: self.session_storage,
                session_backup: self.session_backup,
                session_persistence_mode: self.session_persistence_mode,
                volume_configuration: self.volume_configuration,
                automatic_termination_mode: self.automatic_termination_mode,
            }
        }
    }
}

/// <p>Represents a EULA resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Eula {
    /// <p>The EULA content.</p>
    #[doc(hidden)]
    pub content: std::option::Option<std::string::String>,
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The EULA ID.</p>
    #[doc(hidden)]
    pub eula_id: std::option::Option<std::string::String>,
    /// <p>The name for the EULA.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl Eula {
    /// <p>The EULA content.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The EULA ID.</p>
    pub fn eula_id(&self) -> std::option::Option<&str> {
        self.eula_id.as_deref()
    }
    /// <p>The name for the EULA.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
impl Eula {
    /// Creates a new builder-style object to manufacture [`Eula`](crate::model::Eula).
    pub fn builder() -> crate::model::eula::Builder {
        crate::model::eula::Builder::default()
    }
}

/// See [`Eula`](crate::model::Eula).
pub mod eula {

    /// A builder for [`Eula`](crate::model::Eula).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) eula_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The EULA content.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The EULA content.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The EULA ID.</p>
        pub fn eula_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.eula_id = Some(input.into());
            self
        }
        /// <p>The EULA ID.</p>
        pub fn set_eula_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.eula_id = input;
            self
        }
        /// <p>The name for the EULA.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the EULA.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`Eula`](crate::model::Eula).
        pub fn build(self) -> crate::model::Eula {
            crate::model::Eula {
                content: self.content,
                created_at: self.created_at,
                eula_id: self.eula_id,
                name: self.name,
                updated_at: self.updated_at,
            }
        }
    }
}

/// <p>The acceptance of a EULA, required to use Amazon-provided streaming images.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EulaAcceptance {
    /// <p>The ISO timestamp in seconds for when the EULA was accepted.</p>
    #[doc(hidden)]
    pub accepted_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The ID of the person who accepted the EULA.</p>
    #[doc(hidden)]
    pub accepted_by: std::option::Option<std::string::String>,
    /// <p>The ID of the acceptee.</p>
    #[doc(hidden)]
    pub acceptee_id: std::option::Option<std::string::String>,
    /// <p>The EULA acceptance ID.</p>
    #[doc(hidden)]
    pub eula_acceptance_id: std::option::Option<std::string::String>,
    /// <p>The EULA ID.</p>
    #[doc(hidden)]
    pub eula_id: std::option::Option<std::string::String>,
}
impl EulaAcceptance {
    /// <p>The ISO timestamp in seconds for when the EULA was accepted.</p>
    pub fn accepted_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.accepted_at.as_ref()
    }
    /// <p>The ID of the person who accepted the EULA.</p>
    pub fn accepted_by(&self) -> std::option::Option<&str> {
        self.accepted_by.as_deref()
    }
    /// <p>The ID of the acceptee.</p>
    pub fn acceptee_id(&self) -> std::option::Option<&str> {
        self.acceptee_id.as_deref()
    }
    /// <p>The EULA acceptance ID.</p>
    pub fn eula_acceptance_id(&self) -> std::option::Option<&str> {
        self.eula_acceptance_id.as_deref()
    }
    /// <p>The EULA ID.</p>
    pub fn eula_id(&self) -> std::option::Option<&str> {
        self.eula_id.as_deref()
    }
}
impl EulaAcceptance {
    /// Creates a new builder-style object to manufacture [`EulaAcceptance`](crate::model::EulaAcceptance).
    pub fn builder() -> crate::model::eula_acceptance::Builder {
        crate::model::eula_acceptance::Builder::default()
    }
}

/// See [`EulaAcceptance`](crate::model::EulaAcceptance).
pub mod eula_acceptance {

    /// A builder for [`EulaAcceptance`](crate::model::EulaAcceptance).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accepted_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) accepted_by: std::option::Option<std::string::String>,
        pub(crate) acceptee_id: std::option::Option<std::string::String>,
        pub(crate) eula_acceptance_id: std::option::Option<std::string::String>,
        pub(crate) eula_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ISO timestamp in seconds for when the EULA was accepted.</p>
        pub fn accepted_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.accepted_at = Some(input);
            self
        }
        /// <p>The ISO timestamp in seconds for when the EULA was accepted.</p>
        pub fn set_accepted_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.accepted_at = input;
            self
        }
        /// <p>The ID of the person who accepted the EULA.</p>
        pub fn accepted_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.accepted_by = Some(input.into());
            self
        }
        /// <p>The ID of the person who accepted the EULA.</p>
        pub fn set_accepted_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.accepted_by = input;
            self
        }
        /// <p>The ID of the acceptee.</p>
        pub fn acceptee_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.acceptee_id = Some(input.into());
            self
        }
        /// <p>The ID of the acceptee.</p>
        pub fn set_acceptee_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.acceptee_id = input;
            self
        }
        /// <p>The EULA acceptance ID.</p>
        pub fn eula_acceptance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.eula_acceptance_id = Some(input.into());
            self
        }
        /// <p>The EULA acceptance ID.</p>
        pub fn set_eula_acceptance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.eula_acceptance_id = input;
            self
        }
        /// <p>The EULA ID.</p>
        pub fn eula_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.eula_id = Some(input.into());
            self
        }
        /// <p>The EULA ID.</p>
        pub fn set_eula_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.eula_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EulaAcceptance`](crate::model::EulaAcceptance).
        pub fn build(self) -> crate::model::EulaAcceptance {
            crate::model::EulaAcceptance {
                accepted_at: self.accepted_at,
                accepted_by: self.accepted_by,
                acceptee_id: self.acceptee_id,
                eula_acceptance_id: self.eula_acceptance_id,
                eula_id: self.eula_id,
            }
        }
    }
}
