// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Represents a studio resource.</p>
/// <p>A studio is the core resource used with Nimble Studio. You must create a studio first, before any other resource type can be created. All other resources you create and manage in Nimble Studio are contained within a studio.</p>
/// <p>When creating a studio, you must provides two IAM roles for use with the Nimble Studio portal. These roles are assumed by your users when they log in to the Nimble Studio portal via Amazon Web Services SSO and your identity source.</p>
/// <p>The user role must have the AmazonNimbleStudio-StudioUser managed policy attached for the portal to function properly.</p>
/// <p>The admin role must have the AmazonNimbleStudio-StudioAdmin managed policy attached for the portal to function properly.</p>
/// <p>Your studio roles must trust the identity.nimble.amazonaws.com service principal to function properly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Studio {
    /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
    pub admin_role_arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>A friendly name for the studio.</p>
    pub display_name: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services Region where the studio resource is located.</p>
    pub home_region: std::option::Option<std::string::String>,
    /// <p>The Amazon Web Services SSO application client ID used to integrate with Amazon Web Services SSO to enable Amazon Web Services SSO users to log in to Nimble Studio portal.</p>
    pub sso_client_id: std::option::Option<std::string::String>,
    /// <p>The current state of the studio resource.</p>
    pub state: std::option::Option<crate::model::StudioState>,
    /// <p>Status codes that provide additional detail on the studio state.</p>
    pub status_code: std::option::Option<crate::model::StudioStatusCode>,
    /// <p>Additional detail on the studio state.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>Configuration of the encryption method that is used for the studio.</p>
    pub studio_encryption_configuration:
        std::option::Option<crate::model::StudioEncryptionConfiguration>,
    /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
    pub studio_id: std::option::Option<std::string::String>,
    /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
    pub studio_name: std::option::Option<std::string::String>,
    /// <p>The address of the web page for the studio.</p>
    pub studio_url: std::option::Option<std::string::String>,
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
    pub user_role_arn: std::option::Option<std::string::String>,
}
impl Studio {
    /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
    pub fn admin_role_arn(&self) -> std::option::Option<&str> {
        self.admin_role_arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>A friendly name for the studio.</p>
    pub fn display_name(&self) -> std::option::Option<&str> {
        self.display_name.as_deref()
    }
    /// <p>The Amazon Web Services Region where the studio resource is located.</p>
    pub fn home_region(&self) -> std::option::Option<&str> {
        self.home_region.as_deref()
    }
    /// <p>The Amazon Web Services SSO application client ID used to integrate with Amazon Web Services SSO to enable Amazon Web Services SSO users to log in to Nimble Studio portal.</p>
    pub fn sso_client_id(&self) -> std::option::Option<&str> {
        self.sso_client_id.as_deref()
    }
    /// <p>The current state of the studio resource.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StudioState> {
        self.state.as_ref()
    }
    /// <p>Status codes that provide additional detail on the studio state.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::StudioStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>Additional detail on the studio state.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>Configuration of the encryption method that is used for the studio.</p>
    pub fn studio_encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::StudioEncryptionConfiguration> {
        self.studio_encryption_configuration.as_ref()
    }
    /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
    pub fn studio_id(&self) -> std::option::Option<&str> {
        self.studio_id.as_deref()
    }
    /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
    pub fn studio_name(&self) -> std::option::Option<&str> {
        self.studio_name.as_deref()
    }
    /// <p>The address of the web page for the studio.</p>
    pub fn studio_url(&self) -> std::option::Option<&str> {
        self.studio_url.as_deref()
    }
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
    pub fn user_role_arn(&self) -> std::option::Option<&str> {
        self.user_role_arn.as_deref()
    }
}
impl std::fmt::Debug for Studio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Studio");
        formatter.field("admin_role_arn", &self.admin_role_arn);
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("display_name", &"*** Sensitive Data Redacted ***");
        formatter.field("home_region", &self.home_region);
        formatter.field("sso_client_id", &self.sso_client_id);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field(
            "studio_encryption_configuration",
            &self.studio_encryption_configuration,
        );
        formatter.field("studio_id", &self.studio_id);
        formatter.field("studio_name", &self.studio_name);
        formatter.field("studio_url", &self.studio_url);
        formatter.field("tags", &self.tags);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("user_role_arn", &self.user_role_arn);
        formatter.finish()
    }
}
/// See [`Studio`](crate::model::Studio)
pub mod studio {

    /// A builder for [`Studio`](crate::model::Studio)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) admin_role_arn: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) display_name: std::option::Option<std::string::String>,
        pub(crate) home_region: std::option::Option<std::string::String>,
        pub(crate) sso_client_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StudioState>,
        pub(crate) status_code: std::option::Option<crate::model::StudioStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) studio_encryption_configuration:
            std::option::Option<crate::model::StudioEncryptionConfiguration>,
        pub(crate) studio_id: std::option::Option<std::string::String>,
        pub(crate) studio_name: std::option::Option<std::string::String>,
        pub(crate) studio_url: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) user_role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
        pub fn admin_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.admin_role_arn = Some(input.into());
            self
        }
        /// <p>The IAM role that studio admins assume when logging in to the Nimble Studio portal.</p>
        pub fn set_admin_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.admin_role_arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>A friendly name for the studio.</p>
        pub fn display_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.display_name = Some(input.into());
            self
        }
        /// <p>A friendly name for the studio.</p>
        pub fn set_display_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.display_name = input;
            self
        }
        /// <p>The Amazon Web Services Region where the studio resource is located.</p>
        pub fn home_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.home_region = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services Region where the studio resource is located.</p>
        pub fn set_home_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.home_region = input;
            self
        }
        /// <p>The Amazon Web Services SSO application client ID used to integrate with Amazon Web Services SSO to enable Amazon Web Services SSO users to log in to Nimble Studio portal.</p>
        pub fn sso_client_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sso_client_id = Some(input.into());
            self
        }
        /// <p>The Amazon Web Services SSO application client ID used to integrate with Amazon Web Services SSO to enable Amazon Web Services SSO users to log in to Nimble Studio portal.</p>
        pub fn set_sso_client_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sso_client_id = input;
            self
        }
        /// <p>The current state of the studio resource.</p>
        pub fn state(mut self, input: crate::model::StudioState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the studio resource.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::StudioState>) -> Self {
            self.state = input;
            self
        }
        /// <p>Status codes that provide additional detail on the studio state.</p>
        pub fn status_code(mut self, input: crate::model::StudioStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>Status codes that provide additional detail on the studio state.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StudioStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>Additional detail on the studio state.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>Additional detail on the studio state.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>Configuration of the encryption method that is used for the studio.</p>
        pub fn studio_encryption_configuration(
            mut self,
            input: crate::model::StudioEncryptionConfiguration,
        ) -> Self {
            self.studio_encryption_configuration = Some(input);
            self
        }
        /// <p>Configuration of the encryption method that is used for the studio.</p>
        pub fn set_studio_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioEncryptionConfiguration>,
        ) -> Self {
            self.studio_encryption_configuration = input;
            self
        }
        /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
        pub fn studio_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.</p>
        pub fn set_studio_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.studio_id = input;
            self
        }
        /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
        pub fn studio_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_name = Some(input.into());
            self
        }
        /// <p>The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.</p>
        pub fn set_studio_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.studio_name = input;
            self
        }
        /// <p>The address of the web page for the studio.</p>
        pub fn studio_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_url = Some(input.into());
            self
        }
        /// <p>The address of the web page for the studio.</p>
        pub fn set_studio_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.studio_url = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
        pub fn user_role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_role_arn = Some(input.into());
            self
        }
        /// <p>The IAM role that studio users assume when logging in to the Nimble Studio portal.</p>
        pub fn set_user_role_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Studio`](crate::model::Studio)
        pub fn build(self) -> crate::model::Studio {
            crate::model::Studio {
                admin_role_arn: self.admin_role_arn,
                arn: self.arn,
                created_at: self.created_at,
                display_name: self.display_name,
                home_region: self.home_region,
                sso_client_id: self.sso_client_id,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                studio_encryption_configuration: self.studio_encryption_configuration,
                studio_id: self.studio_id,
                studio_name: self.studio_name,
                studio_url: self.studio_url,
                tags: self.tags,
                updated_at: self.updated_at,
                user_role_arn: self.user_role_arn,
            }
        }
    }
}
impl Studio {
    /// Creates a new builder-style object to manufacture [`Studio`](crate::model::Studio)
    pub fn builder() -> crate::model::studio::Builder {
        crate::model::studio::Builder::default()
    }
}

/// <p>Configuration of the encryption method that is used for the studio.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioEncryptionConfiguration {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    pub key_arn: std::option::Option<std::string::String>,
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    pub key_type: std::option::Option<crate::model::StudioEncryptionConfigurationKeyType>,
}
impl StudioEncryptionConfiguration {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    pub fn key_arn(&self) -> std::option::Option<&str> {
        self.key_arn.as_deref()
    }
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    pub fn key_type(
        &self,
    ) -> std::option::Option<&crate::model::StudioEncryptionConfigurationKeyType> {
        self.key_type.as_ref()
    }
}
impl std::fmt::Debug for StudioEncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioEncryptionConfiguration");
        formatter.field("key_arn", &self.key_arn);
        formatter.field("key_type", &self.key_type);
        formatter.finish()
    }
}
/// See [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration)
pub mod studio_encryption_configuration {

    /// A builder for [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_arn: std::option::Option<std::string::String>,
        pub(crate) key_type:
            std::option::Option<crate::model::StudioEncryptionConfigurationKeyType>,
    }
    impl Builder {
        /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        pub fn key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_arn = Some(input.into());
            self
        }
        /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        pub fn set_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_arn = input;
            self
        }
        /// <p>The type of KMS key that is used to encrypt studio data.</p>
        pub fn key_type(
            mut self,
            input: crate::model::StudioEncryptionConfigurationKeyType,
        ) -> Self {
            self.key_type = Some(input);
            self
        }
        /// <p>The type of KMS key that is used to encrypt studio data.</p>
        pub fn set_key_type(
            mut self,
            input: std::option::Option<crate::model::StudioEncryptionConfigurationKeyType>,
        ) -> Self {
            self.key_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration)
        pub fn build(self) -> crate::model::StudioEncryptionConfiguration {
            crate::model::StudioEncryptionConfiguration {
                key_arn: self.key_arn,
                key_type: self.key_type,
            }
        }
    }
}
impl StudioEncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`StudioEncryptionConfiguration`](crate::model::StudioEncryptionConfiguration)
    pub fn builder() -> crate::model::studio_encryption_configuration::Builder {
        crate::model::studio_encryption_configuration::Builder::default()
    }
}

/// <p>The type of KMS key that is used to encrypt studio data.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioEncryptionConfigurationKeyType {
    #[allow(missing_docs)] // documentation missing in model
    AwsOwnedKey,
    #[allow(missing_docs)] // documentation missing in model
    CustomerManagedKey,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioEncryptionConfigurationKeyType {
    fn from(s: &str) -> Self {
        match s {
            "AWS_OWNED_KEY" => StudioEncryptionConfigurationKeyType::AwsOwnedKey,
            "CUSTOMER_MANAGED_KEY" => StudioEncryptionConfigurationKeyType::CustomerManagedKey,
            other => StudioEncryptionConfigurationKeyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioEncryptionConfigurationKeyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioEncryptionConfigurationKeyType::from(s))
    }
}
impl StudioEncryptionConfigurationKeyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioEncryptionConfigurationKeyType::AwsOwnedKey => "AWS_OWNED_KEY",
            StudioEncryptionConfigurationKeyType::CustomerManagedKey => "CUSTOMER_MANAGED_KEY",
            StudioEncryptionConfigurationKeyType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["AWS_OWNED_KEY", "CUSTOMER_MANAGED_KEY"]
    }
}
impl AsRef<str> for StudioEncryptionConfigurationKeyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The status code.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    AwsSsoAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    AwsSsoConfigurationRepaired,
    #[allow(missing_docs)] // documentation missing in model
    AwsSsoConfigurationRepairInProgress,
    #[allow(missing_docs)] // documentation missing in model
    AwsSsoNotEnabled,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyNotFound,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    RoleCouldNotBeAssumed,
    #[allow(missing_docs)] // documentation missing in model
    RoleNotOwnedByStudioOwner,
    #[allow(missing_docs)] // documentation missing in model
    StudioCreated,
    #[allow(missing_docs)] // documentation missing in model
    StudioCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StudioDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StudioDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StudioUpdated,
    #[allow(missing_docs)] // documentation missing in model
    StudioUpdateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StudioWithLaunchProfilesNotDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StudioWithStreamingImagesNotDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StudioWithStudioComponentsNotDeleted,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "AWS_SSO_ACCESS_DENIED" => StudioStatusCode::AwsSsoAccessDenied,
            "AWS_SSO_CONFIGURATION_REPAIRED" => StudioStatusCode::AwsSsoConfigurationRepaired,
            "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS" => {
                StudioStatusCode::AwsSsoConfigurationRepairInProgress
            }
            "AWS_SSO_NOT_ENABLED" => StudioStatusCode::AwsSsoNotEnabled,
            "ENCRYPTION_KEY_ACCESS_DENIED" => StudioStatusCode::EncryptionKeyAccessDenied,
            "ENCRYPTION_KEY_NOT_FOUND" => StudioStatusCode::EncryptionKeyNotFound,
            "INTERNAL_ERROR" => StudioStatusCode::InternalError,
            "ROLE_COULD_NOT_BE_ASSUMED" => StudioStatusCode::RoleCouldNotBeAssumed,
            "ROLE_NOT_OWNED_BY_STUDIO_OWNER" => StudioStatusCode::RoleNotOwnedByStudioOwner,
            "STUDIO_CREATED" => StudioStatusCode::StudioCreated,
            "STUDIO_CREATE_IN_PROGRESS" => StudioStatusCode::StudioCreateInProgress,
            "STUDIO_DELETED" => StudioStatusCode::StudioDeleted,
            "STUDIO_DELETE_IN_PROGRESS" => StudioStatusCode::StudioDeleteInProgress,
            "STUDIO_UPDATED" => StudioStatusCode::StudioUpdated,
            "STUDIO_UPDATE_IN_PROGRESS" => StudioStatusCode::StudioUpdateInProgress,
            "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED" => {
                StudioStatusCode::StudioWithLaunchProfilesNotDeleted
            }
            "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED" => {
                StudioStatusCode::StudioWithStreamingImagesNotDeleted
            }
            "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED" => {
                StudioStatusCode::StudioWithStudioComponentsNotDeleted
            }
            other => StudioStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioStatusCode::from(s))
    }
}
impl StudioStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioStatusCode::AwsSsoAccessDenied => "AWS_SSO_ACCESS_DENIED",
            StudioStatusCode::AwsSsoConfigurationRepaired => "AWS_SSO_CONFIGURATION_REPAIRED",
            StudioStatusCode::AwsSsoConfigurationRepairInProgress => {
                "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
            }
            StudioStatusCode::AwsSsoNotEnabled => "AWS_SSO_NOT_ENABLED",
            StudioStatusCode::EncryptionKeyAccessDenied => "ENCRYPTION_KEY_ACCESS_DENIED",
            StudioStatusCode::EncryptionKeyNotFound => "ENCRYPTION_KEY_NOT_FOUND",
            StudioStatusCode::InternalError => "INTERNAL_ERROR",
            StudioStatusCode::RoleCouldNotBeAssumed => "ROLE_COULD_NOT_BE_ASSUMED",
            StudioStatusCode::RoleNotOwnedByStudioOwner => "ROLE_NOT_OWNED_BY_STUDIO_OWNER",
            StudioStatusCode::StudioCreated => "STUDIO_CREATED",
            StudioStatusCode::StudioCreateInProgress => "STUDIO_CREATE_IN_PROGRESS",
            StudioStatusCode::StudioDeleted => "STUDIO_DELETED",
            StudioStatusCode::StudioDeleteInProgress => "STUDIO_DELETE_IN_PROGRESS",
            StudioStatusCode::StudioUpdated => "STUDIO_UPDATED",
            StudioStatusCode::StudioUpdateInProgress => "STUDIO_UPDATE_IN_PROGRESS",
            StudioStatusCode::StudioWithLaunchProfilesNotDeleted => {
                "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
            }
            StudioStatusCode::StudioWithStreamingImagesNotDeleted => {
                "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
            }
            StudioStatusCode::StudioWithStudioComponentsNotDeleted => {
                "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
            }
            StudioStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AWS_SSO_ACCESS_DENIED",
            "AWS_SSO_CONFIGURATION_REPAIRED",
            "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS",
            "AWS_SSO_NOT_ENABLED",
            "ENCRYPTION_KEY_ACCESS_DENIED",
            "ENCRYPTION_KEY_NOT_FOUND",
            "INTERNAL_ERROR",
            "ROLE_COULD_NOT_BE_ASSUMED",
            "ROLE_NOT_OWNED_BY_STUDIO_OWNER",
            "STUDIO_CREATED",
            "STUDIO_CREATE_IN_PROGRESS",
            "STUDIO_DELETED",
            "STUDIO_DELETE_IN_PROGRESS",
            "STUDIO_UPDATED",
            "STUDIO_UPDATE_IN_PROGRESS",
            "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED",
            "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED",
            "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED",
        ]
    }
}
impl AsRef<str> for StudioStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StudioState::CreateFailed,
            "CREATE_IN_PROGRESS" => StudioState::CreateInProgress,
            "DELETED" => StudioState::Deleted,
            "DELETE_FAILED" => StudioState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StudioState::DeleteInProgress,
            "READY" => StudioState::Ready,
            "UPDATE_FAILED" => StudioState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => StudioState::UpdateInProgress,
            other => StudioState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioState::from(s))
    }
}
impl StudioState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioState::CreateFailed => "CREATE_FAILED",
            StudioState::CreateInProgress => "CREATE_IN_PROGRESS",
            StudioState::Deleted => "DELETED",
            StudioState::DeleteFailed => "DELETE_FAILED",
            StudioState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StudioState::Ready => "READY",
            StudioState::UpdateFailed => "UPDATE_FAILED",
            StudioState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            StudioState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StudioState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A new studio user's membership.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NewStudioMember {
    /// <p>The persona.</p>
    pub persona: std::option::Option<crate::model::StudioPersona>,
    /// <p>The principal ID.</p>
    pub principal_id: std::option::Option<std::string::String>,
}
impl NewStudioMember {
    /// <p>The persona.</p>
    pub fn persona(&self) -> std::option::Option<&crate::model::StudioPersona> {
        self.persona.as_ref()
    }
    /// <p>The principal ID.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
}
impl std::fmt::Debug for NewStudioMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NewStudioMember");
        formatter.field("persona", &self.persona);
        formatter.field("principal_id", &self.principal_id);
        formatter.finish()
    }
}
/// See [`NewStudioMember`](crate::model::NewStudioMember)
pub mod new_studio_member {

    /// A builder for [`NewStudioMember`](crate::model::NewStudioMember)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) persona: std::option::Option<crate::model::StudioPersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::StudioPersona) -> Self {
            self.persona = Some(input);
            self
        }
        /// <p>The persona.</p>
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::StudioPersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NewStudioMember`](crate::model::NewStudioMember)
        pub fn build(self) -> crate::model::NewStudioMember {
            crate::model::NewStudioMember {
                persona: self.persona,
                principal_id: self.principal_id,
            }
        }
    }
}
impl NewStudioMember {
    /// Creates a new builder-style object to manufacture [`NewStudioMember`](crate::model::NewStudioMember)
    pub fn builder() -> crate::model::new_studio_member::Builder {
        crate::model::new_studio_member::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioPersona {
    #[allow(missing_docs)] // documentation missing in model
    Administrator,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioPersona {
    fn from(s: &str) -> Self {
        match s {
            "ADMINISTRATOR" => StudioPersona::Administrator,
            other => StudioPersona::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioPersona {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioPersona::from(s))
    }
}
impl StudioPersona {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioPersona::Administrator => "ADMINISTRATOR",
            StudioPersona::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["ADMINISTRATOR"]
    }
}
impl AsRef<str> for StudioPersona {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A studio member is an association of a user from your studio identity source to elevated permissions that they are granted in the studio.</p>
/// <p>When you add a user to your studio using the Nimble Studio console, they are given access to the studio's AWS SSO application and are given access to log in to the Nimble Studio portal. These users have the permissions provided by the studio's user IAM role and do not appear in the studio membership collection. Only studio admins appear in studio membership.</p>
/// <p>When you add a user to studio membership with the persona ADMIN, upon logging in to the Nimble Studio portal, they are granted permissions specified by the Studio's Admin IAM role.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioMembership {
    /// <p>The ID of the identity store.</p>
    pub identity_store_id: std::option::Option<std::string::String>,
    /// <p>The persona.</p>
    pub persona: std::option::Option<crate::model::StudioPersona>,
    /// <p>The principal ID.</p>
    pub principal_id: std::option::Option<std::string::String>,
    /// <p>The Active Directory Security Identifier for this user, if available.</p>
    pub sid: std::option::Option<std::string::String>,
}
impl StudioMembership {
    /// <p>The ID of the identity store.</p>
    pub fn identity_store_id(&self) -> std::option::Option<&str> {
        self.identity_store_id.as_deref()
    }
    /// <p>The persona.</p>
    pub fn persona(&self) -> std::option::Option<&crate::model::StudioPersona> {
        self.persona.as_ref()
    }
    /// <p>The principal ID.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
    /// <p>The Active Directory Security Identifier for this user, if available.</p>
    pub fn sid(&self) -> std::option::Option<&str> {
        self.sid.as_deref()
    }
}
impl std::fmt::Debug for StudioMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioMembership");
        formatter.field("identity_store_id", &self.identity_store_id);
        formatter.field("persona", &self.persona);
        formatter.field("principal_id", &self.principal_id);
        formatter.field("sid", &self.sid);
        formatter.finish()
    }
}
/// See [`StudioMembership`](crate::model::StudioMembership)
pub mod studio_membership {

    /// A builder for [`StudioMembership`](crate::model::StudioMembership)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_store_id: std::option::Option<std::string::String>,
        pub(crate) persona: std::option::Option<crate::model::StudioPersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
        pub(crate) sid: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_store_id = Some(input.into());
            self
        }
        /// <p>The ID of the identity store.</p>
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_store_id = input;
            self
        }
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::StudioPersona) -> Self {
            self.persona = Some(input);
            self
        }
        /// <p>The persona.</p>
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::StudioPersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// <p>The Active Directory Security Identifier for this user, if available.</p>
        pub fn sid(mut self, input: impl Into<std::string::String>) -> Self {
            self.sid = Some(input.into());
            self
        }
        /// <p>The Active Directory Security Identifier for this user, if available.</p>
        pub fn set_sid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sid = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioMembership`](crate::model::StudioMembership)
        pub fn build(self) -> crate::model::StudioMembership {
            crate::model::StudioMembership {
                identity_store_id: self.identity_store_id,
                persona: self.persona,
                principal_id: self.principal_id,
                sid: self.sid,
            }
        }
    }
}
impl StudioMembership {
    /// Creates a new builder-style object to manufacture [`StudioMembership`](crate::model::StudioMembership)
    pub fn builder() -> crate::model::studio_membership::Builder {
        crate::model::studio_membership::Builder::default()
    }
}

/// <p>A studio component represents a network resource to be used by a studio's users and workflows. A typical studio contains studio components for each of the following: render farm, Active Directory, licensing, and file system.</p>
/// <p>Access to a studio component is managed by specifying security groups for the resource, as well as its endpoint.</p>
/// <p>A studio component also has a set of initialization scripts that are returned by <code>GetLaunchProfileInitialization</code>. These initialization scripts run on streaming sessions when they start. They provide users with flexibility in controlling how the studio resources are configured on a streaming session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioComponent {
    /// <p>The ARN of the resource.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The configuration of the studio component, based on component type.</p>
    pub configuration: std::option::Option<crate::model::StudioComponentConfiguration>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that created the studio component.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>A human-readable description for the studio component resource.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The EC2 security groups that control access to the studio component.</p>
    pub ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Initialization scripts for studio components.</p>
    pub initialization_scripts:
        std::option::Option<std::vec::Vec<crate::model::StudioComponentInitializationScript>>,
    /// <p>A friendly name for the studio component resource.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>Parameters for the studio component scripts.</p>
    pub script_parameters:
        std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::StudioComponentState>,
    /// <p>The status code.</p>
    pub status_code: std::option::Option<crate::model::StudioComponentStatusCode>,
    /// <p>The status message for the studio component.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The specific subtype of a studio component.</p>
    pub subtype: std::option::Option<crate::model::StudioComponentSubtype>,
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The type of the studio component.</p>
    pub r#type: std::option::Option<crate::model::StudioComponentType>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub updated_by: std::option::Option<std::string::String>,
}
impl StudioComponent {
    /// <p>The ARN of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The configuration of the studio component, based on component type.</p>
    pub fn configuration(
        &self,
    ) -> std::option::Option<&crate::model::StudioComponentConfiguration> {
        self.configuration.as_ref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The user ID of the user that created the studio component.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>A human-readable description for the studio component resource.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The EC2 security groups that control access to the studio component.</p>
    pub fn ec2_security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.ec2_security_group_ids.as_deref()
    }
    /// <p>Initialization scripts for studio components.</p>
    pub fn initialization_scripts(
        &self,
    ) -> std::option::Option<&[crate::model::StudioComponentInitializationScript]> {
        self.initialization_scripts.as_deref()
    }
    /// <p>A friendly name for the studio component resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Parameters for the studio component scripts.</p>
    pub fn script_parameters(
        &self,
    ) -> std::option::Option<&[crate::model::ScriptParameterKeyValue]> {
        self.script_parameters.as_deref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StudioComponentState> {
        self.state.as_ref()
    }
    /// <p>The status code.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::StudioComponentStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the studio component.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The unique identifier for a studio component resource.</p>
    pub fn studio_component_id(&self) -> std::option::Option<&str> {
        self.studio_component_id.as_deref()
    }
    /// <p>The specific subtype of a studio component.</p>
    pub fn subtype(&self) -> std::option::Option<&crate::model::StudioComponentSubtype> {
        self.subtype.as_ref()
    }
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The type of the studio component.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::StudioComponentType> {
        self.r#type.as_ref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub fn updated_by(&self) -> std::option::Option<&str> {
        self.updated_by.as_deref()
    }
}
impl std::fmt::Debug for StudioComponent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioComponent");
        formatter.field("arn", &self.arn);
        formatter.field("configuration", &self.configuration);
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("ec2_security_group_ids", &self.ec2_security_group_ids);
        formatter.field("initialization_scripts", &self.initialization_scripts);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("script_parameters", &"*** Sensitive Data Redacted ***");
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("subtype", &self.subtype);
        formatter.field("tags", &self.tags);
        formatter.field("r#type", &self.r#type);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.finish()
    }
}
/// See [`StudioComponent`](crate::model::StudioComponent)
pub mod studio_component {

    /// A builder for [`StudioComponent`](crate::model::StudioComponent)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) configuration: std::option::Option<crate::model::StudioComponentConfiguration>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) initialization_scripts:
            std::option::Option<std::vec::Vec<crate::model::StudioComponentInitializationScript>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) script_parameters:
            std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
        pub(crate) state: std::option::Option<crate::model::StudioComponentState>,
        pub(crate) status_code: std::option::Option<crate::model::StudioComponentStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) subtype: std::option::Option<crate::model::StudioComponentSubtype>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) r#type: std::option::Option<crate::model::StudioComponentType>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The configuration of the studio component, based on component type.</p>
        pub fn configuration(mut self, input: crate::model::StudioComponentConfiguration) -> Self {
            self.configuration = Some(input);
            self
        }
        /// <p>The configuration of the studio component, based on component type.</p>
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::StudioComponentConfiguration>,
        ) -> Self {
            self.configuration = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the studio component.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that created the studio component.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>A human-readable description for the studio component resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A human-readable description for the studio component resource.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `ec2_security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_ec2_security_group_ids`](Self::set_ec2_security_group_ids).
        ///
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn ec2_security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ec2_security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.ec2_security_group_ids = Some(v);
            self
        }
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn set_ec2_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ec2_security_group_ids = input;
            self
        }
        /// Appends an item to `initialization_scripts`.
        ///
        /// To override the contents of this collection use [`set_initialization_scripts`](Self::set_initialization_scripts).
        ///
        /// <p>Initialization scripts for studio components.</p>
        pub fn initialization_scripts(
            mut self,
            input: crate::model::StudioComponentInitializationScript,
        ) -> Self {
            let mut v = self.initialization_scripts.unwrap_or_default();
            v.push(input);
            self.initialization_scripts = Some(v);
            self
        }
        /// <p>Initialization scripts for studio components.</p>
        pub fn set_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::StudioComponentInitializationScript>,
            >,
        ) -> Self {
            self.initialization_scripts = input;
            self
        }
        /// <p>A friendly name for the studio component resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A friendly name for the studio component resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Appends an item to `script_parameters`.
        ///
        /// To override the contents of this collection use [`set_script_parameters`](Self::set_script_parameters).
        ///
        /// <p>Parameters for the studio component scripts.</p>
        pub fn script_parameters(mut self, input: crate::model::ScriptParameterKeyValue) -> Self {
            let mut v = self.script_parameters.unwrap_or_default();
            v.push(input);
            self.script_parameters = Some(v);
            self
        }
        /// <p>Parameters for the studio component scripts.</p>
        pub fn set_script_parameters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ScriptParameterKeyValue>>,
        ) -> Self {
            self.script_parameters = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StudioComponentState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StudioComponentState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::StudioComponentStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StudioComponentStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the studio component.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the studio component.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn subtype(mut self, input: crate::model::StudioComponentSubtype) -> Self {
            self.subtype = Some(input);
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn set_subtype(
            mut self,
            input: std::option::Option<crate::model::StudioComponentSubtype>,
        ) -> Self {
            self.subtype = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn r#type(mut self, input: crate::model::StudioComponentType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StudioComponentType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioComponent`](crate::model::StudioComponent)
        pub fn build(self) -> crate::model::StudioComponent {
            crate::model::StudioComponent {
                arn: self.arn,
                configuration: self.configuration,
                created_at: self.created_at,
                created_by: self.created_by,
                description: self.description,
                ec2_security_group_ids: self.ec2_security_group_ids,
                initialization_scripts: self.initialization_scripts,
                name: self.name,
                script_parameters: self.script_parameters,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                studio_component_id: self.studio_component_id,
                subtype: self.subtype,
                tags: self.tags,
                r#type: self.r#type,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
            }
        }
    }
}
impl StudioComponent {
    /// Creates a new builder-style object to manufacture [`StudioComponent`](crate::model::StudioComponent)
    pub fn builder() -> crate::model::studio_component::Builder {
        crate::model::studio_component::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentType {
    #[allow(missing_docs)] // documentation missing in model
    ActiveDirectory,
    #[allow(missing_docs)] // documentation missing in model
    ComputeFarm,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    #[allow(missing_docs)] // documentation missing in model
    LicenseService,
    #[allow(missing_docs)] // documentation missing in model
    SharedFileSystem,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioComponentType {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_DIRECTORY" => StudioComponentType::ActiveDirectory,
            "COMPUTE_FARM" => StudioComponentType::ComputeFarm,
            "CUSTOM" => StudioComponentType::Custom,
            "LICENSE_SERVICE" => StudioComponentType::LicenseService,
            "SHARED_FILE_SYSTEM" => StudioComponentType::SharedFileSystem,
            other => StudioComponentType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioComponentType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentType::from(s))
    }
}
impl StudioComponentType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentType::ActiveDirectory => "ACTIVE_DIRECTORY",
            StudioComponentType::ComputeFarm => "COMPUTE_FARM",
            StudioComponentType::Custom => "CUSTOM",
            StudioComponentType::LicenseService => "LICENSE_SERVICE",
            StudioComponentType::SharedFileSystem => "SHARED_FILE_SYSTEM",
            StudioComponentType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE_DIRECTORY",
            "COMPUTE_FARM",
            "CUSTOM",
            "LICENSE_SERVICE",
            "SHARED_FILE_SYSTEM",
        ]
    }
}
impl AsRef<str> for StudioComponentType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentSubtype {
    #[allow(missing_docs)] // documentation missing in model
    AmazonFsxForLustre,
    #[allow(missing_docs)] // documentation missing in model
    AmazonFsxForWindows,
    #[allow(missing_docs)] // documentation missing in model
    AwsManagedMicrosoftAd,
    #[allow(missing_docs)] // documentation missing in model
    Custom,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioComponentSubtype {
    fn from(s: &str) -> Self {
        match s {
            "AMAZON_FSX_FOR_LUSTRE" => StudioComponentSubtype::AmazonFsxForLustre,
            "AMAZON_FSX_FOR_WINDOWS" => StudioComponentSubtype::AmazonFsxForWindows,
            "AWS_MANAGED_MICROSOFT_AD" => StudioComponentSubtype::AwsManagedMicrosoftAd,
            "CUSTOM" => StudioComponentSubtype::Custom,
            other => StudioComponentSubtype::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioComponentSubtype {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentSubtype::from(s))
    }
}
impl StudioComponentSubtype {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentSubtype::AmazonFsxForLustre => "AMAZON_FSX_FOR_LUSTRE",
            StudioComponentSubtype::AmazonFsxForWindows => "AMAZON_FSX_FOR_WINDOWS",
            StudioComponentSubtype::AwsManagedMicrosoftAd => "AWS_MANAGED_MICROSOFT_AD",
            StudioComponentSubtype::Custom => "CUSTOM",
            StudioComponentSubtype::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "AMAZON_FSX_FOR_LUSTRE",
            "AMAZON_FSX_FOR_WINDOWS",
            "AWS_MANAGED_MICROSOFT_AD",
            "CUSTOM",
        ]
    }
}
impl AsRef<str> for StudioComponentSubtype {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The current status of the studio component resource.</p>
/// <p>When the resource is in the 'READY' state, the status code signals what the last
/// mutation made to the resource was.</p>
/// <p>When the resource is in a CREATE_FAILED/UPDATE_FAILED/DELETE_FAILED state, the status
/// code signals what went wrong and why the mutation failed.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    ActiveDirectoryAlreadyExists,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyNotFound,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentCreated,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentUpdated,
    #[allow(missing_docs)] // documentation missing in model
    StudioComponentUpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioComponentStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_DIRECTORY_ALREADY_EXISTS" => {
                StudioComponentStatusCode::ActiveDirectoryAlreadyExists
            }
            "ENCRYPTION_KEY_ACCESS_DENIED" => StudioComponentStatusCode::EncryptionKeyAccessDenied,
            "ENCRYPTION_KEY_NOT_FOUND" => StudioComponentStatusCode::EncryptionKeyNotFound,
            "INTERNAL_ERROR" => StudioComponentStatusCode::InternalError,
            "STUDIO_COMPONENT_CREATED" => StudioComponentStatusCode::StudioComponentCreated,
            "STUDIO_COMPONENT_CREATE_IN_PROGRESS" => {
                StudioComponentStatusCode::StudioComponentCreateInProgress
            }
            "STUDIO_COMPONENT_DELETED" => StudioComponentStatusCode::StudioComponentDeleted,
            "STUDIO_COMPONENT_DELETE_IN_PROGRESS" => {
                StudioComponentStatusCode::StudioComponentDeleteInProgress
            }
            "STUDIO_COMPONENT_UPDATED" => StudioComponentStatusCode::StudioComponentUpdated,
            "STUDIO_COMPONENT_UPDATE_IN_PROGRESS" => {
                StudioComponentStatusCode::StudioComponentUpdateInProgress
            }
            other => StudioComponentStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioComponentStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentStatusCode::from(s))
    }
}
impl StudioComponentStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentStatusCode::ActiveDirectoryAlreadyExists => {
                "ACTIVE_DIRECTORY_ALREADY_EXISTS"
            }
            StudioComponentStatusCode::EncryptionKeyAccessDenied => "ENCRYPTION_KEY_ACCESS_DENIED",
            StudioComponentStatusCode::EncryptionKeyNotFound => "ENCRYPTION_KEY_NOT_FOUND",
            StudioComponentStatusCode::InternalError => "INTERNAL_ERROR",
            StudioComponentStatusCode::StudioComponentCreated => "STUDIO_COMPONENT_CREATED",
            StudioComponentStatusCode::StudioComponentCreateInProgress => {
                "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
            }
            StudioComponentStatusCode::StudioComponentDeleted => "STUDIO_COMPONENT_DELETED",
            StudioComponentStatusCode::StudioComponentDeleteInProgress => {
                "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
            }
            StudioComponentStatusCode::StudioComponentUpdated => "STUDIO_COMPONENT_UPDATED",
            StudioComponentStatusCode::StudioComponentUpdateInProgress => {
                "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
            }
            StudioComponentStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE_DIRECTORY_ALREADY_EXISTS",
            "ENCRYPTION_KEY_ACCESS_DENIED",
            "ENCRYPTION_KEY_NOT_FOUND",
            "INTERNAL_ERROR",
            "STUDIO_COMPONENT_CREATED",
            "STUDIO_COMPONENT_CREATE_IN_PROGRESS",
            "STUDIO_COMPONENT_DELETED",
            "STUDIO_COMPONENT_DELETE_IN_PROGRESS",
            "STUDIO_COMPONENT_UPDATED",
            "STUDIO_COMPONENT_UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StudioComponentStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The current state of the studio component resource.</p>
/// <p>While a studio component is being created, modified, or deleted, its state will equal
/// "CREATE_IN_PROGRESS", "UPDATE_IN_PROGRESS", or "DELETE_IN_PROGRESS"</p>
/// <p>These are called 'transition states'.</p>
/// <p>No modifications may be made to the studio component while it is in a transition
/// state.</p>
/// <p>If creation of the resource fails, the state will change to `CREATE_FAILED`. The
/// resource StatusCode and StatusMessage will provide more information of why creation
/// failed. The resource in this state will automatically be deleted from your account after
/// a period of time.</p>
/// <p>If updating the resource fails, the state will change to `UPDATE_FAILED`. The resource
/// StatusCode and StatusMessage will provide more information of why the update failed. The
/// resource will be returned to the state it was in when the update request was
/// invoked.</p>
/// <p>If deleting the resource fails, the state will change to `DELETE_FAILED`. The resource
/// StatusCode and StatusMessage will provide more information of why the update failed. The
/// resource will be returned to the state it was in when the update request was invoked.
/// After the resource is deleted successfully, it will change to the "DELETED" state. The
/// resource will no longer count against service quotas and cannot be used or acted upon
/// any futher. It will be removed from your account after a period of time.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioComponentState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StudioComponentState::CreateFailed,
            "CREATE_IN_PROGRESS" => StudioComponentState::CreateInProgress,
            "DELETED" => StudioComponentState::Deleted,
            "DELETE_FAILED" => StudioComponentState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StudioComponentState::DeleteInProgress,
            "READY" => StudioComponentState::Ready,
            "UPDATE_FAILED" => StudioComponentState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => StudioComponentState::UpdateInProgress,
            other => StudioComponentState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioComponentState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentState::from(s))
    }
}
impl StudioComponentState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentState::CreateFailed => "CREATE_FAILED",
            StudioComponentState::CreateInProgress => "CREATE_IN_PROGRESS",
            StudioComponentState::Deleted => "DELETED",
            StudioComponentState::DeleteFailed => "DELETE_FAILED",
            StudioComponentState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StudioComponentState::Ready => "READY",
            StudioComponentState::UpdateFailed => "UPDATE_FAILED",
            StudioComponentState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            StudioComponentState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StudioComponentState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A parameter for a studio component script, in the form of a key:value pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ScriptParameterKeyValue {
    /// <p>A script parameter key.</p>
    pub key: std::option::Option<std::string::String>,
    /// <p>A script parameter value.</p>
    pub value: std::option::Option<std::string::String>,
}
impl ScriptParameterKeyValue {
    /// <p>A script parameter key.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>A script parameter value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for ScriptParameterKeyValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ScriptParameterKeyValue");
        formatter.field("key", &self.key);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue)
pub mod script_parameter_key_value {

    /// A builder for [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A script parameter key.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>A script parameter key.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>A script parameter value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>A script parameter value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue)
        pub fn build(self) -> crate::model::ScriptParameterKeyValue {
            crate::model::ScriptParameterKeyValue {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl ScriptParameterKeyValue {
    /// Creates a new builder-style object to manufacture [`ScriptParameterKeyValue`](crate::model::ScriptParameterKeyValue)
    pub fn builder() -> crate::model::script_parameter_key_value::Builder {
        crate::model::script_parameter_key_value::Builder::default()
    }
}

/// <p>Initialization scripts for studio components.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioComponentInitializationScript {
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub launch_profile_protocol_version: std::option::Option<std::string::String>,
    /// <p>The platform of the initialization script, either WINDOWS or LINUX.</p>
    pub platform: std::option::Option<crate::model::LaunchProfilePlatform>,
    /// <p>The method to use when running the initialization script.</p>
    pub run_context:
        std::option::Option<crate::model::StudioComponentInitializationScriptRunContext>,
    /// <p>The initialization script.</p>
    pub script: std::option::Option<std::string::String>,
}
impl StudioComponentInitializationScript {
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub fn launch_profile_protocol_version(&self) -> std::option::Option<&str> {
        self.launch_profile_protocol_version.as_deref()
    }
    /// <p>The platform of the initialization script, either WINDOWS or LINUX.</p>
    pub fn platform(&self) -> std::option::Option<&crate::model::LaunchProfilePlatform> {
        self.platform.as_ref()
    }
    /// <p>The method to use when running the initialization script.</p>
    pub fn run_context(
        &self,
    ) -> std::option::Option<&crate::model::StudioComponentInitializationScriptRunContext> {
        self.run_context.as_ref()
    }
    /// <p>The initialization script.</p>
    pub fn script(&self) -> std::option::Option<&str> {
        self.script.as_deref()
    }
}
impl std::fmt::Debug for StudioComponentInitializationScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioComponentInitializationScript");
        formatter.field(
            "launch_profile_protocol_version",
            &self.launch_profile_protocol_version,
        );
        formatter.field("platform", &self.platform);
        formatter.field("run_context", &self.run_context);
        formatter.field("script", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript)
pub mod studio_component_initialization_script {

    /// A builder for [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) launch_profile_protocol_version: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<crate::model::LaunchProfilePlatform>,
        pub(crate) run_context:
            std::option::Option<crate::model::StudioComponentInitializationScriptRunContext>,
        pub(crate) script: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_version(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = Some(input.into());
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn set_launch_profile_protocol_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = input;
            self
        }
        /// <p>The platform of the initialization script, either WINDOWS or LINUX.</p>
        pub fn platform(mut self, input: crate::model::LaunchProfilePlatform) -> Self {
            self.platform = Some(input);
            self
        }
        /// <p>The platform of the initialization script, either WINDOWS or LINUX.</p>
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePlatform>,
        ) -> Self {
            self.platform = input;
            self
        }
        /// <p>The method to use when running the initialization script.</p>
        pub fn run_context(
            mut self,
            input: crate::model::StudioComponentInitializationScriptRunContext,
        ) -> Self {
            self.run_context = Some(input);
            self
        }
        /// <p>The method to use when running the initialization script.</p>
        pub fn set_run_context(
            mut self,
            input: std::option::Option<crate::model::StudioComponentInitializationScriptRunContext>,
        ) -> Self {
            self.run_context = input;
            self
        }
        /// <p>The initialization script.</p>
        pub fn script(mut self, input: impl Into<std::string::String>) -> Self {
            self.script = Some(input.into());
            self
        }
        /// <p>The initialization script.</p>
        pub fn set_script(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.script = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript)
        pub fn build(self) -> crate::model::StudioComponentInitializationScript {
            crate::model::StudioComponentInitializationScript {
                launch_profile_protocol_version: self.launch_profile_protocol_version,
                platform: self.platform,
                run_context: self.run_context,
                script: self.script,
            }
        }
    }
}
impl StudioComponentInitializationScript {
    /// Creates a new builder-style object to manufacture [`StudioComponentInitializationScript`](crate::model::StudioComponentInitializationScript)
    pub fn builder() -> crate::model::studio_component_initialization_script::Builder {
        crate::model::studio_component_initialization_script::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StudioComponentInitializationScriptRunContext {
    #[allow(missing_docs)] // documentation missing in model
    SystemInitialization,
    #[allow(missing_docs)] // documentation missing in model
    UserInitialization,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StudioComponentInitializationScriptRunContext {
    fn from(s: &str) -> Self {
        match s {
            "SYSTEM_INITIALIZATION" => {
                StudioComponentInitializationScriptRunContext::SystemInitialization
            }
            "USER_INITIALIZATION" => {
                StudioComponentInitializationScriptRunContext::UserInitialization
            }
            other => StudioComponentInitializationScriptRunContext::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StudioComponentInitializationScriptRunContext {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StudioComponentInitializationScriptRunContext::from(s))
    }
}
impl StudioComponentInitializationScriptRunContext {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StudioComponentInitializationScriptRunContext::SystemInitialization => {
                "SYSTEM_INITIALIZATION"
            }
            StudioComponentInitializationScriptRunContext::UserInitialization => {
                "USER_INITIALIZATION"
            }
            StudioComponentInitializationScriptRunContext::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["SYSTEM_INITIALIZATION", "USER_INITIALIZATION"]
    }
}
impl AsRef<str> for StudioComponentInitializationScriptRunContext {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfilePlatform {
    #[allow(missing_docs)] // documentation missing in model
    Linux,
    #[allow(missing_docs)] // documentation missing in model
    Windows,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfilePlatform {
    fn from(s: &str) -> Self {
        match s {
            "LINUX" => LaunchProfilePlatform::Linux,
            "WINDOWS" => LaunchProfilePlatform::Windows,
            other => LaunchProfilePlatform::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchProfilePlatform {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfilePlatform::from(s))
    }
}
impl LaunchProfilePlatform {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfilePlatform::Linux => "LINUX",
            LaunchProfilePlatform::Windows => "WINDOWS",
            LaunchProfilePlatform::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["LINUX", "WINDOWS"]
    }
}
impl AsRef<str> for LaunchProfilePlatform {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration of the studio component, based on component type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum StudioComponentConfiguration {
    /// <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.</p>
    ActiveDirectoryConfiguration(crate::model::ActiveDirectoryConfiguration),
    /// <p>The configuration for a render farm that is associated with a studio resource.</p>
    ComputeFarmConfiguration(crate::model::ComputeFarmConfiguration),
    /// <p>The configuration for a license service that is associated with a studio resource.</p>
    LicenseServiceConfiguration(crate::model::LicenseServiceConfiguration),
    /// <p>The configuration for a shared file storage system that is associated with a studio resource.</p>
    SharedFileSystemConfiguration(crate::model::SharedFileSystemConfiguration),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl StudioComponentConfiguration {
    /// Tries to convert the enum instance into [`ActiveDirectoryConfiguration`](crate::model::StudioComponentConfiguration::ActiveDirectoryConfiguration), extracting the inner [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_active_directory_configuration(
        &self,
    ) -> std::result::Result<&crate::model::ActiveDirectoryConfiguration, &Self> {
        if let StudioComponentConfiguration::ActiveDirectoryConfiguration(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ActiveDirectoryConfiguration`](crate::model::StudioComponentConfiguration::ActiveDirectoryConfiguration).
    pub fn is_active_directory_configuration(&self) -> bool {
        self.as_active_directory_configuration().is_ok()
    }
    /// Tries to convert the enum instance into [`ComputeFarmConfiguration`](crate::model::StudioComponentConfiguration::ComputeFarmConfiguration), extracting the inner [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_compute_farm_configuration(
        &self,
    ) -> std::result::Result<&crate::model::ComputeFarmConfiguration, &Self> {
        if let StudioComponentConfiguration::ComputeFarmConfiguration(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`ComputeFarmConfiguration`](crate::model::StudioComponentConfiguration::ComputeFarmConfiguration).
    pub fn is_compute_farm_configuration(&self) -> bool {
        self.as_compute_farm_configuration().is_ok()
    }
    /// Tries to convert the enum instance into [`LicenseServiceConfiguration`](crate::model::StudioComponentConfiguration::LicenseServiceConfiguration), extracting the inner [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_license_service_configuration(
        &self,
    ) -> std::result::Result<&crate::model::LicenseServiceConfiguration, &Self> {
        if let StudioComponentConfiguration::LicenseServiceConfiguration(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`LicenseServiceConfiguration`](crate::model::StudioComponentConfiguration::LicenseServiceConfiguration).
    pub fn is_license_service_configuration(&self) -> bool {
        self.as_license_service_configuration().is_ok()
    }
    /// Tries to convert the enum instance into [`SharedFileSystemConfiguration`](crate::model::StudioComponentConfiguration::SharedFileSystemConfiguration), extracting the inner [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_shared_file_system_configuration(
        &self,
    ) -> std::result::Result<&crate::model::SharedFileSystemConfiguration, &Self> {
        if let StudioComponentConfiguration::SharedFileSystemConfiguration(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SharedFileSystemConfiguration`](crate::model::StudioComponentConfiguration::SharedFileSystemConfiguration).
    pub fn is_shared_file_system_configuration(&self) -> bool {
        self.as_shared_file_system_configuration().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The configuration for a shared file storage system that is associated with a studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SharedFileSystemConfiguration {
    /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
    pub endpoint: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a file system.</p>
    pub file_system_id: std::option::Option<std::string::String>,
    /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
    pub linux_mount_point: std::option::Option<std::string::String>,
    /// <p>The name of the file share.</p>
    pub share_name: std::option::Option<std::string::String>,
    /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
    pub windows_mount_drive: std::option::Option<std::string::String>,
}
impl SharedFileSystemConfiguration {
    /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
    /// <p>The unique identifier for a file system.</p>
    pub fn file_system_id(&self) -> std::option::Option<&str> {
        self.file_system_id.as_deref()
    }
    /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
    pub fn linux_mount_point(&self) -> std::option::Option<&str> {
        self.linux_mount_point.as_deref()
    }
    /// <p>The name of the file share.</p>
    pub fn share_name(&self) -> std::option::Option<&str> {
        self.share_name.as_deref()
    }
    /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
    pub fn windows_mount_drive(&self) -> std::option::Option<&str> {
        self.windows_mount_drive.as_deref()
    }
}
impl std::fmt::Debug for SharedFileSystemConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SharedFileSystemConfiguration");
        formatter.field("endpoint", &"*** Sensitive Data Redacted ***");
        formatter.field("file_system_id", &self.file_system_id);
        formatter.field("linux_mount_point", &"*** Sensitive Data Redacted ***");
        formatter.field("share_name", &"*** Sensitive Data Redacted ***");
        formatter.field("windows_mount_drive", &self.windows_mount_drive);
        formatter.finish()
    }
}
/// See [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration)
pub mod shared_file_system_configuration {

    /// A builder for [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint: std::option::Option<std::string::String>,
        pub(crate) file_system_id: std::option::Option<std::string::String>,
        pub(crate) linux_mount_point: std::option::Option<std::string::String>,
        pub(crate) share_name: std::option::Option<std::string::String>,
        pub(crate) windows_mount_drive: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of the shared file system that is accessed by the studio component resource.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// <p>The unique identifier for a file system.</p>
        pub fn file_system_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.file_system_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a file system.</p>
        pub fn set_file_system_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.file_system_id = input;
            self
        }
        /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
        pub fn linux_mount_point(mut self, input: impl Into<std::string::String>) -> Self {
            self.linux_mount_point = Some(input.into());
            self
        }
        /// <p>The mount location for a shared file system on a Linux virtual workstation.</p>
        pub fn set_linux_mount_point(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.linux_mount_point = input;
            self
        }
        /// <p>The name of the file share.</p>
        pub fn share_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.share_name = Some(input.into());
            self
        }
        /// <p>The name of the file share.</p>
        pub fn set_share_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.share_name = input;
            self
        }
        /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
        pub fn windows_mount_drive(mut self, input: impl Into<std::string::String>) -> Self {
            self.windows_mount_drive = Some(input.into());
            self
        }
        /// <p>The mount location for a shared file system on a Windows virtual workstation.</p>
        pub fn set_windows_mount_drive(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.windows_mount_drive = input;
            self
        }
        /// Consumes the builder and constructs a [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration)
        pub fn build(self) -> crate::model::SharedFileSystemConfiguration {
            crate::model::SharedFileSystemConfiguration {
                endpoint: self.endpoint,
                file_system_id: self.file_system_id,
                linux_mount_point: self.linux_mount_point,
                share_name: self.share_name,
                windows_mount_drive: self.windows_mount_drive,
            }
        }
    }
}
impl SharedFileSystemConfiguration {
    /// Creates a new builder-style object to manufacture [`SharedFileSystemConfiguration`](crate::model::SharedFileSystemConfiguration)
    pub fn builder() -> crate::model::shared_file_system_configuration::Builder {
        crate::model::shared_file_system_configuration::Builder::default()
    }
}

/// <p>The configuration for a license service that is associated with a studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LicenseServiceConfiguration {
    /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
    pub endpoint: std::option::Option<std::string::String>,
}
impl LicenseServiceConfiguration {
    /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
}
impl std::fmt::Debug for LicenseServiceConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LicenseServiceConfiguration");
        formatter.field("endpoint", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration)
pub mod license_service_configuration {

    /// A builder for [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of the license service that is accessed by the studio component resource.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration)
        pub fn build(self) -> crate::model::LicenseServiceConfiguration {
            crate::model::LicenseServiceConfiguration {
                endpoint: self.endpoint,
            }
        }
    }
}
impl LicenseServiceConfiguration {
    /// Creates a new builder-style object to manufacture [`LicenseServiceConfiguration`](crate::model::LicenseServiceConfiguration)
    pub fn builder() -> crate::model::license_service_configuration::Builder {
        crate::model::license_service_configuration::Builder::default()
    }
}

/// <p>The configuration for a render farm that is associated with a studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ComputeFarmConfiguration {
    /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
    pub active_directory_user: std::option::Option<std::string::String>,
    /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
    pub endpoint: std::option::Option<std::string::String>,
}
impl ComputeFarmConfiguration {
    /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
    pub fn active_directory_user(&self) -> std::option::Option<&str> {
        self.active_directory_user.as_deref()
    }
    /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
    pub fn endpoint(&self) -> std::option::Option<&str> {
        self.endpoint.as_deref()
    }
}
impl std::fmt::Debug for ComputeFarmConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ComputeFarmConfiguration");
        formatter.field("active_directory_user", &self.active_directory_user);
        formatter.field("endpoint", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration)
pub mod compute_farm_configuration {

    /// A builder for [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_directory_user: std::option::Option<std::string::String>,
        pub(crate) endpoint: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
        pub fn active_directory_user(mut self, input: impl Into<std::string::String>) -> Self {
            self.active_directory_user = Some(input.into());
            self
        }
        /// <p>The name of an Active Directory user that is used on ComputeFarm worker instances.</p>
        pub fn set_active_directory_user(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.active_directory_user = input;
            self
        }
        /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
        pub fn endpoint(mut self, input: impl Into<std::string::String>) -> Self {
            self.endpoint = Some(input.into());
            self
        }
        /// <p>The endpoint of the ComputeFarm that is accessed by the studio component resource.</p>
        pub fn set_endpoint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.endpoint = input;
            self
        }
        /// Consumes the builder and constructs a [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration)
        pub fn build(self) -> crate::model::ComputeFarmConfiguration {
            crate::model::ComputeFarmConfiguration {
                active_directory_user: self.active_directory_user,
                endpoint: self.endpoint,
            }
        }
    }
}
impl ComputeFarmConfiguration {
    /// Creates a new builder-style object to manufacture [`ComputeFarmConfiguration`](crate::model::ComputeFarmConfiguration)
    pub fn builder() -> crate::model::compute_farm_configuration::Builder {
        crate::model::compute_farm_configuration::Builder::default()
    }
}

/// <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActiveDirectoryConfiguration {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    pub computer_attributes:
        std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
    /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.</p>
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
    pub organizational_unit_distinguished_name: std::option::Option<std::string::String>,
}
impl ActiveDirectoryConfiguration {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    pub fn computer_attributes(
        &self,
    ) -> std::option::Option<&[crate::model::ActiveDirectoryComputerAttribute]> {
        self.computer_attributes.as_deref()
    }
    /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.</p>
    pub fn directory_id(&self) -> std::option::Option<&str> {
        self.directory_id.as_deref()
    }
    /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
    pub fn organizational_unit_distinguished_name(&self) -> std::option::Option<&str> {
        self.organizational_unit_distinguished_name.as_deref()
    }
}
impl std::fmt::Debug for ActiveDirectoryConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActiveDirectoryConfiguration");
        formatter.field("computer_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("directory_id", &self.directory_id);
        formatter.field(
            "organizational_unit_distinguished_name",
            &self.organizational_unit_distinguished_name,
        );
        formatter.finish()
    }
}
/// See [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration)
pub mod active_directory_configuration {

    /// A builder for [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computer_attributes:
            std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) organizational_unit_distinguished_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `computer_attributes`.
        ///
        /// To override the contents of this collection use [`set_computer_attributes`](Self::set_computer_attributes).
        ///
        /// <p>A collection of custom attributes for an Active Directory computer.</p>
        pub fn computer_attributes(
            mut self,
            input: crate::model::ActiveDirectoryComputerAttribute,
        ) -> Self {
            let mut v = self.computer_attributes.unwrap_or_default();
            v.push(input);
            self.computer_attributes = Some(v);
            self
        }
        /// <p>A collection of custom attributes for an Active Directory computer.</p>
        pub fn set_computer_attributes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>,
            >,
        ) -> Self {
            self.computer_attributes = input;
            self
        }
        /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.</p>
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
        pub fn organizational_unit_distinguished_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = Some(input.into());
            self
        }
        /// <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.</p>
        pub fn set_organizational_unit_distinguished_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration)
        pub fn build(self) -> crate::model::ActiveDirectoryConfiguration {
            crate::model::ActiveDirectoryConfiguration {
                computer_attributes: self.computer_attributes,
                directory_id: self.directory_id,
                organizational_unit_distinguished_name: self.organizational_unit_distinguished_name,
            }
        }
    }
}
impl ActiveDirectoryConfiguration {
    /// Creates a new builder-style object to manufacture [`ActiveDirectoryConfiguration`](crate::model::ActiveDirectoryConfiguration)
    pub fn builder() -> crate::model::active_directory_configuration::Builder {
        crate::model::active_directory_configuration::Builder::default()
    }
}

/// <p>An LDAP attribute of an Active Directory computer account, in the form of a name:value pair.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActiveDirectoryComputerAttribute {
    /// <p>The name for the LDAP attribute.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The value for the LDAP attribute.</p>
    pub value: std::option::Option<std::string::String>,
}
impl ActiveDirectoryComputerAttribute {
    /// <p>The name for the LDAP attribute.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The value for the LDAP attribute.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl std::fmt::Debug for ActiveDirectoryComputerAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActiveDirectoryComputerAttribute");
        formatter.field("name", &self.name);
        formatter.field("value", &self.value);
        formatter.finish()
    }
}
/// See [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute)
pub mod active_directory_computer_attribute {

    /// A builder for [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name for the LDAP attribute.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the LDAP attribute.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The value for the LDAP attribute.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for the LDAP attribute.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute)
        pub fn build(self) -> crate::model::ActiveDirectoryComputerAttribute {
            crate::model::ActiveDirectoryComputerAttribute {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl ActiveDirectoryComputerAttribute {
    /// Creates a new builder-style object to manufacture [`ActiveDirectoryComputerAttribute`](crate::model::ActiveDirectoryComputerAttribute)
    pub fn builder() -> crate::model::active_directory_computer_attribute::Builder {
        crate::model::active_directory_computer_attribute::Builder::default()
    }
}

/// <p>A streaming session is a virtual workstation created using a particular launch profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingSession {
    /// <p>The ARN of the resource.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that created the streaming session.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The EC2 Instance type used for the streaming session.</p>
    pub ec2_instance_type: std::option::Option<std::string::String>,
    /// <p>The ID of the launch profile used to control access from the streaming session.</p>
    pub launch_profile_id: std::option::Option<std::string::String>,
    /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
    pub owned_by: std::option::Option<std::string::String>,
    /// <p>The session ID.</p>
    pub session_id: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::StreamingSessionState>,
    /// <p>The status code.</p>
    pub status_code: std::option::Option<crate::model::StreamingSessionStatusCode>,
    /// <p>The status message for the streaming session.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The ID of the streaming image.</p>
    pub streaming_image_id: std::option::Option<std::string::String>,
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
    pub terminate_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub updated_by: std::option::Option<std::string::String>,
    /// <p>The time the session entered STOP_IN_PROGRESS state.</p>
    pub stopped_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that stopped the streaming session.</p>
    pub stopped_by: std::option::Option<std::string::String>,
    /// <p>The time the session entered START_IN_PROGRESS state.</p>
    pub started_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that started the streaming session.</p>
    pub started_by: std::option::Option<std::string::String>,
    /// <p>The time the streaming session will automatically be stopped if the user doesnt stop the session themselves. </p>
    pub stop_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl StreamingSession {
    /// <p>The ARN of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The user ID of the user that created the streaming session.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The EC2 Instance type used for the streaming session.</p>
    pub fn ec2_instance_type(&self) -> std::option::Option<&str> {
        self.ec2_instance_type.as_deref()
    }
    /// <p>The ID of the launch profile used to control access from the streaming session.</p>
    pub fn launch_profile_id(&self) -> std::option::Option<&str> {
        self.launch_profile_id.as_deref()
    }
    /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
    pub fn owned_by(&self) -> std::option::Option<&str> {
        self.owned_by.as_deref()
    }
    /// <p>The session ID.</p>
    pub fn session_id(&self) -> std::option::Option<&str> {
        self.session_id.as_deref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StreamingSessionState> {
        self.state.as_ref()
    }
    /// <p>The status code.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::StreamingSessionStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the streaming session.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The ID of the streaming image.</p>
    pub fn streaming_image_id(&self) -> std::option::Option<&str> {
        self.streaming_image_id.as_deref()
    }
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
    pub fn terminate_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.terminate_at.as_ref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub fn updated_by(&self) -> std::option::Option<&str> {
        self.updated_by.as_deref()
    }
    /// <p>The time the session entered STOP_IN_PROGRESS state.</p>
    pub fn stopped_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.stopped_at.as_ref()
    }
    /// <p>The user ID of the user that stopped the streaming session.</p>
    pub fn stopped_by(&self) -> std::option::Option<&str> {
        self.stopped_by.as_deref()
    }
    /// <p>The time the session entered START_IN_PROGRESS state.</p>
    pub fn started_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.started_at.as_ref()
    }
    /// <p>The user ID of the user that started the streaming session.</p>
    pub fn started_by(&self) -> std::option::Option<&str> {
        self.started_by.as_deref()
    }
    /// <p>The time the streaming session will automatically be stopped if the user doesnt stop the session themselves. </p>
    pub fn stop_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.stop_at.as_ref()
    }
}
impl std::fmt::Debug for StreamingSession {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingSession");
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("ec2_instance_type", &self.ec2_instance_type);
        formatter.field("launch_profile_id", &self.launch_profile_id);
        formatter.field("owned_by", &self.owned_by);
        formatter.field("session_id", &self.session_id);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("streaming_image_id", &self.streaming_image_id);
        formatter.field("tags", &self.tags);
        formatter.field("terminate_at", &self.terminate_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.field("stopped_at", &self.stopped_at);
        formatter.field("stopped_by", &self.stopped_by);
        formatter.field("started_at", &self.started_at);
        formatter.field("started_by", &self.started_by);
        formatter.field("stop_at", &self.stop_at);
        formatter.finish()
    }
}
/// See [`StreamingSession`](crate::model::StreamingSession)
pub mod streaming_session {

    /// A builder for [`StreamingSession`](crate::model::StreamingSession)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) ec2_instance_type: std::option::Option<std::string::String>,
        pub(crate) launch_profile_id: std::option::Option<std::string::String>,
        pub(crate) owned_by: std::option::Option<std::string::String>,
        pub(crate) session_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StreamingSessionState>,
        pub(crate) status_code: std::option::Option<crate::model::StreamingSessionStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) streaming_image_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) terminate_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
        pub(crate) stopped_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) stopped_by: std::option::Option<std::string::String>,
        pub(crate) started_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) started_by: std::option::Option<std::string::String>,
        pub(crate) stop_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the streaming session.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that created the streaming session.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The EC2 Instance type used for the streaming session.</p>
        pub fn ec2_instance_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_instance_type = Some(input.into());
            self
        }
        /// <p>The EC2 Instance type used for the streaming session.</p>
        pub fn set_ec2_instance_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ec2_instance_type = input;
            self
        }
        /// <p>The ID of the launch profile used to control access from the streaming session.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_profile_id = Some(input.into());
            self
        }
        /// <p>The ID of the launch profile used to control access from the streaming session.</p>
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_id = input;
            self
        }
        /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
        pub fn owned_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.owned_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
        pub fn set_owned_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owned_by = input;
            self
        }
        /// <p>The session ID.</p>
        pub fn session_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_id = Some(input.into());
            self
        }
        /// <p>The session ID.</p>
        pub fn set_session_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.session_id = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StreamingSessionState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::StreamingSessionStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the streaming session.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the streaming session.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn streaming_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.streaming_image_id = Some(input.into());
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.streaming_image_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
        pub fn terminate_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.terminate_at = Some(input);
            self
        }
        /// <p>The time the streaming session will automatically terminate if not terminated by the user.</p>
        pub fn set_terminate_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.terminate_at = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// <p>The time the session entered STOP_IN_PROGRESS state.</p>
        pub fn stopped_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.stopped_at = Some(input);
            self
        }
        /// <p>The time the session entered STOP_IN_PROGRESS state.</p>
        pub fn set_stopped_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.stopped_at = input;
            self
        }
        /// <p>The user ID of the user that stopped the streaming session.</p>
        pub fn stopped_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.stopped_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that stopped the streaming session.</p>
        pub fn set_stopped_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stopped_by = input;
            self
        }
        /// <p>The time the session entered START_IN_PROGRESS state.</p>
        pub fn started_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.started_at = Some(input);
            self
        }
        /// <p>The time the session entered START_IN_PROGRESS state.</p>
        pub fn set_started_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.started_at = input;
            self
        }
        /// <p>The user ID of the user that started the streaming session.</p>
        pub fn started_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.started_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that started the streaming session.</p>
        pub fn set_started_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.started_by = input;
            self
        }
        /// <p>The time the streaming session will automatically be stopped if the user doesnt stop the session themselves. </p>
        pub fn stop_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.stop_at = Some(input);
            self
        }
        /// <p>The time the streaming session will automatically be stopped if the user doesnt stop the session themselves. </p>
        pub fn set_stop_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.stop_at = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingSession`](crate::model::StreamingSession)
        pub fn build(self) -> crate::model::StreamingSession {
            crate::model::StreamingSession {
                arn: self.arn,
                created_at: self.created_at,
                created_by: self.created_by,
                ec2_instance_type: self.ec2_instance_type,
                launch_profile_id: self.launch_profile_id,
                owned_by: self.owned_by,
                session_id: self.session_id,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                streaming_image_id: self.streaming_image_id,
                tags: self.tags,
                terminate_at: self.terminate_at,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
                stopped_at: self.stopped_at,
                stopped_by: self.stopped_by,
                started_at: self.started_at,
                started_by: self.started_by,
                stop_at: self.stop_at,
            }
        }
    }
}
impl StreamingSession {
    /// Creates a new builder-style object to manufacture [`StreamingSession`](crate::model::StreamingSession)
    pub fn builder() -> crate::model::streaming_session::Builder {
        crate::model::streaming_session::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    ActiveDirectoryDomainJoinError,
    #[allow(missing_docs)] // documentation missing in model
    AmiValidationError,
    #[allow(missing_docs)] // documentation missing in model
    DecryptStreamingImageError,
    #[allow(missing_docs)] // documentation missing in model
    InitializationScriptError,
    #[allow(missing_docs)] // documentation missing in model
    InsufficientCapacity,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    NetworkConnectionError,
    #[allow(missing_docs)] // documentation missing in model
    NetworkInterfaceError,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionReady,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionStarted,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionStartInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionStopped,
    #[allow(missing_docs)] // documentation missing in model
    StreamingSessionStopInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingSessionStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR" => {
                StreamingSessionStatusCode::ActiveDirectoryDomainJoinError
            }
            "AMI_VALIDATION_ERROR" => StreamingSessionStatusCode::AmiValidationError,
            "DECRYPT_STREAMING_IMAGE_ERROR" => {
                StreamingSessionStatusCode::DecryptStreamingImageError
            }
            "INITIALIZATION_SCRIPT_ERROR" => StreamingSessionStatusCode::InitializationScriptError,
            "INSUFFICIENT_CAPACITY" => StreamingSessionStatusCode::InsufficientCapacity,
            "INTERNAL_ERROR" => StreamingSessionStatusCode::InternalError,
            "NETWORK_CONNECTION_ERROR" => StreamingSessionStatusCode::NetworkConnectionError,
            "NETWORK_INTERFACE_ERROR" => StreamingSessionStatusCode::NetworkInterfaceError,
            "STREAMING_SESSION_CREATE_IN_PROGRESS" => {
                StreamingSessionStatusCode::StreamingSessionCreateInProgress
            }
            "STREAMING_SESSION_DELETED" => StreamingSessionStatusCode::StreamingSessionDeleted,
            "STREAMING_SESSION_DELETE_IN_PROGRESS" => {
                StreamingSessionStatusCode::StreamingSessionDeleteInProgress
            }
            "STREAMING_SESSION_READY" => StreamingSessionStatusCode::StreamingSessionReady,
            "STREAMING_SESSION_STARTED" => StreamingSessionStatusCode::StreamingSessionStarted,
            "STREAMING_SESSION_START_IN_PROGRESS" => {
                StreamingSessionStatusCode::StreamingSessionStartInProgress
            }
            "STREAMING_SESSION_STOPPED" => StreamingSessionStatusCode::StreamingSessionStopped,
            "STREAMING_SESSION_STOP_IN_PROGRESS" => {
                StreamingSessionStatusCode::StreamingSessionStopInProgress
            }
            other => StreamingSessionStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingSessionStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStatusCode::from(s))
    }
}
impl StreamingSessionStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStatusCode::ActiveDirectoryDomainJoinError => {
                "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
            }
            StreamingSessionStatusCode::AmiValidationError => "AMI_VALIDATION_ERROR",
            StreamingSessionStatusCode::DecryptStreamingImageError => {
                "DECRYPT_STREAMING_IMAGE_ERROR"
            }
            StreamingSessionStatusCode::InitializationScriptError => "INITIALIZATION_SCRIPT_ERROR",
            StreamingSessionStatusCode::InsufficientCapacity => "INSUFFICIENT_CAPACITY",
            StreamingSessionStatusCode::InternalError => "INTERNAL_ERROR",
            StreamingSessionStatusCode::NetworkConnectionError => "NETWORK_CONNECTION_ERROR",
            StreamingSessionStatusCode::NetworkInterfaceError => "NETWORK_INTERFACE_ERROR",
            StreamingSessionStatusCode::StreamingSessionCreateInProgress => {
                "STREAMING_SESSION_CREATE_IN_PROGRESS"
            }
            StreamingSessionStatusCode::StreamingSessionDeleted => "STREAMING_SESSION_DELETED",
            StreamingSessionStatusCode::StreamingSessionDeleteInProgress => {
                "STREAMING_SESSION_DELETE_IN_PROGRESS"
            }
            StreamingSessionStatusCode::StreamingSessionReady => "STREAMING_SESSION_READY",
            StreamingSessionStatusCode::StreamingSessionStarted => "STREAMING_SESSION_STARTED",
            StreamingSessionStatusCode::StreamingSessionStartInProgress => {
                "STREAMING_SESSION_START_IN_PROGRESS"
            }
            StreamingSessionStatusCode::StreamingSessionStopped => "STREAMING_SESSION_STOPPED",
            StreamingSessionStatusCode::StreamingSessionStopInProgress => {
                "STREAMING_SESSION_STOP_IN_PROGRESS"
            }
            StreamingSessionStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR",
            "AMI_VALIDATION_ERROR",
            "DECRYPT_STREAMING_IMAGE_ERROR",
            "INITIALIZATION_SCRIPT_ERROR",
            "INSUFFICIENT_CAPACITY",
            "INTERNAL_ERROR",
            "NETWORK_CONNECTION_ERROR",
            "NETWORK_INTERFACE_ERROR",
            "STREAMING_SESSION_CREATE_IN_PROGRESS",
            "STREAMING_SESSION_DELETED",
            "STREAMING_SESSION_DELETE_IN_PROGRESS",
            "STREAMING_SESSION_READY",
            "STREAMING_SESSION_STARTED",
            "STREAMING_SESSION_START_IN_PROGRESS",
            "STREAMING_SESSION_STOPPED",
            "STREAMING_SESSION_STOP_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StreamingSessionStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The streaming session state.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    StartFailed,
    #[allow(missing_docs)] // documentation missing in model
    StartInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    StopFailed,
    #[allow(missing_docs)] // documentation missing in model
    StopInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingSessionState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StreamingSessionState::CreateFailed,
            "CREATE_IN_PROGRESS" => StreamingSessionState::CreateInProgress,
            "DELETED" => StreamingSessionState::Deleted,
            "DELETE_FAILED" => StreamingSessionState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StreamingSessionState::DeleteInProgress,
            "READY" => StreamingSessionState::Ready,
            "START_FAILED" => StreamingSessionState::StartFailed,
            "START_IN_PROGRESS" => StreamingSessionState::StartInProgress,
            "STOPPED" => StreamingSessionState::Stopped,
            "STOP_FAILED" => StreamingSessionState::StopFailed,
            "STOP_IN_PROGRESS" => StreamingSessionState::StopInProgress,
            other => StreamingSessionState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingSessionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionState::from(s))
    }
}
impl StreamingSessionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionState::CreateFailed => "CREATE_FAILED",
            StreamingSessionState::CreateInProgress => "CREATE_IN_PROGRESS",
            StreamingSessionState::Deleted => "DELETED",
            StreamingSessionState::DeleteFailed => "DELETE_FAILED",
            StreamingSessionState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StreamingSessionState::Ready => "READY",
            StreamingSessionState::StartFailed => "START_FAILED",
            StreamingSessionState::StartInProgress => "START_IN_PROGRESS",
            StreamingSessionState::Stopped => "STOPPED",
            StreamingSessionState::StopFailed => "STOP_FAILED",
            StreamingSessionState::StopInProgress => "STOP_IN_PROGRESS",
            StreamingSessionState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "START_FAILED",
            "START_IN_PROGRESS",
            "STOPPED",
            "STOP_FAILED",
            "STOP_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StreamingSessionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A stream is an active connection to a streaming session, enabling a studio user to control the streaming session using a compatible client. Streaming session streams are compatible with the NICE DCV web client, included in the Nimble Studio portal, or the NICE DCV desktop client.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingSessionStream {
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that created the streaming session stream.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource expires.</p>
    pub expires_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
    pub owned_by: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::StreamingSessionStreamState>,
    /// <p>The streaming session stream status code.</p>
    pub status_code: std::option::Option<crate::model::StreamingSessionStreamStatusCode>,
    /// <p>The stream ID.</p>
    pub stream_id: std::option::Option<std::string::String>,
    /// <p>The URL to connect to this stream using the DCV client.</p>
    pub url: std::option::Option<std::string::String>,
}
impl StreamingSessionStream {
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The user ID of the user that created the streaming session stream.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource expires.</p>
    pub fn expires_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.expires_at.as_ref()
    }
    /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
    pub fn owned_by(&self) -> std::option::Option<&str> {
        self.owned_by.as_deref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StreamingSessionStreamState> {
        self.state.as_ref()
    }
    /// <p>The streaming session stream status code.</p>
    pub fn status_code(
        &self,
    ) -> std::option::Option<&crate::model::StreamingSessionStreamStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The stream ID.</p>
    pub fn stream_id(&self) -> std::option::Option<&str> {
        self.stream_id.as_deref()
    }
    /// <p>The URL to connect to this stream using the DCV client.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
}
impl std::fmt::Debug for StreamingSessionStream {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingSessionStream");
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("expires_at", &self.expires_at);
        formatter.field("owned_by", &self.owned_by);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("stream_id", &self.stream_id);
        formatter.field("url", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`StreamingSessionStream`](crate::model::StreamingSessionStream)
pub mod streaming_session_stream {

    /// A builder for [`StreamingSessionStream`](crate::model::StreamingSessionStream)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) expires_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) owned_by: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StreamingSessionStreamState>,
        pub(crate) status_code: std::option::Option<crate::model::StreamingSessionStreamStatusCode>,
        pub(crate) stream_id: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the streaming session stream.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that created the streaming session stream.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource expires.</p>
        pub fn expires_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.expires_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource expires.</p>
        pub fn set_expires_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.expires_at = input;
            self
        }
        /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
        pub fn owned_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.owned_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.</p>
        pub fn set_owned_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owned_by = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StreamingSessionStreamState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStreamState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The streaming session stream status code.</p>
        pub fn status_code(
            mut self,
            input: crate::model::StreamingSessionStreamStatusCode,
        ) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The streaming session stream status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStreamStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The stream ID.</p>
        pub fn stream_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.stream_id = Some(input.into());
            self
        }
        /// <p>The stream ID.</p>
        pub fn set_stream_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.stream_id = input;
            self
        }
        /// <p>The URL to connect to this stream using the DCV client.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The URL to connect to this stream using the DCV client.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingSessionStream`](crate::model::StreamingSessionStream)
        pub fn build(self) -> crate::model::StreamingSessionStream {
            crate::model::StreamingSessionStream {
                created_at: self.created_at,
                created_by: self.created_by,
                expires_at: self.expires_at,
                owned_by: self.owned_by,
                state: self.state,
                status_code: self.status_code,
                stream_id: self.stream_id,
                url: self.url,
            }
        }
    }
}
impl StreamingSessionStream {
    /// Creates a new builder-style object to manufacture [`StreamingSessionStream`](crate::model::StreamingSessionStream)
    pub fn builder() -> crate::model::streaming_session_stream::Builder {
        crate::model::streaming_session_stream::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStreamStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    NetworkConnectionError,
    #[allow(missing_docs)] // documentation missing in model
    StreamCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StreamDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamReady,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingSessionStreamStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "INTERNAL_ERROR" => StreamingSessionStreamStatusCode::InternalError,
            "NETWORK_CONNECTION_ERROR" => StreamingSessionStreamStatusCode::NetworkConnectionError,
            "STREAM_CREATE_IN_PROGRESS" => StreamingSessionStreamStatusCode::StreamCreateInProgress,
            "STREAM_DELETED" => StreamingSessionStreamStatusCode::StreamDeleted,
            "STREAM_DELETE_IN_PROGRESS" => StreamingSessionStreamStatusCode::StreamDeleteInProgress,
            "STREAM_READY" => StreamingSessionStreamStatusCode::StreamReady,
            other => StreamingSessionStreamStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingSessionStreamStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStreamStatusCode::from(s))
    }
}
impl StreamingSessionStreamStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStreamStatusCode::InternalError => "INTERNAL_ERROR",
            StreamingSessionStreamStatusCode::NetworkConnectionError => "NETWORK_CONNECTION_ERROR",
            StreamingSessionStreamStatusCode::StreamCreateInProgress => "STREAM_CREATE_IN_PROGRESS",
            StreamingSessionStreamStatusCode::StreamDeleted => "STREAM_DELETED",
            StreamingSessionStreamStatusCode::StreamDeleteInProgress => "STREAM_DELETE_IN_PROGRESS",
            StreamingSessionStreamStatusCode::StreamReady => "STREAM_READY",
            StreamingSessionStreamStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "INTERNAL_ERROR",
            "NETWORK_CONNECTION_ERROR",
            "STREAM_CREATE_IN_PROGRESS",
            "STREAM_DELETED",
            "STREAM_DELETE_IN_PROGRESS",
            "STREAM_READY",
        ]
    }
}
impl AsRef<str> for StreamingSessionStreamStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStreamState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingSessionStreamState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StreamingSessionStreamState::CreateFailed,
            "CREATE_IN_PROGRESS" => StreamingSessionStreamState::CreateInProgress,
            "DELETED" => StreamingSessionStreamState::Deleted,
            "DELETE_FAILED" => StreamingSessionStreamState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StreamingSessionStreamState::DeleteInProgress,
            "READY" => StreamingSessionStreamState::Ready,
            other => StreamingSessionStreamState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingSessionStreamState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStreamState::from(s))
    }
}
impl StreamingSessionStreamState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStreamState::CreateFailed => "CREATE_FAILED",
            StreamingSessionStreamState::CreateInProgress => "CREATE_IN_PROGRESS",
            StreamingSessionStreamState::Deleted => "DELETED",
            StreamingSessionStreamState::DeleteFailed => "DELETE_FAILED",
            StreamingSessionStreamState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StreamingSessionStreamState::Ready => "READY",
            StreamingSessionStreamState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
        ]
    }
}
impl AsRef<str> for StreamingSessionStreamState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingInstanceType {
    #[allow(missing_docs)] // documentation missing in model
    G4dn12xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dn16xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dn2xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dn4xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dn8xlarge,
    #[allow(missing_docs)] // documentation missing in model
    G4dnXlarge,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingInstanceType {
    fn from(s: &str) -> Self {
        match s {
            "g4dn.12xlarge" => StreamingInstanceType::G4dn12xlarge,
            "g4dn.16xlarge" => StreamingInstanceType::G4dn16xlarge,
            "g4dn.2xlarge" => StreamingInstanceType::G4dn2xlarge,
            "g4dn.4xlarge" => StreamingInstanceType::G4dn4xlarge,
            "g4dn.8xlarge" => StreamingInstanceType::G4dn8xlarge,
            "g4dn.xlarge" => StreamingInstanceType::G4dnXlarge,
            other => StreamingInstanceType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingInstanceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingInstanceType::from(s))
    }
}
impl StreamingInstanceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingInstanceType::G4dn12xlarge => "g4dn.12xlarge",
            StreamingInstanceType::G4dn16xlarge => "g4dn.16xlarge",
            StreamingInstanceType::G4dn2xlarge => "g4dn.2xlarge",
            StreamingInstanceType::G4dn4xlarge => "g4dn.4xlarge",
            StreamingInstanceType::G4dn8xlarge => "g4dn.8xlarge",
            StreamingInstanceType::G4dnXlarge => "g4dn.xlarge",
            StreamingInstanceType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "g4dn.12xlarge",
            "g4dn.16xlarge",
            "g4dn.2xlarge",
            "g4dn.4xlarge",
            "g4dn.8xlarge",
            "g4dn.xlarge",
        ]
    }
}
impl AsRef<str> for StreamingInstanceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Represents a streaming image resource.</p>
/// <p>Streaming images are used by studio users to select which operating system and software they want to use in a Nimble Studio streaming session.</p>
/// <p>Amazon provides a number of streaming images that include popular 3rd-party software.</p>
/// <p>You can create your own streaming images using an Amazon Elastic Compute Cloud (Amazon EC2) machine image that you create for this purpose. You can also include software that your users require.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingImage {
    /// <p>The ARN of the resource.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>A human-readable description of the streaming image.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
    pub ec2_image_id: std::option::Option<std::string::String>,
    /// <p>The encryption configuration.</p>
    pub encryption_configuration:
        std::option::Option<crate::model::StreamingImageEncryptionConfiguration>,
    /// <p>The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.</p>
    pub eula_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A friendly name for a streaming image resource.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.</p>
    pub owner: std::option::Option<std::string::String>,
    /// <p>The platform of the streaming image, either WINDOWS or LINUX.</p>
    pub platform: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::StreamingImageState>,
    /// <p>The status code.</p>
    pub status_code: std::option::Option<crate::model::StreamingImageStatusCode>,
    /// <p>The status message for the streaming image.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>The ID of the streaming image.</p>
    pub streaming_image_id: std::option::Option<std::string::String>,
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl StreamingImage {
    /// <p>The ARN of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>A human-readable description of the streaming image.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
    pub fn ec2_image_id(&self) -> std::option::Option<&str> {
        self.ec2_image_id.as_deref()
    }
    /// <p>The encryption configuration.</p>
    pub fn encryption_configuration(
        &self,
    ) -> std::option::Option<&crate::model::StreamingImageEncryptionConfiguration> {
        self.encryption_configuration.as_ref()
    }
    /// <p>The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.</p>
    pub fn eula_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.eula_ids.as_deref()
    }
    /// <p>A friendly name for a streaming image resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The platform of the streaming image, either WINDOWS or LINUX.</p>
    pub fn platform(&self) -> std::option::Option<&str> {
        self.platform.as_deref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::StreamingImageState> {
        self.state.as_ref()
    }
    /// <p>The status code.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::StreamingImageStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the streaming image.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>The ID of the streaming image.</p>
    pub fn streaming_image_id(&self) -> std::option::Option<&str> {
        self.streaming_image_id.as_deref()
    }
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
}
impl std::fmt::Debug for StreamingImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingImage");
        formatter.field("arn", &self.arn);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("ec2_image_id", &self.ec2_image_id);
        formatter.field("encryption_configuration", &self.encryption_configuration);
        formatter.field("eula_ids", &self.eula_ids);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("owner", &self.owner);
        formatter.field("platform", &self.platform);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("streaming_image_id", &self.streaming_image_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}
/// See [`StreamingImage`](crate::model::StreamingImage)
pub mod streaming_image {

    /// A builder for [`StreamingImage`](crate::model::StreamingImage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ec2_image_id: std::option::Option<std::string::String>,
        pub(crate) encryption_configuration:
            std::option::Option<crate::model::StreamingImageEncryptionConfiguration>,
        pub(crate) eula_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::StreamingImageState>,
        pub(crate) status_code: std::option::Option<crate::model::StreamingImageStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) streaming_image_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>A human-readable description of the streaming image.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A human-readable description of the streaming image.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
        pub fn ec2_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.ec2_image_id = Some(input.into());
            self
        }
        /// <p>The ID of an EC2 machine image with which to create the streaming image.</p>
        pub fn set_ec2_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ec2_image_id = input;
            self
        }
        /// <p>The encryption configuration.</p>
        pub fn encryption_configuration(
            mut self,
            input: crate::model::StreamingImageEncryptionConfiguration,
        ) -> Self {
            self.encryption_configuration = Some(input);
            self
        }
        /// <p>The encryption configuration.</p>
        pub fn set_encryption_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamingImageEncryptionConfiguration>,
        ) -> Self {
            self.encryption_configuration = input;
            self
        }
        /// Appends an item to `eula_ids`.
        ///
        /// To override the contents of this collection use [`set_eula_ids`](Self::set_eula_ids).
        ///
        /// <p>The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.</p>
        pub fn eula_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.eula_ids.unwrap_or_default();
            v.push(input.into());
            self.eula_ids = Some(v);
            self
        }
        /// <p>The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.</p>
        pub fn set_eula_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.eula_ids = input;
            self
        }
        /// <p>A friendly name for a streaming image resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A friendly name for a streaming image resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The owner of the streaming image, either the studioId that contains the streaming image, or 'amazon' for images that are provided by Amazon Nimble Studio.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The platform of the streaming image, either WINDOWS or LINUX.</p>
        pub fn platform(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform = Some(input.into());
            self
        }
        /// <p>The platform of the streaming image, either WINDOWS or LINUX.</p>
        pub fn set_platform(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.platform = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::StreamingImageState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::StreamingImageState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::StreamingImageStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::StreamingImageStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the streaming image.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the streaming image.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn streaming_image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.streaming_image_id = Some(input.into());
            self
        }
        /// <p>The ID of the streaming image.</p>
        pub fn set_streaming_image_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.streaming_image_id = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingImage`](crate::model::StreamingImage)
        pub fn build(self) -> crate::model::StreamingImage {
            crate::model::StreamingImage {
                arn: self.arn,
                description: self.description,
                ec2_image_id: self.ec2_image_id,
                encryption_configuration: self.encryption_configuration,
                eula_ids: self.eula_ids,
                name: self.name,
                owner: self.owner,
                platform: self.platform,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                streaming_image_id: self.streaming_image_id,
                tags: self.tags,
            }
        }
    }
}
impl StreamingImage {
    /// Creates a new builder-style object to manufacture [`StreamingImage`](crate::model::StreamingImage)
    pub fn builder() -> crate::model::streaming_image::Builder {
        crate::model::streaming_image::Builder::default()
    }
}

/// <p>The status code.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingImageStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageReady,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageUpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingImageStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED" => StreamingImageStatusCode::AccessDenied,
            "INTERNAL_ERROR" => StreamingImageStatusCode::InternalError,
            "STREAMING_IMAGE_CREATE_IN_PROGRESS" => {
                StreamingImageStatusCode::StreamingImageCreateInProgress
            }
            "STREAMING_IMAGE_DELETED" => StreamingImageStatusCode::StreamingImageDeleted,
            "STREAMING_IMAGE_DELETE_IN_PROGRESS" => {
                StreamingImageStatusCode::StreamingImageDeleteInProgress
            }
            "STREAMING_IMAGE_READY" => StreamingImageStatusCode::StreamingImageReady,
            "STREAMING_IMAGE_UPDATE_IN_PROGRESS" => {
                StreamingImageStatusCode::StreamingImageUpdateInProgress
            }
            other => StreamingImageStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingImageStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingImageStatusCode::from(s))
    }
}
impl StreamingImageStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingImageStatusCode::AccessDenied => "ACCESS_DENIED",
            StreamingImageStatusCode::InternalError => "INTERNAL_ERROR",
            StreamingImageStatusCode::StreamingImageCreateInProgress => {
                "STREAMING_IMAGE_CREATE_IN_PROGRESS"
            }
            StreamingImageStatusCode::StreamingImageDeleted => "STREAMING_IMAGE_DELETED",
            StreamingImageStatusCode::StreamingImageDeleteInProgress => {
                "STREAMING_IMAGE_DELETE_IN_PROGRESS"
            }
            StreamingImageStatusCode::StreamingImageReady => "STREAMING_IMAGE_READY",
            StreamingImageStatusCode::StreamingImageUpdateInProgress => {
                "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
            }
            StreamingImageStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED",
            "INTERNAL_ERROR",
            "STREAMING_IMAGE_CREATE_IN_PROGRESS",
            "STREAMING_IMAGE_DELETED",
            "STREAMING_IMAGE_DELETE_IN_PROGRESS",
            "STREAMING_IMAGE_READY",
            "STREAMING_IMAGE_UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StreamingImageStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingImageState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingImageState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => StreamingImageState::CreateFailed,
            "CREATE_IN_PROGRESS" => StreamingImageState::CreateInProgress,
            "DELETED" => StreamingImageState::Deleted,
            "DELETE_FAILED" => StreamingImageState::DeleteFailed,
            "DELETE_IN_PROGRESS" => StreamingImageState::DeleteInProgress,
            "READY" => StreamingImageState::Ready,
            "UPDATE_FAILED" => StreamingImageState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => StreamingImageState::UpdateInProgress,
            other => StreamingImageState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingImageState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingImageState::from(s))
    }
}
impl StreamingImageState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingImageState::CreateFailed => "CREATE_FAILED",
            StreamingImageState::CreateInProgress => "CREATE_IN_PROGRESS",
            StreamingImageState::Deleted => "DELETED",
            StreamingImageState::DeleteFailed => "DELETE_FAILED",
            StreamingImageState::DeleteInProgress => "DELETE_IN_PROGRESS",
            StreamingImageState::Ready => "READY",
            StreamingImageState::UpdateFailed => "UPDATE_FAILED",
            StreamingImageState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            StreamingImageState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for StreamingImageState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Specifies how a streaming image is encrypted.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingImageEncryptionConfiguration {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    pub key_arn: std::option::Option<std::string::String>,
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    pub key_type: std::option::Option<crate::model::StreamingImageEncryptionConfigurationKeyType>,
}
impl StreamingImageEncryptionConfiguration {
    /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
    pub fn key_arn(&self) -> std::option::Option<&str> {
        self.key_arn.as_deref()
    }
    /// <p>The type of KMS key that is used to encrypt studio data.</p>
    pub fn key_type(
        &self,
    ) -> std::option::Option<&crate::model::StreamingImageEncryptionConfigurationKeyType> {
        self.key_type.as_ref()
    }
}
impl std::fmt::Debug for StreamingImageEncryptionConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingImageEncryptionConfiguration");
        formatter.field("key_arn", &self.key_arn);
        formatter.field("key_type", &self.key_type);
        formatter.finish()
    }
}
/// See [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration)
pub mod streaming_image_encryption_configuration {

    /// A builder for [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key_arn: std::option::Option<std::string::String>,
        pub(crate) key_type:
            std::option::Option<crate::model::StreamingImageEncryptionConfigurationKeyType>,
    }
    impl Builder {
        /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        pub fn key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.key_arn = Some(input.into());
            self
        }
        /// <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        pub fn set_key_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key_arn = input;
            self
        }
        /// <p>The type of KMS key that is used to encrypt studio data.</p>
        pub fn key_type(
            mut self,
            input: crate::model::StreamingImageEncryptionConfigurationKeyType,
        ) -> Self {
            self.key_type = Some(input);
            self
        }
        /// <p>The type of KMS key that is used to encrypt studio data.</p>
        pub fn set_key_type(
            mut self,
            input: std::option::Option<crate::model::StreamingImageEncryptionConfigurationKeyType>,
        ) -> Self {
            self.key_type = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration)
        pub fn build(self) -> crate::model::StreamingImageEncryptionConfiguration {
            crate::model::StreamingImageEncryptionConfiguration {
                key_arn: self.key_arn,
                key_type: self.key_type,
            }
        }
    }
}
impl StreamingImageEncryptionConfiguration {
    /// Creates a new builder-style object to manufacture [`StreamingImageEncryptionConfiguration`](crate::model::StreamingImageEncryptionConfiguration)
    pub fn builder() -> crate::model::streaming_image_encryption_configuration::Builder {
        crate::model::streaming_image_encryption_configuration::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingImageEncryptionConfigurationKeyType {
    #[allow(missing_docs)] // documentation missing in model
    CustomerManagedKey,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingImageEncryptionConfigurationKeyType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOMER_MANAGED_KEY" => {
                StreamingImageEncryptionConfigurationKeyType::CustomerManagedKey
            }
            other => StreamingImageEncryptionConfigurationKeyType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingImageEncryptionConfigurationKeyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingImageEncryptionConfigurationKeyType::from(s))
    }
}
impl StreamingImageEncryptionConfigurationKeyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingImageEncryptionConfigurationKeyType::CustomerManagedKey => {
                "CUSTOMER_MANAGED_KEY"
            }
            StreamingImageEncryptionConfigurationKeyType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["CUSTOMER_MANAGED_KEY"]
    }
}
impl AsRef<str> for StreamingImageEncryptionConfigurationKeyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Launch profile membership enables your studio admins to delegate launch profile access to other studio users in the Nimble Studio portal without needing to write or maintain complex IAM policies. A launch profile member is a user association from your studio identity source who is granted permissions to a launch profile.</p>
/// <p>A launch profile member (type USER) provides the following permissions to that launch profile:</p>
/// <ul>
/// <li> <p>GetLaunchProfile</p> </li>
/// <li> <p>GetLaunchProfileInitialization</p> </li>
/// <li> <p>GetLaunchProfileMembers</p> </li>
/// <li> <p>GetLaunchProfileMember</p> </li>
/// <li> <p>CreateStreamingSession</p> </li>
/// <li> <p>GetLaunchProfileDetails</p> </li>
/// </ul>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileMembership {
    /// <p>The ID of the identity store.</p>
    pub identity_store_id: std::option::Option<std::string::String>,
    /// <p>The persona.</p>
    pub persona: std::option::Option<crate::model::LaunchProfilePersona>,
    /// <p>The principal ID.</p>
    pub principal_id: std::option::Option<std::string::String>,
    /// <p>The Active Directory Security Identifier for this user, if available.</p>
    pub sid: std::option::Option<std::string::String>,
}
impl LaunchProfileMembership {
    /// <p>The ID of the identity store.</p>
    pub fn identity_store_id(&self) -> std::option::Option<&str> {
        self.identity_store_id.as_deref()
    }
    /// <p>The persona.</p>
    pub fn persona(&self) -> std::option::Option<&crate::model::LaunchProfilePersona> {
        self.persona.as_ref()
    }
    /// <p>The principal ID.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
    /// <p>The Active Directory Security Identifier for this user, if available.</p>
    pub fn sid(&self) -> std::option::Option<&str> {
        self.sid.as_deref()
    }
}
impl std::fmt::Debug for LaunchProfileMembership {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileMembership");
        formatter.field("identity_store_id", &self.identity_store_id);
        formatter.field("persona", &self.persona);
        formatter.field("principal_id", &self.principal_id);
        formatter.field("sid", &self.sid);
        formatter.finish()
    }
}
/// See [`LaunchProfileMembership`](crate::model::LaunchProfileMembership)
pub mod launch_profile_membership {

    /// A builder for [`LaunchProfileMembership`](crate::model::LaunchProfileMembership)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identity_store_id: std::option::Option<std::string::String>,
        pub(crate) persona: std::option::Option<crate::model::LaunchProfilePersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
        pub(crate) sid: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the identity store.</p>
        pub fn identity_store_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.identity_store_id = Some(input.into());
            self
        }
        /// <p>The ID of the identity store.</p>
        pub fn set_identity_store_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.identity_store_id = input;
            self
        }
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::LaunchProfilePersona) -> Self {
            self.persona = Some(input);
            self
        }
        /// <p>The persona.</p>
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// <p>The Active Directory Security Identifier for this user, if available.</p>
        pub fn sid(mut self, input: impl Into<std::string::String>) -> Self {
            self.sid = Some(input.into());
            self
        }
        /// <p>The Active Directory Security Identifier for this user, if available.</p>
        pub fn set_sid(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sid = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileMembership`](crate::model::LaunchProfileMembership)
        pub fn build(self) -> crate::model::LaunchProfileMembership {
            crate::model::LaunchProfileMembership {
                identity_store_id: self.identity_store_id,
                persona: self.persona,
                principal_id: self.principal_id,
                sid: self.sid,
            }
        }
    }
}
impl LaunchProfileMembership {
    /// Creates a new builder-style object to manufacture [`LaunchProfileMembership`](crate::model::LaunchProfileMembership)
    pub fn builder() -> crate::model::launch_profile_membership::Builder {
        crate::model::launch_profile_membership::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfilePersona {
    #[allow(missing_docs)] // documentation missing in model
    User,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfilePersona {
    fn from(s: &str) -> Self {
        match s {
            "USER" => LaunchProfilePersona::User,
            other => LaunchProfilePersona::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchProfilePersona {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfilePersona::from(s))
    }
}
impl LaunchProfilePersona {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfilePersona::User => "USER",
            LaunchProfilePersona::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["USER"]
    }
}
impl AsRef<str> for LaunchProfilePersona {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A new member that is added to a launch profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NewLaunchProfileMember {
    /// <p>The persona.</p>
    pub persona: std::option::Option<crate::model::LaunchProfilePersona>,
    /// <p>The principal ID.</p>
    pub principal_id: std::option::Option<std::string::String>,
}
impl NewLaunchProfileMember {
    /// <p>The persona.</p>
    pub fn persona(&self) -> std::option::Option<&crate::model::LaunchProfilePersona> {
        self.persona.as_ref()
    }
    /// <p>The principal ID.</p>
    pub fn principal_id(&self) -> std::option::Option<&str> {
        self.principal_id.as_deref()
    }
}
impl std::fmt::Debug for NewLaunchProfileMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NewLaunchProfileMember");
        formatter.field("persona", &self.persona);
        formatter.field("principal_id", &self.principal_id);
        formatter.finish()
    }
}
/// See [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember)
pub mod new_launch_profile_member {

    /// A builder for [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) persona: std::option::Option<crate::model::LaunchProfilePersona>,
        pub(crate) principal_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The persona.</p>
        pub fn persona(mut self, input: crate::model::LaunchProfilePersona) -> Self {
            self.persona = Some(input);
            self
        }
        /// <p>The persona.</p>
        pub fn set_persona(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePersona>,
        ) -> Self {
            self.persona = input;
            self
        }
        /// <p>The principal ID.</p>
        pub fn principal_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.principal_id = Some(input.into());
            self
        }
        /// <p>The principal ID.</p>
        pub fn set_principal_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.principal_id = input;
            self
        }
        /// Consumes the builder and constructs a [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember)
        pub fn build(self) -> crate::model::NewLaunchProfileMember {
            crate::model::NewLaunchProfileMember {
                persona: self.persona,
                principal_id: self.principal_id,
            }
        }
    }
}
impl NewLaunchProfileMember {
    /// Creates a new builder-style object to manufacture [`NewLaunchProfileMember`](crate::model::NewLaunchProfileMember)
    pub fn builder() -> crate::model::new_launch_profile_member::Builder {
        crate::model::new_launch_profile_member::Builder::default()
    }
}

/// <p>A Launch Profile Initialization contains information required for a workstation or server to connect to a launch profile.</p>
/// <p>This includes scripts, endpoints, security groups, subnets, and other configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileInitialization {
    /// <p>A LaunchProfileInitializationActiveDirectory resource.</p>
    pub active_directory:
        std::option::Option<crate::model::LaunchProfileInitializationActiveDirectory>,
    /// <p>The EC2 security groups that control access to the studio component.</p>
    pub ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The launch profile ID.</p>
    pub launch_profile_id: std::option::Option<std::string::String>,
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub launch_profile_protocol_version: std::option::Option<std::string::String>,
    /// <p>The launch purpose.</p>
    pub launch_purpose: std::option::Option<std::string::String>,
    /// <p>The name for the launch profile.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The platform of the launch platform, either WINDOWS or LINUX.</p>
    pub platform: std::option::Option<crate::model::LaunchProfilePlatform>,
    /// <p>The system initializtion scripts.</p>
    pub system_initialization_scripts:
        std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
    /// <p>The user initializtion scripts.</p>
    pub user_initialization_scripts:
        std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
}
impl LaunchProfileInitialization {
    /// <p>A LaunchProfileInitializationActiveDirectory resource.</p>
    pub fn active_directory(
        &self,
    ) -> std::option::Option<&crate::model::LaunchProfileInitializationActiveDirectory> {
        self.active_directory.as_ref()
    }
    /// <p>The EC2 security groups that control access to the studio component.</p>
    pub fn ec2_security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.ec2_security_group_ids.as_deref()
    }
    /// <p>The launch profile ID.</p>
    pub fn launch_profile_id(&self) -> std::option::Option<&str> {
        self.launch_profile_id.as_deref()
    }
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub fn launch_profile_protocol_version(&self) -> std::option::Option<&str> {
        self.launch_profile_protocol_version.as_deref()
    }
    /// <p>The launch purpose.</p>
    pub fn launch_purpose(&self) -> std::option::Option<&str> {
        self.launch_purpose.as_deref()
    }
    /// <p>The name for the launch profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The platform of the launch platform, either WINDOWS or LINUX.</p>
    pub fn platform(&self) -> std::option::Option<&crate::model::LaunchProfilePlatform> {
        self.platform.as_ref()
    }
    /// <p>The system initializtion scripts.</p>
    pub fn system_initialization_scripts(
        &self,
    ) -> std::option::Option<&[crate::model::LaunchProfileInitializationScript]> {
        self.system_initialization_scripts.as_deref()
    }
    /// <p>The user initializtion scripts.</p>
    pub fn user_initialization_scripts(
        &self,
    ) -> std::option::Option<&[crate::model::LaunchProfileInitializationScript]> {
        self.user_initialization_scripts.as_deref()
    }
}
impl std::fmt::Debug for LaunchProfileInitialization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileInitialization");
        formatter.field("active_directory", &self.active_directory);
        formatter.field("ec2_security_group_ids", &self.ec2_security_group_ids);
        formatter.field("launch_profile_id", &self.launch_profile_id);
        formatter.field(
            "launch_profile_protocol_version",
            &self.launch_profile_protocol_version,
        );
        formatter.field("launch_purpose", &self.launch_purpose);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("platform", &self.platform);
        formatter.field(
            "system_initialization_scripts",
            &self.system_initialization_scripts,
        );
        formatter.field(
            "user_initialization_scripts",
            &self.user_initialization_scripts,
        );
        formatter.finish()
    }
}
/// See [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization)
pub mod launch_profile_initialization {

    /// A builder for [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) active_directory:
            std::option::Option<crate::model::LaunchProfileInitializationActiveDirectory>,
        pub(crate) ec2_security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) launch_profile_id: std::option::Option<std::string::String>,
        pub(crate) launch_profile_protocol_version: std::option::Option<std::string::String>,
        pub(crate) launch_purpose: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) platform: std::option::Option<crate::model::LaunchProfilePlatform>,
        pub(crate) system_initialization_scripts:
            std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
        pub(crate) user_initialization_scripts:
            std::option::Option<std::vec::Vec<crate::model::LaunchProfileInitializationScript>>,
    }
    impl Builder {
        /// <p>A LaunchProfileInitializationActiveDirectory resource.</p>
        pub fn active_directory(
            mut self,
            input: crate::model::LaunchProfileInitializationActiveDirectory,
        ) -> Self {
            self.active_directory = Some(input);
            self
        }
        /// <p>A LaunchProfileInitializationActiveDirectory resource.</p>
        pub fn set_active_directory(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileInitializationActiveDirectory>,
        ) -> Self {
            self.active_directory = input;
            self
        }
        /// Appends an item to `ec2_security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_ec2_security_group_ids`](Self::set_ec2_security_group_ids).
        ///
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn ec2_security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ec2_security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.ec2_security_group_ids = Some(v);
            self
        }
        /// <p>The EC2 security groups that control access to the studio component.</p>
        pub fn set_ec2_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ec2_security_group_ids = input;
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_profile_id = Some(input.into());
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_id = input;
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_version(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = Some(input.into());
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn set_launch_profile_protocol_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_protocol_version = input;
            self
        }
        /// <p>The launch purpose.</p>
        pub fn launch_purpose(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_purpose = Some(input.into());
            self
        }
        /// <p>The launch purpose.</p>
        pub fn set_launch_purpose(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_purpose = input;
            self
        }
        /// <p>The name for the launch profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the launch profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The platform of the launch platform, either WINDOWS or LINUX.</p>
        pub fn platform(mut self, input: crate::model::LaunchProfilePlatform) -> Self {
            self.platform = Some(input);
            self
        }
        /// <p>The platform of the launch platform, either WINDOWS or LINUX.</p>
        pub fn set_platform(
            mut self,
            input: std::option::Option<crate::model::LaunchProfilePlatform>,
        ) -> Self {
            self.platform = input;
            self
        }
        /// Appends an item to `system_initialization_scripts`.
        ///
        /// To override the contents of this collection use [`set_system_initialization_scripts`](Self::set_system_initialization_scripts).
        ///
        /// <p>The system initializtion scripts.</p>
        pub fn system_initialization_scripts(
            mut self,
            input: crate::model::LaunchProfileInitializationScript,
        ) -> Self {
            let mut v = self.system_initialization_scripts.unwrap_or_default();
            v.push(input);
            self.system_initialization_scripts = Some(v);
            self
        }
        /// <p>The system initializtion scripts.</p>
        pub fn set_system_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchProfileInitializationScript>,
            >,
        ) -> Self {
            self.system_initialization_scripts = input;
            self
        }
        /// Appends an item to `user_initialization_scripts`.
        ///
        /// To override the contents of this collection use [`set_user_initialization_scripts`](Self::set_user_initialization_scripts).
        ///
        /// <p>The user initializtion scripts.</p>
        pub fn user_initialization_scripts(
            mut self,
            input: crate::model::LaunchProfileInitializationScript,
        ) -> Self {
            let mut v = self.user_initialization_scripts.unwrap_or_default();
            v.push(input);
            self.user_initialization_scripts = Some(v);
            self
        }
        /// <p>The user initializtion scripts.</p>
        pub fn set_user_initialization_scripts(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::LaunchProfileInitializationScript>,
            >,
        ) -> Self {
            self.user_initialization_scripts = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization)
        pub fn build(self) -> crate::model::LaunchProfileInitialization {
            crate::model::LaunchProfileInitialization {
                active_directory: self.active_directory,
                ec2_security_group_ids: self.ec2_security_group_ids,
                launch_profile_id: self.launch_profile_id,
                launch_profile_protocol_version: self.launch_profile_protocol_version,
                launch_purpose: self.launch_purpose,
                name: self.name,
                platform: self.platform,
                system_initialization_scripts: self.system_initialization_scripts,
                user_initialization_scripts: self.user_initialization_scripts,
            }
        }
    }
}
impl LaunchProfileInitialization {
    /// Creates a new builder-style object to manufacture [`LaunchProfileInitialization`](crate::model::LaunchProfileInitialization)
    pub fn builder() -> crate::model::launch_profile_initialization::Builder {
        crate::model::launch_profile_initialization::Builder::default()
    }
}

/// <p>The Launch Profile Initialization Script is used when start streaming session runs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileInitializationScript {
    /// <p>The initialization script.</p>
    pub script: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The name for the studio component.</p>
    pub studio_component_name: std::option::Option<std::string::String>,
}
impl LaunchProfileInitializationScript {
    /// <p>The initialization script.</p>
    pub fn script(&self) -> std::option::Option<&str> {
        self.script.as_deref()
    }
    /// <p>The unique identifier for a studio component resource.</p>
    pub fn studio_component_id(&self) -> std::option::Option<&str> {
        self.studio_component_id.as_deref()
    }
    /// <p>The name for the studio component.</p>
    pub fn studio_component_name(&self) -> std::option::Option<&str> {
        self.studio_component_name.as_deref()
    }
}
impl std::fmt::Debug for LaunchProfileInitializationScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileInitializationScript");
        formatter.field("script", &"*** Sensitive Data Redacted ***");
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("studio_component_name", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript)
pub mod launch_profile_initialization_script {

    /// A builder for [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) script: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) studio_component_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The initialization script.</p>
        pub fn script(mut self, input: impl Into<std::string::String>) -> Self {
            self.script = Some(input.into());
            self
        }
        /// <p>The initialization script.</p>
        pub fn set_script(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.script = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn studio_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_name = Some(input.into());
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn set_studio_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_name = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript)
        pub fn build(self) -> crate::model::LaunchProfileInitializationScript {
            crate::model::LaunchProfileInitializationScript {
                script: self.script,
                studio_component_id: self.studio_component_id,
                studio_component_name: self.studio_component_name,
            }
        }
    }
}
impl LaunchProfileInitializationScript {
    /// Creates a new builder-style object to manufacture [`LaunchProfileInitializationScript`](crate::model::LaunchProfileInitializationScript)
    pub fn builder() -> crate::model::launch_profile_initialization_script::Builder {
        crate::model::launch_profile_initialization_script::Builder::default()
    }
}

/// <p>The Launch Profile Initialization Active Directory contains information required for the launch profile to connect to the Active Directory.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfileInitializationActiveDirectory {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    pub computer_attributes:
        std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
    /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.</p>
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The directory name.</p>
    pub directory_name: std::option::Option<std::string::String>,
    /// <p>The DNS IP address.</p>
    pub dns_ip_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The name for the organizational unit distinguished name.</p>
    pub organizational_unit_distinguished_name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The name for the studio component.</p>
    pub studio_component_name: std::option::Option<std::string::String>,
}
impl LaunchProfileInitializationActiveDirectory {
    /// <p>A collection of custom attributes for an Active Directory computer.</p>
    pub fn computer_attributes(
        &self,
    ) -> std::option::Option<&[crate::model::ActiveDirectoryComputerAttribute]> {
        self.computer_attributes.as_deref()
    }
    /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.</p>
    pub fn directory_id(&self) -> std::option::Option<&str> {
        self.directory_id.as_deref()
    }
    /// <p>The directory name.</p>
    pub fn directory_name(&self) -> std::option::Option<&str> {
        self.directory_name.as_deref()
    }
    /// <p>The DNS IP address.</p>
    pub fn dns_ip_addresses(&self) -> std::option::Option<&[std::string::String]> {
        self.dns_ip_addresses.as_deref()
    }
    /// <p>The name for the organizational unit distinguished name.</p>
    pub fn organizational_unit_distinguished_name(&self) -> std::option::Option<&str> {
        self.organizational_unit_distinguished_name.as_deref()
    }
    /// <p>The unique identifier for a studio component resource.</p>
    pub fn studio_component_id(&self) -> std::option::Option<&str> {
        self.studio_component_id.as_deref()
    }
    /// <p>The name for the studio component.</p>
    pub fn studio_component_name(&self) -> std::option::Option<&str> {
        self.studio_component_name.as_deref()
    }
}
impl std::fmt::Debug for LaunchProfileInitializationActiveDirectory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfileInitializationActiveDirectory");
        formatter.field("computer_attributes", &"*** Sensitive Data Redacted ***");
        formatter.field("directory_id", &self.directory_id);
        formatter.field("directory_name", &self.directory_name);
        formatter.field("dns_ip_addresses", &self.dns_ip_addresses);
        formatter.field(
            "organizational_unit_distinguished_name",
            &self.organizational_unit_distinguished_name,
        );
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("studio_component_name", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory)
pub mod launch_profile_initialization_active_directory {

    /// A builder for [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) computer_attributes:
            std::option::Option<std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) directory_name: std::option::Option<std::string::String>,
        pub(crate) dns_ip_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) organizational_unit_distinguished_name: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) studio_component_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `computer_attributes`.
        ///
        /// To override the contents of this collection use [`set_computer_attributes`](Self::set_computer_attributes).
        ///
        /// <p>A collection of custom attributes for an Active Directory computer.</p>
        pub fn computer_attributes(
            mut self,
            input: crate::model::ActiveDirectoryComputerAttribute,
        ) -> Self {
            let mut v = self.computer_attributes.unwrap_or_default();
            v.push(input);
            self.computer_attributes = Some(v);
            self
        }
        /// <p>A collection of custom attributes for an Active Directory computer.</p>
        pub fn set_computer_attributes(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ActiveDirectoryComputerAttribute>,
            >,
        ) -> Self {
            self.computer_attributes = input;
            self
        }
        /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        /// <p>The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.</p>
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>The directory name.</p>
        pub fn directory_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_name = Some(input.into());
            self
        }
        /// <p>The directory name.</p>
        pub fn set_directory_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_name = input;
            self
        }
        /// Appends an item to `dns_ip_addresses`.
        ///
        /// To override the contents of this collection use [`set_dns_ip_addresses`](Self::set_dns_ip_addresses).
        ///
        /// <p>The DNS IP address.</p>
        pub fn dns_ip_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dns_ip_addresses.unwrap_or_default();
            v.push(input.into());
            self.dns_ip_addresses = Some(v);
            self
        }
        /// <p>The DNS IP address.</p>
        pub fn set_dns_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dns_ip_addresses = input;
            self
        }
        /// <p>The name for the organizational unit distinguished name.</p>
        pub fn organizational_unit_distinguished_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = Some(input.into());
            self
        }
        /// <p>The name for the organizational unit distinguished name.</p>
        pub fn set_organizational_unit_distinguished_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.organizational_unit_distinguished_name = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn studio_component_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_name = Some(input.into());
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn set_studio_component_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_name = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory)
        pub fn build(self) -> crate::model::LaunchProfileInitializationActiveDirectory {
            crate::model::LaunchProfileInitializationActiveDirectory {
                computer_attributes: self.computer_attributes,
                directory_id: self.directory_id,
                directory_name: self.directory_name,
                dns_ip_addresses: self.dns_ip_addresses,
                organizational_unit_distinguished_name: self.organizational_unit_distinguished_name,
                studio_component_id: self.studio_component_id,
                studio_component_name: self.studio_component_name,
            }
        }
    }
}
impl LaunchProfileInitializationActiveDirectory {
    /// Creates a new builder-style object to manufacture [`LaunchProfileInitializationActiveDirectory`](crate::model::LaunchProfileInitializationActiveDirectory)
    pub fn builder() -> crate::model::launch_profile_initialization_active_directory::Builder {
        crate::model::launch_profile_initialization_active_directory::Builder::default()
    }
}

/// <p>The studio component's summary.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StudioComponentSummary {
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that created the studio component.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The description.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>The name for the studio component.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique identifier for a studio component resource.</p>
    pub studio_component_id: std::option::Option<std::string::String>,
    /// <p>The specific subtype of a studio component.</p>
    pub subtype: std::option::Option<crate::model::StudioComponentSubtype>,
    /// <p>The type of the studio component.</p>
    pub r#type: std::option::Option<crate::model::StudioComponentType>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub updated_by: std::option::Option<std::string::String>,
}
impl StudioComponentSummary {
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The user ID of the user that created the studio component.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The description.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name for the studio component.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The unique identifier for a studio component resource.</p>
    pub fn studio_component_id(&self) -> std::option::Option<&str> {
        self.studio_component_id.as_deref()
    }
    /// <p>The specific subtype of a studio component.</p>
    pub fn subtype(&self) -> std::option::Option<&crate::model::StudioComponentSubtype> {
        self.subtype.as_ref()
    }
    /// <p>The type of the studio component.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::StudioComponentType> {
        self.r#type.as_ref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub fn updated_by(&self) -> std::option::Option<&str> {
        self.updated_by.as_deref()
    }
}
impl std::fmt::Debug for StudioComponentSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StudioComponentSummary");
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("studio_component_id", &self.studio_component_id);
        formatter.field("subtype", &self.subtype);
        formatter.field("r#type", &self.r#type);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.finish()
    }
}
/// See [`StudioComponentSummary`](crate::model::StudioComponentSummary)
pub mod studio_component_summary {

    /// A builder for [`StudioComponentSummary`](crate::model::StudioComponentSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) studio_component_id: std::option::Option<std::string::String>,
        pub(crate) subtype: std::option::Option<crate::model::StudioComponentSubtype>,
        pub(crate) r#type: std::option::Option<crate::model::StudioComponentType>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the studio component.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that created the studio component.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the studio component.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn studio_component_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.studio_component_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a studio component resource.</p>
        pub fn set_studio_component_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.studio_component_id = input;
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn subtype(mut self, input: crate::model::StudioComponentSubtype) -> Self {
            self.subtype = Some(input);
            self
        }
        /// <p>The specific subtype of a studio component.</p>
        pub fn set_subtype(
            mut self,
            input: std::option::Option<crate::model::StudioComponentSubtype>,
        ) -> Self {
            self.subtype = input;
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn r#type(mut self, input: crate::model::StudioComponentType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the studio component.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StudioComponentType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// Consumes the builder and constructs a [`StudioComponentSummary`](crate::model::StudioComponentSummary)
        pub fn build(self) -> crate::model::StudioComponentSummary {
            crate::model::StudioComponentSummary {
                created_at: self.created_at,
                created_by: self.created_by,
                description: self.description,
                name: self.name,
                studio_component_id: self.studio_component_id,
                subtype: self.subtype,
                r#type: self.r#type,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
            }
        }
    }
}
impl StudioComponentSummary {
    /// Creates a new builder-style object to manufacture [`StudioComponentSummary`](crate::model::StudioComponentSummary)
    pub fn builder() -> crate::model::studio_component_summary::Builder {
        crate::model::studio_component_summary::Builder::default()
    }
}

/// <p>A launch profile controls your artist workforces access to studio components, like compute farms, shared file systems, managed file systems, and license server configurations, as well as instance types and Amazon Machine Images (AMIs). </p>
/// <p>Studio administrators create launch profiles in the Nimble Studio console. Artists can use their launch profiles to launch an instance from the Nimble Studio portal. Each users launch profile defines how they can launch a streaming session. By default, studio admins can use all launch profiles.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct LaunchProfile {
    /// <p>The ARN of the resource.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that created the launch profile.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>A human-readable description of the launch profile.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>Unique identifiers for a collection of EC2 subnets.</p>
    pub ec2_subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The launch profile ID.</p>
    pub launch_profile_id: std::option::Option<std::string::String>,
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub launch_profile_protocol_versions: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A friendly name for the launch profile.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::LaunchProfileState>,
    /// <p>The status code.</p>
    pub status_code: std::option::Option<crate::model::LaunchProfileStatusCode>,
    /// <p>The status message for the launch profile.</p>
    pub status_message: std::option::Option<std::string::String>,
    /// <p>A configuration for a streaming session.</p>
    pub stream_configuration: std::option::Option<crate::model::StreamConfiguration>,
    /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
    pub studio_component_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub updated_by: std::option::Option<std::string::String>,
    /// <p>The list of the latest validation results.</p>
    pub validation_results: std::option::Option<std::vec::Vec<crate::model::ValidationResult>>,
}
impl LaunchProfile {
    /// <p>The ARN of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The user ID of the user that created the launch profile.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>A human-readable description of the launch profile.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Unique identifiers for a collection of EC2 subnets.</p>
    pub fn ec2_subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.ec2_subnet_ids.as_deref()
    }
    /// <p>The launch profile ID.</p>
    pub fn launch_profile_id(&self) -> std::option::Option<&str> {
        self.launch_profile_id.as_deref()
    }
    /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
    pub fn launch_profile_protocol_versions(&self) -> std::option::Option<&[std::string::String]> {
        self.launch_profile_protocol_versions.as_deref()
    }
    /// <p>A friendly name for the launch profile.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::LaunchProfileState> {
        self.state.as_ref()
    }
    /// <p>The status code.</p>
    pub fn status_code(&self) -> std::option::Option<&crate::model::LaunchProfileStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the launch profile.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
    /// <p>A configuration for a streaming session.</p>
    pub fn stream_configuration(&self) -> std::option::Option<&crate::model::StreamConfiguration> {
        self.stream_configuration.as_ref()
    }
    /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
    pub fn studio_component_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.studio_component_ids.as_deref()
    }
    /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The user ID of the user that most recently updated the resource.</p>
    pub fn updated_by(&self) -> std::option::Option<&str> {
        self.updated_by.as_deref()
    }
    /// <p>The list of the latest validation results.</p>
    pub fn validation_results(&self) -> std::option::Option<&[crate::model::ValidationResult]> {
        self.validation_results.as_deref()
    }
}
impl std::fmt::Debug for LaunchProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LaunchProfile");
        formatter.field("arn", &self.arn);
        formatter.field("created_at", &self.created_at);
        formatter.field("created_by", &self.created_by);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("ec2_subnet_ids", &self.ec2_subnet_ids);
        formatter.field("launch_profile_id", &self.launch_profile_id);
        formatter.field(
            "launch_profile_protocol_versions",
            &self.launch_profile_protocol_versions,
        );
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.field("stream_configuration", &self.stream_configuration);
        formatter.field("studio_component_ids", &self.studio_component_ids);
        formatter.field("tags", &self.tags);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("updated_by", &self.updated_by);
        formatter.field("validation_results", &self.validation_results);
        formatter.finish()
    }
}
/// See [`LaunchProfile`](crate::model::LaunchProfile)
pub mod launch_profile {

    /// A builder for [`LaunchProfile`](crate::model::LaunchProfile)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) ec2_subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) launch_profile_id: std::option::Option<std::string::String>,
        pub(crate) launch_profile_protocol_versions:
            std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::LaunchProfileState>,
        pub(crate) status_code: std::option::Option<crate::model::LaunchProfileStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
        pub(crate) stream_configuration: std::option::Option<crate::model::StreamConfiguration>,
        pub(crate) studio_component_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_by: std::option::Option<std::string::String>,
        pub(crate) validation_results:
            std::option::Option<std::vec::Vec<crate::model::ValidationResult>>,
    }
    impl Builder {
        /// <p>The ARN of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The user ID of the user that created the launch profile.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that created the launch profile.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>A human-readable description of the launch profile.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A human-readable description of the launch profile.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `ec2_subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_ec2_subnet_ids`](Self::set_ec2_subnet_ids).
        ///
        /// <p>Unique identifiers for a collection of EC2 subnets.</p>
        pub fn ec2_subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ec2_subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.ec2_subnet_ids = Some(v);
            self
        }
        /// <p>Unique identifiers for a collection of EC2 subnets.</p>
        pub fn set_ec2_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ec2_subnet_ids = input;
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn launch_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.launch_profile_id = Some(input.into());
            self
        }
        /// <p>The launch profile ID.</p>
        pub fn set_launch_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.launch_profile_id = input;
            self
        }
        /// Appends an item to `launch_profile_protocol_versions`.
        ///
        /// To override the contents of this collection use [`set_launch_profile_protocol_versions`](Self::set_launch_profile_protocol_versions).
        ///
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn launch_profile_protocol_versions(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            let mut v = self.launch_profile_protocol_versions.unwrap_or_default();
            v.push(input.into());
            self.launch_profile_protocol_versions = Some(v);
            self
        }
        /// <p>The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".</p>
        pub fn set_launch_profile_protocol_versions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.launch_profile_protocol_versions = input;
            self
        }
        /// <p>A friendly name for the launch profile.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>A friendly name for the launch profile.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::LaunchProfileState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code.</p>
        pub fn status_code(mut self, input: crate::model::LaunchProfileStatusCode) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the launch profile.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the launch profile.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// <p>A configuration for a streaming session.</p>
        pub fn stream_configuration(mut self, input: crate::model::StreamConfiguration) -> Self {
            self.stream_configuration = Some(input);
            self
        }
        /// <p>A configuration for a streaming session.</p>
        pub fn set_stream_configuration(
            mut self,
            input: std::option::Option<crate::model::StreamConfiguration>,
        ) -> Self {
            self.stream_configuration = input;
            self
        }
        /// Appends an item to `studio_component_ids`.
        ///
        /// To override the contents of this collection use [`set_studio_component_ids`](Self::set_studio_component_ids).
        ///
        /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
        pub fn studio_component_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.studio_component_ids.unwrap_or_default();
            v.push(input.into());
            self.studio_component_ids = Some(v);
            self
        }
        /// <p>Unique identifiers for a collection of studio components that can be used with this launch profile.</p>
        pub fn set_studio_component_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.studio_component_ids = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>A collection of labels, in the form of key:value pairs, that apply to this resource.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn updated_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by = Some(input.into());
            self
        }
        /// <p>The user ID of the user that most recently updated the resource.</p>
        pub fn set_updated_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.updated_by = input;
            self
        }
        /// Appends an item to `validation_results`.
        ///
        /// To override the contents of this collection use [`set_validation_results`](Self::set_validation_results).
        ///
        /// <p>The list of the latest validation results.</p>
        pub fn validation_results(mut self, input: crate::model::ValidationResult) -> Self {
            let mut v = self.validation_results.unwrap_or_default();
            v.push(input);
            self.validation_results = Some(v);
            self
        }
        /// <p>The list of the latest validation results.</p>
        pub fn set_validation_results(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ValidationResult>>,
        ) -> Self {
            self.validation_results = input;
            self
        }
        /// Consumes the builder and constructs a [`LaunchProfile`](crate::model::LaunchProfile)
        pub fn build(self) -> crate::model::LaunchProfile {
            crate::model::LaunchProfile {
                arn: self.arn,
                created_at: self.created_at,
                created_by: self.created_by,
                description: self.description,
                ec2_subnet_ids: self.ec2_subnet_ids,
                launch_profile_id: self.launch_profile_id,
                launch_profile_protocol_versions: self.launch_profile_protocol_versions,
                name: self.name,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
                stream_configuration: self.stream_configuration,
                studio_component_ids: self.studio_component_ids,
                tags: self.tags,
                updated_at: self.updated_at,
                updated_by: self.updated_by,
                validation_results: self.validation_results,
            }
        }
    }
}
impl LaunchProfile {
    /// Creates a new builder-style object to manufacture [`LaunchProfile`](crate::model::LaunchProfile)
    pub fn builder() -> crate::model::launch_profile::Builder {
        crate::model::launch_profile::Builder::default()
    }
}

/// <p>The launch profile validation result.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationResult {
    /// <p>The type of the validation result.</p>
    pub r#type: std::option::Option<crate::model::LaunchProfileValidationType>,
    /// <p>The current state.</p>
    pub state: std::option::Option<crate::model::LaunchProfileValidationState>,
    /// <p>The status code. This will contain the failure reason if the state is <code>VALIDATION_FAILED</code>.</p>
    pub status_code: std::option::Option<crate::model::LaunchProfileValidationStatusCode>,
    /// <p>The status message for the validation result.</p>
    pub status_message: std::option::Option<std::string::String>,
}
impl ValidationResult {
    /// <p>The type of the validation result.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::LaunchProfileValidationType> {
        self.r#type.as_ref()
    }
    /// <p>The current state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::LaunchProfileValidationState> {
        self.state.as_ref()
    }
    /// <p>The status code. This will contain the failure reason if the state is <code>VALIDATION_FAILED</code>.</p>
    pub fn status_code(
        &self,
    ) -> std::option::Option<&crate::model::LaunchProfileValidationStatusCode> {
        self.status_code.as_ref()
    }
    /// <p>The status message for the validation result.</p>
    pub fn status_message(&self) -> std::option::Option<&str> {
        self.status_message.as_deref()
    }
}
impl std::fmt::Debug for ValidationResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationResult");
        formatter.field("r#type", &self.r#type);
        formatter.field("state", &self.state);
        formatter.field("status_code", &self.status_code);
        formatter.field("status_message", &self.status_message);
        formatter.finish()
    }
}
/// See [`ValidationResult`](crate::model::ValidationResult)
pub mod validation_result {

    /// A builder for [`ValidationResult`](crate::model::ValidationResult)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::LaunchProfileValidationType>,
        pub(crate) state: std::option::Option<crate::model::LaunchProfileValidationState>,
        pub(crate) status_code:
            std::option::Option<crate::model::LaunchProfileValidationStatusCode>,
        pub(crate) status_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of the validation result.</p>
        pub fn r#type(mut self, input: crate::model::LaunchProfileValidationType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of the validation result.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileValidationType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The current state.</p>
        pub fn state(mut self, input: crate::model::LaunchProfileValidationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileValidationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The status code. This will contain the failure reason if the state is <code>VALIDATION_FAILED</code>.</p>
        pub fn status_code(
            mut self,
            input: crate::model::LaunchProfileValidationStatusCode,
        ) -> Self {
            self.status_code = Some(input);
            self
        }
        /// <p>The status code. This will contain the failure reason if the state is <code>VALIDATION_FAILED</code>.</p>
        pub fn set_status_code(
            mut self,
            input: std::option::Option<crate::model::LaunchProfileValidationStatusCode>,
        ) -> Self {
            self.status_code = input;
            self
        }
        /// <p>The status message for the validation result.</p>
        pub fn status_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.status_message = Some(input.into());
            self
        }
        /// <p>The status message for the validation result.</p>
        pub fn set_status_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.status_message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationResult`](crate::model::ValidationResult)
        pub fn build(self) -> crate::model::ValidationResult {
            crate::model::ValidationResult {
                r#type: self.r#type,
                state: self.state,
                status_code: self.status_code,
                status_message: self.status_message,
            }
        }
    }
}
impl ValidationResult {
    /// Creates a new builder-style object to manufacture [`ValidationResult`](crate::model::ValidationResult)
    pub fn builder() -> crate::model::validation_result::Builder {
        crate::model::validation_result::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileValidationStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedInternalServerError,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedInvalidActiveDirectory,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedInvalidSecurityGroupAssociation,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedInvalidSubnetRouteTableAssociation,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedSubnetNotFound,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedUnauthorized,
    #[allow(missing_docs)] // documentation missing in model
    ValidationInProgress,
    #[allow(missing_docs)] // documentation missing in model
    ValidationNotStarted,
    #[allow(missing_docs)] // documentation missing in model
    ValidationSuccess,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfileValidationStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "VALIDATION_FAILED_INTERNAL_SERVER_ERROR" => LaunchProfileValidationStatusCode::ValidationFailedInternalServerError,
            "VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY" => LaunchProfileValidationStatusCode::ValidationFailedInvalidActiveDirectory,
            "VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION" => LaunchProfileValidationStatusCode::ValidationFailedInvalidSecurityGroupAssociation,
            "VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION" => LaunchProfileValidationStatusCode::ValidationFailedInvalidSubnetRouteTableAssociation,
            "VALIDATION_FAILED_SUBNET_NOT_FOUND" => LaunchProfileValidationStatusCode::ValidationFailedSubnetNotFound,
            "VALIDATION_FAILED_UNAUTHORIZED" => LaunchProfileValidationStatusCode::ValidationFailedUnauthorized,
            "VALIDATION_IN_PROGRESS" => LaunchProfileValidationStatusCode::ValidationInProgress,
            "VALIDATION_NOT_STARTED" => LaunchProfileValidationStatusCode::ValidationNotStarted,
            "VALIDATION_SUCCESS" => LaunchProfileValidationStatusCode::ValidationSuccess,
            other => LaunchProfileValidationStatusCode::Unknown(other.to_owned())
        }
    }
}
impl std::str::FromStr for LaunchProfileValidationStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileValidationStatusCode::from(s))
    }
}
impl LaunchProfileValidationStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileValidationStatusCode::ValidationFailedInternalServerError => "VALIDATION_FAILED_INTERNAL_SERVER_ERROR",
            LaunchProfileValidationStatusCode::ValidationFailedInvalidActiveDirectory => "VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY",
            LaunchProfileValidationStatusCode::ValidationFailedInvalidSecurityGroupAssociation => "VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION",
            LaunchProfileValidationStatusCode::ValidationFailedInvalidSubnetRouteTableAssociation => "VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION",
            LaunchProfileValidationStatusCode::ValidationFailedSubnetNotFound => "VALIDATION_FAILED_SUBNET_NOT_FOUND",
            LaunchProfileValidationStatusCode::ValidationFailedUnauthorized => "VALIDATION_FAILED_UNAUTHORIZED",
            LaunchProfileValidationStatusCode::ValidationInProgress => "VALIDATION_IN_PROGRESS",
            LaunchProfileValidationStatusCode::ValidationNotStarted => "VALIDATION_NOT_STARTED",
            LaunchProfileValidationStatusCode::ValidationSuccess => "VALIDATION_SUCCESS",
            LaunchProfileValidationStatusCode::Unknown(s) => s.as_ref()
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "VALIDATION_FAILED_INTERNAL_SERVER_ERROR",
            "VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY",
            "VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION",
            "VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION",
            "VALIDATION_FAILED_SUBNET_NOT_FOUND",
            "VALIDATION_FAILED_UNAUTHORIZED",
            "VALIDATION_IN_PROGRESS",
            "VALIDATION_NOT_STARTED",
            "VALIDATION_SUCCESS",
        ]
    }
}
impl AsRef<str> for LaunchProfileValidationStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileValidationState {
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailed,
    #[allow(missing_docs)] // documentation missing in model
    ValidationFailedInternalServerError,
    #[allow(missing_docs)] // documentation missing in model
    ValidationInProgress,
    #[allow(missing_docs)] // documentation missing in model
    ValidationNotStarted,
    #[allow(missing_docs)] // documentation missing in model
    ValidationSuccess,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfileValidationState {
    fn from(s: &str) -> Self {
        match s {
            "VALIDATION_FAILED" => LaunchProfileValidationState::ValidationFailed,
            "VALIDATION_FAILED_INTERNAL_SERVER_ERROR" => {
                LaunchProfileValidationState::ValidationFailedInternalServerError
            }
            "VALIDATION_IN_PROGRESS" => LaunchProfileValidationState::ValidationInProgress,
            "VALIDATION_NOT_STARTED" => LaunchProfileValidationState::ValidationNotStarted,
            "VALIDATION_SUCCESS" => LaunchProfileValidationState::ValidationSuccess,
            other => LaunchProfileValidationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchProfileValidationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileValidationState::from(s))
    }
}
impl LaunchProfileValidationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileValidationState::ValidationFailed => "VALIDATION_FAILED",
            LaunchProfileValidationState::ValidationFailedInternalServerError => {
                "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
            }
            LaunchProfileValidationState::ValidationInProgress => "VALIDATION_IN_PROGRESS",
            LaunchProfileValidationState::ValidationNotStarted => "VALIDATION_NOT_STARTED",
            LaunchProfileValidationState::ValidationSuccess => "VALIDATION_SUCCESS",
            LaunchProfileValidationState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "VALIDATION_FAILED",
            "VALIDATION_FAILED_INTERNAL_SERVER_ERROR",
            "VALIDATION_IN_PROGRESS",
            "VALIDATION_NOT_STARTED",
            "VALIDATION_SUCCESS",
        ]
    }
}
impl AsRef<str> for LaunchProfileValidationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileValidationType {
    #[allow(missing_docs)] // documentation missing in model
    ValidateActiveDirectoryStudioComponent,
    #[allow(missing_docs)] // documentation missing in model
    ValidateNetworkAclAssociation,
    #[allow(missing_docs)] // documentation missing in model
    ValidateSecurityGroupAssociation,
    #[allow(missing_docs)] // documentation missing in model
    ValidateSubnetAssociation,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfileValidationType {
    fn from(s: &str) -> Self {
        match s {
            "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT" => {
                LaunchProfileValidationType::ValidateActiveDirectoryStudioComponent
            }
            "VALIDATE_NETWORK_ACL_ASSOCIATION" => {
                LaunchProfileValidationType::ValidateNetworkAclAssociation
            }
            "VALIDATE_SECURITY_GROUP_ASSOCIATION" => {
                LaunchProfileValidationType::ValidateSecurityGroupAssociation
            }
            "VALIDATE_SUBNET_ASSOCIATION" => LaunchProfileValidationType::ValidateSubnetAssociation,
            other => LaunchProfileValidationType::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchProfileValidationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileValidationType::from(s))
    }
}
impl LaunchProfileValidationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileValidationType::ValidateActiveDirectoryStudioComponent => {
                "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT"
            }
            LaunchProfileValidationType::ValidateNetworkAclAssociation => {
                "VALIDATE_NETWORK_ACL_ASSOCIATION"
            }
            LaunchProfileValidationType::ValidateSecurityGroupAssociation => {
                "VALIDATE_SECURITY_GROUP_ASSOCIATION"
            }
            LaunchProfileValidationType::ValidateSubnetAssociation => "VALIDATE_SUBNET_ASSOCIATION",
            LaunchProfileValidationType::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT",
            "VALIDATE_NETWORK_ACL_ASSOCIATION",
            "VALIDATE_SECURITY_GROUP_ASSOCIATION",
            "VALIDATE_SUBNET_ASSOCIATION",
        ]
    }
}
impl AsRef<str> for LaunchProfileValidationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A configuration for a streaming session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamConfiguration {
    /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    pub clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    pub ec2_instance_types: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
    /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
    pub max_session_length_in_minutes: i32,
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    pub streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760.</p>
    /// <p>If the value is missing or set to 0, your sessions cant be stopped. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated by AWS (instead of stopped).</p>
    /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped by AWS (instead of terminated).</p>
    pub max_stopped_session_length_in_minutes: i32,
    /// <p>(Optional) The upload storage for a streaming session.</p>
    pub session_storage: std::option::Option<crate::model::StreamConfigurationSessionStorage>,
}
impl StreamConfiguration {
    /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    pub fn clipboard_mode(&self) -> std::option::Option<&crate::model::StreamingClipboardMode> {
        self.clipboard_mode.as_ref()
    }
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    pub fn ec2_instance_types(
        &self,
    ) -> std::option::Option<&[crate::model::StreamingInstanceType]> {
        self.ec2_instance_types.as_deref()
    }
    /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
    pub fn max_session_length_in_minutes(&self) -> i32 {
        self.max_session_length_in_minutes
    }
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    pub fn streaming_image_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.streaming_image_ids.as_deref()
    }
    /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760.</p>
    /// <p>If the value is missing or set to 0, your sessions cant be stopped. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated by AWS (instead of stopped).</p>
    /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped by AWS (instead of terminated).</p>
    pub fn max_stopped_session_length_in_minutes(&self) -> i32 {
        self.max_stopped_session_length_in_minutes
    }
    /// <p>(Optional) The upload storage for a streaming session.</p>
    pub fn session_storage(
        &self,
    ) -> std::option::Option<&crate::model::StreamConfigurationSessionStorage> {
        self.session_storage.as_ref()
    }
}
impl std::fmt::Debug for StreamConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamConfiguration");
        formatter.field("clipboard_mode", &self.clipboard_mode);
        formatter.field("ec2_instance_types", &self.ec2_instance_types);
        formatter.field(
            "max_session_length_in_minutes",
            &self.max_session_length_in_minutes,
        );
        formatter.field("streaming_image_ids", &self.streaming_image_ids);
        formatter.field(
            "max_stopped_session_length_in_minutes",
            &self.max_stopped_session_length_in_minutes,
        );
        formatter.field("session_storage", &self.session_storage);
        formatter.finish()
    }
}
/// See [`StreamConfiguration`](crate::model::StreamConfiguration)
pub mod stream_configuration {

    /// A builder for [`StreamConfiguration`](crate::model::StreamConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
        pub(crate) ec2_instance_types:
            std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        pub(crate) max_session_length_in_minutes: std::option::Option<i32>,
        pub(crate) streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_stopped_session_length_in_minutes: std::option::Option<i32>,
        pub(crate) session_storage:
            std::option::Option<crate::model::StreamConfigurationSessionStorage>,
    }
    impl Builder {
        /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
        pub fn clipboard_mode(mut self, input: crate::model::StreamingClipboardMode) -> Self {
            self.clipboard_mode = Some(input);
            self
        }
        /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
        pub fn set_clipboard_mode(
            mut self,
            input: std::option::Option<crate::model::StreamingClipboardMode>,
        ) -> Self {
            self.clipboard_mode = input;
            self
        }
        /// Appends an item to `ec2_instance_types`.
        ///
        /// To override the contents of this collection use [`set_ec2_instance_types`](Self::set_ec2_instance_types).
        ///
        /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
        pub fn ec2_instance_types(mut self, input: crate::model::StreamingInstanceType) -> Self {
            let mut v = self.ec2_instance_types.unwrap_or_default();
            v.push(input);
            self.ec2_instance_types = Some(v);
            self
        }
        /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
        pub fn set_ec2_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        ) -> Self {
            self.ec2_instance_types = input;
            self
        }
        /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
        pub fn max_session_length_in_minutes(mut self, input: i32) -> Self {
            self.max_session_length_in_minutes = Some(input);
            self
        }
        /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
        pub fn set_max_session_length_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_session_length_in_minutes = input;
            self
        }
        /// Appends an item to `streaming_image_ids`.
        ///
        /// To override the contents of this collection use [`set_streaming_image_ids`](Self::set_streaming_image_ids).
        ///
        /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
        pub fn streaming_image_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.streaming_image_ids.unwrap_or_default();
            v.push(input.into());
            self.streaming_image_ids = Some(v);
            self
        }
        /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
        pub fn set_streaming_image_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.streaming_image_ids = input;
            self
        }
        /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760.</p>
        /// <p>If the value is missing or set to 0, your sessions cant be stopped. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated by AWS (instead of stopped).</p>
        /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped by AWS (instead of terminated).</p>
        pub fn max_stopped_session_length_in_minutes(mut self, input: i32) -> Self {
            self.max_stopped_session_length_in_minutes = Some(input);
            self
        }
        /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760.</p>
        /// <p>If the value is missing or set to 0, your sessions cant be stopped. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated by AWS (instead of stopped).</p>
        /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped by AWS (instead of terminated).</p>
        pub fn set_max_stopped_session_length_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_stopped_session_length_in_minutes = input;
            self
        }
        /// <p>(Optional) The upload storage for a streaming session.</p>
        pub fn session_storage(
            mut self,
            input: crate::model::StreamConfigurationSessionStorage,
        ) -> Self {
            self.session_storage = Some(input);
            self
        }
        /// <p>(Optional) The upload storage for a streaming session.</p>
        pub fn set_session_storage(
            mut self,
            input: std::option::Option<crate::model::StreamConfigurationSessionStorage>,
        ) -> Self {
            self.session_storage = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamConfiguration`](crate::model::StreamConfiguration)
        pub fn build(self) -> crate::model::StreamConfiguration {
            crate::model::StreamConfiguration {
                clipboard_mode: self.clipboard_mode,
                ec2_instance_types: self.ec2_instance_types,
                max_session_length_in_minutes: self
                    .max_session_length_in_minutes
                    .unwrap_or_default(),
                streaming_image_ids: self.streaming_image_ids,
                max_stopped_session_length_in_minutes: self
                    .max_stopped_session_length_in_minutes
                    .unwrap_or_default(),
                session_storage: self.session_storage,
            }
        }
    }
}
impl StreamConfiguration {
    /// Creates a new builder-style object to manufacture [`StreamConfiguration`](crate::model::StreamConfiguration)
    pub fn builder() -> crate::model::stream_configuration::Builder {
        crate::model::stream_configuration::Builder::default()
    }
}

/// <p>The configuration for a streaming sessions upload storage.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamConfigurationSessionStorage {
    /// <p>The configuration for the upload storage root of the streaming session.</p>
    pub root: std::option::Option<crate::model::StreamingSessionStorageRoot>,
    /// <p>Allows artists to upload files to their workstations. The only valid option is <code>UPLOAD</code>.</p>
    pub mode: std::option::Option<std::vec::Vec<crate::model::StreamingSessionStorageMode>>,
}
impl StreamConfigurationSessionStorage {
    /// <p>The configuration for the upload storage root of the streaming session.</p>
    pub fn root(&self) -> std::option::Option<&crate::model::StreamingSessionStorageRoot> {
        self.root.as_ref()
    }
    /// <p>Allows artists to upload files to their workstations. The only valid option is <code>UPLOAD</code>.</p>
    pub fn mode(&self) -> std::option::Option<&[crate::model::StreamingSessionStorageMode]> {
        self.mode.as_deref()
    }
}
impl std::fmt::Debug for StreamConfigurationSessionStorage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamConfigurationSessionStorage");
        formatter.field("root", &self.root);
        formatter.field("mode", &self.mode);
        formatter.finish()
    }
}
/// See [`StreamConfigurationSessionStorage`](crate::model::StreamConfigurationSessionStorage)
pub mod stream_configuration_session_storage {

    /// A builder for [`StreamConfigurationSessionStorage`](crate::model::StreamConfigurationSessionStorage)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) root: std::option::Option<crate::model::StreamingSessionStorageRoot>,
        pub(crate) mode:
            std::option::Option<std::vec::Vec<crate::model::StreamingSessionStorageMode>>,
    }
    impl Builder {
        /// <p>The configuration for the upload storage root of the streaming session.</p>
        pub fn root(mut self, input: crate::model::StreamingSessionStorageRoot) -> Self {
            self.root = Some(input);
            self
        }
        /// <p>The configuration for the upload storage root of the streaming session.</p>
        pub fn set_root(
            mut self,
            input: std::option::Option<crate::model::StreamingSessionStorageRoot>,
        ) -> Self {
            self.root = input;
            self
        }
        /// Appends an item to `mode`.
        ///
        /// To override the contents of this collection use [`set_mode`](Self::set_mode).
        ///
        /// <p>Allows artists to upload files to their workstations. The only valid option is <code>UPLOAD</code>.</p>
        pub fn mode(mut self, input: crate::model::StreamingSessionStorageMode) -> Self {
            let mut v = self.mode.unwrap_or_default();
            v.push(input);
            self.mode = Some(v);
            self
        }
        /// <p>Allows artists to upload files to their workstations. The only valid option is <code>UPLOAD</code>.</p>
        pub fn set_mode(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamingSessionStorageMode>>,
        ) -> Self {
            self.mode = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamConfigurationSessionStorage`](crate::model::StreamConfigurationSessionStorage)
        pub fn build(self) -> crate::model::StreamConfigurationSessionStorage {
            crate::model::StreamConfigurationSessionStorage {
                root: self.root,
                mode: self.mode,
            }
        }
    }
}
impl StreamConfigurationSessionStorage {
    /// Creates a new builder-style object to manufacture [`StreamConfigurationSessionStorage`](crate::model::StreamConfigurationSessionStorage)
    pub fn builder() -> crate::model::stream_configuration_session_storage::Builder {
        crate::model::stream_configuration_session_storage::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingSessionStorageMode {
    #[allow(missing_docs)] // documentation missing in model
    Upload,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingSessionStorageMode {
    fn from(s: &str) -> Self {
        match s {
            "UPLOAD" => StreamingSessionStorageMode::Upload,
            other => StreamingSessionStorageMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingSessionStorageMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingSessionStorageMode::from(s))
    }
}
impl StreamingSessionStorageMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingSessionStorageMode::Upload => "UPLOAD",
            StreamingSessionStorageMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["UPLOAD"]
    }
}
impl AsRef<str> for StreamingSessionStorageMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The upload storage root location (folder) on streaming workstations where files are uploaded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamingSessionStorageRoot {
    /// <p>The folder path in Linux workstations where files are uploaded.</p>
    pub linux: std::option::Option<std::string::String>,
    /// <p>The folder path in Windows workstations where files are uploaded.</p>
    pub windows: std::option::Option<std::string::String>,
}
impl StreamingSessionStorageRoot {
    /// <p>The folder path in Linux workstations where files are uploaded.</p>
    pub fn linux(&self) -> std::option::Option<&str> {
        self.linux.as_deref()
    }
    /// <p>The folder path in Windows workstations where files are uploaded.</p>
    pub fn windows(&self) -> std::option::Option<&str> {
        self.windows.as_deref()
    }
}
impl std::fmt::Debug for StreamingSessionStorageRoot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamingSessionStorageRoot");
        formatter.field("linux", &"*** Sensitive Data Redacted ***");
        formatter.field("windows", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`StreamingSessionStorageRoot`](crate::model::StreamingSessionStorageRoot)
pub mod streaming_session_storage_root {

    /// A builder for [`StreamingSessionStorageRoot`](crate::model::StreamingSessionStorageRoot)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) linux: std::option::Option<std::string::String>,
        pub(crate) windows: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The folder path in Linux workstations where files are uploaded.</p>
        pub fn linux(mut self, input: impl Into<std::string::String>) -> Self {
            self.linux = Some(input.into());
            self
        }
        /// <p>The folder path in Linux workstations where files are uploaded.</p>
        pub fn set_linux(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.linux = input;
            self
        }
        /// <p>The folder path in Windows workstations where files are uploaded.</p>
        pub fn windows(mut self, input: impl Into<std::string::String>) -> Self {
            self.windows = Some(input.into());
            self
        }
        /// <p>The folder path in Windows workstations where files are uploaded.</p>
        pub fn set_windows(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.windows = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamingSessionStorageRoot`](crate::model::StreamingSessionStorageRoot)
        pub fn build(self) -> crate::model::StreamingSessionStorageRoot {
            crate::model::StreamingSessionStorageRoot {
                linux: self.linux,
                windows: self.windows,
            }
        }
    }
}
impl StreamingSessionStorageRoot {
    /// Creates a new builder-style object to manufacture [`StreamingSessionStorageRoot`](crate::model::StreamingSessionStorageRoot)
    pub fn builder() -> crate::model::streaming_session_storage_root::Builder {
        crate::model::streaming_session_storage_root::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StreamingClipboardMode {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for StreamingClipboardMode {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => StreamingClipboardMode::Disabled,
            "ENABLED" => StreamingClipboardMode::Enabled,
            other => StreamingClipboardMode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for StreamingClipboardMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StreamingClipboardMode::from(s))
    }
}
impl StreamingClipboardMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StreamingClipboardMode::Disabled => "DISABLED",
            StreamingClipboardMode::Enabled => "ENABLED",
            StreamingClipboardMode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for StreamingClipboardMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileStatusCode {
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyAccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    EncryptionKeyNotFound,
    #[allow(missing_docs)] // documentation missing in model
    InternalError,
    #[allow(missing_docs)] // documentation missing in model
    InvalidSubnetsProvided,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileCreated,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileCreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileDeleted,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileDeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileUpdated,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileUpdateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    LaunchProfileWithStreamSessionsNotDeleted,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageNotFound,
    #[allow(missing_docs)] // documentation missing in model
    StreamingImageNotReady,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfileStatusCode {
    fn from(s: &str) -> Self {
        match s {
            "ENCRYPTION_KEY_ACCESS_DENIED" => LaunchProfileStatusCode::EncryptionKeyAccessDenied,
            "ENCRYPTION_KEY_NOT_FOUND" => LaunchProfileStatusCode::EncryptionKeyNotFound,
            "INTERNAL_ERROR" => LaunchProfileStatusCode::InternalError,
            "INVALID_SUBNETS_PROVIDED" => LaunchProfileStatusCode::InvalidSubnetsProvided,
            "LAUNCH_PROFILE_CREATED" => LaunchProfileStatusCode::LaunchProfileCreated,
            "LAUNCH_PROFILE_CREATE_IN_PROGRESS" => {
                LaunchProfileStatusCode::LaunchProfileCreateInProgress
            }
            "LAUNCH_PROFILE_DELETED" => LaunchProfileStatusCode::LaunchProfileDeleted,
            "LAUNCH_PROFILE_DELETE_IN_PROGRESS" => {
                LaunchProfileStatusCode::LaunchProfileDeleteInProgress
            }
            "LAUNCH_PROFILE_UPDATED" => LaunchProfileStatusCode::LaunchProfileUpdated,
            "LAUNCH_PROFILE_UPDATE_IN_PROGRESS" => {
                LaunchProfileStatusCode::LaunchProfileUpdateInProgress
            }
            "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED" => {
                LaunchProfileStatusCode::LaunchProfileWithStreamSessionsNotDeleted
            }
            "STREAMING_IMAGE_NOT_FOUND" => LaunchProfileStatusCode::StreamingImageNotFound,
            "STREAMING_IMAGE_NOT_READY" => LaunchProfileStatusCode::StreamingImageNotReady,
            other => LaunchProfileStatusCode::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchProfileStatusCode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileStatusCode::from(s))
    }
}
impl LaunchProfileStatusCode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileStatusCode::EncryptionKeyAccessDenied => "ENCRYPTION_KEY_ACCESS_DENIED",
            LaunchProfileStatusCode::EncryptionKeyNotFound => "ENCRYPTION_KEY_NOT_FOUND",
            LaunchProfileStatusCode::InternalError => "INTERNAL_ERROR",
            LaunchProfileStatusCode::InvalidSubnetsProvided => "INVALID_SUBNETS_PROVIDED",
            LaunchProfileStatusCode::LaunchProfileCreated => "LAUNCH_PROFILE_CREATED",
            LaunchProfileStatusCode::LaunchProfileCreateInProgress => {
                "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
            }
            LaunchProfileStatusCode::LaunchProfileDeleted => "LAUNCH_PROFILE_DELETED",
            LaunchProfileStatusCode::LaunchProfileDeleteInProgress => {
                "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
            }
            LaunchProfileStatusCode::LaunchProfileUpdated => "LAUNCH_PROFILE_UPDATED",
            LaunchProfileStatusCode::LaunchProfileUpdateInProgress => {
                "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
            }
            LaunchProfileStatusCode::LaunchProfileWithStreamSessionsNotDeleted => {
                "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
            }
            LaunchProfileStatusCode::StreamingImageNotFound => "STREAMING_IMAGE_NOT_FOUND",
            LaunchProfileStatusCode::StreamingImageNotReady => "STREAMING_IMAGE_NOT_READY",
            LaunchProfileStatusCode::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "ENCRYPTION_KEY_ACCESS_DENIED",
            "ENCRYPTION_KEY_NOT_FOUND",
            "INTERNAL_ERROR",
            "INVALID_SUBNETS_PROVIDED",
            "LAUNCH_PROFILE_CREATED",
            "LAUNCH_PROFILE_CREATE_IN_PROGRESS",
            "LAUNCH_PROFILE_DELETED",
            "LAUNCH_PROFILE_DELETE_IN_PROGRESS",
            "LAUNCH_PROFILE_UPDATED",
            "LAUNCH_PROFILE_UPDATE_IN_PROGRESS",
            "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED",
            "STREAMING_IMAGE_NOT_FOUND",
            "STREAMING_IMAGE_NOT_READY",
        ]
    }
}
impl AsRef<str> for LaunchProfileStatusCode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchProfileState {
    #[allow(missing_docs)] // documentation missing in model
    CreateFailed,
    #[allow(missing_docs)] // documentation missing in model
    CreateInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Deleted,
    #[allow(missing_docs)] // documentation missing in model
    DeleteFailed,
    #[allow(missing_docs)] // documentation missing in model
    DeleteInProgress,
    #[allow(missing_docs)] // documentation missing in model
    Ready,
    #[allow(missing_docs)] // documentation missing in model
    UpdateFailed,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for LaunchProfileState {
    fn from(s: &str) -> Self {
        match s {
            "CREATE_FAILED" => LaunchProfileState::CreateFailed,
            "CREATE_IN_PROGRESS" => LaunchProfileState::CreateInProgress,
            "DELETED" => LaunchProfileState::Deleted,
            "DELETE_FAILED" => LaunchProfileState::DeleteFailed,
            "DELETE_IN_PROGRESS" => LaunchProfileState::DeleteInProgress,
            "READY" => LaunchProfileState::Ready,
            "UPDATE_FAILED" => LaunchProfileState::UpdateFailed,
            "UPDATE_IN_PROGRESS" => LaunchProfileState::UpdateInProgress,
            other => LaunchProfileState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for LaunchProfileState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchProfileState::from(s))
    }
}
impl LaunchProfileState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchProfileState::CreateFailed => "CREATE_FAILED",
            LaunchProfileState::CreateInProgress => "CREATE_IN_PROGRESS",
            LaunchProfileState::Deleted => "DELETED",
            LaunchProfileState::DeleteFailed => "DELETE_FAILED",
            LaunchProfileState::DeleteInProgress => "DELETE_IN_PROGRESS",
            LaunchProfileState::Ready => "READY",
            LaunchProfileState::UpdateFailed => "UPDATE_FAILED",
            LaunchProfileState::UpdateInProgress => "UPDATE_IN_PROGRESS",
            LaunchProfileState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATE_FAILED",
            "CREATE_IN_PROGRESS",
            "DELETED",
            "DELETE_FAILED",
            "DELETE_IN_PROGRESS",
            "READY",
            "UPDATE_FAILED",
            "UPDATE_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for LaunchProfileState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Configuration for streaming workstations created using this launch profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StreamConfigurationCreate {
    /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    pub clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    pub ec2_instance_types: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
    /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
    pub max_session_length_in_minutes: i32,
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    pub streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760.</p>
    /// <p>If the value is missing or set to 0, your sessions cant be stopped. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated by AWS (instead of stopped).</p>
    /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped by AWS (instead of terminated).</p>
    pub max_stopped_session_length_in_minutes: i32,
    /// <p>(Optional) The upload storage for a streaming workstation that is created using this launch profile.</p>
    pub session_storage: std::option::Option<crate::model::StreamConfigurationSessionStorage>,
}
impl StreamConfigurationCreate {
    /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
    pub fn clipboard_mode(&self) -> std::option::Option<&crate::model::StreamingClipboardMode> {
        self.clipboard_mode.as_ref()
    }
    /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
    pub fn ec2_instance_types(
        &self,
    ) -> std::option::Option<&[crate::model::StreamingInstanceType]> {
        self.ec2_instance_types.as_deref()
    }
    /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
    pub fn max_session_length_in_minutes(&self) -> i32 {
        self.max_session_length_in_minutes
    }
    /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
    pub fn streaming_image_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.streaming_image_ids.as_deref()
    }
    /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760.</p>
    /// <p>If the value is missing or set to 0, your sessions cant be stopped. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated by AWS (instead of stopped).</p>
    /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped by AWS (instead of terminated).</p>
    pub fn max_stopped_session_length_in_minutes(&self) -> i32 {
        self.max_stopped_session_length_in_minutes
    }
    /// <p>(Optional) The upload storage for a streaming workstation that is created using this launch profile.</p>
    pub fn session_storage(
        &self,
    ) -> std::option::Option<&crate::model::StreamConfigurationSessionStorage> {
        self.session_storage.as_ref()
    }
}
impl std::fmt::Debug for StreamConfigurationCreate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StreamConfigurationCreate");
        formatter.field("clipboard_mode", &self.clipboard_mode);
        formatter.field("ec2_instance_types", &self.ec2_instance_types);
        formatter.field(
            "max_session_length_in_minutes",
            &self.max_session_length_in_minutes,
        );
        formatter.field("streaming_image_ids", &self.streaming_image_ids);
        formatter.field(
            "max_stopped_session_length_in_minutes",
            &self.max_stopped_session_length_in_minutes,
        );
        formatter.field("session_storage", &self.session_storage);
        formatter.finish()
    }
}
/// See [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate)
pub mod stream_configuration_create {

    /// A builder for [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) clipboard_mode: std::option::Option<crate::model::StreamingClipboardMode>,
        pub(crate) ec2_instance_types:
            std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        pub(crate) max_session_length_in_minutes: std::option::Option<i32>,
        pub(crate) streaming_image_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) max_stopped_session_length_in_minutes: std::option::Option<i32>,
        pub(crate) session_storage:
            std::option::Option<crate::model::StreamConfigurationSessionStorage>,
    }
    impl Builder {
        /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
        pub fn clipboard_mode(mut self, input: crate::model::StreamingClipboardMode) -> Self {
            self.clipboard_mode = Some(input);
            self
        }
        /// <p>Enable or disable the use of the system clipboard to copy and paste between the streaming session and streaming client.</p>
        pub fn set_clipboard_mode(
            mut self,
            input: std::option::Option<crate::model::StreamingClipboardMode>,
        ) -> Self {
            self.clipboard_mode = input;
            self
        }
        /// Appends an item to `ec2_instance_types`.
        ///
        /// To override the contents of this collection use [`set_ec2_instance_types`](Self::set_ec2_instance_types).
        ///
        /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
        pub fn ec2_instance_types(mut self, input: crate::model::StreamingInstanceType) -> Self {
            let mut v = self.ec2_instance_types.unwrap_or_default();
            v.push(input);
            self.ec2_instance_types = Some(v);
            self
        }
        /// <p>The EC2 instance types that users can select from when launching a streaming session with this launch profile.</p>
        pub fn set_ec2_instance_types(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StreamingInstanceType>>,
        ) -> Self {
            self.ec2_instance_types = input;
            self
        }
        /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
        pub fn max_session_length_in_minutes(mut self, input: i32) -> Self {
            self.max_session_length_in_minutes = Some(input);
            self
        }
        /// <p>The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.</p>
        pub fn set_max_session_length_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_session_length_in_minutes = input;
            self
        }
        /// Appends an item to `streaming_image_ids`.
        ///
        /// To override the contents of this collection use [`set_streaming_image_ids`](Self::set_streaming_image_ids).
        ///
        /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
        pub fn streaming_image_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.streaming_image_ids.unwrap_or_default();
            v.push(input.into());
            self.streaming_image_ids = Some(v);
            self
        }
        /// <p>The streaming images that users can select from when launching a streaming session with this launch profile.</p>
        pub fn set_streaming_image_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.streaming_image_ids = input;
            self
        }
        /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760.</p>
        /// <p>If the value is missing or set to 0, your sessions cant be stopped. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated by AWS (instead of stopped).</p>
        /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped by AWS (instead of terminated).</p>
        pub fn max_stopped_session_length_in_minutes(mut self, input: i32) -> Self {
            self.max_stopped_session_length_in_minutes = Some(input);
            self
        }
        /// <p>Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760.</p>
        /// <p>If the value is missing or set to 0, your sessions cant be stopped. If you then call <code>StopStreamingSession</code>, the session fails. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be terminated by AWS (instead of stopped).</p>
        /// <p>If the value is set to a positive number, the session can be stopped. You can call <code>StopStreamingSession</code> to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the <code>maxSessionLengthInMinutes</code> value, the session will automatically be stopped by AWS (instead of terminated).</p>
        pub fn set_max_stopped_session_length_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.max_stopped_session_length_in_minutes = input;
            self
        }
        /// <p>(Optional) The upload storage for a streaming workstation that is created using this launch profile.</p>
        pub fn session_storage(
            mut self,
            input: crate::model::StreamConfigurationSessionStorage,
        ) -> Self {
            self.session_storage = Some(input);
            self
        }
        /// <p>(Optional) The upload storage for a streaming workstation that is created using this launch profile.</p>
        pub fn set_session_storage(
            mut self,
            input: std::option::Option<crate::model::StreamConfigurationSessionStorage>,
        ) -> Self {
            self.session_storage = input;
            self
        }
        /// Consumes the builder and constructs a [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate)
        pub fn build(self) -> crate::model::StreamConfigurationCreate {
            crate::model::StreamConfigurationCreate {
                clipboard_mode: self.clipboard_mode,
                ec2_instance_types: self.ec2_instance_types,
                max_session_length_in_minutes: self
                    .max_session_length_in_minutes
                    .unwrap_or_default(),
                streaming_image_ids: self.streaming_image_ids,
                max_stopped_session_length_in_minutes: self
                    .max_stopped_session_length_in_minutes
                    .unwrap_or_default(),
                session_storage: self.session_storage,
            }
        }
    }
}
impl StreamConfigurationCreate {
    /// Creates a new builder-style object to manufacture [`StreamConfigurationCreate`](crate::model::StreamConfigurationCreate)
    pub fn builder() -> crate::model::stream_configuration_create::Builder {
        crate::model::stream_configuration_create::Builder::default()
    }
}

/// <p>Represents a EULA resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Eula {
    /// <p>The EULA content.</p>
    pub content: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The EULA ID.</p>
    pub eula_id: std::option::Option<std::string::String>,
    /// <p>The name for the EULA.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl Eula {
    /// <p>The EULA content.</p>
    pub fn content(&self) -> std::option::Option<&str> {
        self.content.as_deref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The EULA ID.</p>
    pub fn eula_id(&self) -> std::option::Option<&str> {
        self.eula_id.as_deref()
    }
    /// <p>The name for the EULA.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
impl std::fmt::Debug for Eula {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Eula");
        formatter.field("content", &self.content);
        formatter.field("created_at", &self.created_at);
        formatter.field("eula_id", &self.eula_id);
        formatter.field("name", &self.name);
        formatter.field("updated_at", &self.updated_at);
        formatter.finish()
    }
}
/// See [`Eula`](crate::model::Eula)
pub mod eula {

    /// A builder for [`Eula`](crate::model::Eula)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) content: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) eula_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The EULA content.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.content = Some(input.into());
            self
        }
        /// <p>The EULA content.</p>
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.content = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The EULA ID.</p>
        pub fn eula_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.eula_id = Some(input.into());
            self
        }
        /// <p>The EULA ID.</p>
        pub fn set_eula_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.eula_id = input;
            self
        }
        /// <p>The name for the EULA.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name for the EULA.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the resource was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`Eula`](crate::model::Eula)
        pub fn build(self) -> crate::model::Eula {
            crate::model::Eula {
                content: self.content,
                created_at: self.created_at,
                eula_id: self.eula_id,
                name: self.name,
                updated_at: self.updated_at,
            }
        }
    }
}
impl Eula {
    /// Creates a new builder-style object to manufacture [`Eula`](crate::model::Eula)
    pub fn builder() -> crate::model::eula::Builder {
        crate::model::eula::Builder::default()
    }
}

/// <p>The acceptance of a EULA, required to use Amazon-provided streaming images.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EulaAcceptance {
    /// <p>The Unix epoch timestamp in seconds for when the EULA was accepted.</p>
    pub accepted_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The ID of the person who accepted the EULA.</p>
    pub accepted_by: std::option::Option<std::string::String>,
    /// <p>The ID of the acceptee.</p>
    pub acceptee_id: std::option::Option<std::string::String>,
    /// <p>The EULA acceptance ID.</p>
    pub eula_acceptance_id: std::option::Option<std::string::String>,
    /// <p>The EULA ID.</p>
    pub eula_id: std::option::Option<std::string::String>,
}
impl EulaAcceptance {
    /// <p>The Unix epoch timestamp in seconds for when the EULA was accepted.</p>
    pub fn accepted_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.accepted_at.as_ref()
    }
    /// <p>The ID of the person who accepted the EULA.</p>
    pub fn accepted_by(&self) -> std::option::Option<&str> {
        self.accepted_by.as_deref()
    }
    /// <p>The ID of the acceptee.</p>
    pub fn acceptee_id(&self) -> std::option::Option<&str> {
        self.acceptee_id.as_deref()
    }
    /// <p>The EULA acceptance ID.</p>
    pub fn eula_acceptance_id(&self) -> std::option::Option<&str> {
        self.eula_acceptance_id.as_deref()
    }
    /// <p>The EULA ID.</p>
    pub fn eula_id(&self) -> std::option::Option<&str> {
        self.eula_id.as_deref()
    }
}
impl std::fmt::Debug for EulaAcceptance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EulaAcceptance");
        formatter.field("accepted_at", &self.accepted_at);
        formatter.field("accepted_by", &self.accepted_by);
        formatter.field("acceptee_id", &self.acceptee_id);
        formatter.field("eula_acceptance_id", &self.eula_acceptance_id);
        formatter.field("eula_id", &self.eula_id);
        formatter.finish()
    }
}
/// See [`EulaAcceptance`](crate::model::EulaAcceptance)
pub mod eula_acceptance {

    /// A builder for [`EulaAcceptance`](crate::model::EulaAcceptance)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) accepted_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) accepted_by: std::option::Option<std::string::String>,
        pub(crate) acceptee_id: std::option::Option<std::string::String>,
        pub(crate) eula_acceptance_id: std::option::Option<std::string::String>,
        pub(crate) eula_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Unix epoch timestamp in seconds for when the EULA was accepted.</p>
        pub fn accepted_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.accepted_at = Some(input);
            self
        }
        /// <p>The Unix epoch timestamp in seconds for when the EULA was accepted.</p>
        pub fn set_accepted_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.accepted_at = input;
            self
        }
        /// <p>The ID of the person who accepted the EULA.</p>
        pub fn accepted_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.accepted_by = Some(input.into());
            self
        }
        /// <p>The ID of the person who accepted the EULA.</p>
        pub fn set_accepted_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.accepted_by = input;
            self
        }
        /// <p>The ID of the acceptee.</p>
        pub fn acceptee_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.acceptee_id = Some(input.into());
            self
        }
        /// <p>The ID of the acceptee.</p>
        pub fn set_acceptee_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.acceptee_id = input;
            self
        }
        /// <p>The EULA acceptance ID.</p>
        pub fn eula_acceptance_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.eula_acceptance_id = Some(input.into());
            self
        }
        /// <p>The EULA acceptance ID.</p>
        pub fn set_eula_acceptance_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.eula_acceptance_id = input;
            self
        }
        /// <p>The EULA ID.</p>
        pub fn eula_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.eula_id = Some(input.into());
            self
        }
        /// <p>The EULA ID.</p>
        pub fn set_eula_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.eula_id = input;
            self
        }
        /// Consumes the builder and constructs a [`EulaAcceptance`](crate::model::EulaAcceptance)
        pub fn build(self) -> crate::model::EulaAcceptance {
            crate::model::EulaAcceptance {
                accepted_at: self.accepted_at,
                accepted_by: self.accepted_by,
                acceptee_id: self.acceptee_id,
                eula_acceptance_id: self.eula_acceptance_id,
                eula_id: self.eula_id,
            }
        }
    }
}
impl EulaAcceptance {
    /// Creates a new builder-style object to manufacture [`EulaAcceptance`](crate::model::EulaAcceptance)
    pub fn builder() -> crate::model::eula_acceptance::Builder {
        crate::model::eula_acceptance::Builder::default()
    }
}
