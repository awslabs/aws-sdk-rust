// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The summary of attributes associated with a job run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobRunSummary {
    /// <p>The ID of the application the job is running on.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The ID of the job run.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The optional job run name. This doesn't have to be unique.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of the job run.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The user who created the job run.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the job run was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the job run was last updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The execution role ARN of the job run.</p>
    #[doc(hidden)]
    pub execution_role: std::option::Option<std::string::String>,
    /// <p>The state of the job run.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::JobRunState>,
    /// <p>The state details of the job run.</p>
    #[doc(hidden)]
    pub state_details: std::option::Option<std::string::String>,
    /// <p>The EMR release associated with the application your job is running on.</p>
    #[doc(hidden)]
    pub release_label: std::option::Option<std::string::String>,
    /// <p>The type of job run, such as Spark or Hive.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
}
impl JobRunSummary {
    /// <p>The ID of the application the job is running on.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The ID of the job run.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The optional job run name. This doesn't have to be unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the job run.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The user who created the job run.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The date and time when the job run was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time when the job run was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The execution role ARN of the job run.</p>
    pub fn execution_role(&self) -> std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>The state of the job run.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::JobRunState> {
        self.state.as_ref()
    }
    /// <p>The state details of the job run.</p>
    pub fn state_details(&self) -> std::option::Option<&str> {
        self.state_details.as_deref()
    }
    /// <p>The EMR release associated with the application your job is running on.</p>
    pub fn release_label(&self) -> std::option::Option<&str> {
        self.release_label.as_deref()
    }
    /// <p>The type of job run, such as Spark or Hive.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
/// See [`JobRunSummary`](crate::model::JobRunSummary).
pub mod job_run_summary {

    /// A builder for [`JobRunSummary`](crate::model::JobRunSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) execution_role: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::JobRunState>,
        pub(crate) state_details: std::option::Option<std::string::String>,
        pub(crate) release_label: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the application the job is running on.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The ID of the application the job is running on.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The ID of the job run.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the job run.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The optional job run name. This doesn't have to be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The optional job run name. This doesn't have to be unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of the job run.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the job run.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The user who created the job run.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user who created the job run.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The date and time when the job run was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time when the job run was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date and time when the job run was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time when the job run was last updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role = Some(input.into());
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn set_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role = input;
            self
        }
        /// <p>The state of the job run.</p>
        pub fn state(mut self, input: crate::model::JobRunState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the job run.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::JobRunState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The state details of the job run.</p>
        pub fn state_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_details = Some(input.into());
            self
        }
        /// <p>The state details of the job run.</p>
        pub fn set_state_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_details = input;
            self
        }
        /// <p>The EMR release associated with the application your job is running on.</p>
        pub fn release_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_label = Some(input.into());
            self
        }
        /// <p>The EMR release associated with the application your job is running on.</p>
        pub fn set_release_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_label = input;
            self
        }
        /// <p>The type of job run, such as Spark or Hive.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of job run, such as Spark or Hive.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`JobRunSummary`](crate::model::JobRunSummary).
        pub fn build(self) -> crate::model::JobRunSummary {
            crate::model::JobRunSummary {
                application_id: self.application_id,
                id: self.id,
                name: self.name,
                arn: self.arn,
                created_by: self.created_by,
                created_at: self.created_at,
                updated_at: self.updated_at,
                execution_role: self.execution_role,
                state: self.state,
                state_details: self.state_details,
                release_label: self.release_label,
                r#type: self.r#type,
            }
        }
    }
}
impl JobRunSummary {
    /// Creates a new builder-style object to manufacture [`JobRunSummary`](crate::model::JobRunSummary).
    pub fn builder() -> crate::model::job_run_summary::Builder {
        crate::model::job_run_summary::Builder::default()
    }
}

/// When writing a match expression against `JobRunState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let jobrunstate = unimplemented!();
/// match jobrunstate {
///     JobRunState::Cancelled => { /* ... */ },
///     JobRunState::Cancelling => { /* ... */ },
///     JobRunState::Failed => { /* ... */ },
///     JobRunState::Pending => { /* ... */ },
///     JobRunState::Running => { /* ... */ },
///     JobRunState::Scheduled => { /* ... */ },
///     JobRunState::Submitted => { /* ... */ },
///     JobRunState::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `jobrunstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `JobRunState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `JobRunState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `JobRunState::NewFeature` is defined.
/// Specifically, when `jobrunstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `JobRunState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobRunState {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Scheduled,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for JobRunState {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => JobRunState::Cancelled,
            "CANCELLING" => JobRunState::Cancelling,
            "FAILED" => JobRunState::Failed,
            "PENDING" => JobRunState::Pending,
            "RUNNING" => JobRunState::Running,
            "SCHEDULED" => JobRunState::Scheduled,
            "SUBMITTED" => JobRunState::Submitted,
            "SUCCESS" => JobRunState::Success,
            other => JobRunState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for JobRunState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobRunState::from(s))
    }
}
impl JobRunState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobRunState::Cancelled => "CANCELLED",
            JobRunState::Cancelling => "CANCELLING",
            JobRunState::Failed => "FAILED",
            JobRunState::Pending => "PENDING",
            JobRunState::Running => "RUNNING",
            JobRunState::Scheduled => "SCHEDULED",
            JobRunState::Submitted => "SUBMITTED",
            JobRunState::Success => "SUCCESS",
            JobRunState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "CANCELLING",
            "FAILED",
            "PENDING",
            "RUNNING",
            "SCHEDULED",
            "SUBMITTED",
            "SUCCESS",
        ]
    }
}
impl AsRef<str> for JobRunState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A configuration specification to be used to override existing configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConfigurationOverrides {
    /// <p>The override configurations for the application.</p>
    #[doc(hidden)]
    pub application_configuration: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
    /// <p>The override configurations for monitoring.</p>
    #[doc(hidden)]
    pub monitoring_configuration: std::option::Option<crate::model::MonitoringConfiguration>,
}
impl ConfigurationOverrides {
    /// <p>The override configurations for the application.</p>
    pub fn application_configuration(&self) -> std::option::Option<&[crate::model::Configuration]> {
        self.application_configuration.as_deref()
    }
    /// <p>The override configurations for monitoring.</p>
    pub fn monitoring_configuration(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringConfiguration> {
        self.monitoring_configuration.as_ref()
    }
}
/// See [`ConfigurationOverrides`](crate::model::ConfigurationOverrides).
pub mod configuration_overrides {

    /// A builder for [`ConfigurationOverrides`](crate::model::ConfigurationOverrides).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_configuration:
            std::option::Option<std::vec::Vec<crate::model::Configuration>>,
        pub(crate) monitoring_configuration:
            std::option::Option<crate::model::MonitoringConfiguration>,
    }
    impl Builder {
        /// Appends an item to `application_configuration`.
        ///
        /// To override the contents of this collection use [`set_application_configuration`](Self::set_application_configuration).
        ///
        /// <p>The override configurations for the application.</p>
        pub fn application_configuration(mut self, input: crate::model::Configuration) -> Self {
            let mut v = self.application_configuration.unwrap_or_default();
            v.push(input);
            self.application_configuration = Some(v);
            self
        }
        /// <p>The override configurations for the application.</p>
        pub fn set_application_configuration(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
        ) -> Self {
            self.application_configuration = input;
            self
        }
        /// <p>The override configurations for monitoring.</p>
        pub fn monitoring_configuration(
            mut self,
            input: crate::model::MonitoringConfiguration,
        ) -> Self {
            self.monitoring_configuration = Some(input);
            self
        }
        /// <p>The override configurations for monitoring.</p>
        pub fn set_monitoring_configuration(
            mut self,
            input: std::option::Option<crate::model::MonitoringConfiguration>,
        ) -> Self {
            self.monitoring_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationOverrides`](crate::model::ConfigurationOverrides).
        pub fn build(self) -> crate::model::ConfigurationOverrides {
            crate::model::ConfigurationOverrides {
                application_configuration: self.application_configuration,
                monitoring_configuration: self.monitoring_configuration,
            }
        }
    }
}
impl ConfigurationOverrides {
    /// Creates a new builder-style object to manufacture [`ConfigurationOverrides`](crate::model::ConfigurationOverrides).
    pub fn builder() -> crate::model::configuration_overrides::Builder {
        crate::model::configuration_overrides::Builder::default()
    }
}

/// <p>The configuration setting for monitoring.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MonitoringConfiguration {
    /// <p>The Amazon S3 configuration for monitoring log publishing.</p>
    #[doc(hidden)]
    pub s3_monitoring_configuration: std::option::Option<crate::model::S3MonitoringConfiguration>,
    /// <p>The managed log persistence configuration for a job run.</p>
    #[doc(hidden)]
    pub managed_persistence_monitoring_configuration:
        std::option::Option<crate::model::ManagedPersistenceMonitoringConfiguration>,
}
impl MonitoringConfiguration {
    /// <p>The Amazon S3 configuration for monitoring log publishing.</p>
    pub fn s3_monitoring_configuration(
        &self,
    ) -> std::option::Option<&crate::model::S3MonitoringConfiguration> {
        self.s3_monitoring_configuration.as_ref()
    }
    /// <p>The managed log persistence configuration for a job run.</p>
    pub fn managed_persistence_monitoring_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ManagedPersistenceMonitoringConfiguration> {
        self.managed_persistence_monitoring_configuration.as_ref()
    }
}
/// See [`MonitoringConfiguration`](crate::model::MonitoringConfiguration).
pub mod monitoring_configuration {

    /// A builder for [`MonitoringConfiguration`](crate::model::MonitoringConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_monitoring_configuration:
            std::option::Option<crate::model::S3MonitoringConfiguration>,
        pub(crate) managed_persistence_monitoring_configuration:
            std::option::Option<crate::model::ManagedPersistenceMonitoringConfiguration>,
    }
    impl Builder {
        /// <p>The Amazon S3 configuration for monitoring log publishing.</p>
        pub fn s3_monitoring_configuration(
            mut self,
            input: crate::model::S3MonitoringConfiguration,
        ) -> Self {
            self.s3_monitoring_configuration = Some(input);
            self
        }
        /// <p>The Amazon S3 configuration for monitoring log publishing.</p>
        pub fn set_s3_monitoring_configuration(
            mut self,
            input: std::option::Option<crate::model::S3MonitoringConfiguration>,
        ) -> Self {
            self.s3_monitoring_configuration = input;
            self
        }
        /// <p>The managed log persistence configuration for a job run.</p>
        pub fn managed_persistence_monitoring_configuration(
            mut self,
            input: crate::model::ManagedPersistenceMonitoringConfiguration,
        ) -> Self {
            self.managed_persistence_monitoring_configuration = Some(input);
            self
        }
        /// <p>The managed log persistence configuration for a job run.</p>
        pub fn set_managed_persistence_monitoring_configuration(
            mut self,
            input: std::option::Option<crate::model::ManagedPersistenceMonitoringConfiguration>,
        ) -> Self {
            self.managed_persistence_monitoring_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringConfiguration`](crate::model::MonitoringConfiguration).
        pub fn build(self) -> crate::model::MonitoringConfiguration {
            crate::model::MonitoringConfiguration {
                s3_monitoring_configuration: self.s3_monitoring_configuration,
                managed_persistence_monitoring_configuration: self
                    .managed_persistence_monitoring_configuration,
            }
        }
    }
}
impl MonitoringConfiguration {
    /// Creates a new builder-style object to manufacture [`MonitoringConfiguration`](crate::model::MonitoringConfiguration).
    pub fn builder() -> crate::model::monitoring_configuration::Builder {
        crate::model::monitoring_configuration::Builder::default()
    }
}

/// <p>The managed log persistence configuration for a job run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ManagedPersistenceMonitoringConfiguration {
    /// <p>Enables managed logging and defaults to true. If set to false, managed logging will be turned off.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>The KMS key ARN to encrypt the logs stored in managed log persistence.</p>
    #[doc(hidden)]
    pub encryption_key_arn: std::option::Option<std::string::String>,
}
impl ManagedPersistenceMonitoringConfiguration {
    /// <p>Enables managed logging and defaults to true. If set to false, managed logging will be turned off.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The KMS key ARN to encrypt the logs stored in managed log persistence.</p>
    pub fn encryption_key_arn(&self) -> std::option::Option<&str> {
        self.encryption_key_arn.as_deref()
    }
}
/// See [`ManagedPersistenceMonitoringConfiguration`](crate::model::ManagedPersistenceMonitoringConfiguration).
pub mod managed_persistence_monitoring_configuration {

    /// A builder for [`ManagedPersistenceMonitoringConfiguration`](crate::model::ManagedPersistenceMonitoringConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) encryption_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Enables managed logging and defaults to true. If set to false, managed logging will be turned off.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Enables managed logging and defaults to true. If set to false, managed logging will be turned off.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The KMS key ARN to encrypt the logs stored in managed log persistence.</p>
        pub fn encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_key_arn = Some(input.into());
            self
        }
        /// <p>The KMS key ARN to encrypt the logs stored in managed log persistence.</p>
        pub fn set_encryption_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedPersistenceMonitoringConfiguration`](crate::model::ManagedPersistenceMonitoringConfiguration).
        pub fn build(self) -> crate::model::ManagedPersistenceMonitoringConfiguration {
            crate::model::ManagedPersistenceMonitoringConfiguration {
                enabled: self.enabled,
                encryption_key_arn: self.encryption_key_arn,
            }
        }
    }
}
impl ManagedPersistenceMonitoringConfiguration {
    /// Creates a new builder-style object to manufacture [`ManagedPersistenceMonitoringConfiguration`](crate::model::ManagedPersistenceMonitoringConfiguration).
    pub fn builder() -> crate::model::managed_persistence_monitoring_configuration::Builder {
        crate::model::managed_persistence_monitoring_configuration::Builder::default()
    }
}

/// <p>The Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3MonitoringConfiguration {
    /// <p>The Amazon S3 destination URI for log publishing.</p>
    #[doc(hidden)]
    pub log_uri: std::option::Option<std::string::String>,
    /// <p>The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.</p>
    #[doc(hidden)]
    pub encryption_key_arn: std::option::Option<std::string::String>,
}
impl S3MonitoringConfiguration {
    /// <p>The Amazon S3 destination URI for log publishing.</p>
    pub fn log_uri(&self) -> std::option::Option<&str> {
        self.log_uri.as_deref()
    }
    /// <p>The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.</p>
    pub fn encryption_key_arn(&self) -> std::option::Option<&str> {
        self.encryption_key_arn.as_deref()
    }
}
/// See [`S3MonitoringConfiguration`](crate::model::S3MonitoringConfiguration).
pub mod s3_monitoring_configuration {

    /// A builder for [`S3MonitoringConfiguration`](crate::model::S3MonitoringConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_uri: std::option::Option<std::string::String>,
        pub(crate) encryption_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 destination URI for log publishing.</p>
        pub fn log_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 destination URI for log publishing.</p>
        pub fn set_log_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_uri = input;
            self
        }
        /// <p>The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.</p>
        pub fn encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_key_arn = Some(input.into());
            self
        }
        /// <p>The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.</p>
        pub fn set_encryption_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`S3MonitoringConfiguration`](crate::model::S3MonitoringConfiguration).
        pub fn build(self) -> crate::model::S3MonitoringConfiguration {
            crate::model::S3MonitoringConfiguration {
                log_uri: self.log_uri,
                encryption_key_arn: self.encryption_key_arn,
            }
        }
    }
}
impl S3MonitoringConfiguration {
    /// Creates a new builder-style object to manufacture [`S3MonitoringConfiguration`](crate::model::S3MonitoringConfiguration).
    pub fn builder() -> crate::model::s3_monitoring_configuration::Builder {
        crate::model::s3_monitoring_configuration::Builder::default()
    }
}

/// <p>A configuration specification to be used when provisioning an application. A configuration consists of a classification, properties, and optional nested configurations. A classification refers to an application-specific configuration file. Properties are the settings you want to change in that file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Configuration {
    /// <p>The classification within a configuration.</p>
    #[doc(hidden)]
    pub classification: std::option::Option<std::string::String>,
    /// <p>A set of properties specified within a configuration classification.</p>
    #[doc(hidden)]
    pub properties:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A list of additional configurations to apply within a configuration object.</p>
    #[doc(hidden)]
    pub configurations: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
}
impl Configuration {
    /// <p>The classification within a configuration.</p>
    pub fn classification(&self) -> std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>A set of properties specified within a configuration classification.</p>
    pub fn properties(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.properties.as_ref()
    }
    /// <p>A list of additional configurations to apply within a configuration object.</p>
    pub fn configurations(&self) -> std::option::Option<&[crate::model::Configuration]> {
        self.configurations.as_deref()
    }
}
impl std::fmt::Debug for Configuration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Configuration");
        formatter.field("classification", &self.classification);
        formatter.field("properties", &"*** Sensitive Data Redacted ***");
        formatter.field("configurations", &self.configurations);
        formatter.finish()
    }
}
/// See [`Configuration`](crate::model::Configuration).
pub mod configuration {

    /// A builder for [`Configuration`](crate::model::Configuration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) configurations: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
    }
    impl Builder {
        /// <p>The classification within a configuration.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        /// <p>The classification within a configuration.</p>
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>A set of properties specified within a configuration classification.</p>
        pub fn properties(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.properties = Some(hash_map);
            self
        }
        /// <p>A set of properties specified within a configuration classification.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Appends an item to `configurations`.
        ///
        /// To override the contents of this collection use [`set_configurations`](Self::set_configurations).
        ///
        /// <p>A list of additional configurations to apply within a configuration object.</p>
        pub fn configurations(mut self, input: crate::model::Configuration) -> Self {
            let mut v = self.configurations.unwrap_or_default();
            v.push(input);
            self.configurations = Some(v);
            self
        }
        /// <p>A list of additional configurations to apply within a configuration object.</p>
        pub fn set_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
        ) -> Self {
            self.configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`Configuration`](crate::model::Configuration).
        pub fn build(self) -> crate::model::Configuration {
            crate::model::Configuration {
                classification: self.classification,
                properties: self.properties,
                configurations: self.configurations,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("classification", &self.classification);
            formatter.field("properties", &"*** Sensitive Data Redacted ***");
            formatter.field("configurations", &self.configurations);
            formatter.finish()
        }
    }
}
impl Configuration {
    /// Creates a new builder-style object to manufacture [`Configuration`](crate::model::Configuration).
    pub fn builder() -> crate::model::configuration::Builder {
        crate::model::configuration::Builder::default()
    }
}

/// <p>The driver that the job runs on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum JobDriver {
    /// <p>The job driver parameters specified for Hive.</p>
    Hive(crate::model::Hive),
    /// <p>The job driver parameters specified for Spark.</p>
    SparkSubmit(crate::model::SparkSubmit),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl JobDriver {
    /// Tries to convert the enum instance into [`Hive`](crate::model::JobDriver::Hive), extracting the inner [`Hive`](crate::model::Hive).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_hive(&self) -> std::result::Result<&crate::model::Hive, &Self> {
        if let JobDriver::Hive(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Hive`](crate::model::JobDriver::Hive).
    pub fn is_hive(&self) -> bool {
        self.as_hive().is_ok()
    }
    /// Tries to convert the enum instance into [`SparkSubmit`](crate::model::JobDriver::SparkSubmit), extracting the inner [`SparkSubmit`](crate::model::SparkSubmit).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_spark_submit(&self) -> std::result::Result<&crate::model::SparkSubmit, &Self> {
        if let JobDriver::SparkSubmit(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SparkSubmit`](crate::model::JobDriver::SparkSubmit).
    pub fn is_spark_submit(&self) -> bool {
        self.as_spark_submit().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The configurations for the Hive job driver.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Hive {
    /// <p>The query for the Hive job run.</p>
    #[doc(hidden)]
    pub query: std::option::Option<std::string::String>,
    /// <p>The query file for the Hive job run.</p>
    #[doc(hidden)]
    pub init_query_file: std::option::Option<std::string::String>,
    /// <p>The parameters for the Hive job run.</p>
    #[doc(hidden)]
    pub parameters: std::option::Option<std::string::String>,
}
impl Hive {
    /// <p>The query for the Hive job run.</p>
    pub fn query(&self) -> std::option::Option<&str> {
        self.query.as_deref()
    }
    /// <p>The query file for the Hive job run.</p>
    pub fn init_query_file(&self) -> std::option::Option<&str> {
        self.init_query_file.as_deref()
    }
    /// <p>The parameters for the Hive job run.</p>
    pub fn parameters(&self) -> std::option::Option<&str> {
        self.parameters.as_deref()
    }
}
impl std::fmt::Debug for Hive {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Hive");
        formatter.field("query", &"*** Sensitive Data Redacted ***");
        formatter.field("init_query_file", &"*** Sensitive Data Redacted ***");
        formatter.field("parameters", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Hive`](crate::model::Hive).
pub mod hive {

    /// A builder for [`Hive`](crate::model::Hive).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) query: std::option::Option<std::string::String>,
        pub(crate) init_query_file: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The query for the Hive job run.</p>
        pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
            self.query = Some(input.into());
            self
        }
        /// <p>The query for the Hive job run.</p>
        pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query = input;
            self
        }
        /// <p>The query file for the Hive job run.</p>
        pub fn init_query_file(mut self, input: impl Into<std::string::String>) -> Self {
            self.init_query_file = Some(input.into());
            self
        }
        /// <p>The query file for the Hive job run.</p>
        pub fn set_init_query_file(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.init_query_file = input;
            self
        }
        /// <p>The parameters for the Hive job run.</p>
        pub fn parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameters = Some(input.into());
            self
        }
        /// <p>The parameters for the Hive job run.</p>
        pub fn set_parameters(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`Hive`](crate::model::Hive).
        pub fn build(self) -> crate::model::Hive {
            crate::model::Hive {
                query: self.query,
                init_query_file: self.init_query_file,
                parameters: self.parameters,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("query", &"*** Sensitive Data Redacted ***");
            formatter.field("init_query_file", &"*** Sensitive Data Redacted ***");
            formatter.field("parameters", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl Hive {
    /// Creates a new builder-style object to manufacture [`Hive`](crate::model::Hive).
    pub fn builder() -> crate::model::hive::Builder {
        crate::model::hive::Builder::default()
    }
}

/// <p>The configurations for the Spark submit job driver.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SparkSubmit {
    /// <p>The entry point for the Spark submit job run.</p>
    #[doc(hidden)]
    pub entry_point: std::option::Option<std::string::String>,
    /// <p>The arguments for the Spark submit job run.</p>
    #[doc(hidden)]
    pub entry_point_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The parameters for the Spark submit job run.</p>
    #[doc(hidden)]
    pub spark_submit_parameters: std::option::Option<std::string::String>,
}
impl SparkSubmit {
    /// <p>The entry point for the Spark submit job run.</p>
    pub fn entry_point(&self) -> std::option::Option<&str> {
        self.entry_point.as_deref()
    }
    /// <p>The arguments for the Spark submit job run.</p>
    pub fn entry_point_arguments(&self) -> std::option::Option<&[std::string::String]> {
        self.entry_point_arguments.as_deref()
    }
    /// <p>The parameters for the Spark submit job run.</p>
    pub fn spark_submit_parameters(&self) -> std::option::Option<&str> {
        self.spark_submit_parameters.as_deref()
    }
}
impl std::fmt::Debug for SparkSubmit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SparkSubmit");
        formatter.field("entry_point", &"*** Sensitive Data Redacted ***");
        formatter.field("entry_point_arguments", &self.entry_point_arguments);
        formatter.field(
            "spark_submit_parameters",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.finish()
    }
}
/// See [`SparkSubmit`](crate::model::SparkSubmit).
pub mod spark_submit {

    /// A builder for [`SparkSubmit`](crate::model::SparkSubmit).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) entry_point: std::option::Option<std::string::String>,
        pub(crate) entry_point_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) spark_submit_parameters: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The entry point for the Spark submit job run.</p>
        pub fn entry_point(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_point = Some(input.into());
            self
        }
        /// <p>The entry point for the Spark submit job run.</p>
        pub fn set_entry_point(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_point = input;
            self
        }
        /// Appends an item to `entry_point_arguments`.
        ///
        /// To override the contents of this collection use [`set_entry_point_arguments`](Self::set_entry_point_arguments).
        ///
        /// <p>The arguments for the Spark submit job run.</p>
        pub fn entry_point_arguments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.entry_point_arguments.unwrap_or_default();
            v.push(input.into());
            self.entry_point_arguments = Some(v);
            self
        }
        /// <p>The arguments for the Spark submit job run.</p>
        pub fn set_entry_point_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.entry_point_arguments = input;
            self
        }
        /// <p>The parameters for the Spark submit job run.</p>
        pub fn spark_submit_parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.spark_submit_parameters = Some(input.into());
            self
        }
        /// <p>The parameters for the Spark submit job run.</p>
        pub fn set_spark_submit_parameters(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spark_submit_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`SparkSubmit`](crate::model::SparkSubmit).
        pub fn build(self) -> crate::model::SparkSubmit {
            crate::model::SparkSubmit {
                entry_point: self.entry_point,
                entry_point_arguments: self.entry_point_arguments,
                spark_submit_parameters: self.spark_submit_parameters,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("entry_point", &"*** Sensitive Data Redacted ***");
            formatter.field("entry_point_arguments", &self.entry_point_arguments);
            formatter.field(
                "spark_submit_parameters",
                &"*** Sensitive Data Redacted ***",
            );
            formatter.finish()
        }
    }
}
impl SparkSubmit {
    /// Creates a new builder-style object to manufacture [`SparkSubmit`](crate::model::SparkSubmit).
    pub fn builder() -> crate::model::spark_submit::Builder {
        crate::model::spark_submit::Builder::default()
    }
}

/// <p>Information about a job run. A job run is a unit of work, such as a Spark JAR, Hive query, or SparkSQL query, that you submit to an EMR Serverless application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JobRun {
    /// <p>The ID of the application the job is running on.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The ID of the job run.</p>
    #[doc(hidden)]
    pub job_run_id: std::option::Option<std::string::String>,
    /// <p>The optional job run name. This doesn't have to be unique.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The execution role ARN of the job run.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The user who created the job run.</p>
    #[doc(hidden)]
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the job run was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the job run was updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The execution role ARN of the job run.</p>
    #[doc(hidden)]
    pub execution_role: std::option::Option<std::string::String>,
    /// <p>The state of the job run.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::JobRunState>,
    /// <p>The state details of the job run.</p>
    #[doc(hidden)]
    pub state_details: std::option::Option<std::string::String>,
    /// <p>The EMR release associated with the application your job is running on.</p>
    #[doc(hidden)]
    pub release_label: std::option::Option<std::string::String>,
    /// <p>The configuration settings that are used to override default configuration.</p>
    #[doc(hidden)]
    pub configuration_overrides: std::option::Option<crate::model::ConfigurationOverrides>,
    /// <p>The job driver for the job run.</p>
    #[doc(hidden)]
    pub job_driver: std::option::Option<crate::model::JobDriver>,
    /// <p>The tags assigned to the job run.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.</p>
    #[doc(hidden)]
    pub total_resource_utilization: std::option::Option<crate::model::TotalResourceUtilization>,
    /// <p>The network configuration for customer VPC connectivity.</p>
    #[doc(hidden)]
    pub network_configuration: std::option::Option<crate::model::NetworkConfiguration>,
    /// <p>The job run total execution duration in seconds. This field is only available for job runs in a <code>COMPLETED</code>, <code>FAILED</code>, or <code>CANCELLED</code> state.</p>
    #[doc(hidden)]
    pub total_execution_duration_seconds: std::option::Option<i32>,
}
impl JobRun {
    /// <p>The ID of the application the job is running on.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The ID of the job run.</p>
    pub fn job_run_id(&self) -> std::option::Option<&str> {
        self.job_run_id.as_deref()
    }
    /// <p>The optional job run name. This doesn't have to be unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The execution role ARN of the job run.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The user who created the job run.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The date and time when the job run was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time when the job run was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The execution role ARN of the job run.</p>
    pub fn execution_role(&self) -> std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>The state of the job run.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::JobRunState> {
        self.state.as_ref()
    }
    /// <p>The state details of the job run.</p>
    pub fn state_details(&self) -> std::option::Option<&str> {
        self.state_details.as_deref()
    }
    /// <p>The EMR release associated with the application your job is running on.</p>
    pub fn release_label(&self) -> std::option::Option<&str> {
        self.release_label.as_deref()
    }
    /// <p>The configuration settings that are used to override default configuration.</p>
    pub fn configuration_overrides(
        &self,
    ) -> std::option::Option<&crate::model::ConfigurationOverrides> {
        self.configuration_overrides.as_ref()
    }
    /// <p>The job driver for the job run.</p>
    pub fn job_driver(&self) -> std::option::Option<&crate::model::JobDriver> {
        self.job_driver.as_ref()
    }
    /// <p>The tags assigned to the job run.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.</p>
    pub fn total_resource_utilization(
        &self,
    ) -> std::option::Option<&crate::model::TotalResourceUtilization> {
        self.total_resource_utilization.as_ref()
    }
    /// <p>The network configuration for customer VPC connectivity.</p>
    pub fn network_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NetworkConfiguration> {
        self.network_configuration.as_ref()
    }
    /// <p>The job run total execution duration in seconds. This field is only available for job runs in a <code>COMPLETED</code>, <code>FAILED</code>, or <code>CANCELLED</code> state.</p>
    pub fn total_execution_duration_seconds(&self) -> std::option::Option<i32> {
        self.total_execution_duration_seconds
    }
}
/// See [`JobRun`](crate::model::JobRun).
pub mod job_run {

    /// A builder for [`JobRun`](crate::model::JobRun).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) job_run_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) execution_role: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::JobRunState>,
        pub(crate) state_details: std::option::Option<std::string::String>,
        pub(crate) release_label: std::option::Option<std::string::String>,
        pub(crate) configuration_overrides:
            std::option::Option<crate::model::ConfigurationOverrides>,
        pub(crate) job_driver: std::option::Option<crate::model::JobDriver>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) total_resource_utilization:
            std::option::Option<crate::model::TotalResourceUtilization>,
        pub(crate) network_configuration: std::option::Option<crate::model::NetworkConfiguration>,
        pub(crate) total_execution_duration_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the application the job is running on.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The ID of the application the job is running on.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The ID of the job run.</p>
        pub fn job_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_run_id = Some(input.into());
            self
        }
        /// <p>The ID of the job run.</p>
        pub fn set_job_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_run_id = input;
            self
        }
        /// <p>The optional job run name. This doesn't have to be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The optional job run name. This doesn't have to be unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The user who created the job run.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user who created the job run.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The date and time when the job run was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time when the job run was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date and time when the job run was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time when the job run was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role = Some(input.into());
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn set_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role = input;
            self
        }
        /// <p>The state of the job run.</p>
        pub fn state(mut self, input: crate::model::JobRunState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the job run.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::JobRunState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The state details of the job run.</p>
        pub fn state_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_details = Some(input.into());
            self
        }
        /// <p>The state details of the job run.</p>
        pub fn set_state_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_details = input;
            self
        }
        /// <p>The EMR release associated with the application your job is running on.</p>
        pub fn release_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_label = Some(input.into());
            self
        }
        /// <p>The EMR release associated with the application your job is running on.</p>
        pub fn set_release_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_label = input;
            self
        }
        /// <p>The configuration settings that are used to override default configuration.</p>
        pub fn configuration_overrides(
            mut self,
            input: crate::model::ConfigurationOverrides,
        ) -> Self {
            self.configuration_overrides = Some(input);
            self
        }
        /// <p>The configuration settings that are used to override default configuration.</p>
        pub fn set_configuration_overrides(
            mut self,
            input: std::option::Option<crate::model::ConfigurationOverrides>,
        ) -> Self {
            self.configuration_overrides = input;
            self
        }
        /// <p>The job driver for the job run.</p>
        pub fn job_driver(mut self, input: crate::model::JobDriver) -> Self {
            self.job_driver = Some(input);
            self
        }
        /// <p>The job driver for the job run.</p>
        pub fn set_job_driver(
            mut self,
            input: std::option::Option<crate::model::JobDriver>,
        ) -> Self {
            self.job_driver = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the job run.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the job run.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.</p>
        pub fn total_resource_utilization(
            mut self,
            input: crate::model::TotalResourceUtilization,
        ) -> Self {
            self.total_resource_utilization = Some(input);
            self
        }
        /// <p>The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.</p>
        pub fn set_total_resource_utilization(
            mut self,
            input: std::option::Option<crate::model::TotalResourceUtilization>,
        ) -> Self {
            self.total_resource_utilization = input;
            self
        }
        /// <p>The network configuration for customer VPC connectivity.</p>
        pub fn network_configuration(mut self, input: crate::model::NetworkConfiguration) -> Self {
            self.network_configuration = Some(input);
            self
        }
        /// <p>The network configuration for customer VPC connectivity.</p>
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::NetworkConfiguration>,
        ) -> Self {
            self.network_configuration = input;
            self
        }
        /// <p>The job run total execution duration in seconds. This field is only available for job runs in a <code>COMPLETED</code>, <code>FAILED</code>, or <code>CANCELLED</code> state.</p>
        pub fn total_execution_duration_seconds(mut self, input: i32) -> Self {
            self.total_execution_duration_seconds = Some(input);
            self
        }
        /// <p>The job run total execution duration in seconds. This field is only available for job runs in a <code>COMPLETED</code>, <code>FAILED</code>, or <code>CANCELLED</code> state.</p>
        pub fn set_total_execution_duration_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.total_execution_duration_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`JobRun`](crate::model::JobRun).
        pub fn build(self) -> crate::model::JobRun {
            crate::model::JobRun {
                application_id: self.application_id,
                job_run_id: self.job_run_id,
                name: self.name,
                arn: self.arn,
                created_by: self.created_by,
                created_at: self.created_at,
                updated_at: self.updated_at,
                execution_role: self.execution_role,
                state: self.state,
                state_details: self.state_details,
                release_label: self.release_label,
                configuration_overrides: self.configuration_overrides,
                job_driver: self.job_driver,
                tags: self.tags,
                total_resource_utilization: self.total_resource_utilization,
                network_configuration: self.network_configuration,
                total_execution_duration_seconds: self.total_execution_duration_seconds,
            }
        }
    }
}
impl JobRun {
    /// Creates a new builder-style object to manufacture [`JobRun`](crate::model::JobRun).
    pub fn builder() -> crate::model::job_run::Builder {
        crate::model::job_run::Builder::default()
    }
}

/// <p>The network configuration for customer VPC connectivity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkConfiguration {
    /// <p>The array of subnet Ids for customer VPC connectivity.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The array of security group Ids for customer VPC connectivity.</p>
    #[doc(hidden)]
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl NetworkConfiguration {
    /// <p>The array of subnet Ids for customer VPC connectivity.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The array of security group Ids for customer VPC connectivity.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
/// See [`NetworkConfiguration`](crate::model::NetworkConfiguration).
pub mod network_configuration {

    /// A builder for [`NetworkConfiguration`](crate::model::NetworkConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The array of subnet Ids for customer VPC connectivity.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The array of subnet Ids for customer VPC connectivity.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The array of security group Ids for customer VPC connectivity.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The array of security group Ids for customer VPC connectivity.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkConfiguration`](crate::model::NetworkConfiguration).
        pub fn build(self) -> crate::model::NetworkConfiguration {
            crate::model::NetworkConfiguration {
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl NetworkConfiguration {
    /// Creates a new builder-style object to manufacture [`NetworkConfiguration`](crate::model::NetworkConfiguration).
    pub fn builder() -> crate::model::network_configuration::Builder {
        crate::model::network_configuration::Builder::default()
    }
}

/// <p>The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TotalResourceUtilization {
    /// <p>The aggregated vCPU used per hour from the time job start executing till the time job is terminated.</p>
    #[doc(hidden)]
    pub v_cpu_hour: std::option::Option<f64>,
    /// <p>The aggregated memory used per hour from the time job start executing till the time job is terminated.</p>
    #[doc(hidden)]
    pub memory_gb_hour: std::option::Option<f64>,
    /// <p>The aggregated storage used per hour from the time job start executing till the time job is terminated.</p>
    #[doc(hidden)]
    pub storage_gb_hour: std::option::Option<f64>,
}
impl TotalResourceUtilization {
    /// <p>The aggregated vCPU used per hour from the time job start executing till the time job is terminated.</p>
    pub fn v_cpu_hour(&self) -> std::option::Option<f64> {
        self.v_cpu_hour
    }
    /// <p>The aggregated memory used per hour from the time job start executing till the time job is terminated.</p>
    pub fn memory_gb_hour(&self) -> std::option::Option<f64> {
        self.memory_gb_hour
    }
    /// <p>The aggregated storage used per hour from the time job start executing till the time job is terminated.</p>
    pub fn storage_gb_hour(&self) -> std::option::Option<f64> {
        self.storage_gb_hour
    }
}
/// See [`TotalResourceUtilization`](crate::model::TotalResourceUtilization).
pub mod total_resource_utilization {

    /// A builder for [`TotalResourceUtilization`](crate::model::TotalResourceUtilization).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) v_cpu_hour: std::option::Option<f64>,
        pub(crate) memory_gb_hour: std::option::Option<f64>,
        pub(crate) storage_gb_hour: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The aggregated vCPU used per hour from the time job start executing till the time job is terminated.</p>
        pub fn v_cpu_hour(mut self, input: f64) -> Self {
            self.v_cpu_hour = Some(input);
            self
        }
        /// <p>The aggregated vCPU used per hour from the time job start executing till the time job is terminated.</p>
        pub fn set_v_cpu_hour(mut self, input: std::option::Option<f64>) -> Self {
            self.v_cpu_hour = input;
            self
        }
        /// <p>The aggregated memory used per hour from the time job start executing till the time job is terminated.</p>
        pub fn memory_gb_hour(mut self, input: f64) -> Self {
            self.memory_gb_hour = Some(input);
            self
        }
        /// <p>The aggregated memory used per hour from the time job start executing till the time job is terminated.</p>
        pub fn set_memory_gb_hour(mut self, input: std::option::Option<f64>) -> Self {
            self.memory_gb_hour = input;
            self
        }
        /// <p>The aggregated storage used per hour from the time job start executing till the time job is terminated.</p>
        pub fn storage_gb_hour(mut self, input: f64) -> Self {
            self.storage_gb_hour = Some(input);
            self
        }
        /// <p>The aggregated storage used per hour from the time job start executing till the time job is terminated.</p>
        pub fn set_storage_gb_hour(mut self, input: std::option::Option<f64>) -> Self {
            self.storage_gb_hour = input;
            self
        }
        /// Consumes the builder and constructs a [`TotalResourceUtilization`](crate::model::TotalResourceUtilization).
        pub fn build(self) -> crate::model::TotalResourceUtilization {
            crate::model::TotalResourceUtilization {
                v_cpu_hour: self.v_cpu_hour,
                memory_gb_hour: self.memory_gb_hour,
                storage_gb_hour: self.storage_gb_hour,
            }
        }
    }
}
impl TotalResourceUtilization {
    /// Creates a new builder-style object to manufacture [`TotalResourceUtilization`](crate::model::TotalResourceUtilization).
    pub fn builder() -> crate::model::total_resource_utilization::Builder {
        crate::model::total_resource_utilization::Builder::default()
    }
}

/// <p>The summary of attributes associated with an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationSummary {
    /// <p>The ID of the application.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the application.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of the application.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The EMR release associated with the application.</p>
    #[doc(hidden)]
    pub release_label: std::option::Option<std::string::String>,
    /// <p>The type of application, such as Spark or Hive.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The state of the application.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ApplicationState>,
    /// <p>The state details of the application.</p>
    #[doc(hidden)]
    pub state_details: std::option::Option<std::string::String>,
    /// <p>The date and time when the application was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the application was last updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The CPU architecture of an application.</p>
    #[doc(hidden)]
    pub architecture: std::option::Option<crate::model::Architecture>,
}
impl ApplicationSummary {
    /// <p>The ID of the application.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the application.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The EMR release associated with the application.</p>
    pub fn release_label(&self) -> std::option::Option<&str> {
        self.release_label.as_deref()
    }
    /// <p>The type of application, such as Spark or Hive.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The state of the application.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ApplicationState> {
        self.state.as_ref()
    }
    /// <p>The state details of the application.</p>
    pub fn state_details(&self) -> std::option::Option<&str> {
        self.state_details.as_deref()
    }
    /// <p>The date and time when the application was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time when the application was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The CPU architecture of an application.</p>
    pub fn architecture(&self) -> std::option::Option<&crate::model::Architecture> {
        self.architecture.as_ref()
    }
}
/// See [`ApplicationSummary`](crate::model::ApplicationSummary).
pub mod application_summary {

    /// A builder for [`ApplicationSummary`](crate::model::ApplicationSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) release_label: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ApplicationState>,
        pub(crate) state_details: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) architecture: std::option::Option<crate::model::Architecture>,
    }
    impl Builder {
        /// <p>The ID of the application.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the application.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The EMR release associated with the application.</p>
        pub fn release_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_label = Some(input.into());
            self
        }
        /// <p>The EMR release associated with the application.</p>
        pub fn set_release_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_label = input;
            self
        }
        /// <p>The type of application, such as Spark or Hive.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of application, such as Spark or Hive.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The state of the application.</p>
        pub fn state(mut self, input: crate::model::ApplicationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the application.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ApplicationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The state details of the application.</p>
        pub fn state_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_details = Some(input.into());
            self
        }
        /// <p>The state details of the application.</p>
        pub fn set_state_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_details = input;
            self
        }
        /// <p>The date and time when the application was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time when the application was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date and time when the application was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time when the application was last updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The CPU architecture of an application.</p>
        pub fn architecture(mut self, input: crate::model::Architecture) -> Self {
            self.architecture = Some(input);
            self
        }
        /// <p>The CPU architecture of an application.</p>
        pub fn set_architecture(
            mut self,
            input: std::option::Option<crate::model::Architecture>,
        ) -> Self {
            self.architecture = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationSummary`](crate::model::ApplicationSummary).
        pub fn build(self) -> crate::model::ApplicationSummary {
            crate::model::ApplicationSummary {
                id: self.id,
                name: self.name,
                arn: self.arn,
                release_label: self.release_label,
                r#type: self.r#type,
                state: self.state,
                state_details: self.state_details,
                created_at: self.created_at,
                updated_at: self.updated_at,
                architecture: self.architecture,
            }
        }
    }
}
impl ApplicationSummary {
    /// Creates a new builder-style object to manufacture [`ApplicationSummary`](crate::model::ApplicationSummary).
    pub fn builder() -> crate::model::application_summary::Builder {
        crate::model::application_summary::Builder::default()
    }
}

/// When writing a match expression against `Architecture`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let architecture = unimplemented!();
/// match architecture {
///     Architecture::Arm64 => { /* ... */ },
///     Architecture::X8664 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `architecture` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Architecture::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Architecture::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Architecture::NewFeature` is defined.
/// Specifically, when `architecture` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Architecture::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Architecture {
    #[allow(missing_docs)] // documentation missing in model
    Arm64,
    #[allow(missing_docs)] // documentation missing in model
    X8664,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Architecture {
    fn from(s: &str) -> Self {
        match s {
            "ARM64" => Architecture::Arm64,
            "X86_64" => Architecture::X8664,
            other => Architecture::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Architecture {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Architecture::from(s))
    }
}
impl Architecture {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Architecture::Arm64 => "ARM64",
            Architecture::X8664 => "X86_64",
            Architecture::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ARM64", "X86_64"]
    }
}
impl AsRef<str> for Architecture {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ApplicationState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let applicationstate = unimplemented!();
/// match applicationstate {
///     ApplicationState::Created => { /* ... */ },
///     ApplicationState::Creating => { /* ... */ },
///     ApplicationState::Started => { /* ... */ },
///     ApplicationState::Starting => { /* ... */ },
///     ApplicationState::Stopped => { /* ... */ },
///     ApplicationState::Stopping => { /* ... */ },
///     ApplicationState::Terminated => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `applicationstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ApplicationState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ApplicationState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ApplicationState::NewFeature` is defined.
/// Specifically, when `applicationstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ApplicationState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationState {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Terminated,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ApplicationState {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => ApplicationState::Created,
            "CREATING" => ApplicationState::Creating,
            "STARTED" => ApplicationState::Started,
            "STARTING" => ApplicationState::Starting,
            "STOPPED" => ApplicationState::Stopped,
            "STOPPING" => ApplicationState::Stopping,
            "TERMINATED" => ApplicationState::Terminated,
            other => ApplicationState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ApplicationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationState::from(s))
    }
}
impl ApplicationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationState::Created => "CREATED",
            ApplicationState::Creating => "CREATING",
            ApplicationState::Started => "STARTED",
            ApplicationState::Starting => "STARTING",
            ApplicationState::Stopped => "STOPPED",
            ApplicationState::Stopping => "STOPPING",
            ApplicationState::Terminated => "TERMINATED",
            ApplicationState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CREATED",
            "CREATING",
            "STARTED",
            "STARTING",
            "STOPPED",
            "STOPPING",
            "TERMINATED",
        ]
    }
}
impl AsRef<str> for ApplicationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The specifications for a worker type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkerTypeSpecificationInput {
    /// <p>The image configuration for a worker type.</p>
    #[doc(hidden)]
    pub image_configuration: std::option::Option<crate::model::ImageConfigurationInput>,
}
impl WorkerTypeSpecificationInput {
    /// <p>The image configuration for a worker type.</p>
    pub fn image_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ImageConfigurationInput> {
        self.image_configuration.as_ref()
    }
}
/// See [`WorkerTypeSpecificationInput`](crate::model::WorkerTypeSpecificationInput).
pub mod worker_type_specification_input {

    /// A builder for [`WorkerTypeSpecificationInput`](crate::model::WorkerTypeSpecificationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_configuration: std::option::Option<crate::model::ImageConfigurationInput>,
    }
    impl Builder {
        /// <p>The image configuration for a worker type.</p>
        pub fn image_configuration(mut self, input: crate::model::ImageConfigurationInput) -> Self {
            self.image_configuration = Some(input);
            self
        }
        /// <p>The image configuration for a worker type.</p>
        pub fn set_image_configuration(
            mut self,
            input: std::option::Option<crate::model::ImageConfigurationInput>,
        ) -> Self {
            self.image_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkerTypeSpecificationInput`](crate::model::WorkerTypeSpecificationInput).
        pub fn build(self) -> crate::model::WorkerTypeSpecificationInput {
            crate::model::WorkerTypeSpecificationInput {
                image_configuration: self.image_configuration,
            }
        }
    }
}
impl WorkerTypeSpecificationInput {
    /// Creates a new builder-style object to manufacture [`WorkerTypeSpecificationInput`](crate::model::WorkerTypeSpecificationInput).
    pub fn builder() -> crate::model::worker_type_specification_input::Builder {
        crate::model::worker_type_specification_input::Builder::default()
    }
}

/// <p>The image configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImageConfigurationInput {
    /// <p>The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.</p>
    #[doc(hidden)]
    pub image_uri: std::option::Option<std::string::String>,
}
impl ImageConfigurationInput {
    /// <p>The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.</p>
    pub fn image_uri(&self) -> std::option::Option<&str> {
        self.image_uri.as_deref()
    }
}
/// See [`ImageConfigurationInput`](crate::model::ImageConfigurationInput).
pub mod image_configuration_input {

    /// A builder for [`ImageConfigurationInput`](crate::model::ImageConfigurationInput).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        /// <p>The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.</p>
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageConfigurationInput`](crate::model::ImageConfigurationInput).
        pub fn build(self) -> crate::model::ImageConfigurationInput {
            crate::model::ImageConfigurationInput {
                image_uri: self.image_uri,
            }
        }
    }
}
impl ImageConfigurationInput {
    /// Creates a new builder-style object to manufacture [`ImageConfigurationInput`](crate::model::ImageConfigurationInput).
    pub fn builder() -> crate::model::image_configuration_input::Builder {
        crate::model::image_configuration_input::Builder::default()
    }
}

/// <p>The configuration for an application to automatically stop after a certain amount of time being idle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoStopConfig {
    /// <p>Enables the application to automatically stop after a certain amount of time being idle. Defaults to true.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
    /// <p>The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.</p>
    #[doc(hidden)]
    pub idle_timeout_minutes: std::option::Option<i32>,
}
impl AutoStopConfig {
    /// <p>Enables the application to automatically stop after a certain amount of time being idle. Defaults to true.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.</p>
    pub fn idle_timeout_minutes(&self) -> std::option::Option<i32> {
        self.idle_timeout_minutes
    }
}
/// See [`AutoStopConfig`](crate::model::AutoStopConfig).
pub mod auto_stop_config {

    /// A builder for [`AutoStopConfig`](crate::model::AutoStopConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) idle_timeout_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Enables the application to automatically stop after a certain amount of time being idle. Defaults to true.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Enables the application to automatically stop after a certain amount of time being idle. Defaults to true.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.</p>
        pub fn idle_timeout_minutes(mut self, input: i32) -> Self {
            self.idle_timeout_minutes = Some(input);
            self
        }
        /// <p>The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.</p>
        pub fn set_idle_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.idle_timeout_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoStopConfig`](crate::model::AutoStopConfig).
        pub fn build(self) -> crate::model::AutoStopConfig {
            crate::model::AutoStopConfig {
                enabled: self.enabled,
                idle_timeout_minutes: self.idle_timeout_minutes,
            }
        }
    }
}
impl AutoStopConfig {
    /// Creates a new builder-style object to manufacture [`AutoStopConfig`](crate::model::AutoStopConfig).
    pub fn builder() -> crate::model::auto_stop_config::Builder {
        crate::model::auto_stop_config::Builder::default()
    }
}

/// <p>The configuration for an application to automatically start on job submission.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AutoStartConfig {
    /// <p>Enables the application to automatically start on job submission. Defaults to true.</p>
    #[doc(hidden)]
    pub enabled: std::option::Option<bool>,
}
impl AutoStartConfig {
    /// <p>Enables the application to automatically start on job submission. Defaults to true.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
}
/// See [`AutoStartConfig`](crate::model::AutoStartConfig).
pub mod auto_start_config {

    /// A builder for [`AutoStartConfig`](crate::model::AutoStartConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Enables the application to automatically start on job submission. Defaults to true.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Enables the application to automatically start on job submission. Defaults to true.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoStartConfig`](crate::model::AutoStartConfig).
        pub fn build(self) -> crate::model::AutoStartConfig {
            crate::model::AutoStartConfig {
                enabled: self.enabled,
            }
        }
    }
}
impl AutoStartConfig {
    /// Creates a new builder-style object to manufacture [`AutoStartConfig`](crate::model::AutoStartConfig).
    pub fn builder() -> crate::model::auto_start_config::Builder {
        crate::model::auto_start_config::Builder::default()
    }
}

/// <p>The maximum allowed cumulative resources for an application. No new resources will be created once the limit is hit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumAllowedResources {
    /// <p>The maximum allowed CPU for an application.</p>
    #[doc(hidden)]
    pub cpu: std::option::Option<std::string::String>,
    /// <p>The maximum allowed resources for an application.</p>
    #[doc(hidden)]
    pub memory: std::option::Option<std::string::String>,
    /// <p>The maximum allowed disk for an application.</p>
    #[doc(hidden)]
    pub disk: std::option::Option<std::string::String>,
}
impl MaximumAllowedResources {
    /// <p>The maximum allowed CPU for an application.</p>
    pub fn cpu(&self) -> std::option::Option<&str> {
        self.cpu.as_deref()
    }
    /// <p>The maximum allowed resources for an application.</p>
    pub fn memory(&self) -> std::option::Option<&str> {
        self.memory.as_deref()
    }
    /// <p>The maximum allowed disk for an application.</p>
    pub fn disk(&self) -> std::option::Option<&str> {
        self.disk.as_deref()
    }
}
/// See [`MaximumAllowedResources`](crate::model::MaximumAllowedResources).
pub mod maximum_allowed_resources {

    /// A builder for [`MaximumAllowedResources`](crate::model::MaximumAllowedResources).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cpu: std::option::Option<std::string::String>,
        pub(crate) memory: std::option::Option<std::string::String>,
        pub(crate) disk: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum allowed CPU for an application.</p>
        pub fn cpu(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu = Some(input.into());
            self
        }
        /// <p>The maximum allowed CPU for an application.</p>
        pub fn set_cpu(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cpu = input;
            self
        }
        /// <p>The maximum allowed resources for an application.</p>
        pub fn memory(mut self, input: impl Into<std::string::String>) -> Self {
            self.memory = Some(input.into());
            self
        }
        /// <p>The maximum allowed resources for an application.</p>
        pub fn set_memory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.memory = input;
            self
        }
        /// <p>The maximum allowed disk for an application.</p>
        pub fn disk(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk = Some(input.into());
            self
        }
        /// <p>The maximum allowed disk for an application.</p>
        pub fn set_disk(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumAllowedResources`](crate::model::MaximumAllowedResources).
        pub fn build(self) -> crate::model::MaximumAllowedResources {
            crate::model::MaximumAllowedResources {
                cpu: self.cpu,
                memory: self.memory,
                disk: self.disk,
            }
        }
    }
}
impl MaximumAllowedResources {
    /// Creates a new builder-style object to manufacture [`MaximumAllowedResources`](crate::model::MaximumAllowedResources).
    pub fn builder() -> crate::model::maximum_allowed_resources::Builder {
        crate::model::maximum_allowed_resources::Builder::default()
    }
}

/// <p>The initial capacity configuration per worker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InitialCapacityConfig {
    /// <p>The number of workers in the initial capacity configuration.</p>
    #[doc(hidden)]
    pub worker_count: i64,
    /// <p>The resource configuration of the initial capacity configuration.</p>
    #[doc(hidden)]
    pub worker_configuration: std::option::Option<crate::model::WorkerResourceConfig>,
}
impl InitialCapacityConfig {
    /// <p>The number of workers in the initial capacity configuration.</p>
    pub fn worker_count(&self) -> i64 {
        self.worker_count
    }
    /// <p>The resource configuration of the initial capacity configuration.</p>
    pub fn worker_configuration(&self) -> std::option::Option<&crate::model::WorkerResourceConfig> {
        self.worker_configuration.as_ref()
    }
}
/// See [`InitialCapacityConfig`](crate::model::InitialCapacityConfig).
pub mod initial_capacity_config {

    /// A builder for [`InitialCapacityConfig`](crate::model::InitialCapacityConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) worker_count: std::option::Option<i64>,
        pub(crate) worker_configuration: std::option::Option<crate::model::WorkerResourceConfig>,
    }
    impl Builder {
        /// <p>The number of workers in the initial capacity configuration.</p>
        pub fn worker_count(mut self, input: i64) -> Self {
            self.worker_count = Some(input);
            self
        }
        /// <p>The number of workers in the initial capacity configuration.</p>
        pub fn set_worker_count(mut self, input: std::option::Option<i64>) -> Self {
            self.worker_count = input;
            self
        }
        /// <p>The resource configuration of the initial capacity configuration.</p>
        pub fn worker_configuration(mut self, input: crate::model::WorkerResourceConfig) -> Self {
            self.worker_configuration = Some(input);
            self
        }
        /// <p>The resource configuration of the initial capacity configuration.</p>
        pub fn set_worker_configuration(
            mut self,
            input: std::option::Option<crate::model::WorkerResourceConfig>,
        ) -> Self {
            self.worker_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`InitialCapacityConfig`](crate::model::InitialCapacityConfig).
        pub fn build(self) -> crate::model::InitialCapacityConfig {
            crate::model::InitialCapacityConfig {
                worker_count: self.worker_count.unwrap_or_default(),
                worker_configuration: self.worker_configuration,
            }
        }
    }
}
impl InitialCapacityConfig {
    /// Creates a new builder-style object to manufacture [`InitialCapacityConfig`](crate::model::InitialCapacityConfig).
    pub fn builder() -> crate::model::initial_capacity_config::Builder {
        crate::model::initial_capacity_config::Builder::default()
    }
}

/// <p>The cumulative configuration requirements for every worker instance of the worker type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkerResourceConfig {
    /// <p>The CPU requirements for every worker instance of the worker type.</p>
    #[doc(hidden)]
    pub cpu: std::option::Option<std::string::String>,
    /// <p>The memory requirements for every worker instance of the worker type.</p>
    #[doc(hidden)]
    pub memory: std::option::Option<std::string::String>,
    /// <p>The disk requirements for every worker instance of the worker type.</p>
    #[doc(hidden)]
    pub disk: std::option::Option<std::string::String>,
}
impl WorkerResourceConfig {
    /// <p>The CPU requirements for every worker instance of the worker type.</p>
    pub fn cpu(&self) -> std::option::Option<&str> {
        self.cpu.as_deref()
    }
    /// <p>The memory requirements for every worker instance of the worker type.</p>
    pub fn memory(&self) -> std::option::Option<&str> {
        self.memory.as_deref()
    }
    /// <p>The disk requirements for every worker instance of the worker type.</p>
    pub fn disk(&self) -> std::option::Option<&str> {
        self.disk.as_deref()
    }
}
/// See [`WorkerResourceConfig`](crate::model::WorkerResourceConfig).
pub mod worker_resource_config {

    /// A builder for [`WorkerResourceConfig`](crate::model::WorkerResourceConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cpu: std::option::Option<std::string::String>,
        pub(crate) memory: std::option::Option<std::string::String>,
        pub(crate) disk: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CPU requirements for every worker instance of the worker type.</p>
        pub fn cpu(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu = Some(input.into());
            self
        }
        /// <p>The CPU requirements for every worker instance of the worker type.</p>
        pub fn set_cpu(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cpu = input;
            self
        }
        /// <p>The memory requirements for every worker instance of the worker type.</p>
        pub fn memory(mut self, input: impl Into<std::string::String>) -> Self {
            self.memory = Some(input.into());
            self
        }
        /// <p>The memory requirements for every worker instance of the worker type.</p>
        pub fn set_memory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.memory = input;
            self
        }
        /// <p>The disk requirements for every worker instance of the worker type.</p>
        pub fn disk(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk = Some(input.into());
            self
        }
        /// <p>The disk requirements for every worker instance of the worker type.</p>
        pub fn set_disk(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkerResourceConfig`](crate::model::WorkerResourceConfig).
        pub fn build(self) -> crate::model::WorkerResourceConfig {
            crate::model::WorkerResourceConfig {
                cpu: self.cpu,
                memory: self.memory,
                disk: self.disk,
            }
        }
    }
}
impl WorkerResourceConfig {
    /// Creates a new builder-style object to manufacture [`WorkerResourceConfig`](crate::model::WorkerResourceConfig).
    pub fn builder() -> crate::model::worker_resource_config::Builder {
        crate::model::worker_resource_config::Builder::default()
    }
}

/// <p>Information about an application. EMR Serverless uses applications to run jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Application {
    /// <p>The ID of the application.</p>
    #[doc(hidden)]
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The name of the application.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of the application.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The EMR release associated with the application.</p>
    #[doc(hidden)]
    pub release_label: std::option::Option<std::string::String>,
    /// <p>The type of application, such as Spark or Hive.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The state of the application.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ApplicationState>,
    /// <p>The state details of the application.</p>
    #[doc(hidden)]
    pub state_details: std::option::Option<std::string::String>,
    /// <p>The initial capacity of the application.</p>
    #[doc(hidden)]
    pub initial_capacity: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::InitialCapacityConfig>,
    >,
    /// <p>The maximum capacity of the application. This is cumulative across all workers at any given point in time during the lifespan of the application is created. No new resources will be created once any one of the defined limits is hit.</p>
    #[doc(hidden)]
    pub maximum_capacity: std::option::Option<crate::model::MaximumAllowedResources>,
    /// <p>The date and time when the application run was created.</p>
    #[doc(hidden)]
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the application run was last updated.</p>
    #[doc(hidden)]
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The tags assigned to the application.</p>
    #[doc(hidden)]
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The configuration for an application to automatically start on job submission.</p>
    #[doc(hidden)]
    pub auto_start_configuration: std::option::Option<crate::model::AutoStartConfig>,
    /// <p>The configuration for an application to automatically stop after a certain amount of time being idle.</p>
    #[doc(hidden)]
    pub auto_stop_configuration: std::option::Option<crate::model::AutoStopConfig>,
    /// <p>The network configuration for customer VPC connectivity for the application.</p>
    #[doc(hidden)]
    pub network_configuration: std::option::Option<crate::model::NetworkConfiguration>,
    /// <p>The CPU architecture of an application.</p>
    #[doc(hidden)]
    pub architecture: std::option::Option<crate::model::Architecture>,
    /// <p>The image configuration applied to all worker types.</p>
    #[doc(hidden)]
    pub image_configuration: std::option::Option<crate::model::ImageConfiguration>,
    /// <p>The specification applied to each worker type.</p>
    #[doc(hidden)]
    pub worker_type_specifications: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::WorkerTypeSpecification>,
    >,
}
impl Application {
    /// <p>The ID of the application.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The name of the application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the application.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The EMR release associated with the application.</p>
    pub fn release_label(&self) -> std::option::Option<&str> {
        self.release_label.as_deref()
    }
    /// <p>The type of application, such as Spark or Hive.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The state of the application.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ApplicationState> {
        self.state.as_ref()
    }
    /// <p>The state details of the application.</p>
    pub fn state_details(&self) -> std::option::Option<&str> {
        self.state_details.as_deref()
    }
    /// <p>The initial capacity of the application.</p>
    pub fn initial_capacity(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::InitialCapacityConfig>,
    > {
        self.initial_capacity.as_ref()
    }
    /// <p>The maximum capacity of the application. This is cumulative across all workers at any given point in time during the lifespan of the application is created. No new resources will be created once any one of the defined limits is hit.</p>
    pub fn maximum_capacity(&self) -> std::option::Option<&crate::model::MaximumAllowedResources> {
        self.maximum_capacity.as_ref()
    }
    /// <p>The date and time when the application run was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time when the application run was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The tags assigned to the application.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The configuration for an application to automatically start on job submission.</p>
    pub fn auto_start_configuration(&self) -> std::option::Option<&crate::model::AutoStartConfig> {
        self.auto_start_configuration.as_ref()
    }
    /// <p>The configuration for an application to automatically stop after a certain amount of time being idle.</p>
    pub fn auto_stop_configuration(&self) -> std::option::Option<&crate::model::AutoStopConfig> {
        self.auto_stop_configuration.as_ref()
    }
    /// <p>The network configuration for customer VPC connectivity for the application.</p>
    pub fn network_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NetworkConfiguration> {
        self.network_configuration.as_ref()
    }
    /// <p>The CPU architecture of an application.</p>
    pub fn architecture(&self) -> std::option::Option<&crate::model::Architecture> {
        self.architecture.as_ref()
    }
    /// <p>The image configuration applied to all worker types.</p>
    pub fn image_configuration(&self) -> std::option::Option<&crate::model::ImageConfiguration> {
        self.image_configuration.as_ref()
    }
    /// <p>The specification applied to each worker type.</p>
    pub fn worker_type_specifications(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::WorkerTypeSpecification>,
    > {
        self.worker_type_specifications.as_ref()
    }
}
/// See [`Application`](crate::model::Application).
pub mod application {

    /// A builder for [`Application`](crate::model::Application).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) release_label: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ApplicationState>,
        pub(crate) state_details: std::option::Option<std::string::String>,
        pub(crate) initial_capacity: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::InitialCapacityConfig>,
        >,
        pub(crate) maximum_capacity: std::option::Option<crate::model::MaximumAllowedResources>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) auto_start_configuration: std::option::Option<crate::model::AutoStartConfig>,
        pub(crate) auto_stop_configuration: std::option::Option<crate::model::AutoStopConfig>,
        pub(crate) network_configuration: std::option::Option<crate::model::NetworkConfiguration>,
        pub(crate) architecture: std::option::Option<crate::model::Architecture>,
        pub(crate) image_configuration: std::option::Option<crate::model::ImageConfiguration>,
        pub(crate) worker_type_specifications: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::WorkerTypeSpecification>,
        >,
    }
    impl Builder {
        /// <p>The ID of the application.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The ID of the application.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The name of the application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The EMR release associated with the application.</p>
        pub fn release_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_label = Some(input.into());
            self
        }
        /// <p>The EMR release associated with the application.</p>
        pub fn set_release_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_label = input;
            self
        }
        /// <p>The type of application, such as Spark or Hive.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of application, such as Spark or Hive.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The state of the application.</p>
        pub fn state(mut self, input: crate::model::ApplicationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the application.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ApplicationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The state details of the application.</p>
        pub fn state_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_details = Some(input.into());
            self
        }
        /// <p>The state details of the application.</p>
        pub fn set_state_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_details = input;
            self
        }
        /// Adds a key-value pair to `initial_capacity`.
        ///
        /// To override the contents of this collection use [`set_initial_capacity`](Self::set_initial_capacity).
        ///
        /// <p>The initial capacity of the application.</p>
        pub fn initial_capacity(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::InitialCapacityConfig,
        ) -> Self {
            let mut hash_map = self.initial_capacity.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.initial_capacity = Some(hash_map);
            self
        }
        /// <p>The initial capacity of the application.</p>
        pub fn set_initial_capacity(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::InitialCapacityConfig>,
            >,
        ) -> Self {
            self.initial_capacity = input;
            self
        }
        /// <p>The maximum capacity of the application. This is cumulative across all workers at any given point in time during the lifespan of the application is created. No new resources will be created once any one of the defined limits is hit.</p>
        pub fn maximum_capacity(mut self, input: crate::model::MaximumAllowedResources) -> Self {
            self.maximum_capacity = Some(input);
            self
        }
        /// <p>The maximum capacity of the application. This is cumulative across all workers at any given point in time during the lifespan of the application is created. No new resources will be created once any one of the defined limits is hit.</p>
        pub fn set_maximum_capacity(
            mut self,
            input: std::option::Option<crate::model::MaximumAllowedResources>,
        ) -> Self {
            self.maximum_capacity = input;
            self
        }
        /// <p>The date and time when the application run was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time when the application run was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date and time when the application run was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time when the application run was last updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the application.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the application.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The configuration for an application to automatically start on job submission.</p>
        pub fn auto_start_configuration(mut self, input: crate::model::AutoStartConfig) -> Self {
            self.auto_start_configuration = Some(input);
            self
        }
        /// <p>The configuration for an application to automatically start on job submission.</p>
        pub fn set_auto_start_configuration(
            mut self,
            input: std::option::Option<crate::model::AutoStartConfig>,
        ) -> Self {
            self.auto_start_configuration = input;
            self
        }
        /// <p>The configuration for an application to automatically stop after a certain amount of time being idle.</p>
        pub fn auto_stop_configuration(mut self, input: crate::model::AutoStopConfig) -> Self {
            self.auto_stop_configuration = Some(input);
            self
        }
        /// <p>The configuration for an application to automatically stop after a certain amount of time being idle.</p>
        pub fn set_auto_stop_configuration(
            mut self,
            input: std::option::Option<crate::model::AutoStopConfig>,
        ) -> Self {
            self.auto_stop_configuration = input;
            self
        }
        /// <p>The network configuration for customer VPC connectivity for the application.</p>
        pub fn network_configuration(mut self, input: crate::model::NetworkConfiguration) -> Self {
            self.network_configuration = Some(input);
            self
        }
        /// <p>The network configuration for customer VPC connectivity for the application.</p>
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::NetworkConfiguration>,
        ) -> Self {
            self.network_configuration = input;
            self
        }
        /// <p>The CPU architecture of an application.</p>
        pub fn architecture(mut self, input: crate::model::Architecture) -> Self {
            self.architecture = Some(input);
            self
        }
        /// <p>The CPU architecture of an application.</p>
        pub fn set_architecture(
            mut self,
            input: std::option::Option<crate::model::Architecture>,
        ) -> Self {
            self.architecture = input;
            self
        }
        /// <p>The image configuration applied to all worker types.</p>
        pub fn image_configuration(mut self, input: crate::model::ImageConfiguration) -> Self {
            self.image_configuration = Some(input);
            self
        }
        /// <p>The image configuration applied to all worker types.</p>
        pub fn set_image_configuration(
            mut self,
            input: std::option::Option<crate::model::ImageConfiguration>,
        ) -> Self {
            self.image_configuration = input;
            self
        }
        /// Adds a key-value pair to `worker_type_specifications`.
        ///
        /// To override the contents of this collection use [`set_worker_type_specifications`](Self::set_worker_type_specifications).
        ///
        /// <p>The specification applied to each worker type.</p>
        pub fn worker_type_specifications(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::WorkerTypeSpecification,
        ) -> Self {
            let mut hash_map = self.worker_type_specifications.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.worker_type_specifications = Some(hash_map);
            self
        }
        /// <p>The specification applied to each worker type.</p>
        pub fn set_worker_type_specifications(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<
                    std::string::String,
                    crate::model::WorkerTypeSpecification,
                >,
            >,
        ) -> Self {
            self.worker_type_specifications = input;
            self
        }
        /// Consumes the builder and constructs a [`Application`](crate::model::Application).
        pub fn build(self) -> crate::model::Application {
            crate::model::Application {
                application_id: self.application_id,
                name: self.name,
                arn: self.arn,
                release_label: self.release_label,
                r#type: self.r#type,
                state: self.state,
                state_details: self.state_details,
                initial_capacity: self.initial_capacity,
                maximum_capacity: self.maximum_capacity,
                created_at: self.created_at,
                updated_at: self.updated_at,
                tags: self.tags,
                auto_start_configuration: self.auto_start_configuration,
                auto_stop_configuration: self.auto_stop_configuration,
                network_configuration: self.network_configuration,
                architecture: self.architecture,
                image_configuration: self.image_configuration,
                worker_type_specifications: self.worker_type_specifications,
            }
        }
    }
}
impl Application {
    /// Creates a new builder-style object to manufacture [`Application`](crate::model::Application).
    pub fn builder() -> crate::model::application::Builder {
        crate::model::application::Builder::default()
    }
}

/// <p>The specifications for a worker type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkerTypeSpecification {
    /// <p>The image configuration for a worker type.</p>
    #[doc(hidden)]
    pub image_configuration: std::option::Option<crate::model::ImageConfiguration>,
}
impl WorkerTypeSpecification {
    /// <p>The image configuration for a worker type.</p>
    pub fn image_configuration(&self) -> std::option::Option<&crate::model::ImageConfiguration> {
        self.image_configuration.as_ref()
    }
}
/// See [`WorkerTypeSpecification`](crate::model::WorkerTypeSpecification).
pub mod worker_type_specification {

    /// A builder for [`WorkerTypeSpecification`](crate::model::WorkerTypeSpecification).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_configuration: std::option::Option<crate::model::ImageConfiguration>,
    }
    impl Builder {
        /// <p>The image configuration for a worker type.</p>
        pub fn image_configuration(mut self, input: crate::model::ImageConfiguration) -> Self {
            self.image_configuration = Some(input);
            self
        }
        /// <p>The image configuration for a worker type.</p>
        pub fn set_image_configuration(
            mut self,
            input: std::option::Option<crate::model::ImageConfiguration>,
        ) -> Self {
            self.image_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkerTypeSpecification`](crate::model::WorkerTypeSpecification).
        pub fn build(self) -> crate::model::WorkerTypeSpecification {
            crate::model::WorkerTypeSpecification {
                image_configuration: self.image_configuration,
            }
        }
    }
}
impl WorkerTypeSpecification {
    /// Creates a new builder-style object to manufacture [`WorkerTypeSpecification`](crate::model::WorkerTypeSpecification).
    pub fn builder() -> crate::model::worker_type_specification::Builder {
        crate::model::worker_type_specification::Builder::default()
    }
}

/// <p>The applied image configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImageConfiguration {
    /// <p>The image URI.</p>
    #[doc(hidden)]
    pub image_uri: std::option::Option<std::string::String>,
    /// <p>The SHA256 digest of the image URI. This indicates which specific image the application is configured for. The image digest doesn't exist until an application has started.</p>
    #[doc(hidden)]
    pub resolved_image_digest: std::option::Option<std::string::String>,
}
impl ImageConfiguration {
    /// <p>The image URI.</p>
    pub fn image_uri(&self) -> std::option::Option<&str> {
        self.image_uri.as_deref()
    }
    /// <p>The SHA256 digest of the image URI. This indicates which specific image the application is configured for. The image digest doesn't exist until an application has started.</p>
    pub fn resolved_image_digest(&self) -> std::option::Option<&str> {
        self.resolved_image_digest.as_deref()
    }
}
/// See [`ImageConfiguration`](crate::model::ImageConfiguration).
pub mod image_configuration {

    /// A builder for [`ImageConfiguration`](crate::model::ImageConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_uri: std::option::Option<std::string::String>,
        pub(crate) resolved_image_digest: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The image URI.</p>
        pub fn image_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_uri = Some(input.into());
            self
        }
        /// <p>The image URI.</p>
        pub fn set_image_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_uri = input;
            self
        }
        /// <p>The SHA256 digest of the image URI. This indicates which specific image the application is configured for. The image digest doesn't exist until an application has started.</p>
        pub fn resolved_image_digest(mut self, input: impl Into<std::string::String>) -> Self {
            self.resolved_image_digest = Some(input.into());
            self
        }
        /// <p>The SHA256 digest of the image URI. This indicates which specific image the application is configured for. The image digest doesn't exist until an application has started.</p>
        pub fn set_resolved_image_digest(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resolved_image_digest = input;
            self
        }
        /// Consumes the builder and constructs a [`ImageConfiguration`](crate::model::ImageConfiguration).
        pub fn build(self) -> crate::model::ImageConfiguration {
            crate::model::ImageConfiguration {
                image_uri: self.image_uri,
                resolved_image_digest: self.resolved_image_digest,
            }
        }
    }
}
impl ImageConfiguration {
    /// Creates a new builder-style object to manufacture [`ImageConfiguration`](crate::model::ImageConfiguration).
    pub fn builder() -> crate::model::image_configuration::Builder {
        crate::model::image_configuration::Builder::default()
    }
}
