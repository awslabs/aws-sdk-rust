// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The summary of attributes associated with a job run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JobRunSummary {
    /// <p>The ID of the application the job is running on.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The ID of the job run.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The optional job run name. This doesn't have to be unique.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of the job run.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The user who created the job run.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the job run was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the job run was last updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The execution role ARN of the job run.</p>
    pub execution_role: std::option::Option<std::string::String>,
    /// <p>The state of the job run.</p>
    pub state: std::option::Option<crate::model::JobRunState>,
    /// <p>The state details of the job run.</p>
    pub state_details: std::option::Option<std::string::String>,
    /// <p>The EMR release version associated with the application your job is running on.</p>
    pub release_label: std::option::Option<std::string::String>,
    /// <p>The type of job run, such as Spark or Hive.</p>
    pub r#type: std::option::Option<std::string::String>,
}
impl JobRunSummary {
    /// <p>The ID of the application the job is running on.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The ID of the job run.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The optional job run name. This doesn't have to be unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the job run.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The user who created the job run.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The date and time when the job run was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time when the job run was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The execution role ARN of the job run.</p>
    pub fn execution_role(&self) -> std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>The state of the job run.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::JobRunState> {
        self.state.as_ref()
    }
    /// <p>The state details of the job run.</p>
    pub fn state_details(&self) -> std::option::Option<&str> {
        self.state_details.as_deref()
    }
    /// <p>The EMR release version associated with the application your job is running on.</p>
    pub fn release_label(&self) -> std::option::Option<&str> {
        self.release_label.as_deref()
    }
    /// <p>The type of job run, such as Spark or Hive.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
}
impl std::fmt::Debug for JobRunSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JobRunSummary");
        formatter.field("application_id", &self.application_id);
        formatter.field("id", &self.id);
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("created_by", &self.created_by);
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("execution_role", &self.execution_role);
        formatter.field("state", &self.state);
        formatter.field("state_details", &self.state_details);
        formatter.field("release_label", &self.release_label);
        formatter.field("r#type", &self.r#type);
        formatter.finish()
    }
}
/// See [`JobRunSummary`](crate::model::JobRunSummary)
pub mod job_run_summary {

    /// A builder for [`JobRunSummary`](crate::model::JobRunSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) execution_role: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::JobRunState>,
        pub(crate) state_details: std::option::Option<std::string::String>,
        pub(crate) release_label: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the application the job is running on.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The ID of the application the job is running on.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The ID of the job run.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the job run.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The optional job run name. This doesn't have to be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The optional job run name. This doesn't have to be unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of the job run.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the job run.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The user who created the job run.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user who created the job run.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The date and time when the job run was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time when the job run was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date and time when the job run was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time when the job run was last updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role = Some(input.into());
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn set_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role = input;
            self
        }
        /// <p>The state of the job run.</p>
        pub fn state(mut self, input: crate::model::JobRunState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the job run.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::JobRunState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The state details of the job run.</p>
        pub fn state_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_details = Some(input.into());
            self
        }
        /// <p>The state details of the job run.</p>
        pub fn set_state_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_details = input;
            self
        }
        /// <p>The EMR release version associated with the application your job is running on.</p>
        pub fn release_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_label = Some(input.into());
            self
        }
        /// <p>The EMR release version associated with the application your job is running on.</p>
        pub fn set_release_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_label = input;
            self
        }
        /// <p>The type of job run, such as Spark or Hive.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of job run, such as Spark or Hive.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`JobRunSummary`](crate::model::JobRunSummary)
        pub fn build(self) -> crate::model::JobRunSummary {
            crate::model::JobRunSummary {
                application_id: self.application_id,
                id: self.id,
                name: self.name,
                arn: self.arn,
                created_by: self.created_by,
                created_at: self.created_at,
                updated_at: self.updated_at,
                execution_role: self.execution_role,
                state: self.state,
                state_details: self.state_details,
                release_label: self.release_label,
                r#type: self.r#type,
            }
        }
    }
}
impl JobRunSummary {
    /// Creates a new builder-style object to manufacture [`JobRunSummary`](crate::model::JobRunSummary)
    pub fn builder() -> crate::model::job_run_summary::Builder {
        crate::model::job_run_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum JobRunState {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Cancelling,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Scheduled,
    #[allow(missing_docs)] // documentation missing in model
    Submitted,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for JobRunState {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => JobRunState::Cancelled,
            "CANCELLING" => JobRunState::Cancelling,
            "FAILED" => JobRunState::Failed,
            "PENDING" => JobRunState::Pending,
            "RUNNING" => JobRunState::Running,
            "SCHEDULED" => JobRunState::Scheduled,
            "SUBMITTED" => JobRunState::Submitted,
            "SUCCESS" => JobRunState::Success,
            other => JobRunState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for JobRunState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(JobRunState::from(s))
    }
}
impl JobRunState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            JobRunState::Cancelled => "CANCELLED",
            JobRunState::Cancelling => "CANCELLING",
            JobRunState::Failed => "FAILED",
            JobRunState::Pending => "PENDING",
            JobRunState::Running => "RUNNING",
            JobRunState::Scheduled => "SCHEDULED",
            JobRunState::Submitted => "SUBMITTED",
            JobRunState::Success => "SUCCESS",
            JobRunState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "CANCELLING",
            "FAILED",
            "PENDING",
            "RUNNING",
            "SCHEDULED",
            "SUBMITTED",
            "SUCCESS",
        ]
    }
}
impl AsRef<str> for JobRunState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A configuration specification to be used to override existing configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConfigurationOverrides {
    /// <p>The override configurations for the application.</p>
    pub application_configuration: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
    /// <p>The override configurations for monitoring.</p>
    pub monitoring_configuration: std::option::Option<crate::model::MonitoringConfiguration>,
}
impl ConfigurationOverrides {
    /// <p>The override configurations for the application.</p>
    pub fn application_configuration(&self) -> std::option::Option<&[crate::model::Configuration]> {
        self.application_configuration.as_deref()
    }
    /// <p>The override configurations for monitoring.</p>
    pub fn monitoring_configuration(
        &self,
    ) -> std::option::Option<&crate::model::MonitoringConfiguration> {
        self.monitoring_configuration.as_ref()
    }
}
impl std::fmt::Debug for ConfigurationOverrides {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConfigurationOverrides");
        formatter.field("application_configuration", &self.application_configuration);
        formatter.field("monitoring_configuration", &self.monitoring_configuration);
        formatter.finish()
    }
}
/// See [`ConfigurationOverrides`](crate::model::ConfigurationOverrides)
pub mod configuration_overrides {

    /// A builder for [`ConfigurationOverrides`](crate::model::ConfigurationOverrides)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_configuration:
            std::option::Option<std::vec::Vec<crate::model::Configuration>>,
        pub(crate) monitoring_configuration:
            std::option::Option<crate::model::MonitoringConfiguration>,
    }
    impl Builder {
        /// Appends an item to `application_configuration`.
        ///
        /// To override the contents of this collection use [`set_application_configuration`](Self::set_application_configuration).
        ///
        /// <p>The override configurations for the application.</p>
        pub fn application_configuration(mut self, input: crate::model::Configuration) -> Self {
            let mut v = self.application_configuration.unwrap_or_default();
            v.push(input);
            self.application_configuration = Some(v);
            self
        }
        /// <p>The override configurations for the application.</p>
        pub fn set_application_configuration(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
        ) -> Self {
            self.application_configuration = input;
            self
        }
        /// <p>The override configurations for monitoring.</p>
        pub fn monitoring_configuration(
            mut self,
            input: crate::model::MonitoringConfiguration,
        ) -> Self {
            self.monitoring_configuration = Some(input);
            self
        }
        /// <p>The override configurations for monitoring.</p>
        pub fn set_monitoring_configuration(
            mut self,
            input: std::option::Option<crate::model::MonitoringConfiguration>,
        ) -> Self {
            self.monitoring_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`ConfigurationOverrides`](crate::model::ConfigurationOverrides)
        pub fn build(self) -> crate::model::ConfigurationOverrides {
            crate::model::ConfigurationOverrides {
                application_configuration: self.application_configuration,
                monitoring_configuration: self.monitoring_configuration,
            }
        }
    }
}
impl ConfigurationOverrides {
    /// Creates a new builder-style object to manufacture [`ConfigurationOverrides`](crate::model::ConfigurationOverrides)
    pub fn builder() -> crate::model::configuration_overrides::Builder {
        crate::model::configuration_overrides::Builder::default()
    }
}

/// <p>The configuration setting for monitoring.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MonitoringConfiguration {
    /// <p>The Amazon S3 configuration for monitoring log publishing.</p>
    pub s3_monitoring_configuration: std::option::Option<crate::model::S3MonitoringConfiguration>,
    /// <p>The managed log persistence configuration for a job run.</p>
    pub managed_persistence_monitoring_configuration:
        std::option::Option<crate::model::ManagedPersistenceMonitoringConfiguration>,
}
impl MonitoringConfiguration {
    /// <p>The Amazon S3 configuration for monitoring log publishing.</p>
    pub fn s3_monitoring_configuration(
        &self,
    ) -> std::option::Option<&crate::model::S3MonitoringConfiguration> {
        self.s3_monitoring_configuration.as_ref()
    }
    /// <p>The managed log persistence configuration for a job run.</p>
    pub fn managed_persistence_monitoring_configuration(
        &self,
    ) -> std::option::Option<&crate::model::ManagedPersistenceMonitoringConfiguration> {
        self.managed_persistence_monitoring_configuration.as_ref()
    }
}
impl std::fmt::Debug for MonitoringConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MonitoringConfiguration");
        formatter.field(
            "s3_monitoring_configuration",
            &self.s3_monitoring_configuration,
        );
        formatter.field(
            "managed_persistence_monitoring_configuration",
            &self.managed_persistence_monitoring_configuration,
        );
        formatter.finish()
    }
}
/// See [`MonitoringConfiguration`](crate::model::MonitoringConfiguration)
pub mod monitoring_configuration {

    /// A builder for [`MonitoringConfiguration`](crate::model::MonitoringConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) s3_monitoring_configuration:
            std::option::Option<crate::model::S3MonitoringConfiguration>,
        pub(crate) managed_persistence_monitoring_configuration:
            std::option::Option<crate::model::ManagedPersistenceMonitoringConfiguration>,
    }
    impl Builder {
        /// <p>The Amazon S3 configuration for monitoring log publishing.</p>
        pub fn s3_monitoring_configuration(
            mut self,
            input: crate::model::S3MonitoringConfiguration,
        ) -> Self {
            self.s3_monitoring_configuration = Some(input);
            self
        }
        /// <p>The Amazon S3 configuration for monitoring log publishing.</p>
        pub fn set_s3_monitoring_configuration(
            mut self,
            input: std::option::Option<crate::model::S3MonitoringConfiguration>,
        ) -> Self {
            self.s3_monitoring_configuration = input;
            self
        }
        /// <p>The managed log persistence configuration for a job run.</p>
        pub fn managed_persistence_monitoring_configuration(
            mut self,
            input: crate::model::ManagedPersistenceMonitoringConfiguration,
        ) -> Self {
            self.managed_persistence_monitoring_configuration = Some(input);
            self
        }
        /// <p>The managed log persistence configuration for a job run.</p>
        pub fn set_managed_persistence_monitoring_configuration(
            mut self,
            input: std::option::Option<crate::model::ManagedPersistenceMonitoringConfiguration>,
        ) -> Self {
            self.managed_persistence_monitoring_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`MonitoringConfiguration`](crate::model::MonitoringConfiguration)
        pub fn build(self) -> crate::model::MonitoringConfiguration {
            crate::model::MonitoringConfiguration {
                s3_monitoring_configuration: self.s3_monitoring_configuration,
                managed_persistence_monitoring_configuration: self
                    .managed_persistence_monitoring_configuration,
            }
        }
    }
}
impl MonitoringConfiguration {
    /// Creates a new builder-style object to manufacture [`MonitoringConfiguration`](crate::model::MonitoringConfiguration)
    pub fn builder() -> crate::model::monitoring_configuration::Builder {
        crate::model::monitoring_configuration::Builder::default()
    }
}

/// <p>The managed log persistence configuration for a job run.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManagedPersistenceMonitoringConfiguration {
    /// <p>Enables managed logging and defaults to true. If set to false, managed logging will be turned off.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>The KMS key ARN to encrypt the logs stored in managed log persistence.</p>
    pub encryption_key_arn: std::option::Option<std::string::String>,
}
impl ManagedPersistenceMonitoringConfiguration {
    /// <p>Enables managed logging and defaults to true. If set to false, managed logging will be turned off.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The KMS key ARN to encrypt the logs stored in managed log persistence.</p>
    pub fn encryption_key_arn(&self) -> std::option::Option<&str> {
        self.encryption_key_arn.as_deref()
    }
}
impl std::fmt::Debug for ManagedPersistenceMonitoringConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManagedPersistenceMonitoringConfiguration");
        formatter.field("enabled", &self.enabled);
        formatter.field("encryption_key_arn", &self.encryption_key_arn);
        formatter.finish()
    }
}
/// See [`ManagedPersistenceMonitoringConfiguration`](crate::model::ManagedPersistenceMonitoringConfiguration)
pub mod managed_persistence_monitoring_configuration {

    /// A builder for [`ManagedPersistenceMonitoringConfiguration`](crate::model::ManagedPersistenceMonitoringConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) encryption_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Enables managed logging and defaults to true. If set to false, managed logging will be turned off.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Enables managed logging and defaults to true. If set to false, managed logging will be turned off.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The KMS key ARN to encrypt the logs stored in managed log persistence.</p>
        pub fn encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_key_arn = Some(input.into());
            self
        }
        /// <p>The KMS key ARN to encrypt the logs stored in managed log persistence.</p>
        pub fn set_encryption_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`ManagedPersistenceMonitoringConfiguration`](crate::model::ManagedPersistenceMonitoringConfiguration)
        pub fn build(self) -> crate::model::ManagedPersistenceMonitoringConfiguration {
            crate::model::ManagedPersistenceMonitoringConfiguration {
                enabled: self.enabled,
                encryption_key_arn: self.encryption_key_arn,
            }
        }
    }
}
impl ManagedPersistenceMonitoringConfiguration {
    /// Creates a new builder-style object to manufacture [`ManagedPersistenceMonitoringConfiguration`](crate::model::ManagedPersistenceMonitoringConfiguration)
    pub fn builder() -> crate::model::managed_persistence_monitoring_configuration::Builder {
        crate::model::managed_persistence_monitoring_configuration::Builder::default()
    }
}

/// <p>The Amazon S3 configuration for monitoring log publishing. You can configure your jobs to send log information to Amazon S3.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct S3MonitoringConfiguration {
    /// <p>The Amazon S3 destination URI for log publishing.</p>
    pub log_uri: std::option::Option<std::string::String>,
    /// <p>The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.</p>
    pub encryption_key_arn: std::option::Option<std::string::String>,
}
impl S3MonitoringConfiguration {
    /// <p>The Amazon S3 destination URI for log publishing.</p>
    pub fn log_uri(&self) -> std::option::Option<&str> {
        self.log_uri.as_deref()
    }
    /// <p>The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.</p>
    pub fn encryption_key_arn(&self) -> std::option::Option<&str> {
        self.encryption_key_arn.as_deref()
    }
}
impl std::fmt::Debug for S3MonitoringConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("S3MonitoringConfiguration");
        formatter.field("log_uri", &self.log_uri);
        formatter.field("encryption_key_arn", &self.encryption_key_arn);
        formatter.finish()
    }
}
/// See [`S3MonitoringConfiguration`](crate::model::S3MonitoringConfiguration)
pub mod s3_monitoring_configuration {

    /// A builder for [`S3MonitoringConfiguration`](crate::model::S3MonitoringConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) log_uri: std::option::Option<std::string::String>,
        pub(crate) encryption_key_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon S3 destination URI for log publishing.</p>
        pub fn log_uri(mut self, input: impl Into<std::string::String>) -> Self {
            self.log_uri = Some(input.into());
            self
        }
        /// <p>The Amazon S3 destination URI for log publishing.</p>
        pub fn set_log_uri(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.log_uri = input;
            self
        }
        /// <p>The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.</p>
        pub fn encryption_key_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.encryption_key_arn = Some(input.into());
            self
        }
        /// <p>The KMS key ARN to encrypt the logs published to the given Amazon S3 destination.</p>
        pub fn set_encryption_key_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.encryption_key_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`S3MonitoringConfiguration`](crate::model::S3MonitoringConfiguration)
        pub fn build(self) -> crate::model::S3MonitoringConfiguration {
            crate::model::S3MonitoringConfiguration {
                log_uri: self.log_uri,
                encryption_key_arn: self.encryption_key_arn,
            }
        }
    }
}
impl S3MonitoringConfiguration {
    /// Creates a new builder-style object to manufacture [`S3MonitoringConfiguration`](crate::model::S3MonitoringConfiguration)
    pub fn builder() -> crate::model::s3_monitoring_configuration::Builder {
        crate::model::s3_monitoring_configuration::Builder::default()
    }
}

/// <p>A configuration specification to be used when provisioning an application. A configuration consists of a classification, properties, and optional nested configurations. A classification refers to an application-specific configuration file. Properties are the settings you want to change in that file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Configuration {
    /// <p>The classification within a configuration.</p>
    pub classification: std::option::Option<std::string::String>,
    /// <p>A set of properties specified within a configuration classification.</p>
    pub properties:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>A list of additional configurations to apply within a configuration object.</p>
    pub configurations: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
}
impl Configuration {
    /// <p>The classification within a configuration.</p>
    pub fn classification(&self) -> std::option::Option<&str> {
        self.classification.as_deref()
    }
    /// <p>A set of properties specified within a configuration classification.</p>
    pub fn properties(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.properties.as_ref()
    }
    /// <p>A list of additional configurations to apply within a configuration object.</p>
    pub fn configurations(&self) -> std::option::Option<&[crate::model::Configuration]> {
        self.configurations.as_deref()
    }
}
impl std::fmt::Debug for Configuration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Configuration");
        formatter.field("classification", &self.classification);
        formatter.field("properties", &"*** Sensitive Data Redacted ***");
        formatter.field("configurations", &self.configurations);
        formatter.finish()
    }
}
/// See [`Configuration`](crate::model::Configuration)
pub mod configuration {

    /// A builder for [`Configuration`](crate::model::Configuration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) classification: std::option::Option<std::string::String>,
        pub(crate) properties: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) configurations: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
    }
    impl Builder {
        /// <p>The classification within a configuration.</p>
        pub fn classification(mut self, input: impl Into<std::string::String>) -> Self {
            self.classification = Some(input.into());
            self
        }
        /// <p>The classification within a configuration.</p>
        pub fn set_classification(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.classification = input;
            self
        }
        /// Adds a key-value pair to `properties`.
        ///
        /// To override the contents of this collection use [`set_properties`](Self::set_properties).
        ///
        /// <p>A set of properties specified within a configuration classification.</p>
        pub fn properties(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.properties.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.properties = Some(hash_map);
            self
        }
        /// <p>A set of properties specified within a configuration classification.</p>
        pub fn set_properties(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.properties = input;
            self
        }
        /// Appends an item to `configurations`.
        ///
        /// To override the contents of this collection use [`set_configurations`](Self::set_configurations).
        ///
        /// <p>A list of additional configurations to apply within a configuration object.</p>
        pub fn configurations(mut self, input: crate::model::Configuration) -> Self {
            let mut v = self.configurations.unwrap_or_default();
            v.push(input);
            self.configurations = Some(v);
            self
        }
        /// <p>A list of additional configurations to apply within a configuration object.</p>
        pub fn set_configurations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Configuration>>,
        ) -> Self {
            self.configurations = input;
            self
        }
        /// Consumes the builder and constructs a [`Configuration`](crate::model::Configuration)
        pub fn build(self) -> crate::model::Configuration {
            crate::model::Configuration {
                classification: self.classification,
                properties: self.properties,
                configurations: self.configurations,
            }
        }
    }
}
impl Configuration {
    /// Creates a new builder-style object to manufacture [`Configuration`](crate::model::Configuration)
    pub fn builder() -> crate::model::configuration::Builder {
        crate::model::configuration::Builder::default()
    }
}

/// <p>The driver that the job runs on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum JobDriver {
    /// <p>The job driver parameters specified for Hive.</p>
    Hive(crate::model::Hive),
    /// <p>The job driver parameters specified for Spark.</p>
    SparkSubmit(crate::model::SparkSubmit),
    /// The `Unknown` variant represents cases where new union variant was received. Consider upgrading the SDK to the latest available version.
    /// An unknown enum variant
    ///
    /// _Note: If you encounter this error, consider upgrading your SDK to the latest version._
    /// The `Unknown` variant represents cases where the server sent a value that wasn't recognized
    /// by the client. This can happen when the server adds new functionality, but the client has not been updated.
    /// To investigate this, consider turning on debug logging to print the raw HTTP response.
    #[non_exhaustive]
    Unknown,
}
impl JobDriver {
    /// Tries to convert the enum instance into [`Hive`](crate::model::JobDriver::Hive), extracting the inner [`Hive`](crate::model::Hive).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_hive(&self) -> std::result::Result<&crate::model::Hive, &Self> {
        if let JobDriver::Hive(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`Hive`](crate::model::JobDriver::Hive).
    pub fn is_hive(&self) -> bool {
        self.as_hive().is_ok()
    }
    /// Tries to convert the enum instance into [`SparkSubmit`](crate::model::JobDriver::SparkSubmit), extracting the inner [`SparkSubmit`](crate::model::SparkSubmit).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_spark_submit(&self) -> std::result::Result<&crate::model::SparkSubmit, &Self> {
        if let JobDriver::SparkSubmit(val) = &self {
            Ok(val)
        } else {
            Err(self)
        }
    }
    /// Returns true if this is a [`SparkSubmit`](crate::model::JobDriver::SparkSubmit).
    pub fn is_spark_submit(&self) -> bool {
        self.as_spark_submit().is_ok()
    }
    /// Returns true if the enum instance is the `Unknown` variant.
    pub fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown)
    }
}

/// <p>The configurations for the Hive job driver.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Hive {
    /// <p>The query for the Hive job run.</p>
    pub query: std::option::Option<std::string::String>,
    /// <p>The query file for the Hive job run.</p>
    pub init_query_file: std::option::Option<std::string::String>,
    /// <p>The parameters for the Hive job run.</p>
    pub parameters: std::option::Option<std::string::String>,
}
impl Hive {
    /// <p>The query for the Hive job run.</p>
    pub fn query(&self) -> std::option::Option<&str> {
        self.query.as_deref()
    }
    /// <p>The query file for the Hive job run.</p>
    pub fn init_query_file(&self) -> std::option::Option<&str> {
        self.init_query_file.as_deref()
    }
    /// <p>The parameters for the Hive job run.</p>
    pub fn parameters(&self) -> std::option::Option<&str> {
        self.parameters.as_deref()
    }
}
impl std::fmt::Debug for Hive {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Hive");
        formatter.field("query", &"*** Sensitive Data Redacted ***");
        formatter.field("init_query_file", &"*** Sensitive Data Redacted ***");
        formatter.field("parameters", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`Hive`](crate::model::Hive)
pub mod hive {

    /// A builder for [`Hive`](crate::model::Hive)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) query: std::option::Option<std::string::String>,
        pub(crate) init_query_file: std::option::Option<std::string::String>,
        pub(crate) parameters: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The query for the Hive job run.</p>
        pub fn query(mut self, input: impl Into<std::string::String>) -> Self {
            self.query = Some(input.into());
            self
        }
        /// <p>The query for the Hive job run.</p>
        pub fn set_query(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.query = input;
            self
        }
        /// <p>The query file for the Hive job run.</p>
        pub fn init_query_file(mut self, input: impl Into<std::string::String>) -> Self {
            self.init_query_file = Some(input.into());
            self
        }
        /// <p>The query file for the Hive job run.</p>
        pub fn set_init_query_file(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.init_query_file = input;
            self
        }
        /// <p>The parameters for the Hive job run.</p>
        pub fn parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.parameters = Some(input.into());
            self
        }
        /// <p>The parameters for the Hive job run.</p>
        pub fn set_parameters(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`Hive`](crate::model::Hive)
        pub fn build(self) -> crate::model::Hive {
            crate::model::Hive {
                query: self.query,
                init_query_file: self.init_query_file,
                parameters: self.parameters,
            }
        }
    }
}
impl Hive {
    /// Creates a new builder-style object to manufacture [`Hive`](crate::model::Hive)
    pub fn builder() -> crate::model::hive::Builder {
        crate::model::hive::Builder::default()
    }
}

/// <p>The configurations for the Spark submit job driver.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SparkSubmit {
    /// <p>The entry point for the Spark submit job run.</p>
    pub entry_point: std::option::Option<std::string::String>,
    /// <p>The arguments for the Spark submit job run.</p>
    pub entry_point_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The parameters for the Spark submit job run.</p>
    pub spark_submit_parameters: std::option::Option<std::string::String>,
}
impl SparkSubmit {
    /// <p>The entry point for the Spark submit job run.</p>
    pub fn entry_point(&self) -> std::option::Option<&str> {
        self.entry_point.as_deref()
    }
    /// <p>The arguments for the Spark submit job run.</p>
    pub fn entry_point_arguments(&self) -> std::option::Option<&[std::string::String]> {
        self.entry_point_arguments.as_deref()
    }
    /// <p>The parameters for the Spark submit job run.</p>
    pub fn spark_submit_parameters(&self) -> std::option::Option<&str> {
        self.spark_submit_parameters.as_deref()
    }
}
impl std::fmt::Debug for SparkSubmit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SparkSubmit");
        formatter.field("entry_point", &"*** Sensitive Data Redacted ***");
        formatter.field("entry_point_arguments", &self.entry_point_arguments);
        formatter.field(
            "spark_submit_parameters",
            &"*** Sensitive Data Redacted ***",
        );
        formatter.finish()
    }
}
/// See [`SparkSubmit`](crate::model::SparkSubmit)
pub mod spark_submit {

    /// A builder for [`SparkSubmit`](crate::model::SparkSubmit)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entry_point: std::option::Option<std::string::String>,
        pub(crate) entry_point_arguments: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) spark_submit_parameters: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The entry point for the Spark submit job run.</p>
        pub fn entry_point(mut self, input: impl Into<std::string::String>) -> Self {
            self.entry_point = Some(input.into());
            self
        }
        /// <p>The entry point for the Spark submit job run.</p>
        pub fn set_entry_point(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.entry_point = input;
            self
        }
        /// Appends an item to `entry_point_arguments`.
        ///
        /// To override the contents of this collection use [`set_entry_point_arguments`](Self::set_entry_point_arguments).
        ///
        /// <p>The arguments for the Spark submit job run.</p>
        pub fn entry_point_arguments(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.entry_point_arguments.unwrap_or_default();
            v.push(input.into());
            self.entry_point_arguments = Some(v);
            self
        }
        /// <p>The arguments for the Spark submit job run.</p>
        pub fn set_entry_point_arguments(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.entry_point_arguments = input;
            self
        }
        /// <p>The parameters for the Spark submit job run.</p>
        pub fn spark_submit_parameters(mut self, input: impl Into<std::string::String>) -> Self {
            self.spark_submit_parameters = Some(input.into());
            self
        }
        /// <p>The parameters for the Spark submit job run.</p>
        pub fn set_spark_submit_parameters(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.spark_submit_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`SparkSubmit`](crate::model::SparkSubmit)
        pub fn build(self) -> crate::model::SparkSubmit {
            crate::model::SparkSubmit {
                entry_point: self.entry_point,
                entry_point_arguments: self.entry_point_arguments,
                spark_submit_parameters: self.spark_submit_parameters,
            }
        }
    }
}
impl SparkSubmit {
    /// Creates a new builder-style object to manufacture [`SparkSubmit`](crate::model::SparkSubmit)
    pub fn builder() -> crate::model::spark_submit::Builder {
        crate::model::spark_submit::Builder::default()
    }
}

/// <p>Information about a job run. A job run is a unit of work, such as a Spark JAR, Hive query, or SparkSQL query, that you submit to an EMR Serverless application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct JobRun {
    /// <p>The ID of the application the job is running on.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The ID of the job run.</p>
    pub job_run_id: std::option::Option<std::string::String>,
    /// <p>The optional job run name. This doesn't have to be unique.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The execution role ARN of the job run.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The user who created the job run.</p>
    pub created_by: std::option::Option<std::string::String>,
    /// <p>The date and time when the job run was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the job run was updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The execution role ARN of the job run.</p>
    pub execution_role: std::option::Option<std::string::String>,
    /// <p>The state of the job run.</p>
    pub state: std::option::Option<crate::model::JobRunState>,
    /// <p>The state details of the job run.</p>
    pub state_details: std::option::Option<std::string::String>,
    /// <p>The EMR release version associated with the application your job is running on.</p>
    pub release_label: std::option::Option<std::string::String>,
    /// <p>The configuration settings that are used to override default configuration.</p>
    pub configuration_overrides: std::option::Option<crate::model::ConfigurationOverrides>,
    /// <p>The job driver for the job run.</p>
    pub job_driver: std::option::Option<crate::model::JobDriver>,
    /// <p>The tags assigned to the job run.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.</p>
    pub total_resource_utilization: std::option::Option<crate::model::TotalResourceUtilization>,
    /// <p>The network configuration for customer VPC connectivity.</p>
    pub network_configuration: std::option::Option<crate::model::NetworkConfiguration>,
    /// <p>The job run total execution duration in seconds. This field is only available for job runs in a <code>COMPLETED</code>, <code>FAILED</code>, or <code>CANCELLED</code> state.</p>
    pub total_execution_duration_seconds: std::option::Option<i32>,
}
impl JobRun {
    /// <p>The ID of the application the job is running on.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The ID of the job run.</p>
    pub fn job_run_id(&self) -> std::option::Option<&str> {
        self.job_run_id.as_deref()
    }
    /// <p>The optional job run name. This doesn't have to be unique.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The execution role ARN of the job run.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The user who created the job run.</p>
    pub fn created_by(&self) -> std::option::Option<&str> {
        self.created_by.as_deref()
    }
    /// <p>The date and time when the job run was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time when the job run was updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The execution role ARN of the job run.</p>
    pub fn execution_role(&self) -> std::option::Option<&str> {
        self.execution_role.as_deref()
    }
    /// <p>The state of the job run.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::JobRunState> {
        self.state.as_ref()
    }
    /// <p>The state details of the job run.</p>
    pub fn state_details(&self) -> std::option::Option<&str> {
        self.state_details.as_deref()
    }
    /// <p>The EMR release version associated with the application your job is running on.</p>
    pub fn release_label(&self) -> std::option::Option<&str> {
        self.release_label.as_deref()
    }
    /// <p>The configuration settings that are used to override default configuration.</p>
    pub fn configuration_overrides(
        &self,
    ) -> std::option::Option<&crate::model::ConfigurationOverrides> {
        self.configuration_overrides.as_ref()
    }
    /// <p>The job driver for the job run.</p>
    pub fn job_driver(&self) -> std::option::Option<&crate::model::JobDriver> {
        self.job_driver.as_ref()
    }
    /// <p>The tags assigned to the job run.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.</p>
    pub fn total_resource_utilization(
        &self,
    ) -> std::option::Option<&crate::model::TotalResourceUtilization> {
        self.total_resource_utilization.as_ref()
    }
    /// <p>The network configuration for customer VPC connectivity.</p>
    pub fn network_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NetworkConfiguration> {
        self.network_configuration.as_ref()
    }
    /// <p>The job run total execution duration in seconds. This field is only available for job runs in a <code>COMPLETED</code>, <code>FAILED</code>, or <code>CANCELLED</code> state.</p>
    pub fn total_execution_duration_seconds(&self) -> std::option::Option<i32> {
        self.total_execution_duration_seconds
    }
}
impl std::fmt::Debug for JobRun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("JobRun");
        formatter.field("application_id", &self.application_id);
        formatter.field("job_run_id", &self.job_run_id);
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("created_by", &self.created_by);
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("execution_role", &self.execution_role);
        formatter.field("state", &self.state);
        formatter.field("state_details", &self.state_details);
        formatter.field("release_label", &self.release_label);
        formatter.field("configuration_overrides", &self.configuration_overrides);
        formatter.field("job_driver", &self.job_driver);
        formatter.field("tags", &self.tags);
        formatter.field(
            "total_resource_utilization",
            &self.total_resource_utilization,
        );
        formatter.field("network_configuration", &self.network_configuration);
        formatter.field(
            "total_execution_duration_seconds",
            &self.total_execution_duration_seconds,
        );
        formatter.finish()
    }
}
/// See [`JobRun`](crate::model::JobRun)
pub mod job_run {

    /// A builder for [`JobRun`](crate::model::JobRun)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) job_run_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) created_by: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) execution_role: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::JobRunState>,
        pub(crate) state_details: std::option::Option<std::string::String>,
        pub(crate) release_label: std::option::Option<std::string::String>,
        pub(crate) configuration_overrides:
            std::option::Option<crate::model::ConfigurationOverrides>,
        pub(crate) job_driver: std::option::Option<crate::model::JobDriver>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) total_resource_utilization:
            std::option::Option<crate::model::TotalResourceUtilization>,
        pub(crate) network_configuration: std::option::Option<crate::model::NetworkConfiguration>,
        pub(crate) total_execution_duration_seconds: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the application the job is running on.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The ID of the application the job is running on.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The ID of the job run.</p>
        pub fn job_run_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_run_id = Some(input.into());
            self
        }
        /// <p>The ID of the job run.</p>
        pub fn set_job_run_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_run_id = input;
            self
        }
        /// <p>The optional job run name. This doesn't have to be unique.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The optional job run name. This doesn't have to be unique.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The user who created the job run.</p>
        pub fn created_by(mut self, input: impl Into<std::string::String>) -> Self {
            self.created_by = Some(input.into());
            self
        }
        /// <p>The user who created the job run.</p>
        pub fn set_created_by(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.created_by = input;
            self
        }
        /// <p>The date and time when the job run was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time when the job run was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date and time when the job run was updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time when the job run was updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn execution_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.execution_role = Some(input.into());
            self
        }
        /// <p>The execution role ARN of the job run.</p>
        pub fn set_execution_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.execution_role = input;
            self
        }
        /// <p>The state of the job run.</p>
        pub fn state(mut self, input: crate::model::JobRunState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the job run.</p>
        pub fn set_state(mut self, input: std::option::Option<crate::model::JobRunState>) -> Self {
            self.state = input;
            self
        }
        /// <p>The state details of the job run.</p>
        pub fn state_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_details = Some(input.into());
            self
        }
        /// <p>The state details of the job run.</p>
        pub fn set_state_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_details = input;
            self
        }
        /// <p>The EMR release version associated with the application your job is running on.</p>
        pub fn release_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_label = Some(input.into());
            self
        }
        /// <p>The EMR release version associated with the application your job is running on.</p>
        pub fn set_release_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_label = input;
            self
        }
        /// <p>The configuration settings that are used to override default configuration.</p>
        pub fn configuration_overrides(
            mut self,
            input: crate::model::ConfigurationOverrides,
        ) -> Self {
            self.configuration_overrides = Some(input);
            self
        }
        /// <p>The configuration settings that are used to override default configuration.</p>
        pub fn set_configuration_overrides(
            mut self,
            input: std::option::Option<crate::model::ConfigurationOverrides>,
        ) -> Self {
            self.configuration_overrides = input;
            self
        }
        /// <p>The job driver for the job run.</p>
        pub fn job_driver(mut self, input: crate::model::JobDriver) -> Self {
            self.job_driver = Some(input);
            self
        }
        /// <p>The job driver for the job run.</p>
        pub fn set_job_driver(
            mut self,
            input: std::option::Option<crate::model::JobDriver>,
        ) -> Self {
            self.job_driver = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the job run.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the job run.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.</p>
        pub fn total_resource_utilization(
            mut self,
            input: crate::model::TotalResourceUtilization,
        ) -> Self {
            self.total_resource_utilization = Some(input);
            self
        }
        /// <p>The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.</p>
        pub fn set_total_resource_utilization(
            mut self,
            input: std::option::Option<crate::model::TotalResourceUtilization>,
        ) -> Self {
            self.total_resource_utilization = input;
            self
        }
        /// <p>The network configuration for customer VPC connectivity.</p>
        pub fn network_configuration(mut self, input: crate::model::NetworkConfiguration) -> Self {
            self.network_configuration = Some(input);
            self
        }
        /// <p>The network configuration for customer VPC connectivity.</p>
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::NetworkConfiguration>,
        ) -> Self {
            self.network_configuration = input;
            self
        }
        /// <p>The job run total execution duration in seconds. This field is only available for job runs in a <code>COMPLETED</code>, <code>FAILED</code>, or <code>CANCELLED</code> state.</p>
        pub fn total_execution_duration_seconds(mut self, input: i32) -> Self {
            self.total_execution_duration_seconds = Some(input);
            self
        }
        /// <p>The job run total execution duration in seconds. This field is only available for job runs in a <code>COMPLETED</code>, <code>FAILED</code>, or <code>CANCELLED</code> state.</p>
        pub fn set_total_execution_duration_seconds(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.total_execution_duration_seconds = input;
            self
        }
        /// Consumes the builder and constructs a [`JobRun`](crate::model::JobRun)
        pub fn build(self) -> crate::model::JobRun {
            crate::model::JobRun {
                application_id: self.application_id,
                job_run_id: self.job_run_id,
                name: self.name,
                arn: self.arn,
                created_by: self.created_by,
                created_at: self.created_at,
                updated_at: self.updated_at,
                execution_role: self.execution_role,
                state: self.state,
                state_details: self.state_details,
                release_label: self.release_label,
                configuration_overrides: self.configuration_overrides,
                job_driver: self.job_driver,
                tags: self.tags,
                total_resource_utilization: self.total_resource_utilization,
                network_configuration: self.network_configuration,
                total_execution_duration_seconds: self.total_execution_duration_seconds,
            }
        }
    }
}
impl JobRun {
    /// Creates a new builder-style object to manufacture [`JobRun`](crate::model::JobRun)
    pub fn builder() -> crate::model::job_run::Builder {
        crate::model::job_run::Builder::default()
    }
}

/// <p>The network configuration for customer VPC connectivity.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NetworkConfiguration {
    /// <p>The array of subnet Ids for customer VPC connectivity.</p>
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The array of security group Ids for customer VPC connectivity.</p>
    pub security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl NetworkConfiguration {
    /// <p>The array of subnet Ids for customer VPC connectivity.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The array of security group Ids for customer VPC connectivity.</p>
    pub fn security_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.security_group_ids.as_deref()
    }
}
impl std::fmt::Debug for NetworkConfiguration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NetworkConfiguration");
        formatter.field("subnet_ids", &self.subnet_ids);
        formatter.field("security_group_ids", &self.security_group_ids);
        formatter.finish()
    }
}
/// See [`NetworkConfiguration`](crate::model::NetworkConfiguration)
pub mod network_configuration {

    /// A builder for [`NetworkConfiguration`](crate::model::NetworkConfiguration)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The array of subnet Ids for customer VPC connectivity.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The array of subnet Ids for customer VPC connectivity.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `security_group_ids`.
        ///
        /// To override the contents of this collection use [`set_security_group_ids`](Self::set_security_group_ids).
        ///
        /// <p>The array of security group Ids for customer VPC connectivity.</p>
        pub fn security_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_group_ids.unwrap_or_default();
            v.push(input.into());
            self.security_group_ids = Some(v);
            self
        }
        /// <p>The array of security group Ids for customer VPC connectivity.</p>
        pub fn set_security_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_group_ids = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkConfiguration`](crate::model::NetworkConfiguration)
        pub fn build(self) -> crate::model::NetworkConfiguration {
            crate::model::NetworkConfiguration {
                subnet_ids: self.subnet_ids,
                security_group_ids: self.security_group_ids,
            }
        }
    }
}
impl NetworkConfiguration {
    /// Creates a new builder-style object to manufacture [`NetworkConfiguration`](crate::model::NetworkConfiguration)
    pub fn builder() -> crate::model::network_configuration::Builder {
        crate::model::network_configuration::Builder::default()
    }
}

/// <p>The aggregate vCPU, memory, and storage resources used from the time job start executing till the time job is terminated, rounded up to the nearest second.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TotalResourceUtilization {
    /// <p>The aggregated vCPU used per hour from the time job start executing till the time job is terminated.</p>
    pub v_cpu_hour: std::option::Option<f64>,
    /// <p>The aggregated memory used per hour from the time job start executing till the time job is terminated.</p>
    pub memory_gb_hour: std::option::Option<f64>,
    /// <p>The aggregated storage used per hour from the time job start executing till the time job is terminated.</p>
    pub storage_gb_hour: std::option::Option<f64>,
}
impl TotalResourceUtilization {
    /// <p>The aggregated vCPU used per hour from the time job start executing till the time job is terminated.</p>
    pub fn v_cpu_hour(&self) -> std::option::Option<f64> {
        self.v_cpu_hour
    }
    /// <p>The aggregated memory used per hour from the time job start executing till the time job is terminated.</p>
    pub fn memory_gb_hour(&self) -> std::option::Option<f64> {
        self.memory_gb_hour
    }
    /// <p>The aggregated storage used per hour from the time job start executing till the time job is terminated.</p>
    pub fn storage_gb_hour(&self) -> std::option::Option<f64> {
        self.storage_gb_hour
    }
}
impl std::fmt::Debug for TotalResourceUtilization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TotalResourceUtilization");
        formatter.field("v_cpu_hour", &self.v_cpu_hour);
        formatter.field("memory_gb_hour", &self.memory_gb_hour);
        formatter.field("storage_gb_hour", &self.storage_gb_hour);
        formatter.finish()
    }
}
/// See [`TotalResourceUtilization`](crate::model::TotalResourceUtilization)
pub mod total_resource_utilization {

    /// A builder for [`TotalResourceUtilization`](crate::model::TotalResourceUtilization)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) v_cpu_hour: std::option::Option<f64>,
        pub(crate) memory_gb_hour: std::option::Option<f64>,
        pub(crate) storage_gb_hour: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The aggregated vCPU used per hour from the time job start executing till the time job is terminated.</p>
        pub fn v_cpu_hour(mut self, input: f64) -> Self {
            self.v_cpu_hour = Some(input);
            self
        }
        /// <p>The aggregated vCPU used per hour from the time job start executing till the time job is terminated.</p>
        pub fn set_v_cpu_hour(mut self, input: std::option::Option<f64>) -> Self {
            self.v_cpu_hour = input;
            self
        }
        /// <p>The aggregated memory used per hour from the time job start executing till the time job is terminated.</p>
        pub fn memory_gb_hour(mut self, input: f64) -> Self {
            self.memory_gb_hour = Some(input);
            self
        }
        /// <p>The aggregated memory used per hour from the time job start executing till the time job is terminated.</p>
        pub fn set_memory_gb_hour(mut self, input: std::option::Option<f64>) -> Self {
            self.memory_gb_hour = input;
            self
        }
        /// <p>The aggregated storage used per hour from the time job start executing till the time job is terminated.</p>
        pub fn storage_gb_hour(mut self, input: f64) -> Self {
            self.storage_gb_hour = Some(input);
            self
        }
        /// <p>The aggregated storage used per hour from the time job start executing till the time job is terminated.</p>
        pub fn set_storage_gb_hour(mut self, input: std::option::Option<f64>) -> Self {
            self.storage_gb_hour = input;
            self
        }
        /// Consumes the builder and constructs a [`TotalResourceUtilization`](crate::model::TotalResourceUtilization)
        pub fn build(self) -> crate::model::TotalResourceUtilization {
            crate::model::TotalResourceUtilization {
                v_cpu_hour: self.v_cpu_hour,
                memory_gb_hour: self.memory_gb_hour,
                storage_gb_hour: self.storage_gb_hour,
            }
        }
    }
}
impl TotalResourceUtilization {
    /// Creates a new builder-style object to manufacture [`TotalResourceUtilization`](crate::model::TotalResourceUtilization)
    pub fn builder() -> crate::model::total_resource_utilization::Builder {
        crate::model::total_resource_utilization::Builder::default()
    }
}

/// <p>The summary of attributes associated with an application.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApplicationSummary {
    /// <p>The ID of the application.</p>
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the application.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of the application.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The EMR release version associated with the application.</p>
    pub release_label: std::option::Option<std::string::String>,
    /// <p>The type of application, such as Spark or Hive.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The state of the application.</p>
    pub state: std::option::Option<crate::model::ApplicationState>,
    /// <p>The state details of the application.</p>
    pub state_details: std::option::Option<std::string::String>,
    /// <p>The date and time when the application was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the application was last updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
}
impl ApplicationSummary {
    /// <p>The ID of the application.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the application.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The EMR release version associated with the application.</p>
    pub fn release_label(&self) -> std::option::Option<&str> {
        self.release_label.as_deref()
    }
    /// <p>The type of application, such as Spark or Hive.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The state of the application.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ApplicationState> {
        self.state.as_ref()
    }
    /// <p>The state details of the application.</p>
    pub fn state_details(&self) -> std::option::Option<&str> {
        self.state_details.as_deref()
    }
    /// <p>The date and time when the application was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time when the application was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
}
impl std::fmt::Debug for ApplicationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApplicationSummary");
        formatter.field("id", &self.id);
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("release_label", &self.release_label);
        formatter.field("r#type", &self.r#type);
        formatter.field("state", &self.state);
        formatter.field("state_details", &self.state_details);
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.finish()
    }
}
/// See [`ApplicationSummary`](crate::model::ApplicationSummary)
pub mod application_summary {

    /// A builder for [`ApplicationSummary`](crate::model::ApplicationSummary)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) release_label: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ApplicationState>,
        pub(crate) state_details: std::option::Option<std::string::String>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The ID of the application.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the application.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The EMR release version associated with the application.</p>
        pub fn release_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_label = Some(input.into());
            self
        }
        /// <p>The EMR release version associated with the application.</p>
        pub fn set_release_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_label = input;
            self
        }
        /// <p>The type of application, such as Spark or Hive.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of application, such as Spark or Hive.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The state of the application.</p>
        pub fn state(mut self, input: crate::model::ApplicationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the application.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ApplicationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The state details of the application.</p>
        pub fn state_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_details = Some(input.into());
            self
        }
        /// <p>The state details of the application.</p>
        pub fn set_state_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_details = input;
            self
        }
        /// <p>The date and time when the application was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time when the application was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date and time when the application was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time when the application was last updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationSummary`](crate::model::ApplicationSummary)
        pub fn build(self) -> crate::model::ApplicationSummary {
            crate::model::ApplicationSummary {
                id: self.id,
                name: self.name,
                arn: self.arn,
                release_label: self.release_label,
                r#type: self.r#type,
                state: self.state,
                state_details: self.state_details,
                created_at: self.created_at,
                updated_at: self.updated_at,
            }
        }
    }
}
impl ApplicationSummary {
    /// Creates a new builder-style object to manufacture [`ApplicationSummary`](crate::model::ApplicationSummary)
    pub fn builder() -> crate::model::application_summary::Builder {
        crate::model::application_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationState {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Started,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Terminated,
    /// Unknown contains new variants that have been added since this code was generated.
    Unknown(String),
}
impl std::convert::From<&str> for ApplicationState {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => ApplicationState::Created,
            "CREATING" => ApplicationState::Creating,
            "STARTED" => ApplicationState::Started,
            "STARTING" => ApplicationState::Starting,
            "STOPPED" => ApplicationState::Stopped,
            "STOPPING" => ApplicationState::Stopping,
            "TERMINATED" => ApplicationState::Terminated,
            other => ApplicationState::Unknown(other.to_owned()),
        }
    }
}
impl std::str::FromStr for ApplicationState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationState::from(s))
    }
}
impl ApplicationState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationState::Created => "CREATED",
            ApplicationState::Creating => "CREATING",
            ApplicationState::Started => "STARTED",
            ApplicationState::Starting => "STARTING",
            ApplicationState::Stopped => "STOPPED",
            ApplicationState::Stopping => "STOPPING",
            ApplicationState::Terminated => "TERMINATED",
            ApplicationState::Unknown(s) => s.as_ref(),
        }
    }
    /// Returns all the `&str` values of the enum members.
    pub fn values() -> &'static [&'static str] {
        &[
            "CREATED",
            "CREATING",
            "STARTED",
            "STARTING",
            "STOPPED",
            "STOPPING",
            "TERMINATED",
        ]
    }
}
impl AsRef<str> for ApplicationState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The configuration for an application to automatically stop after a certain amount of time being idle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoStopConfig {
    /// <p>Enables the application to automatically stop after a certain amount of time being idle. Defaults to true.</p>
    pub enabled: std::option::Option<bool>,
    /// <p>The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.</p>
    pub idle_timeout_minutes: std::option::Option<i32>,
}
impl AutoStopConfig {
    /// <p>Enables the application to automatically stop after a certain amount of time being idle. Defaults to true.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
    /// <p>The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.</p>
    pub fn idle_timeout_minutes(&self) -> std::option::Option<i32> {
        self.idle_timeout_minutes
    }
}
impl std::fmt::Debug for AutoStopConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoStopConfig");
        formatter.field("enabled", &self.enabled);
        formatter.field("idle_timeout_minutes", &self.idle_timeout_minutes);
        formatter.finish()
    }
}
/// See [`AutoStopConfig`](crate::model::AutoStopConfig)
pub mod auto_stop_config {

    /// A builder for [`AutoStopConfig`](crate::model::AutoStopConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
        pub(crate) idle_timeout_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Enables the application to automatically stop after a certain amount of time being idle. Defaults to true.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Enables the application to automatically stop after a certain amount of time being idle. Defaults to true.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// <p>The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.</p>
        pub fn idle_timeout_minutes(mut self, input: i32) -> Self {
            self.idle_timeout_minutes = Some(input);
            self
        }
        /// <p>The amount of idle time in minutes after which your application will automatically stop. Defaults to 15 minutes.</p>
        pub fn set_idle_timeout_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.idle_timeout_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoStopConfig`](crate::model::AutoStopConfig)
        pub fn build(self) -> crate::model::AutoStopConfig {
            crate::model::AutoStopConfig {
                enabled: self.enabled,
                idle_timeout_minutes: self.idle_timeout_minutes,
            }
        }
    }
}
impl AutoStopConfig {
    /// Creates a new builder-style object to manufacture [`AutoStopConfig`](crate::model::AutoStopConfig)
    pub fn builder() -> crate::model::auto_stop_config::Builder {
        crate::model::auto_stop_config::Builder::default()
    }
}

/// <p>The configuration for an application to automatically start on job submission.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AutoStartConfig {
    /// <p>Enables the application to automatically start on job submission. Defaults to true.</p>
    pub enabled: std::option::Option<bool>,
}
impl AutoStartConfig {
    /// <p>Enables the application to automatically start on job submission. Defaults to true.</p>
    pub fn enabled(&self) -> std::option::Option<bool> {
        self.enabled
    }
}
impl std::fmt::Debug for AutoStartConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AutoStartConfig");
        formatter.field("enabled", &self.enabled);
        formatter.finish()
    }
}
/// See [`AutoStartConfig`](crate::model::AutoStartConfig)
pub mod auto_start_config {

    /// A builder for [`AutoStartConfig`](crate::model::AutoStartConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Enables the application to automatically start on job submission. Defaults to true.</p>
        pub fn enabled(mut self, input: bool) -> Self {
            self.enabled = Some(input);
            self
        }
        /// <p>Enables the application to automatically start on job submission. Defaults to true.</p>
        pub fn set_enabled(mut self, input: std::option::Option<bool>) -> Self {
            self.enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`AutoStartConfig`](crate::model::AutoStartConfig)
        pub fn build(self) -> crate::model::AutoStartConfig {
            crate::model::AutoStartConfig {
                enabled: self.enabled,
            }
        }
    }
}
impl AutoStartConfig {
    /// Creates a new builder-style object to manufacture [`AutoStartConfig`](crate::model::AutoStartConfig)
    pub fn builder() -> crate::model::auto_start_config::Builder {
        crate::model::auto_start_config::Builder::default()
    }
}

/// <p>The maximum allowed cumulative resources for an application. No new resources will be created once the limit is hit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumAllowedResources {
    /// <p>The maximum allowed CPU for an application.</p>
    pub cpu: std::option::Option<std::string::String>,
    /// <p>The maximum allowed resources for an application.</p>
    pub memory: std::option::Option<std::string::String>,
    /// <p>The maximum allowed disk for an application.</p>
    pub disk: std::option::Option<std::string::String>,
}
impl MaximumAllowedResources {
    /// <p>The maximum allowed CPU for an application.</p>
    pub fn cpu(&self) -> std::option::Option<&str> {
        self.cpu.as_deref()
    }
    /// <p>The maximum allowed resources for an application.</p>
    pub fn memory(&self) -> std::option::Option<&str> {
        self.memory.as_deref()
    }
    /// <p>The maximum allowed disk for an application.</p>
    pub fn disk(&self) -> std::option::Option<&str> {
        self.disk.as_deref()
    }
}
impl std::fmt::Debug for MaximumAllowedResources {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumAllowedResources");
        formatter.field("cpu", &self.cpu);
        formatter.field("memory", &self.memory);
        formatter.field("disk", &self.disk);
        formatter.finish()
    }
}
/// See [`MaximumAllowedResources`](crate::model::MaximumAllowedResources)
pub mod maximum_allowed_resources {

    /// A builder for [`MaximumAllowedResources`](crate::model::MaximumAllowedResources)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cpu: std::option::Option<std::string::String>,
        pub(crate) memory: std::option::Option<std::string::String>,
        pub(crate) disk: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The maximum allowed CPU for an application.</p>
        pub fn cpu(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu = Some(input.into());
            self
        }
        /// <p>The maximum allowed CPU for an application.</p>
        pub fn set_cpu(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cpu = input;
            self
        }
        /// <p>The maximum allowed resources for an application.</p>
        pub fn memory(mut self, input: impl Into<std::string::String>) -> Self {
            self.memory = Some(input.into());
            self
        }
        /// <p>The maximum allowed resources for an application.</p>
        pub fn set_memory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.memory = input;
            self
        }
        /// <p>The maximum allowed disk for an application.</p>
        pub fn disk(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk = Some(input.into());
            self
        }
        /// <p>The maximum allowed disk for an application.</p>
        pub fn set_disk(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumAllowedResources`](crate::model::MaximumAllowedResources)
        pub fn build(self) -> crate::model::MaximumAllowedResources {
            crate::model::MaximumAllowedResources {
                cpu: self.cpu,
                memory: self.memory,
                disk: self.disk,
            }
        }
    }
}
impl MaximumAllowedResources {
    /// Creates a new builder-style object to manufacture [`MaximumAllowedResources`](crate::model::MaximumAllowedResources)
    pub fn builder() -> crate::model::maximum_allowed_resources::Builder {
        crate::model::maximum_allowed_resources::Builder::default()
    }
}

/// <p>The initial capacity configuration per worker.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InitialCapacityConfig {
    /// <p>The number of workers in the initial capacity configuration.</p>
    pub worker_count: i64,
    /// <p>The resource configuration of the initial capacity configuration.</p>
    pub worker_configuration: std::option::Option<crate::model::WorkerResourceConfig>,
}
impl InitialCapacityConfig {
    /// <p>The number of workers in the initial capacity configuration.</p>
    pub fn worker_count(&self) -> i64 {
        self.worker_count
    }
    /// <p>The resource configuration of the initial capacity configuration.</p>
    pub fn worker_configuration(&self) -> std::option::Option<&crate::model::WorkerResourceConfig> {
        self.worker_configuration.as_ref()
    }
}
impl std::fmt::Debug for InitialCapacityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InitialCapacityConfig");
        formatter.field("worker_count", &self.worker_count);
        formatter.field("worker_configuration", &self.worker_configuration);
        formatter.finish()
    }
}
/// See [`InitialCapacityConfig`](crate::model::InitialCapacityConfig)
pub mod initial_capacity_config {

    /// A builder for [`InitialCapacityConfig`](crate::model::InitialCapacityConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) worker_count: std::option::Option<i64>,
        pub(crate) worker_configuration: std::option::Option<crate::model::WorkerResourceConfig>,
    }
    impl Builder {
        /// <p>The number of workers in the initial capacity configuration.</p>
        pub fn worker_count(mut self, input: i64) -> Self {
            self.worker_count = Some(input);
            self
        }
        /// <p>The number of workers in the initial capacity configuration.</p>
        pub fn set_worker_count(mut self, input: std::option::Option<i64>) -> Self {
            self.worker_count = input;
            self
        }
        /// <p>The resource configuration of the initial capacity configuration.</p>
        pub fn worker_configuration(mut self, input: crate::model::WorkerResourceConfig) -> Self {
            self.worker_configuration = Some(input);
            self
        }
        /// <p>The resource configuration of the initial capacity configuration.</p>
        pub fn set_worker_configuration(
            mut self,
            input: std::option::Option<crate::model::WorkerResourceConfig>,
        ) -> Self {
            self.worker_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`InitialCapacityConfig`](crate::model::InitialCapacityConfig)
        pub fn build(self) -> crate::model::InitialCapacityConfig {
            crate::model::InitialCapacityConfig {
                worker_count: self.worker_count.unwrap_or_default(),
                worker_configuration: self.worker_configuration,
            }
        }
    }
}
impl InitialCapacityConfig {
    /// Creates a new builder-style object to manufacture [`InitialCapacityConfig`](crate::model::InitialCapacityConfig)
    pub fn builder() -> crate::model::initial_capacity_config::Builder {
        crate::model::initial_capacity_config::Builder::default()
    }
}

/// <p>The cumulative configuration requirements for every worker instance of the worker type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct WorkerResourceConfig {
    /// <p>The CPU requirements for every worker instance of the worker type.</p>
    pub cpu: std::option::Option<std::string::String>,
    /// <p>The memory requirements for every worker instance of the worker type.</p>
    pub memory: std::option::Option<std::string::String>,
    /// <p>The disk requirements for every worker instance of the worker type.</p>
    pub disk: std::option::Option<std::string::String>,
}
impl WorkerResourceConfig {
    /// <p>The CPU requirements for every worker instance of the worker type.</p>
    pub fn cpu(&self) -> std::option::Option<&str> {
        self.cpu.as_deref()
    }
    /// <p>The memory requirements for every worker instance of the worker type.</p>
    pub fn memory(&self) -> std::option::Option<&str> {
        self.memory.as_deref()
    }
    /// <p>The disk requirements for every worker instance of the worker type.</p>
    pub fn disk(&self) -> std::option::Option<&str> {
        self.disk.as_deref()
    }
}
impl std::fmt::Debug for WorkerResourceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("WorkerResourceConfig");
        formatter.field("cpu", &self.cpu);
        formatter.field("memory", &self.memory);
        formatter.field("disk", &self.disk);
        formatter.finish()
    }
}
/// See [`WorkerResourceConfig`](crate::model::WorkerResourceConfig)
pub mod worker_resource_config {

    /// A builder for [`WorkerResourceConfig`](crate::model::WorkerResourceConfig)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) cpu: std::option::Option<std::string::String>,
        pub(crate) memory: std::option::Option<std::string::String>,
        pub(crate) disk: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The CPU requirements for every worker instance of the worker type.</p>
        pub fn cpu(mut self, input: impl Into<std::string::String>) -> Self {
            self.cpu = Some(input.into());
            self
        }
        /// <p>The CPU requirements for every worker instance of the worker type.</p>
        pub fn set_cpu(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.cpu = input;
            self
        }
        /// <p>The memory requirements for every worker instance of the worker type.</p>
        pub fn memory(mut self, input: impl Into<std::string::String>) -> Self {
            self.memory = Some(input.into());
            self
        }
        /// <p>The memory requirements for every worker instance of the worker type.</p>
        pub fn set_memory(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.memory = input;
            self
        }
        /// <p>The disk requirements for every worker instance of the worker type.</p>
        pub fn disk(mut self, input: impl Into<std::string::String>) -> Self {
            self.disk = Some(input.into());
            self
        }
        /// <p>The disk requirements for every worker instance of the worker type.</p>
        pub fn set_disk(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.disk = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkerResourceConfig`](crate::model::WorkerResourceConfig)
        pub fn build(self) -> crate::model::WorkerResourceConfig {
            crate::model::WorkerResourceConfig {
                cpu: self.cpu,
                memory: self.memory,
                disk: self.disk,
            }
        }
    }
}
impl WorkerResourceConfig {
    /// Creates a new builder-style object to manufacture [`WorkerResourceConfig`](crate::model::WorkerResourceConfig)
    pub fn builder() -> crate::model::worker_resource_config::Builder {
        crate::model::worker_resource_config::Builder::default()
    }
}

/// <p>Information about an application. EMR Serverless uses applications to run jobs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct Application {
    /// <p>The ID of the application.</p>
    pub application_id: std::option::Option<std::string::String>,
    /// <p>The name of the application.</p>
    pub name: std::option::Option<std::string::String>,
    /// <p>The ARN of the application.</p>
    pub arn: std::option::Option<std::string::String>,
    /// <p>The EMR release version associated with the application.</p>
    pub release_label: std::option::Option<std::string::String>,
    /// <p>The type of application, such as Spark or Hive.</p>
    pub r#type: std::option::Option<std::string::String>,
    /// <p>The state of the application.</p>
    pub state: std::option::Option<crate::model::ApplicationState>,
    /// <p>The state details of the application.</p>
    pub state_details: std::option::Option<std::string::String>,
    /// <p>The initial capacity of the application.</p>
    pub initial_capacity: std::option::Option<
        std::collections::HashMap<std::string::String, crate::model::InitialCapacityConfig>,
    >,
    /// <p>The maximum capacity of the application. This is cumulative across all workers at any given point in time during the lifespan of the application is created. No new resources will be created once any one of the defined limits is hit.</p>
    pub maximum_capacity: std::option::Option<crate::model::MaximumAllowedResources>,
    /// <p>The date and time when the application run was created.</p>
    pub created_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The date and time when the application run was last updated.</p>
    pub updated_at: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The tags assigned to the application.</p>
    pub tags:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The configuration for an application to automatically start on job submission.</p>
    pub auto_start_configuration: std::option::Option<crate::model::AutoStartConfig>,
    /// <p>The configuration for an application to automatically stop after a certain amount of time being idle.</p>
    pub auto_stop_configuration: std::option::Option<crate::model::AutoStopConfig>,
    /// <p>The network configuration for customer VPC connectivity for the application.</p>
    pub network_configuration: std::option::Option<crate::model::NetworkConfiguration>,
}
impl Application {
    /// <p>The ID of the application.</p>
    pub fn application_id(&self) -> std::option::Option<&str> {
        self.application_id.as_deref()
    }
    /// <p>The name of the application.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ARN of the application.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The EMR release version associated with the application.</p>
    pub fn release_label(&self) -> std::option::Option<&str> {
        self.release_label.as_deref()
    }
    /// <p>The type of application, such as Spark or Hive.</p>
    pub fn r#type(&self) -> std::option::Option<&str> {
        self.r#type.as_deref()
    }
    /// <p>The state of the application.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ApplicationState> {
        self.state.as_ref()
    }
    /// <p>The state details of the application.</p>
    pub fn state_details(&self) -> std::option::Option<&str> {
        self.state_details.as_deref()
    }
    /// <p>The initial capacity of the application.</p>
    pub fn initial_capacity(
        &self,
    ) -> std::option::Option<
        &std::collections::HashMap<std::string::String, crate::model::InitialCapacityConfig>,
    > {
        self.initial_capacity.as_ref()
    }
    /// <p>The maximum capacity of the application. This is cumulative across all workers at any given point in time during the lifespan of the application is created. No new resources will be created once any one of the defined limits is hit.</p>
    pub fn maximum_capacity(&self) -> std::option::Option<&crate::model::MaximumAllowedResources> {
        self.maximum_capacity.as_ref()
    }
    /// <p>The date and time when the application run was created.</p>
    pub fn created_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created_at.as_ref()
    }
    /// <p>The date and time when the application run was last updated.</p>
    pub fn updated_at(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.updated_at.as_ref()
    }
    /// <p>The tags assigned to the application.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.tags.as_ref()
    }
    /// <p>The configuration for an application to automatically start on job submission.</p>
    pub fn auto_start_configuration(&self) -> std::option::Option<&crate::model::AutoStartConfig> {
        self.auto_start_configuration.as_ref()
    }
    /// <p>The configuration for an application to automatically stop after a certain amount of time being idle.</p>
    pub fn auto_stop_configuration(&self) -> std::option::Option<&crate::model::AutoStopConfig> {
        self.auto_stop_configuration.as_ref()
    }
    /// <p>The network configuration for customer VPC connectivity for the application.</p>
    pub fn network_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NetworkConfiguration> {
        self.network_configuration.as_ref()
    }
}
impl std::fmt::Debug for Application {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("Application");
        formatter.field("application_id", &self.application_id);
        formatter.field("name", &self.name);
        formatter.field("arn", &self.arn);
        formatter.field("release_label", &self.release_label);
        formatter.field("r#type", &self.r#type);
        formatter.field("state", &self.state);
        formatter.field("state_details", &self.state_details);
        formatter.field("initial_capacity", &self.initial_capacity);
        formatter.field("maximum_capacity", &self.maximum_capacity);
        formatter.field("created_at", &self.created_at);
        formatter.field("updated_at", &self.updated_at);
        formatter.field("tags", &self.tags);
        formatter.field("auto_start_configuration", &self.auto_start_configuration);
        formatter.field("auto_stop_configuration", &self.auto_stop_configuration);
        formatter.field("network_configuration", &self.network_configuration);
        formatter.finish()
    }
}
/// See [`Application`](crate::model::Application)
pub mod application {

    /// A builder for [`Application`](crate::model::Application)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) application_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) release_label: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ApplicationState>,
        pub(crate) state_details: std::option::Option<std::string::String>,
        pub(crate) initial_capacity: std::option::Option<
            std::collections::HashMap<std::string::String, crate::model::InitialCapacityConfig>,
        >,
        pub(crate) maximum_capacity: std::option::Option<crate::model::MaximumAllowedResources>,
        pub(crate) created_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) updated_at: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) tags: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) auto_start_configuration: std::option::Option<crate::model::AutoStartConfig>,
        pub(crate) auto_stop_configuration: std::option::Option<crate::model::AutoStopConfig>,
        pub(crate) network_configuration: std::option::Option<crate::model::NetworkConfiguration>,
    }
    impl Builder {
        /// <p>The ID of the application.</p>
        pub fn application_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.application_id = Some(input.into());
            self
        }
        /// <p>The ID of the application.</p>
        pub fn set_application_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.application_id = input;
            self
        }
        /// <p>The name of the application.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the application.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The ARN of the application.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The EMR release version associated with the application.</p>
        pub fn release_label(mut self, input: impl Into<std::string::String>) -> Self {
            self.release_label = Some(input.into());
            self
        }
        /// <p>The EMR release version associated with the application.</p>
        pub fn set_release_label(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.release_label = input;
            self
        }
        /// <p>The type of application, such as Spark or Hive.</p>
        pub fn r#type(mut self, input: impl Into<std::string::String>) -> Self {
            self.r#type = Some(input.into());
            self
        }
        /// <p>The type of application, such as Spark or Hive.</p>
        pub fn set_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The state of the application.</p>
        pub fn state(mut self, input: crate::model::ApplicationState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the application.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ApplicationState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The state details of the application.</p>
        pub fn state_details(mut self, input: impl Into<std::string::String>) -> Self {
            self.state_details = Some(input.into());
            self
        }
        /// <p>The state details of the application.</p>
        pub fn set_state_details(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.state_details = input;
            self
        }
        /// Adds a key-value pair to `initial_capacity`.
        ///
        /// To override the contents of this collection use [`set_initial_capacity`](Self::set_initial_capacity).
        ///
        /// <p>The initial capacity of the application.</p>
        pub fn initial_capacity(
            mut self,
            k: impl Into<std::string::String>,
            v: crate::model::InitialCapacityConfig,
        ) -> Self {
            let mut hash_map = self.initial_capacity.unwrap_or_default();
            hash_map.insert(k.into(), v);
            self.initial_capacity = Some(hash_map);
            self
        }
        /// <p>The initial capacity of the application.</p>
        pub fn set_initial_capacity(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, crate::model::InitialCapacityConfig>,
            >,
        ) -> Self {
            self.initial_capacity = input;
            self
        }
        /// <p>The maximum capacity of the application. This is cumulative across all workers at any given point in time during the lifespan of the application is created. No new resources will be created once any one of the defined limits is hit.</p>
        pub fn maximum_capacity(mut self, input: crate::model::MaximumAllowedResources) -> Self {
            self.maximum_capacity = Some(input);
            self
        }
        /// <p>The maximum capacity of the application. This is cumulative across all workers at any given point in time during the lifespan of the application is created. No new resources will be created once any one of the defined limits is hit.</p>
        pub fn set_maximum_capacity(
            mut self,
            input: std::option::Option<crate::model::MaximumAllowedResources>,
        ) -> Self {
            self.maximum_capacity = input;
            self
        }
        /// <p>The date and time when the application run was created.</p>
        pub fn created_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created_at = Some(input);
            self
        }
        /// <p>The date and time when the application run was created.</p>
        pub fn set_created_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created_at = input;
            self
        }
        /// <p>The date and time when the application run was last updated.</p>
        pub fn updated_at(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.updated_at = Some(input);
            self
        }
        /// <p>The date and time when the application run was last updated.</p>
        pub fn set_updated_at(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.updated_at = input;
            self
        }
        /// Adds a key-value pair to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags assigned to the application.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.tags.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.tags = Some(hash_map);
            self
        }
        /// <p>The tags assigned to the application.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// <p>The configuration for an application to automatically start on job submission.</p>
        pub fn auto_start_configuration(mut self, input: crate::model::AutoStartConfig) -> Self {
            self.auto_start_configuration = Some(input);
            self
        }
        /// <p>The configuration for an application to automatically start on job submission.</p>
        pub fn set_auto_start_configuration(
            mut self,
            input: std::option::Option<crate::model::AutoStartConfig>,
        ) -> Self {
            self.auto_start_configuration = input;
            self
        }
        /// <p>The configuration for an application to automatically stop after a certain amount of time being idle.</p>
        pub fn auto_stop_configuration(mut self, input: crate::model::AutoStopConfig) -> Self {
            self.auto_stop_configuration = Some(input);
            self
        }
        /// <p>The configuration for an application to automatically stop after a certain amount of time being idle.</p>
        pub fn set_auto_stop_configuration(
            mut self,
            input: std::option::Option<crate::model::AutoStopConfig>,
        ) -> Self {
            self.auto_stop_configuration = input;
            self
        }
        /// <p>The network configuration for customer VPC connectivity for the application.</p>
        pub fn network_configuration(mut self, input: crate::model::NetworkConfiguration) -> Self {
            self.network_configuration = Some(input);
            self
        }
        /// <p>The network configuration for customer VPC connectivity for the application.</p>
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::NetworkConfiguration>,
        ) -> Self {
            self.network_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`Application`](crate::model::Application)
        pub fn build(self) -> crate::model::Application {
            crate::model::Application {
                application_id: self.application_id,
                name: self.name,
                arn: self.arn,
                release_label: self.release_label,
                r#type: self.r#type,
                state: self.state,
                state_details: self.state_details,
                initial_capacity: self.initial_capacity,
                maximum_capacity: self.maximum_capacity,
                created_at: self.created_at,
                updated_at: self.updated_at,
                tags: self.tags,
                auto_start_configuration: self.auto_start_configuration,
                auto_stop_configuration: self.auto_stop_configuration,
                network_configuration: self.network_configuration,
            }
        }
    }
}
impl Application {
    /// Creates a new builder-style object to manufacture [`Application`](crate::model::Application)
    pub fn builder() -> crate::model::application::Builder {
        crate::model::application::Builder::default()
    }
}
