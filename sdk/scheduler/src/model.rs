// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The details of a schedule group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduleGroupSummary {
    /// <p>The Amazon Resource Name (ARN) of the schedule group.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the schedule group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Specifies the state of the schedule group.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ScheduleGroupState>,
    /// <p>The time at which the schedule group was created.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the schedule group was last modified.</p>
    #[doc(hidden)]
    pub last_modification_date: std::option::Option<aws_smithy_types::DateTime>,
}
impl ScheduleGroupSummary {
    /// <p>The Amazon Resource Name (ARN) of the schedule group.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the schedule group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Specifies the state of the schedule group.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ScheduleGroupState> {
        self.state.as_ref()
    }
    /// <p>The time at which the schedule group was created.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The time at which the schedule group was last modified.</p>
    pub fn last_modification_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_date.as_ref()
    }
}
/// See [`ScheduleGroupSummary`](crate::model::ScheduleGroupSummary).
pub mod schedule_group_summary {

    /// A builder for [`ScheduleGroupSummary`](crate::model::ScheduleGroupSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ScheduleGroupState>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_date: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the schedule group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the schedule group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the schedule group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the schedule group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Specifies the state of the schedule group.</p>
        pub fn state(mut self, input: crate::model::ScheduleGroupState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Specifies the state of the schedule group.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ScheduleGroupState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The time at which the schedule group was created.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The time at which the schedule group was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The time at which the schedule group was last modified.</p>
        pub fn last_modification_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_date = Some(input);
            self
        }
        /// <p>The time at which the schedule group was last modified.</p>
        pub fn set_last_modification_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_date = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduleGroupSummary`](crate::model::ScheduleGroupSummary).
        pub fn build(self) -> crate::model::ScheduleGroupSummary {
            crate::model::ScheduleGroupSummary {
                arn: self.arn,
                name: self.name,
                state: self.state,
                creation_date: self.creation_date,
                last_modification_date: self.last_modification_date,
            }
        }
    }
}
impl ScheduleGroupSummary {
    /// Creates a new builder-style object to manufacture [`ScheduleGroupSummary`](crate::model::ScheduleGroupSummary).
    pub fn builder() -> crate::model::schedule_group_summary::Builder {
        crate::model::schedule_group_summary::Builder::default()
    }
}

/// When writing a match expression against `ScheduleGroupState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let schedulegroupstate = unimplemented!();
/// match schedulegroupstate {
///     ScheduleGroupState::Active => { /* ... */ },
///     ScheduleGroupState::Deleting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `schedulegroupstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScheduleGroupState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScheduleGroupState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScheduleGroupState::NewFeature` is defined.
/// Specifically, when `schedulegroupstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScheduleGroupState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduleGroupState {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScheduleGroupState {
    fn from(s: &str) -> Self {
        match s {
            "ACTIVE" => ScheduleGroupState::Active,
            "DELETING" => ScheduleGroupState::Deleting,
            other => {
                ScheduleGroupState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ScheduleGroupState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduleGroupState::from(s))
    }
}
impl ScheduleGroupState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduleGroupState::Active => "ACTIVE",
            ScheduleGroupState::Deleting => "DELETING",
            ScheduleGroupState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ACTIVE", "DELETING"]
    }
}
impl AsRef<str> for ScheduleGroupState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Tag to associate with a schedule group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The key for the tag.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value for the tag.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The key for the tag.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value for the tag.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key for the tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key for the tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value for the tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value for the tag.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// <p>The details of a schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ScheduleSummary {
    /// <p>The Amazon Resource Name (ARN) of the schedule.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the schedule.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the schedule group associated with this schedule.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
    /// <p>Specifies whether the schedule is enabled or disabled.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ScheduleState>,
    /// <p>The time at which the schedule was created.</p>
    #[doc(hidden)]
    pub creation_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time at which the schedule was last modified.</p>
    #[doc(hidden)]
    pub last_modification_date: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The schedule's target details.</p>
    #[doc(hidden)]
    pub target: std::option::Option<crate::model::TargetSummary>,
}
impl ScheduleSummary {
    /// <p>The Amazon Resource Name (ARN) of the schedule.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the schedule.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the schedule group associated with this schedule.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>Specifies whether the schedule is enabled or disabled.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ScheduleState> {
        self.state.as_ref()
    }
    /// <p>The time at which the schedule was created.</p>
    pub fn creation_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_date.as_ref()
    }
    /// <p>The time at which the schedule was last modified.</p>
    pub fn last_modification_date(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_modification_date.as_ref()
    }
    /// <p>The schedule's target details.</p>
    pub fn target(&self) -> std::option::Option<&crate::model::TargetSummary> {
        self.target.as_ref()
    }
}
/// See [`ScheduleSummary`](crate::model::ScheduleSummary).
pub mod schedule_summary {

    /// A builder for [`ScheduleSummary`](crate::model::ScheduleSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ScheduleState>,
        pub(crate) creation_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_modification_date: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) target: std::option::Option<crate::model::TargetSummary>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the schedule.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the schedule.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the schedule.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the schedule.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the schedule group associated with this schedule.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the schedule group associated with this schedule.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>Specifies whether the schedule is enabled or disabled.</p>
        pub fn state(mut self, input: crate::model::ScheduleState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Specifies whether the schedule is enabled or disabled.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ScheduleState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The time at which the schedule was created.</p>
        pub fn creation_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_date = Some(input);
            self
        }
        /// <p>The time at which the schedule was created.</p>
        pub fn set_creation_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_date = input;
            self
        }
        /// <p>The time at which the schedule was last modified.</p>
        pub fn last_modification_date(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_modification_date = Some(input);
            self
        }
        /// <p>The time at which the schedule was last modified.</p>
        pub fn set_last_modification_date(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_modification_date = input;
            self
        }
        /// <p>The schedule's target details.</p>
        pub fn target(mut self, input: crate::model::TargetSummary) -> Self {
            self.target = Some(input);
            self
        }
        /// <p>The schedule's target details.</p>
        pub fn set_target(
            mut self,
            input: std::option::Option<crate::model::TargetSummary>,
        ) -> Self {
            self.target = input;
            self
        }
        /// Consumes the builder and constructs a [`ScheduleSummary`](crate::model::ScheduleSummary).
        pub fn build(self) -> crate::model::ScheduleSummary {
            crate::model::ScheduleSummary {
                arn: self.arn,
                name: self.name,
                group_name: self.group_name,
                state: self.state,
                creation_date: self.creation_date,
                last_modification_date: self.last_modification_date,
                target: self.target,
            }
        }
    }
}
impl ScheduleSummary {
    /// Creates a new builder-style object to manufacture [`ScheduleSummary`](crate::model::ScheduleSummary).
    pub fn builder() -> crate::model::schedule_summary::Builder {
        crate::model::schedule_summary::Builder::default()
    }
}

/// <p>The details of a target.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TargetSummary {
    /// <p>The Amazon Resource Name (ARN) of the target.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl TargetSummary {
    /// <p>The Amazon Resource Name (ARN) of the target.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`TargetSummary`](crate::model::TargetSummary).
pub mod target_summary {

    /// A builder for [`TargetSummary`](crate::model::TargetSummary).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the target.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the target.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetSummary`](crate::model::TargetSummary).
        pub fn build(self) -> crate::model::TargetSummary {
            crate::model::TargetSummary { arn: self.arn }
        }
    }
}
impl TargetSummary {
    /// Creates a new builder-style object to manufacture [`TargetSummary`](crate::model::TargetSummary).
    pub fn builder() -> crate::model::target_summary::Builder {
        crate::model::target_summary::Builder::default()
    }
}

/// When writing a match expression against `ScheduleState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let schedulestate = unimplemented!();
/// match schedulestate {
///     ScheduleState::Disabled => { /* ... */ },
///     ScheduleState::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `schedulestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ScheduleState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ScheduleState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ScheduleState::NewFeature` is defined.
/// Specifically, when `schedulestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ScheduleState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ScheduleState {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ScheduleState {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => ScheduleState::Disabled,
            "ENABLED" => ScheduleState::Enabled,
            other => ScheduleState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ScheduleState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ScheduleState::from(s))
    }
}
impl ScheduleState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ScheduleState::Disabled => "DISABLED",
            ScheduleState::Enabled => "ENABLED",
            ScheduleState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for ScheduleState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FlexibleTimeWindow {
    /// <p>Determines whether the schedule is invoked within a flexible time window.</p>
    #[doc(hidden)]
    pub mode: std::option::Option<crate::model::FlexibleTimeWindowMode>,
    /// <p>The maximum time window during which a schedule can be invoked.</p>
    #[doc(hidden)]
    pub maximum_window_in_minutes: std::option::Option<i32>,
}
impl FlexibleTimeWindow {
    /// <p>Determines whether the schedule is invoked within a flexible time window.</p>
    pub fn mode(&self) -> std::option::Option<&crate::model::FlexibleTimeWindowMode> {
        self.mode.as_ref()
    }
    /// <p>The maximum time window during which a schedule can be invoked.</p>
    pub fn maximum_window_in_minutes(&self) -> std::option::Option<i32> {
        self.maximum_window_in_minutes
    }
}
/// See [`FlexibleTimeWindow`](crate::model::FlexibleTimeWindow).
pub mod flexible_time_window {

    /// A builder for [`FlexibleTimeWindow`](crate::model::FlexibleTimeWindow).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mode: std::option::Option<crate::model::FlexibleTimeWindowMode>,
        pub(crate) maximum_window_in_minutes: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Determines whether the schedule is invoked within a flexible time window.</p>
        pub fn mode(mut self, input: crate::model::FlexibleTimeWindowMode) -> Self {
            self.mode = Some(input);
            self
        }
        /// <p>Determines whether the schedule is invoked within a flexible time window.</p>
        pub fn set_mode(
            mut self,
            input: std::option::Option<crate::model::FlexibleTimeWindowMode>,
        ) -> Self {
            self.mode = input;
            self
        }
        /// <p>The maximum time window during which a schedule can be invoked.</p>
        pub fn maximum_window_in_minutes(mut self, input: i32) -> Self {
            self.maximum_window_in_minutes = Some(input);
            self
        }
        /// <p>The maximum time window during which a schedule can be invoked.</p>
        pub fn set_maximum_window_in_minutes(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_window_in_minutes = input;
            self
        }
        /// Consumes the builder and constructs a [`FlexibleTimeWindow`](crate::model::FlexibleTimeWindow).
        pub fn build(self) -> crate::model::FlexibleTimeWindow {
            crate::model::FlexibleTimeWindow {
                mode: self.mode,
                maximum_window_in_minutes: self.maximum_window_in_minutes,
            }
        }
    }
}
impl FlexibleTimeWindow {
    /// Creates a new builder-style object to manufacture [`FlexibleTimeWindow`](crate::model::FlexibleTimeWindow).
    pub fn builder() -> crate::model::flexible_time_window::Builder {
        crate::model::flexible_time_window::Builder::default()
    }
}

/// When writing a match expression against `FlexibleTimeWindowMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let flexibletimewindowmode = unimplemented!();
/// match flexibletimewindowmode {
///     FlexibleTimeWindowMode::Flexible => { /* ... */ },
///     FlexibleTimeWindowMode::Off => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `flexibletimewindowmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FlexibleTimeWindowMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FlexibleTimeWindowMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FlexibleTimeWindowMode::NewFeature` is defined.
/// Specifically, when `flexibletimewindowmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FlexibleTimeWindowMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FlexibleTimeWindowMode {
    #[allow(missing_docs)] // documentation missing in model
    Flexible,
    #[allow(missing_docs)] // documentation missing in model
    Off,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FlexibleTimeWindowMode {
    fn from(s: &str) -> Self {
        match s {
            "FLEXIBLE" => FlexibleTimeWindowMode::Flexible,
            "OFF" => FlexibleTimeWindowMode::Off,
            other => {
                FlexibleTimeWindowMode::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FlexibleTimeWindowMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FlexibleTimeWindowMode::from(s))
    }
}
impl FlexibleTimeWindowMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FlexibleTimeWindowMode::Flexible => "FLEXIBLE",
            FlexibleTimeWindowMode::Off => "OFF",
            FlexibleTimeWindowMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FLEXIBLE", "OFF"]
    }
}
impl AsRef<str> for FlexibleTimeWindowMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The schedule's target. EventBridge Scheduler supports templated target that invoke common API operations, as well as universal targets that you can customize to invoke over 6,000 API operations across more than 270 services. You can only specify one templated or universal target for a schedule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Target {
    /// <p>The Amazon Resource Name (ARN) of the target.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
    /// <p>An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.</p>
    #[doc(hidden)]
    pub dead_letter_config: std::option::Option<crate::model::DeadLetterConfig>,
    /// <p>A <code>RetryPolicy</code> object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.</p>
    #[doc(hidden)]
    pub retry_policy: std::option::Option<crate::model::RetryPolicy>,
    /// <p>The text, or well-formed JSON, passed to the target. If you are configuring a templated Lambda, AWS Step Functions, or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, EventBridge Scheduler delivers a default notification to the target.</p>
    #[doc(hidden)]
    pub input: std::option::Option<std::string::String>,
    /// <p>The templated target type for the Amazon ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html"> <code>RunTask</code> </a> API operation.</p>
    #[doc(hidden)]
    pub ecs_parameters: std::option::Option<crate::model::EcsParameters>,
    /// <p>The templated target type for the EventBridge <a href="https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html"> <code>PutEvents</code> </a> API operation.</p>
    #[doc(hidden)]
    pub event_bridge_parameters: std::option::Option<crate::model::EventBridgeParameters>,
    /// <p>The templated target type for the Amazon Kinesis <a href="kinesis/latest/APIReference/API_PutRecord.html"> <code>PutRecord</code> </a> API operation.</p>
    #[doc(hidden)]
    pub kinesis_parameters: std::option::Option<crate::model::KinesisParameters>,
    /// <p>The templated target type for the Amazon SageMaker <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html"> <code>StartPipelineExecution</code> </a> API operation.</p>
    #[doc(hidden)]
    pub sage_maker_pipeline_parameters:
        std::option::Option<crate::model::SageMakerPipelineParameters>,
    /// <p>The templated target type for the Amazon SQS <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html"> <code>SendMessage</code> </a> API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html">Using the Amazon SQS message deduplication ID</a> in the <i>Amazon SQS Developer Guide</i>.</p>
    #[doc(hidden)]
    pub sqs_parameters: std::option::Option<crate::model::SqsParameters>,
}
impl Target {
    /// <p>The Amazon Resource Name (ARN) of the target.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The Amazon Resource Name (ARN) of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
    /// <p>An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.</p>
    pub fn dead_letter_config(&self) -> std::option::Option<&crate::model::DeadLetterConfig> {
        self.dead_letter_config.as_ref()
    }
    /// <p>A <code>RetryPolicy</code> object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.</p>
    pub fn retry_policy(&self) -> std::option::Option<&crate::model::RetryPolicy> {
        self.retry_policy.as_ref()
    }
    /// <p>The text, or well-formed JSON, passed to the target. If you are configuring a templated Lambda, AWS Step Functions, or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, EventBridge Scheduler delivers a default notification to the target.</p>
    pub fn input(&self) -> std::option::Option<&str> {
        self.input.as_deref()
    }
    /// <p>The templated target type for the Amazon ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html"> <code>RunTask</code> </a> API operation.</p>
    pub fn ecs_parameters(&self) -> std::option::Option<&crate::model::EcsParameters> {
        self.ecs_parameters.as_ref()
    }
    /// <p>The templated target type for the EventBridge <a href="https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html"> <code>PutEvents</code> </a> API operation.</p>
    pub fn event_bridge_parameters(
        &self,
    ) -> std::option::Option<&crate::model::EventBridgeParameters> {
        self.event_bridge_parameters.as_ref()
    }
    /// <p>The templated target type for the Amazon Kinesis <a href="kinesis/latest/APIReference/API_PutRecord.html"> <code>PutRecord</code> </a> API operation.</p>
    pub fn kinesis_parameters(&self) -> std::option::Option<&crate::model::KinesisParameters> {
        self.kinesis_parameters.as_ref()
    }
    /// <p>The templated target type for the Amazon SageMaker <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html"> <code>StartPipelineExecution</code> </a> API operation.</p>
    pub fn sage_maker_pipeline_parameters(
        &self,
    ) -> std::option::Option<&crate::model::SageMakerPipelineParameters> {
        self.sage_maker_pipeline_parameters.as_ref()
    }
    /// <p>The templated target type for the Amazon SQS <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html"> <code>SendMessage</code> </a> API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html">Using the Amazon SQS message deduplication ID</a> in the <i>Amazon SQS Developer Guide</i>.</p>
    pub fn sqs_parameters(&self) -> std::option::Option<&crate::model::SqsParameters> {
        self.sqs_parameters.as_ref()
    }
}
/// See [`Target`](crate::model::Target).
pub mod target {

    /// A builder for [`Target`](crate::model::Target).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
        pub(crate) dead_letter_config: std::option::Option<crate::model::DeadLetterConfig>,
        pub(crate) retry_policy: std::option::Option<crate::model::RetryPolicy>,
        pub(crate) input: std::option::Option<std::string::String>,
        pub(crate) ecs_parameters: std::option::Option<crate::model::EcsParameters>,
        pub(crate) event_bridge_parameters:
            std::option::Option<crate::model::EventBridgeParameters>,
        pub(crate) kinesis_parameters: std::option::Option<crate::model::KinesisParameters>,
        pub(crate) sage_maker_pipeline_parameters:
            std::option::Option<crate::model::SageMakerPipelineParameters>,
        pub(crate) sqs_parameters: std::option::Option<crate::model::SqsParameters>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the target.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the target.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the IAM role that EventBridge Scheduler will use for this target when the schedule is invoked.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// <p>An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.</p>
        pub fn dead_letter_config(mut self, input: crate::model::DeadLetterConfig) -> Self {
            self.dead_letter_config = Some(input);
            self
        }
        /// <p>An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.</p>
        pub fn set_dead_letter_config(
            mut self,
            input: std::option::Option<crate::model::DeadLetterConfig>,
        ) -> Self {
            self.dead_letter_config = input;
            self
        }
        /// <p>A <code>RetryPolicy</code> object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.</p>
        pub fn retry_policy(mut self, input: crate::model::RetryPolicy) -> Self {
            self.retry_policy = Some(input);
            self
        }
        /// <p>A <code>RetryPolicy</code> object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.</p>
        pub fn set_retry_policy(
            mut self,
            input: std::option::Option<crate::model::RetryPolicy>,
        ) -> Self {
            self.retry_policy = input;
            self
        }
        /// <p>The text, or well-formed JSON, passed to the target. If you are configuring a templated Lambda, AWS Step Functions, or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, EventBridge Scheduler delivers a default notification to the target.</p>
        pub fn input(mut self, input: impl Into<std::string::String>) -> Self {
            self.input = Some(input.into());
            self
        }
        /// <p>The text, or well-formed JSON, passed to the target. If you are configuring a templated Lambda, AWS Step Functions, or Amazon EventBridge target, the input must be a well-formed JSON. For all other target types, a JSON is not required. If you do not specify anything for this field, EventBridge Scheduler delivers a default notification to the target.</p>
        pub fn set_input(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.input = input;
            self
        }
        /// <p>The templated target type for the Amazon ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html"> <code>RunTask</code> </a> API operation.</p>
        pub fn ecs_parameters(mut self, input: crate::model::EcsParameters) -> Self {
            self.ecs_parameters = Some(input);
            self
        }
        /// <p>The templated target type for the Amazon ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html"> <code>RunTask</code> </a> API operation.</p>
        pub fn set_ecs_parameters(
            mut self,
            input: std::option::Option<crate::model::EcsParameters>,
        ) -> Self {
            self.ecs_parameters = input;
            self
        }
        /// <p>The templated target type for the EventBridge <a href="https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html"> <code>PutEvents</code> </a> API operation.</p>
        pub fn event_bridge_parameters(
            mut self,
            input: crate::model::EventBridgeParameters,
        ) -> Self {
            self.event_bridge_parameters = Some(input);
            self
        }
        /// <p>The templated target type for the EventBridge <a href="https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html"> <code>PutEvents</code> </a> API operation.</p>
        pub fn set_event_bridge_parameters(
            mut self,
            input: std::option::Option<crate::model::EventBridgeParameters>,
        ) -> Self {
            self.event_bridge_parameters = input;
            self
        }
        /// <p>The templated target type for the Amazon Kinesis <a href="kinesis/latest/APIReference/API_PutRecord.html"> <code>PutRecord</code> </a> API operation.</p>
        pub fn kinesis_parameters(mut self, input: crate::model::KinesisParameters) -> Self {
            self.kinesis_parameters = Some(input);
            self
        }
        /// <p>The templated target type for the Amazon Kinesis <a href="kinesis/latest/APIReference/API_PutRecord.html"> <code>PutRecord</code> </a> API operation.</p>
        pub fn set_kinesis_parameters(
            mut self,
            input: std::option::Option<crate::model::KinesisParameters>,
        ) -> Self {
            self.kinesis_parameters = input;
            self
        }
        /// <p>The templated target type for the Amazon SageMaker <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html"> <code>StartPipelineExecution</code> </a> API operation.</p>
        pub fn sage_maker_pipeline_parameters(
            mut self,
            input: crate::model::SageMakerPipelineParameters,
        ) -> Self {
            self.sage_maker_pipeline_parameters = Some(input);
            self
        }
        /// <p>The templated target type for the Amazon SageMaker <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html"> <code>StartPipelineExecution</code> </a> API operation.</p>
        pub fn set_sage_maker_pipeline_parameters(
            mut self,
            input: std::option::Option<crate::model::SageMakerPipelineParameters>,
        ) -> Self {
            self.sage_maker_pipeline_parameters = input;
            self
        }
        /// <p>The templated target type for the Amazon SQS <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html"> <code>SendMessage</code> </a> API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html">Using the Amazon SQS message deduplication ID</a> in the <i>Amazon SQS Developer Guide</i>.</p>
        pub fn sqs_parameters(mut self, input: crate::model::SqsParameters) -> Self {
            self.sqs_parameters = Some(input);
            self
        }
        /// <p>The templated target type for the Amazon SQS <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html"> <code>SendMessage</code> </a> API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html">Using the Amazon SQS message deduplication ID</a> in the <i>Amazon SQS Developer Guide</i>.</p>
        pub fn set_sqs_parameters(
            mut self,
            input: std::option::Option<crate::model::SqsParameters>,
        ) -> Self {
            self.sqs_parameters = input;
            self
        }
        /// Consumes the builder and constructs a [`Target`](crate::model::Target).
        pub fn build(self) -> crate::model::Target {
            crate::model::Target {
                arn: self.arn,
                role_arn: self.role_arn,
                dead_letter_config: self.dead_letter_config,
                retry_policy: self.retry_policy,
                input: self.input,
                ecs_parameters: self.ecs_parameters,
                event_bridge_parameters: self.event_bridge_parameters,
                kinesis_parameters: self.kinesis_parameters,
                sage_maker_pipeline_parameters: self.sage_maker_pipeline_parameters,
                sqs_parameters: self.sqs_parameters,
            }
        }
    }
}
impl Target {
    /// Creates a new builder-style object to manufacture [`Target`](crate::model::Target).
    pub fn builder() -> crate::model::target::Builder {
        crate::model::target::Builder::default()
    }
}

/// <p>The templated target type for the Amazon SQS <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html"> <code>SendMessage</code> </a> API operation. Contains the message group ID to use when the target is a FIFO queue. If you specify an Amazon SQS FIFO queue as a target, the queue must have content-based deduplication enabled. For more information, see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html">Using the Amazon SQS message deduplication ID</a> in the <i>Amazon SQS Developer Guide</i>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SqsParameters {
    /// <p>The FIFO message group ID to use as the target.</p>
    #[doc(hidden)]
    pub message_group_id: std::option::Option<std::string::String>,
}
impl SqsParameters {
    /// <p>The FIFO message group ID to use as the target.</p>
    pub fn message_group_id(&self) -> std::option::Option<&str> {
        self.message_group_id.as_deref()
    }
}
/// See [`SqsParameters`](crate::model::SqsParameters).
pub mod sqs_parameters {

    /// A builder for [`SqsParameters`](crate::model::SqsParameters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_group_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The FIFO message group ID to use as the target.</p>
        pub fn message_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_group_id = Some(input.into());
            self
        }
        /// <p>The FIFO message group ID to use as the target.</p>
        pub fn set_message_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.message_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`SqsParameters`](crate::model::SqsParameters).
        pub fn build(self) -> crate::model::SqsParameters {
            crate::model::SqsParameters {
                message_group_id: self.message_group_id,
            }
        }
    }
}
impl SqsParameters {
    /// Creates a new builder-style object to manufacture [`SqsParameters`](crate::model::SqsParameters).
    pub fn builder() -> crate::model::sqs_parameters::Builder {
        crate::model::sqs_parameters::Builder::default()
    }
}

/// <p>The templated target type for the Amazon SageMaker <a href="https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_StartPipelineExecution.html"> <code>StartPipelineExecution</code> </a> API operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SageMakerPipelineParameters {
    /// <p>List of parameter names and values to use when executing the SageMaker Model Building Pipeline.</p>
    #[doc(hidden)]
    pub pipeline_parameter_list:
        std::option::Option<std::vec::Vec<crate::model::SageMakerPipelineParameter>>,
}
impl SageMakerPipelineParameters {
    /// <p>List of parameter names and values to use when executing the SageMaker Model Building Pipeline.</p>
    pub fn pipeline_parameter_list(
        &self,
    ) -> std::option::Option<&[crate::model::SageMakerPipelineParameter]> {
        self.pipeline_parameter_list.as_deref()
    }
}
/// See [`SageMakerPipelineParameters`](crate::model::SageMakerPipelineParameters).
pub mod sage_maker_pipeline_parameters {

    /// A builder for [`SageMakerPipelineParameters`](crate::model::SageMakerPipelineParameters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pipeline_parameter_list:
            std::option::Option<std::vec::Vec<crate::model::SageMakerPipelineParameter>>,
    }
    impl Builder {
        /// Appends an item to `pipeline_parameter_list`.
        ///
        /// To override the contents of this collection use [`set_pipeline_parameter_list`](Self::set_pipeline_parameter_list).
        ///
        /// <p>List of parameter names and values to use when executing the SageMaker Model Building Pipeline.</p>
        pub fn pipeline_parameter_list(
            mut self,
            input: crate::model::SageMakerPipelineParameter,
        ) -> Self {
            let mut v = self.pipeline_parameter_list.unwrap_or_default();
            v.push(input);
            self.pipeline_parameter_list = Some(v);
            self
        }
        /// <p>List of parameter names and values to use when executing the SageMaker Model Building Pipeline.</p>
        pub fn set_pipeline_parameter_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SageMakerPipelineParameter>>,
        ) -> Self {
            self.pipeline_parameter_list = input;
            self
        }
        /// Consumes the builder and constructs a [`SageMakerPipelineParameters`](crate::model::SageMakerPipelineParameters).
        pub fn build(self) -> crate::model::SageMakerPipelineParameters {
            crate::model::SageMakerPipelineParameters {
                pipeline_parameter_list: self.pipeline_parameter_list,
            }
        }
    }
}
impl SageMakerPipelineParameters {
    /// Creates a new builder-style object to manufacture [`SageMakerPipelineParameters`](crate::model::SageMakerPipelineParameters).
    pub fn builder() -> crate::model::sage_maker_pipeline_parameters::Builder {
        crate::model::sage_maker_pipeline_parameters::Builder::default()
    }
}

/// <p>The name and value pair of a parameter to use to start execution of a SageMaker Model Building Pipeline.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SageMakerPipelineParameter {
    /// <p>Name of parameter to start execution of a SageMaker Model Building Pipeline.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Value of parameter to start execution of a SageMaker Model Building Pipeline.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl SageMakerPipelineParameter {
    /// <p>Name of parameter to start execution of a SageMaker Model Building Pipeline.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Value of parameter to start execution of a SageMaker Model Building Pipeline.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`SageMakerPipelineParameter`](crate::model::SageMakerPipelineParameter).
pub mod sage_maker_pipeline_parameter {

    /// A builder for [`SageMakerPipelineParameter`](crate::model::SageMakerPipelineParameter).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Name of parameter to start execution of a SageMaker Model Building Pipeline.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of parameter to start execution of a SageMaker Model Building Pipeline.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Value of parameter to start execution of a SageMaker Model Building Pipeline.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>Value of parameter to start execution of a SageMaker Model Building Pipeline.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`SageMakerPipelineParameter`](crate::model::SageMakerPipelineParameter).
        pub fn build(self) -> crate::model::SageMakerPipelineParameter {
            crate::model::SageMakerPipelineParameter {
                name: self.name,
                value: self.value,
            }
        }
    }
}
impl SageMakerPipelineParameter {
    /// Creates a new builder-style object to manufacture [`SageMakerPipelineParameter`](crate::model::SageMakerPipelineParameter).
    pub fn builder() -> crate::model::sage_maker_pipeline_parameter::Builder {
        crate::model::sage_maker_pipeline_parameter::Builder::default()
    }
}

/// <p>The templated target type for the Amazon Kinesis <a href="kinesis/latest/APIReference/API_PutRecord.html"> <code>PutRecord</code> </a> API operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct KinesisParameters {
    /// <p>Specifies the shard to which EventBridge Scheduler sends the event. For more information, see <a href="https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html">Amazon Kinesis Data Streams terminology and concepts</a> in the <i>Amazon Kinesis Streams Developer Guide</i>.</p>
    #[doc(hidden)]
    pub partition_key: std::option::Option<std::string::String>,
}
impl KinesisParameters {
    /// <p>Specifies the shard to which EventBridge Scheduler sends the event. For more information, see <a href="https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html">Amazon Kinesis Data Streams terminology and concepts</a> in the <i>Amazon Kinesis Streams Developer Guide</i>.</p>
    pub fn partition_key(&self) -> std::option::Option<&str> {
        self.partition_key.as_deref()
    }
}
/// See [`KinesisParameters`](crate::model::KinesisParameters).
pub mod kinesis_parameters {

    /// A builder for [`KinesisParameters`](crate::model::KinesisParameters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) partition_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the shard to which EventBridge Scheduler sends the event. For more information, see <a href="https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html">Amazon Kinesis Data Streams terminology and concepts</a> in the <i>Amazon Kinesis Streams Developer Guide</i>.</p>
        pub fn partition_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.partition_key = Some(input.into());
            self
        }
        /// <p>Specifies the shard to which EventBridge Scheduler sends the event. For more information, see <a href="https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html">Amazon Kinesis Data Streams terminology and concepts</a> in the <i>Amazon Kinesis Streams Developer Guide</i>.</p>
        pub fn set_partition_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.partition_key = input;
            self
        }
        /// Consumes the builder and constructs a [`KinesisParameters`](crate::model::KinesisParameters).
        pub fn build(self) -> crate::model::KinesisParameters {
            crate::model::KinesisParameters {
                partition_key: self.partition_key,
            }
        }
    }
}
impl KinesisParameters {
    /// Creates a new builder-style object to manufacture [`KinesisParameters`](crate::model::KinesisParameters).
    pub fn builder() -> crate::model::kinesis_parameters::Builder {
        crate::model::kinesis_parameters::Builder::default()
    }
}

/// <p>The templated target type for the EventBridge <a href="https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEvents.html"> <code>PutEvents</code> </a> API operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventBridgeParameters {
    /// <p>A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.</p>
    #[doc(hidden)]
    pub detail_type: std::option::Option<std::string::String>,
    /// <p>The source of the event.</p>
    #[doc(hidden)]
    pub source: std::option::Option<std::string::String>,
}
impl EventBridgeParameters {
    /// <p>A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.</p>
    pub fn detail_type(&self) -> std::option::Option<&str> {
        self.detail_type.as_deref()
    }
    /// <p>The source of the event.</p>
    pub fn source(&self) -> std::option::Option<&str> {
        self.source.as_deref()
    }
}
/// See [`EventBridgeParameters`](crate::model::EventBridgeParameters).
pub mod event_bridge_parameters {

    /// A builder for [`EventBridgeParameters`](crate::model::EventBridgeParameters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) detail_type: std::option::Option<std::string::String>,
        pub(crate) source: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.</p>
        pub fn detail_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.detail_type = Some(input.into());
            self
        }
        /// <p>A free-form string, with a maximum of 128 characters, used to decide what fields to expect in the event detail.</p>
        pub fn set_detail_type(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.detail_type = input;
            self
        }
        /// <p>The source of the event.</p>
        pub fn source(mut self, input: impl Into<std::string::String>) -> Self {
            self.source = Some(input.into());
            self
        }
        /// <p>The source of the event.</p>
        pub fn set_source(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.source = input;
            self
        }
        /// Consumes the builder and constructs a [`EventBridgeParameters`](crate::model::EventBridgeParameters).
        pub fn build(self) -> crate::model::EventBridgeParameters {
            crate::model::EventBridgeParameters {
                detail_type: self.detail_type,
                source: self.source,
            }
        }
    }
}
impl EventBridgeParameters {
    /// Creates a new builder-style object to manufacture [`EventBridgeParameters`](crate::model::EventBridgeParameters).
    pub fn builder() -> crate::model::event_bridge_parameters::Builder {
        crate::model::event_bridge_parameters::Builder::default()
    }
}

/// <p>The templated target type for the Amazon ECS <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html"> <code>RunTask</code> </a> API operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EcsParameters {
    /// <p>The Amazon Resource Name (ARN) of the task definition to use if the event target is an Amazon ECS task.</p>
    #[doc(hidden)]
    pub task_definition_arn: std::option::Option<std::string::String>,
    /// <p>The number of tasks to create based on <code>TaskDefinition</code>. The default is <code>1</code>.</p>
    #[doc(hidden)]
    pub task_count: std::option::Option<i32>,
    /// <p>Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The <code>FARGATE</code> value is supported only in the Regions where Fargate with Amazon ECS is supported. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html">AWS Fargate on Amazon ECS</a> in the <i>Amazon ECS Developer Guide</i>.</p>
    #[doc(hidden)]
    pub launch_type: std::option::Option<crate::model::LaunchType>,
    /// <p>This structure specifies the network configuration for an ECS task.</p>
    #[doc(hidden)]
    pub network_configuration: std::option::Option<crate::model::NetworkConfiguration>,
    /// <p>Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as <code>1.1.0</code>.</p>
    #[doc(hidden)]
    pub platform_version: std::option::Option<std::string::String>,
    /// <p>Specifies an ECS task group for the task. The maximum length is 255 characters.</p>
    #[doc(hidden)]
    pub group: std::option::Option<std::string::String>,
    /// <p>The capacity provider strategy to use for the task.</p>
    #[doc(hidden)]
    pub capacity_provider_strategy:
        std::option::Option<std::vec::Vec<crate::model::CapacityProviderStrategyItem>>,
    /// <p>Specifies whether to enable Amazon ECS managed tags for the task. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html">Tagging Your Amazon ECS Resources</a> in the <i>Amazon ECS Developer Guide</i>.</p>
    #[doc(hidden)]
    pub enable_ecs_managed_tags: std::option::Option<bool>,
    /// <p>Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.</p>
    #[doc(hidden)]
    pub enable_execute_command: std::option::Option<bool>,
    /// <p>An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).</p>
    #[doc(hidden)]
    pub placement_constraints:
        std::option::Option<std::vec::Vec<crate::model::PlacementConstraint>>,
    /// <p>The task placement strategy for a task or service.</p>
    #[doc(hidden)]
    pub placement_strategy: std::option::Option<std::vec::Vec<crate::model::PlacementStrategy>>,
    /// <p>Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use Amazon ECS's <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html"> <code>TagResource</code> </a> API action. </p>
    #[doc(hidden)]
    pub propagate_tags: std::option::Option<crate::model::PropagateTags>,
    /// <p>The reference ID to use for the task.</p>
    #[doc(hidden)]
    pub reference_id: std::option::Option<std::string::String>,
    /// <p>The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html"> <code>RunTask</code> </a> in the <i>Amazon ECS API Reference</i>.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<
        std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
    >,
}
impl EcsParameters {
    /// <p>The Amazon Resource Name (ARN) of the task definition to use if the event target is an Amazon ECS task.</p>
    pub fn task_definition_arn(&self) -> std::option::Option<&str> {
        self.task_definition_arn.as_deref()
    }
    /// <p>The number of tasks to create based on <code>TaskDefinition</code>. The default is <code>1</code>.</p>
    pub fn task_count(&self) -> std::option::Option<i32> {
        self.task_count
    }
    /// <p>Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The <code>FARGATE</code> value is supported only in the Regions where Fargate with Amazon ECS is supported. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html">AWS Fargate on Amazon ECS</a> in the <i>Amazon ECS Developer Guide</i>.</p>
    pub fn launch_type(&self) -> std::option::Option<&crate::model::LaunchType> {
        self.launch_type.as_ref()
    }
    /// <p>This structure specifies the network configuration for an ECS task.</p>
    pub fn network_configuration(
        &self,
    ) -> std::option::Option<&crate::model::NetworkConfiguration> {
        self.network_configuration.as_ref()
    }
    /// <p>Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as <code>1.1.0</code>.</p>
    pub fn platform_version(&self) -> std::option::Option<&str> {
        self.platform_version.as_deref()
    }
    /// <p>Specifies an ECS task group for the task. The maximum length is 255 characters.</p>
    pub fn group(&self) -> std::option::Option<&str> {
        self.group.as_deref()
    }
    /// <p>The capacity provider strategy to use for the task.</p>
    pub fn capacity_provider_strategy(
        &self,
    ) -> std::option::Option<&[crate::model::CapacityProviderStrategyItem]> {
        self.capacity_provider_strategy.as_deref()
    }
    /// <p>Specifies whether to enable Amazon ECS managed tags for the task. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html">Tagging Your Amazon ECS Resources</a> in the <i>Amazon ECS Developer Guide</i>.</p>
    pub fn enable_ecs_managed_tags(&self) -> std::option::Option<bool> {
        self.enable_ecs_managed_tags
    }
    /// <p>Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.</p>
    pub fn enable_execute_command(&self) -> std::option::Option<bool> {
        self.enable_execute_command
    }
    /// <p>An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).</p>
    pub fn placement_constraints(
        &self,
    ) -> std::option::Option<&[crate::model::PlacementConstraint]> {
        self.placement_constraints.as_deref()
    }
    /// <p>The task placement strategy for a task or service.</p>
    pub fn placement_strategy(&self) -> std::option::Option<&[crate::model::PlacementStrategy]> {
        self.placement_strategy.as_deref()
    }
    /// <p>Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use Amazon ECS's <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html"> <code>TagResource</code> </a> API action. </p>
    pub fn propagate_tags(&self) -> std::option::Option<&crate::model::PropagateTags> {
        self.propagate_tags.as_ref()
    }
    /// <p>The reference ID to use for the task.</p>
    pub fn reference_id(&self) -> std::option::Option<&str> {
        self.reference_id.as_deref()
    }
    /// <p>The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html"> <code>RunTask</code> </a> in the <i>Amazon ECS API Reference</i>.</p>
    pub fn tags(
        &self,
    ) -> std::option::Option<&[std::collections::HashMap<std::string::String, std::string::String>]>
    {
        self.tags.as_deref()
    }
}
/// See [`EcsParameters`](crate::model::EcsParameters).
pub mod ecs_parameters {

    /// A builder for [`EcsParameters`](crate::model::EcsParameters).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) task_definition_arn: std::option::Option<std::string::String>,
        pub(crate) task_count: std::option::Option<i32>,
        pub(crate) launch_type: std::option::Option<crate::model::LaunchType>,
        pub(crate) network_configuration: std::option::Option<crate::model::NetworkConfiguration>,
        pub(crate) platform_version: std::option::Option<std::string::String>,
        pub(crate) group: std::option::Option<std::string::String>,
        pub(crate) capacity_provider_strategy:
            std::option::Option<std::vec::Vec<crate::model::CapacityProviderStrategyItem>>,
        pub(crate) enable_ecs_managed_tags: std::option::Option<bool>,
        pub(crate) enable_execute_command: std::option::Option<bool>,
        pub(crate) placement_constraints:
            std::option::Option<std::vec::Vec<crate::model::PlacementConstraint>>,
        pub(crate) placement_strategy:
            std::option::Option<std::vec::Vec<crate::model::PlacementStrategy>>,
        pub(crate) propagate_tags: std::option::Option<crate::model::PropagateTags>,
        pub(crate) reference_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<
            std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
        >,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the task definition to use if the event target is an Amazon ECS task.</p>
        pub fn task_definition_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.task_definition_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the task definition to use if the event target is an Amazon ECS task.</p>
        pub fn set_task_definition_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.task_definition_arn = input;
            self
        }
        /// <p>The number of tasks to create based on <code>TaskDefinition</code>. The default is <code>1</code>.</p>
        pub fn task_count(mut self, input: i32) -> Self {
            self.task_count = Some(input);
            self
        }
        /// <p>The number of tasks to create based on <code>TaskDefinition</code>. The default is <code>1</code>.</p>
        pub fn set_task_count(mut self, input: std::option::Option<i32>) -> Self {
            self.task_count = input;
            self
        }
        /// <p>Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The <code>FARGATE</code> value is supported only in the Regions where Fargate with Amazon ECS is supported. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html">AWS Fargate on Amazon ECS</a> in the <i>Amazon ECS Developer Guide</i>.</p>
        pub fn launch_type(mut self, input: crate::model::LaunchType) -> Self {
            self.launch_type = Some(input);
            self
        }
        /// <p>Specifies the launch type on which your task is running. The launch type that you specify here must match one of the launch type (compatibilities) of the target task. The <code>FARGATE</code> value is supported only in the Regions where Fargate with Amazon ECS is supported. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html">AWS Fargate on Amazon ECS</a> in the <i>Amazon ECS Developer Guide</i>.</p>
        pub fn set_launch_type(
            mut self,
            input: std::option::Option<crate::model::LaunchType>,
        ) -> Self {
            self.launch_type = input;
            self
        }
        /// <p>This structure specifies the network configuration for an ECS task.</p>
        pub fn network_configuration(mut self, input: crate::model::NetworkConfiguration) -> Self {
            self.network_configuration = Some(input);
            self
        }
        /// <p>This structure specifies the network configuration for an ECS task.</p>
        pub fn set_network_configuration(
            mut self,
            input: std::option::Option<crate::model::NetworkConfiguration>,
        ) -> Self {
            self.network_configuration = input;
            self
        }
        /// <p>Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as <code>1.1.0</code>.</p>
        pub fn platform_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.platform_version = Some(input.into());
            self
        }
        /// <p>Specifies the platform version for the task. Specify only the numeric portion of the platform version, such as <code>1.1.0</code>.</p>
        pub fn set_platform_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.platform_version = input;
            self
        }
        /// <p>Specifies an ECS task group for the task. The maximum length is 255 characters.</p>
        pub fn group(mut self, input: impl Into<std::string::String>) -> Self {
            self.group = Some(input.into());
            self
        }
        /// <p>Specifies an ECS task group for the task. The maximum length is 255 characters.</p>
        pub fn set_group(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group = input;
            self
        }
        /// Appends an item to `capacity_provider_strategy`.
        ///
        /// To override the contents of this collection use [`set_capacity_provider_strategy`](Self::set_capacity_provider_strategy).
        ///
        /// <p>The capacity provider strategy to use for the task.</p>
        pub fn capacity_provider_strategy(
            mut self,
            input: crate::model::CapacityProviderStrategyItem,
        ) -> Self {
            let mut v = self.capacity_provider_strategy.unwrap_or_default();
            v.push(input);
            self.capacity_provider_strategy = Some(v);
            self
        }
        /// <p>The capacity provider strategy to use for the task.</p>
        pub fn set_capacity_provider_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CapacityProviderStrategyItem>>,
        ) -> Self {
            self.capacity_provider_strategy = input;
            self
        }
        /// <p>Specifies whether to enable Amazon ECS managed tags for the task. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html">Tagging Your Amazon ECS Resources</a> in the <i>Amazon ECS Developer Guide</i>.</p>
        pub fn enable_ecs_managed_tags(mut self, input: bool) -> Self {
            self.enable_ecs_managed_tags = Some(input);
            self
        }
        /// <p>Specifies whether to enable Amazon ECS managed tags for the task. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html">Tagging Your Amazon ECS Resources</a> in the <i>Amazon ECS Developer Guide</i>.</p>
        pub fn set_enable_ecs_managed_tags(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_ecs_managed_tags = input;
            self
        }
        /// <p>Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.</p>
        pub fn enable_execute_command(mut self, input: bool) -> Self {
            self.enable_execute_command = Some(input);
            self
        }
        /// <p>Whether or not to enable the execute command functionality for the containers in this task. If true, this enables execute command functionality on all containers in the task.</p>
        pub fn set_enable_execute_command(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_execute_command = input;
            self
        }
        /// Appends an item to `placement_constraints`.
        ///
        /// To override the contents of this collection use [`set_placement_constraints`](Self::set_placement_constraints).
        ///
        /// <p>An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).</p>
        pub fn placement_constraints(mut self, input: crate::model::PlacementConstraint) -> Self {
            let mut v = self.placement_constraints.unwrap_or_default();
            v.push(input);
            self.placement_constraints = Some(v);
            self
        }
        /// <p>An array of placement constraint objects to use for the task. You can specify up to 10 constraints per task (including constraints in the task definition and those specified at runtime).</p>
        pub fn set_placement_constraints(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlacementConstraint>>,
        ) -> Self {
            self.placement_constraints = input;
            self
        }
        /// Appends an item to `placement_strategy`.
        ///
        /// To override the contents of this collection use [`set_placement_strategy`](Self::set_placement_strategy).
        ///
        /// <p>The task placement strategy for a task or service.</p>
        pub fn placement_strategy(mut self, input: crate::model::PlacementStrategy) -> Self {
            let mut v = self.placement_strategy.unwrap_or_default();
            v.push(input);
            self.placement_strategy = Some(v);
            self
        }
        /// <p>The task placement strategy for a task or service.</p>
        pub fn set_placement_strategy(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PlacementStrategy>>,
        ) -> Self {
            self.placement_strategy = input;
            self
        }
        /// <p>Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use Amazon ECS's <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html"> <code>TagResource</code> </a> API action. </p>
        pub fn propagate_tags(mut self, input: crate::model::PropagateTags) -> Self {
            self.propagate_tags = Some(input);
            self
        }
        /// <p>Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags are not propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task creation, use Amazon ECS's <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html"> <code>TagResource</code> </a> API action. </p>
        pub fn set_propagate_tags(
            mut self,
            input: std::option::Option<crate::model::PropagateTags>,
        ) -> Self {
            self.propagate_tags = input;
            self
        }
        /// <p>The reference ID to use for the task.</p>
        pub fn reference_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.reference_id = Some(input.into());
            self
        }
        /// <p>The reference ID to use for the task.</p>
        pub fn set_reference_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.reference_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html"> <code>RunTask</code> </a> in the <i>Amazon ECS API Reference</i>.</p>
        pub fn tags(
            mut self,
            input: std::collections::HashMap<std::string::String, std::string::String>,
        ) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The metadata that you apply to the task to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html"> <code>RunTask</code> </a> in the <i>Amazon ECS API Reference</i>.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::vec::Vec<std::collections::HashMap<std::string::String, std::string::String>>,
            >,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`EcsParameters`](crate::model::EcsParameters).
        pub fn build(self) -> crate::model::EcsParameters {
            crate::model::EcsParameters {
                task_definition_arn: self.task_definition_arn,
                task_count: self.task_count,
                launch_type: self.launch_type,
                network_configuration: self.network_configuration,
                platform_version: self.platform_version,
                group: self.group,
                capacity_provider_strategy: self.capacity_provider_strategy,
                enable_ecs_managed_tags: self.enable_ecs_managed_tags,
                enable_execute_command: self.enable_execute_command,
                placement_constraints: self.placement_constraints,
                placement_strategy: self.placement_strategy,
                propagate_tags: self.propagate_tags,
                reference_id: self.reference_id,
                tags: self.tags,
            }
        }
    }
}
impl EcsParameters {
    /// Creates a new builder-style object to manufacture [`EcsParameters`](crate::model::EcsParameters).
    pub fn builder() -> crate::model::ecs_parameters::Builder {
        crate::model::ecs_parameters::Builder::default()
    }
}

/// When writing a match expression against `PropagateTags`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let propagatetags = unimplemented!();
/// match propagatetags {
///     PropagateTags::TaskDefinition => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `propagatetags` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PropagateTags::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PropagateTags::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PropagateTags::NewFeature` is defined.
/// Specifically, when `propagatetags` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PropagateTags::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PropagateTags {
    #[allow(missing_docs)] // documentation missing in model
    TaskDefinition,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PropagateTags {
    fn from(s: &str) -> Self {
        match s {
            "TASK_DEFINITION" => PropagateTags::TaskDefinition,
            other => PropagateTags::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PropagateTags {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PropagateTags::from(s))
    }
}
impl PropagateTags {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PropagateTags::TaskDefinition => "TASK_DEFINITION",
            PropagateTags::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["TASK_DEFINITION"]
    }
}
impl AsRef<str> for PropagateTags {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The task placement strategy for a task or service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PlacementStrategy {
    /// <p>The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PlacementStrategyType>,
    /// <p>The field to apply the placement strategy against. For the spread placement strategy, valid values are <code>instanceId</code> (or <code>instanceId</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>. For the binpack placement strategy, valid values are <code>cpu</code> and <code>memory</code>. For the random placement strategy, this field is not used.</p>
    #[doc(hidden)]
    pub field: std::option::Option<std::string::String>,
}
impl PlacementStrategy {
    /// <p>The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PlacementStrategyType> {
        self.r#type.as_ref()
    }
    /// <p>The field to apply the placement strategy against. For the spread placement strategy, valid values are <code>instanceId</code> (or <code>instanceId</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>. For the binpack placement strategy, valid values are <code>cpu</code> and <code>memory</code>. For the random placement strategy, this field is not used.</p>
    pub fn field(&self) -> std::option::Option<&str> {
        self.field.as_deref()
    }
}
/// See [`PlacementStrategy`](crate::model::PlacementStrategy).
pub mod placement_strategy {

    /// A builder for [`PlacementStrategy`](crate::model::PlacementStrategy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::PlacementStrategyType>,
        pub(crate) field: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).</p>
        pub fn r#type(mut self, input: crate::model::PlacementStrategyType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::PlacementStrategyType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The field to apply the placement strategy against. For the spread placement strategy, valid values are <code>instanceId</code> (or <code>instanceId</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>. For the binpack placement strategy, valid values are <code>cpu</code> and <code>memory</code>. For the random placement strategy, this field is not used.</p>
        pub fn field(mut self, input: impl Into<std::string::String>) -> Self {
            self.field = Some(input.into());
            self
        }
        /// <p>The field to apply the placement strategy against. For the spread placement strategy, valid values are <code>instanceId</code> (or <code>instanceId</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>. For the binpack placement strategy, valid values are <code>cpu</code> and <code>memory</code>. For the random placement strategy, this field is not used.</p>
        pub fn set_field(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.field = input;
            self
        }
        /// Consumes the builder and constructs a [`PlacementStrategy`](crate::model::PlacementStrategy).
        pub fn build(self) -> crate::model::PlacementStrategy {
            crate::model::PlacementStrategy {
                r#type: self.r#type,
                field: self.field,
            }
        }
    }
}
impl PlacementStrategy {
    /// Creates a new builder-style object to manufacture [`PlacementStrategy`](crate::model::PlacementStrategy).
    pub fn builder() -> crate::model::placement_strategy::Builder {
        crate::model::placement_strategy::Builder::default()
    }
}

/// When writing a match expression against `PlacementStrategyType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let placementstrategytype = unimplemented!();
/// match placementstrategytype {
///     PlacementStrategyType::Binpack => { /* ... */ },
///     PlacementStrategyType::Random => { /* ... */ },
///     PlacementStrategyType::Spread => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `placementstrategytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PlacementStrategyType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PlacementStrategyType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PlacementStrategyType::NewFeature` is defined.
/// Specifically, when `placementstrategytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PlacementStrategyType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PlacementStrategyType {
    #[allow(missing_docs)] // documentation missing in model
    Binpack,
    #[allow(missing_docs)] // documentation missing in model
    Random,
    #[allow(missing_docs)] // documentation missing in model
    Spread,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PlacementStrategyType {
    fn from(s: &str) -> Self {
        match s {
            "binpack" => PlacementStrategyType::Binpack,
            "random" => PlacementStrategyType::Random,
            "spread" => PlacementStrategyType::Spread,
            other => {
                PlacementStrategyType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PlacementStrategyType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PlacementStrategyType::from(s))
    }
}
impl PlacementStrategyType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PlacementStrategyType::Binpack => "binpack",
            PlacementStrategyType::Random => "random",
            PlacementStrategyType::Spread => "spread",
            PlacementStrategyType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["binpack", "random", "spread"]
    }
}
impl AsRef<str> for PlacementStrategyType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>An object representing a constraint on task placement.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PlacementConstraint {
    /// <p>The type of constraint. Use <code>distinctInstance</code> to ensure that each task in a particular group is running on a different container instance. Use <code>memberOf</code> to restrict the selection to a group of valid candidates.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PlacementConstraintType>,
    /// <p>A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is <code>distinctInstance</code>. For more information, see <a href="https://docs.aws.amazon.com/latest/developerguide/cluster-query-language.html">Cluster query language</a> in the <i>Amazon ECS Developer Guide</i>.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
}
impl PlacementConstraint {
    /// <p>The type of constraint. Use <code>distinctInstance</code> to ensure that each task in a particular group is running on a different container instance. Use <code>memberOf</code> to restrict the selection to a group of valid candidates.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PlacementConstraintType> {
        self.r#type.as_ref()
    }
    /// <p>A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is <code>distinctInstance</code>. For more information, see <a href="https://docs.aws.amazon.com/latest/developerguide/cluster-query-language.html">Cluster query language</a> in the <i>Amazon ECS Developer Guide</i>.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
}
/// See [`PlacementConstraint`](crate::model::PlacementConstraint).
pub mod placement_constraint {

    /// A builder for [`PlacementConstraint`](crate::model::PlacementConstraint).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::PlacementConstraintType>,
        pub(crate) expression: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The type of constraint. Use <code>distinctInstance</code> to ensure that each task in a particular group is running on a different container instance. Use <code>memberOf</code> to restrict the selection to a group of valid candidates.</p>
        pub fn r#type(mut self, input: crate::model::PlacementConstraintType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of constraint. Use <code>distinctInstance</code> to ensure that each task in a particular group is running on a different container instance. Use <code>memberOf</code> to restrict the selection to a group of valid candidates.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::PlacementConstraintType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is <code>distinctInstance</code>. For more information, see <a href="https://docs.aws.amazon.com/latest/developerguide/cluster-query-language.html">Cluster query language</a> in the <i>Amazon ECS Developer Guide</i>.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>A cluster query language expression to apply to the constraint. You cannot specify an expression if the constraint type is <code>distinctInstance</code>. For more information, see <a href="https://docs.aws.amazon.com/latest/developerguide/cluster-query-language.html">Cluster query language</a> in the <i>Amazon ECS Developer Guide</i>.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// Consumes the builder and constructs a [`PlacementConstraint`](crate::model::PlacementConstraint).
        pub fn build(self) -> crate::model::PlacementConstraint {
            crate::model::PlacementConstraint {
                r#type: self.r#type,
                expression: self.expression,
            }
        }
    }
}
impl PlacementConstraint {
    /// Creates a new builder-style object to manufacture [`PlacementConstraint`](crate::model::PlacementConstraint).
    pub fn builder() -> crate::model::placement_constraint::Builder {
        crate::model::placement_constraint::Builder::default()
    }
}

/// When writing a match expression against `PlacementConstraintType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let placementconstrainttype = unimplemented!();
/// match placementconstrainttype {
///     PlacementConstraintType::DistinctInstance => { /* ... */ },
///     PlacementConstraintType::MemberOf => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `placementconstrainttype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PlacementConstraintType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PlacementConstraintType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PlacementConstraintType::NewFeature` is defined.
/// Specifically, when `placementconstrainttype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PlacementConstraintType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PlacementConstraintType {
    #[allow(missing_docs)] // documentation missing in model
    DistinctInstance,
    #[allow(missing_docs)] // documentation missing in model
    MemberOf,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PlacementConstraintType {
    fn from(s: &str) -> Self {
        match s {
            "distinctInstance" => PlacementConstraintType::DistinctInstance,
            "memberOf" => PlacementConstraintType::MemberOf,
            other => PlacementConstraintType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PlacementConstraintType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PlacementConstraintType::from(s))
    }
}
impl PlacementConstraintType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PlacementConstraintType::DistinctInstance => "distinctInstance",
            PlacementConstraintType::MemberOf => "memberOf",
            PlacementConstraintType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["distinctInstance", "memberOf"]
    }
}
impl AsRef<str> for PlacementConstraintType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The details of a capacity provider strategy.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CapacityProviderStrategyItem {
    /// <p>The short name of the capacity provider.</p>
    #[doc(hidden)]
    pub capacity_provider: std::option::Option<std::string::String>,
    /// <p>The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.</p>
    #[doc(hidden)]
    pub weight: i32,
    /// <p>The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of <code>0</code> is used.</p>
    #[doc(hidden)]
    pub base: i32,
}
impl CapacityProviderStrategyItem {
    /// <p>The short name of the capacity provider.</p>
    pub fn capacity_provider(&self) -> std::option::Option<&str> {
        self.capacity_provider.as_deref()
    }
    /// <p>The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.</p>
    pub fn weight(&self) -> i32 {
        self.weight
    }
    /// <p>The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of <code>0</code> is used.</p>
    pub fn base(&self) -> i32 {
        self.base
    }
}
/// See [`CapacityProviderStrategyItem`](crate::model::CapacityProviderStrategyItem).
pub mod capacity_provider_strategy_item {

    /// A builder for [`CapacityProviderStrategyItem`](crate::model::CapacityProviderStrategyItem).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity_provider: std::option::Option<std::string::String>,
        pub(crate) weight: std::option::Option<i32>,
        pub(crate) base: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The short name of the capacity provider.</p>
        pub fn capacity_provider(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity_provider = Some(input.into());
            self
        }
        /// <p>The short name of the capacity provider.</p>
        pub fn set_capacity_provider(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.capacity_provider = input;
            self
        }
        /// <p>The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.</p>
        pub fn weight(mut self, input: i32) -> Self {
            self.weight = Some(input);
            self
        }
        /// <p>The weight value designates the relative percentage of the total number of tasks launched that should use the specified capacity provider. The weight value is taken into consideration after the base value, if defined, is satisfied.</p>
        pub fn set_weight(mut self, input: std::option::Option<i32>) -> Self {
            self.weight = input;
            self
        }
        /// <p>The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of <code>0</code> is used.</p>
        pub fn base(mut self, input: i32) -> Self {
            self.base = Some(input);
            self
        }
        /// <p>The base value designates how many tasks, at a minimum, to run on the specified capacity provider. Only one capacity provider in a capacity provider strategy can have a base defined. If no value is specified, the default value of <code>0</code> is used.</p>
        pub fn set_base(mut self, input: std::option::Option<i32>) -> Self {
            self.base = input;
            self
        }
        /// Consumes the builder and constructs a [`CapacityProviderStrategyItem`](crate::model::CapacityProviderStrategyItem).
        pub fn build(self) -> crate::model::CapacityProviderStrategyItem {
            crate::model::CapacityProviderStrategyItem {
                capacity_provider: self.capacity_provider,
                weight: self.weight.unwrap_or_default(),
                base: self.base.unwrap_or_default(),
            }
        }
    }
}
impl CapacityProviderStrategyItem {
    /// Creates a new builder-style object to manufacture [`CapacityProviderStrategyItem`](crate::model::CapacityProviderStrategyItem).
    pub fn builder() -> crate::model::capacity_provider_strategy_item::Builder {
        crate::model::capacity_provider_strategy_item::Builder::default()
    }
}

/// <p>Specifies the network configuration for an ECS task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkConfiguration {
    /// <p>Specifies the Amazon VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.</p>
    #[doc(hidden)]
    pub awsvpc_configuration: std::option::Option<crate::model::AwsVpcConfiguration>,
}
impl NetworkConfiguration {
    /// <p>Specifies the Amazon VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.</p>
    pub fn awsvpc_configuration(&self) -> std::option::Option<&crate::model::AwsVpcConfiguration> {
        self.awsvpc_configuration.as_ref()
    }
}
/// See [`NetworkConfiguration`](crate::model::NetworkConfiguration).
pub mod network_configuration {

    /// A builder for [`NetworkConfiguration`](crate::model::NetworkConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) awsvpc_configuration: std::option::Option<crate::model::AwsVpcConfiguration>,
    }
    impl Builder {
        /// <p>Specifies the Amazon VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.</p>
        pub fn awsvpc_configuration(mut self, input: crate::model::AwsVpcConfiguration) -> Self {
            self.awsvpc_configuration = Some(input);
            self
        }
        /// <p>Specifies the Amazon VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.</p>
        pub fn set_awsvpc_configuration(
            mut self,
            input: std::option::Option<crate::model::AwsVpcConfiguration>,
        ) -> Self {
            self.awsvpc_configuration = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkConfiguration`](crate::model::NetworkConfiguration).
        pub fn build(self) -> crate::model::NetworkConfiguration {
            crate::model::NetworkConfiguration {
                awsvpc_configuration: self.awsvpc_configuration,
            }
        }
    }
}
impl NetworkConfiguration {
    /// Creates a new builder-style object to manufacture [`NetworkConfiguration`](crate::model::NetworkConfiguration).
    pub fn builder() -> crate::model::network_configuration::Builder {
        crate::model::network_configuration::Builder::default()
    }
}

/// <p>This structure specifies the VPC subnets and security groups for the task, and whether a public IP address is to be used. This structure is relevant only for ECS tasks that use the awsvpc network mode.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AwsVpcConfiguration {
    /// <p>Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.</p>
    #[doc(hidden)]
    pub subnets: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.</p>
    #[doc(hidden)]
    pub security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Specifies whether the task's elastic network interface receives a public IP address. You can specify <code>ENABLED</code> only when <code>LaunchType</code> in <code>EcsParameters</code> is set to <code>FARGATE</code>.</p>
    #[doc(hidden)]
    pub assign_public_ip: std::option::Option<crate::model::AssignPublicIp>,
}
impl AwsVpcConfiguration {
    /// <p>Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.</p>
    pub fn subnets(&self) -> std::option::Option<&[std::string::String]> {
        self.subnets.as_deref()
    }
    /// <p>Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.</p>
    pub fn security_groups(&self) -> std::option::Option<&[std::string::String]> {
        self.security_groups.as_deref()
    }
    /// <p>Specifies whether the task's elastic network interface receives a public IP address. You can specify <code>ENABLED</code> only when <code>LaunchType</code> in <code>EcsParameters</code> is set to <code>FARGATE</code>.</p>
    pub fn assign_public_ip(&self) -> std::option::Option<&crate::model::AssignPublicIp> {
        self.assign_public_ip.as_ref()
    }
}
/// See [`AwsVpcConfiguration`](crate::model::AwsVpcConfiguration).
pub mod aws_vpc_configuration {

    /// A builder for [`AwsVpcConfiguration`](crate::model::AwsVpcConfiguration).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) subnets: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) security_groups: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) assign_public_ip: std::option::Option<crate::model::AssignPublicIp>,
    }
    impl Builder {
        /// Appends an item to `subnets`.
        ///
        /// To override the contents of this collection use [`set_subnets`](Self::set_subnets).
        ///
        /// <p>Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.</p>
        pub fn subnets(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnets.unwrap_or_default();
            v.push(input.into());
            self.subnets = Some(v);
            self
        }
        /// <p>Specifies the subnets associated with the task. These subnets must all be in the same VPC. You can specify as many as 16 subnets.</p>
        pub fn set_subnets(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnets = input;
            self
        }
        /// Appends an item to `security_groups`.
        ///
        /// To override the contents of this collection use [`set_security_groups`](Self::set_security_groups).
        ///
        /// <p>Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.</p>
        pub fn security_groups(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.security_groups.unwrap_or_default();
            v.push(input.into());
            self.security_groups = Some(v);
            self
        }
        /// <p>Specifies the security groups associated with the task. These security groups must all be in the same VPC. You can specify as many as five security groups. If you do not specify a security group, the default security group for the VPC is used.</p>
        pub fn set_security_groups(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.security_groups = input;
            self
        }
        /// <p>Specifies whether the task's elastic network interface receives a public IP address. You can specify <code>ENABLED</code> only when <code>LaunchType</code> in <code>EcsParameters</code> is set to <code>FARGATE</code>.</p>
        pub fn assign_public_ip(mut self, input: crate::model::AssignPublicIp) -> Self {
            self.assign_public_ip = Some(input);
            self
        }
        /// <p>Specifies whether the task's elastic network interface receives a public IP address. You can specify <code>ENABLED</code> only when <code>LaunchType</code> in <code>EcsParameters</code> is set to <code>FARGATE</code>.</p>
        pub fn set_assign_public_ip(
            mut self,
            input: std::option::Option<crate::model::AssignPublicIp>,
        ) -> Self {
            self.assign_public_ip = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsVpcConfiguration`](crate::model::AwsVpcConfiguration).
        pub fn build(self) -> crate::model::AwsVpcConfiguration {
            crate::model::AwsVpcConfiguration {
                subnets: self.subnets,
                security_groups: self.security_groups,
                assign_public_ip: self.assign_public_ip,
            }
        }
    }
}
impl AwsVpcConfiguration {
    /// Creates a new builder-style object to manufacture [`AwsVpcConfiguration`](crate::model::AwsVpcConfiguration).
    pub fn builder() -> crate::model::aws_vpc_configuration::Builder {
        crate::model::aws_vpc_configuration::Builder::default()
    }
}

/// When writing a match expression against `AssignPublicIp`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let assignpublicip = unimplemented!();
/// match assignpublicip {
///     AssignPublicIp::Disabled => { /* ... */ },
///     AssignPublicIp::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `assignpublicip` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssignPublicIp::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssignPublicIp::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssignPublicIp::NewFeature` is defined.
/// Specifically, when `assignpublicip` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssignPublicIp::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssignPublicIp {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssignPublicIp {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => AssignPublicIp::Disabled,
            "ENABLED" => AssignPublicIp::Enabled,
            other => AssignPublicIp::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for AssignPublicIp {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssignPublicIp::from(s))
    }
}
impl AssignPublicIp {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssignPublicIp::Disabled => "DISABLED",
            AssignPublicIp::Enabled => "ENABLED",
            AssignPublicIp::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for AssignPublicIp {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LaunchType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let launchtype = unimplemented!();
/// match launchtype {
///     LaunchType::Ec2 => { /* ... */ },
///     LaunchType::External => { /* ... */ },
///     LaunchType::Fargate => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `launchtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LaunchType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LaunchType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LaunchType::NewFeature` is defined.
/// Specifically, when `launchtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LaunchType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LaunchType {
    #[allow(missing_docs)] // documentation missing in model
    Ec2,
    #[allow(missing_docs)] // documentation missing in model
    External,
    #[allow(missing_docs)] // documentation missing in model
    Fargate,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LaunchType {
    fn from(s: &str) -> Self {
        match s {
            "EC2" => LaunchType::Ec2,
            "EXTERNAL" => LaunchType::External,
            "FARGATE" => LaunchType::Fargate,
            other => LaunchType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LaunchType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LaunchType::from(s))
    }
}
impl LaunchType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LaunchType::Ec2 => "EC2",
            LaunchType::External => "EXTERNAL",
            LaunchType::Fargate => "FARGATE",
            LaunchType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["EC2", "EXTERNAL", "FARGATE"]
    }
}
impl AsRef<str> for LaunchType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A <code>RetryPolicy</code> object that includes information about the retry policy settings, including the maximum age of an event, and the maximum number of times EventBridge Scheduler will try to deliver the event to a target.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RetryPolicy {
    /// <p>The maximum amount of time, in seconds, to continue to make retry attempts.</p>
    #[doc(hidden)]
    pub maximum_event_age_in_seconds: std::option::Option<i32>,
    /// <p>The maximum number of retry attempts to make before the request fails. Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the <code>MaximumEventAgeInSeconds</code> is reached.</p>
    #[doc(hidden)]
    pub maximum_retry_attempts: std::option::Option<i32>,
}
impl RetryPolicy {
    /// <p>The maximum amount of time, in seconds, to continue to make retry attempts.</p>
    pub fn maximum_event_age_in_seconds(&self) -> std::option::Option<i32> {
        self.maximum_event_age_in_seconds
    }
    /// <p>The maximum number of retry attempts to make before the request fails. Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the <code>MaximumEventAgeInSeconds</code> is reached.</p>
    pub fn maximum_retry_attempts(&self) -> std::option::Option<i32> {
        self.maximum_retry_attempts
    }
}
/// See [`RetryPolicy`](crate::model::RetryPolicy).
pub mod retry_policy {

    /// A builder for [`RetryPolicy`](crate::model::RetryPolicy).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) maximum_event_age_in_seconds: std::option::Option<i32>,
        pub(crate) maximum_retry_attempts: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The maximum amount of time, in seconds, to continue to make retry attempts.</p>
        pub fn maximum_event_age_in_seconds(mut self, input: i32) -> Self {
            self.maximum_event_age_in_seconds = Some(input);
            self
        }
        /// <p>The maximum amount of time, in seconds, to continue to make retry attempts.</p>
        pub fn set_maximum_event_age_in_seconds(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_event_age_in_seconds = input;
            self
        }
        /// <p>The maximum number of retry attempts to make before the request fails. Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the <code>MaximumEventAgeInSeconds</code> is reached.</p>
        pub fn maximum_retry_attempts(mut self, input: i32) -> Self {
            self.maximum_retry_attempts = Some(input);
            self
        }
        /// <p>The maximum number of retry attempts to make before the request fails. Retry attempts with exponential backoff continue until either the maximum number of attempts is made or until the duration of the <code>MaximumEventAgeInSeconds</code> is reached.</p>
        pub fn set_maximum_retry_attempts(mut self, input: std::option::Option<i32>) -> Self {
            self.maximum_retry_attempts = input;
            self
        }
        /// Consumes the builder and constructs a [`RetryPolicy`](crate::model::RetryPolicy).
        pub fn build(self) -> crate::model::RetryPolicy {
            crate::model::RetryPolicy {
                maximum_event_age_in_seconds: self.maximum_event_age_in_seconds,
                maximum_retry_attempts: self.maximum_retry_attempts,
            }
        }
    }
}
impl RetryPolicy {
    /// Creates a new builder-style object to manufacture [`RetryPolicy`](crate::model::RetryPolicy).
    pub fn builder() -> crate::model::retry_policy::Builder {
        crate::model::retry_policy::Builder::default()
    }
}

/// <p>An object that contains information about an Amazon SQS queue that EventBridge Scheduler uses as a dead-letter queue for your schedule. If specified, EventBridge Scheduler delivers failed events that could not be successfully delivered to a target to the queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeadLetterConfig {
    /// <p>The Amazon Resource Name (ARN) of the SQS queue specified as the destination for the dead-letter queue.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl DeadLetterConfig {
    /// <p>The Amazon Resource Name (ARN) of the SQS queue specified as the destination for the dead-letter queue.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
/// See [`DeadLetterConfig`](crate::model::DeadLetterConfig).
pub mod dead_letter_config {

    /// A builder for [`DeadLetterConfig`](crate::model::DeadLetterConfig).
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name (ARN) of the SQS queue specified as the destination for the dead-letter queue.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the SQS queue specified as the destination for the dead-letter queue.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`DeadLetterConfig`](crate::model::DeadLetterConfig).
        pub fn build(self) -> crate::model::DeadLetterConfig {
            crate::model::DeadLetterConfig { arn: self.arn }
        }
    }
}
impl DeadLetterConfig {
    /// Creates a new builder-style object to manufacture [`DeadLetterConfig`](crate::model::DeadLetterConfig).
    pub fn builder() -> crate::model::dead_letter_config::Builder {
        crate::model::dead_letter_config::Builder::default()
    }
}
