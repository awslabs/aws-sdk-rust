// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct UpdateScheduleInput {
    /// <p>The name of the schedule that you are updating.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The name of the schedule group with which the schedule is associated. You must provide this value in order for EventBridge Scheduler to find the schedule you want to update. If you omit this value, EventBridge Scheduler assumes the group is associated to the default group.</p>
    pub group_name: ::std::option::Option<::std::string::String>,
    /// <p> The expression that defines when the schedule runs. The following formats are supported. </p>
    /// <ul>
    /// <li> <p> <code>at</code> expression - <code>at(yyyy-mm-ddThh:mm:ss)</code> </p> </li>
    /// <li> <p> <code>rate</code> expression - <code>rate(value unit)</code> </p> </li>
    /// <li> <p> <code>cron</code> expression - <code>cron(fields)</code> </p> </li>
    /// </ul>
    /// <p> You can use <code>at</code> expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use <code>rate</code> and <code>cron</code> expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. </p>
    /// <p> A <code>cron</code> expression consists of six fields separated by white spaces: <code>(minutes hours day_of_month month day_of_week year)</code>. </p>
    /// <p> A <code>rate</code> expression consists of a <i>value</i> as a positive integer, and a <i>unit</i> with the following options: <code>minute</code> | <code>minutes</code> | <code>hour</code> | <code>hours</code> | <code>day</code> | <code>days</code> </p>
    /// <p> For more information and examples, see <a href="https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html">Schedule types on EventBridge Scheduler</a> in the <i>EventBridge Scheduler User Guide</i>. </p>
    pub schedule_expression: ::std::option::Option<::std::string::String>,
    /// <p>The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the <code>StartDate</code> you specify. EventBridge Scheduler ignores <code>StartDate</code> for one-time schedules.</p>
    pub start_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the <code>EndDate</code> you specify. EventBridge Scheduler ignores <code>EndDate</code> for one-time schedules.</p>
    pub end_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    /// <p>The description you specify for the schedule.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The timezone in which the scheduling expression is evaluated.</p>
    pub schedule_expression_timezone: ::std::option::Option<::std::string::String>,
    /// <p>Specifies whether the schedule is enabled or disabled.</p>
    pub state: ::std::option::Option<crate::types::ScheduleState>,
    /// <p>The ARN for the customer managed KMS key that that you want EventBridge Scheduler to use to encrypt and decrypt your data.</p>
    pub kms_key_arn: ::std::option::Option<::std::string::String>,
    /// <p>The schedule target. You can use this operation to change the target that your schedule invokes.</p>
    pub target: ::std::option::Option<crate::types::Target>,
    /// <p>Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.</p>
    pub flexible_time_window: ::std::option::Option<crate::types::FlexibleTimeWindow>,
    /// <p> Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. </p>
    pub client_token: ::std::option::Option<::std::string::String>,
    /// <p>Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.</p>
    pub action_after_completion: ::std::option::Option<crate::types::ActionAfterCompletion>,
}
impl UpdateScheduleInput {
    /// <p>The name of the schedule that you are updating.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the schedule group with which the schedule is associated. You must provide this value in order for EventBridge Scheduler to find the schedule you want to update. If you omit this value, EventBridge Scheduler assumes the group is associated to the default group.</p>
    pub fn group_name(&self) -> ::std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p> The expression that defines when the schedule runs. The following formats are supported. </p>
    /// <ul>
    /// <li> <p> <code>at</code> expression - <code>at(yyyy-mm-ddThh:mm:ss)</code> </p> </li>
    /// <li> <p> <code>rate</code> expression - <code>rate(value unit)</code> </p> </li>
    /// <li> <p> <code>cron</code> expression - <code>cron(fields)</code> </p> </li>
    /// </ul>
    /// <p> You can use <code>at</code> expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use <code>rate</code> and <code>cron</code> expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. </p>
    /// <p> A <code>cron</code> expression consists of six fields separated by white spaces: <code>(minutes hours day_of_month month day_of_week year)</code>. </p>
    /// <p> A <code>rate</code> expression consists of a <i>value</i> as a positive integer, and a <i>unit</i> with the following options: <code>minute</code> | <code>minutes</code> | <code>hour</code> | <code>hours</code> | <code>day</code> | <code>days</code> </p>
    /// <p> For more information and examples, see <a href="https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html">Schedule types on EventBridge Scheduler</a> in the <i>EventBridge Scheduler User Guide</i>. </p>
    pub fn schedule_expression(&self) -> ::std::option::Option<&str> {
        self.schedule_expression.as_deref()
    }
    /// <p>The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the <code>StartDate</code> you specify. EventBridge Scheduler ignores <code>StartDate</code> for one-time schedules.</p>
    pub fn start_date(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.start_date.as_ref()
    }
    /// <p>The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the <code>EndDate</code> you specify. EventBridge Scheduler ignores <code>EndDate</code> for one-time schedules.</p>
    pub fn end_date(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.end_date.as_ref()
    }
    /// <p>The description you specify for the schedule.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The timezone in which the scheduling expression is evaluated.</p>
    pub fn schedule_expression_timezone(&self) -> ::std::option::Option<&str> {
        self.schedule_expression_timezone.as_deref()
    }
    /// <p>Specifies whether the schedule is enabled or disabled.</p>
    pub fn state(&self) -> ::std::option::Option<&crate::types::ScheduleState> {
        self.state.as_ref()
    }
    /// <p>The ARN for the customer managed KMS key that that you want EventBridge Scheduler to use to encrypt and decrypt your data.</p>
    pub fn kms_key_arn(&self) -> ::std::option::Option<&str> {
        self.kms_key_arn.as_deref()
    }
    /// <p>The schedule target. You can use this operation to change the target that your schedule invokes.</p>
    pub fn target(&self) -> ::std::option::Option<&crate::types::Target> {
        self.target.as_ref()
    }
    /// <p>Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.</p>
    pub fn flexible_time_window(&self) -> ::std::option::Option<&crate::types::FlexibleTimeWindow> {
        self.flexible_time_window.as_ref()
    }
    /// <p> Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. </p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
    /// <p>Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.</p>
    pub fn action_after_completion(&self) -> ::std::option::Option<&crate::types::ActionAfterCompletion> {
        self.action_after_completion.as_ref()
    }
}
impl UpdateScheduleInput {
    /// Creates a new builder-style object to manufacture [`UpdateScheduleInput`](crate::operation::update_schedule::UpdateScheduleInput).
    pub fn builder() -> crate::operation::update_schedule::builders::UpdateScheduleInputBuilder {
        crate::operation::update_schedule::builders::UpdateScheduleInputBuilder::default()
    }
}

/// A builder for [`UpdateScheduleInput`](crate::operation::update_schedule::UpdateScheduleInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct UpdateScheduleInputBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) group_name: ::std::option::Option<::std::string::String>,
    pub(crate) schedule_expression: ::std::option::Option<::std::string::String>,
    pub(crate) start_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) end_date: ::std::option::Option<::aws_smithy_types::DateTime>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) schedule_expression_timezone: ::std::option::Option<::std::string::String>,
    pub(crate) state: ::std::option::Option<crate::types::ScheduleState>,
    pub(crate) kms_key_arn: ::std::option::Option<::std::string::String>,
    pub(crate) target: ::std::option::Option<crate::types::Target>,
    pub(crate) flexible_time_window: ::std::option::Option<crate::types::FlexibleTimeWindow>,
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
    pub(crate) action_after_completion: ::std::option::Option<crate::types::ActionAfterCompletion>,
}
impl UpdateScheduleInputBuilder {
    /// <p>The name of the schedule that you are updating.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the schedule that you are updating.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the schedule that you are updating.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The name of the schedule group with which the schedule is associated. You must provide this value in order for EventBridge Scheduler to find the schedule you want to update. If you omit this value, EventBridge Scheduler assumes the group is associated to the default group.</p>
    pub fn group_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.group_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the schedule group with which the schedule is associated. You must provide this value in order for EventBridge Scheduler to find the schedule you want to update. If you omit this value, EventBridge Scheduler assumes the group is associated to the default group.</p>
    pub fn set_group_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.group_name = input;
        self
    }
    /// <p>The name of the schedule group with which the schedule is associated. You must provide this value in order for EventBridge Scheduler to find the schedule you want to update. If you omit this value, EventBridge Scheduler assumes the group is associated to the default group.</p>
    pub fn get_group_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.group_name
    }
    /// <p> The expression that defines when the schedule runs. The following formats are supported. </p>
    /// <ul>
    /// <li> <p> <code>at</code> expression - <code>at(yyyy-mm-ddThh:mm:ss)</code> </p> </li>
    /// <li> <p> <code>rate</code> expression - <code>rate(value unit)</code> </p> </li>
    /// <li> <p> <code>cron</code> expression - <code>cron(fields)</code> </p> </li>
    /// </ul>
    /// <p> You can use <code>at</code> expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use <code>rate</code> and <code>cron</code> expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. </p>
    /// <p> A <code>cron</code> expression consists of six fields separated by white spaces: <code>(minutes hours day_of_month month day_of_week year)</code>. </p>
    /// <p> A <code>rate</code> expression consists of a <i>value</i> as a positive integer, and a <i>unit</i> with the following options: <code>minute</code> | <code>minutes</code> | <code>hour</code> | <code>hours</code> | <code>day</code> | <code>days</code> </p>
    /// <p> For more information and examples, see <a href="https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html">Schedule types on EventBridge Scheduler</a> in the <i>EventBridge Scheduler User Guide</i>. </p>
    /// This field is required.
    pub fn schedule_expression(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.schedule_expression = ::std::option::Option::Some(input.into());
        self
    }
    /// <p> The expression that defines when the schedule runs. The following formats are supported. </p>
    /// <ul>
    /// <li> <p> <code>at</code> expression - <code>at(yyyy-mm-ddThh:mm:ss)</code> </p> </li>
    /// <li> <p> <code>rate</code> expression - <code>rate(value unit)</code> </p> </li>
    /// <li> <p> <code>cron</code> expression - <code>cron(fields)</code> </p> </li>
    /// </ul>
    /// <p> You can use <code>at</code> expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use <code>rate</code> and <code>cron</code> expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. </p>
    /// <p> A <code>cron</code> expression consists of six fields separated by white spaces: <code>(minutes hours day_of_month month day_of_week year)</code>. </p>
    /// <p> A <code>rate</code> expression consists of a <i>value</i> as a positive integer, and a <i>unit</i> with the following options: <code>minute</code> | <code>minutes</code> | <code>hour</code> | <code>hours</code> | <code>day</code> | <code>days</code> </p>
    /// <p> For more information and examples, see <a href="https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html">Schedule types on EventBridge Scheduler</a> in the <i>EventBridge Scheduler User Guide</i>. </p>
    pub fn set_schedule_expression(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.schedule_expression = input;
        self
    }
    /// <p> The expression that defines when the schedule runs. The following formats are supported. </p>
    /// <ul>
    /// <li> <p> <code>at</code> expression - <code>at(yyyy-mm-ddThh:mm:ss)</code> </p> </li>
    /// <li> <p> <code>rate</code> expression - <code>rate(value unit)</code> </p> </li>
    /// <li> <p> <code>cron</code> expression - <code>cron(fields)</code> </p> </li>
    /// </ul>
    /// <p> You can use <code>at</code> expressions to create one-time schedules that invoke a target once, at the time and in the time zone, that you specify. You can use <code>rate</code> and <code>cron</code> expressions to create recurring schedules. Rate-based schedules are useful when you want to invoke a target at regular intervals, such as every 15 minutes or every five days. Cron-based schedules are useful when you want to invoke a target periodically at a specific time, such as at 8:00 am (UTC+0) every 1st day of the month. </p>
    /// <p> A <code>cron</code> expression consists of six fields separated by white spaces: <code>(minutes hours day_of_month month day_of_week year)</code>. </p>
    /// <p> A <code>rate</code> expression consists of a <i>value</i> as a positive integer, and a <i>unit</i> with the following options: <code>minute</code> | <code>minutes</code> | <code>hour</code> | <code>hours</code> | <code>day</code> | <code>days</code> </p>
    /// <p> For more information and examples, see <a href="https://docs.aws.amazon.com/scheduler/latest/UserGuide/schedule-types.html">Schedule types on EventBridge Scheduler</a> in the <i>EventBridge Scheduler User Guide</i>. </p>
    pub fn get_schedule_expression(&self) -> &::std::option::Option<::std::string::String> {
        &self.schedule_expression
    }
    /// <p>The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the <code>StartDate</code> you specify. EventBridge Scheduler ignores <code>StartDate</code> for one-time schedules.</p>
    pub fn start_date(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.start_date = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the <code>StartDate</code> you specify. EventBridge Scheduler ignores <code>StartDate</code> for one-time schedules.</p>
    pub fn set_start_date(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.start_date = input;
        self
    }
    /// <p>The date, in UTC, after which the schedule can begin invoking its target. Depending on the schedule's recurrence expression, invocations might occur on, or after, the <code>StartDate</code> you specify. EventBridge Scheduler ignores <code>StartDate</code> for one-time schedules.</p>
    pub fn get_start_date(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.start_date
    }
    /// <p>The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the <code>EndDate</code> you specify. EventBridge Scheduler ignores <code>EndDate</code> for one-time schedules.</p>
    pub fn end_date(mut self, input: ::aws_smithy_types::DateTime) -> Self {
        self.end_date = ::std::option::Option::Some(input);
        self
    }
    /// <p>The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the <code>EndDate</code> you specify. EventBridge Scheduler ignores <code>EndDate</code> for one-time schedules.</p>
    pub fn set_end_date(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
        self.end_date = input;
        self
    }
    /// <p>The date, in UTC, before which the schedule can invoke its target. Depending on the schedule's recurrence expression, invocations might stop on, or before, the <code>EndDate</code> you specify. EventBridge Scheduler ignores <code>EndDate</code> for one-time schedules.</p>
    pub fn get_end_date(&self) -> &::std::option::Option<::aws_smithy_types::DateTime> {
        &self.end_date
    }
    /// <p>The description you specify for the schedule.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The description you specify for the schedule.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The description you specify for the schedule.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The timezone in which the scheduling expression is evaluated.</p>
    pub fn schedule_expression_timezone(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.schedule_expression_timezone = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The timezone in which the scheduling expression is evaluated.</p>
    pub fn set_schedule_expression_timezone(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.schedule_expression_timezone = input;
        self
    }
    /// <p>The timezone in which the scheduling expression is evaluated.</p>
    pub fn get_schedule_expression_timezone(&self) -> &::std::option::Option<::std::string::String> {
        &self.schedule_expression_timezone
    }
    /// <p>Specifies whether the schedule is enabled or disabled.</p>
    pub fn state(mut self, input: crate::types::ScheduleState) -> Self {
        self.state = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies whether the schedule is enabled or disabled.</p>
    pub fn set_state(mut self, input: ::std::option::Option<crate::types::ScheduleState>) -> Self {
        self.state = input;
        self
    }
    /// <p>Specifies whether the schedule is enabled or disabled.</p>
    pub fn get_state(&self) -> &::std::option::Option<crate::types::ScheduleState> {
        &self.state
    }
    /// <p>The ARN for the customer managed KMS key that that you want EventBridge Scheduler to use to encrypt and decrypt your data.</p>
    pub fn kms_key_arn(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.kms_key_arn = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The ARN for the customer managed KMS key that that you want EventBridge Scheduler to use to encrypt and decrypt your data.</p>
    pub fn set_kms_key_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.kms_key_arn = input;
        self
    }
    /// <p>The ARN for the customer managed KMS key that that you want EventBridge Scheduler to use to encrypt and decrypt your data.</p>
    pub fn get_kms_key_arn(&self) -> &::std::option::Option<::std::string::String> {
        &self.kms_key_arn
    }
    /// <p>The schedule target. You can use this operation to change the target that your schedule invokes.</p>
    /// This field is required.
    pub fn target(mut self, input: crate::types::Target) -> Self {
        self.target = ::std::option::Option::Some(input);
        self
    }
    /// <p>The schedule target. You can use this operation to change the target that your schedule invokes.</p>
    pub fn set_target(mut self, input: ::std::option::Option<crate::types::Target>) -> Self {
        self.target = input;
        self
    }
    /// <p>The schedule target. You can use this operation to change the target that your schedule invokes.</p>
    pub fn get_target(&self) -> &::std::option::Option<crate::types::Target> {
        &self.target
    }
    /// <p>Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.</p>
    /// This field is required.
    pub fn flexible_time_window(mut self, input: crate::types::FlexibleTimeWindow) -> Self {
        self.flexible_time_window = ::std::option::Option::Some(input);
        self
    }
    /// <p>Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.</p>
    pub fn set_flexible_time_window(mut self, input: ::std::option::Option<crate::types::FlexibleTimeWindow>) -> Self {
        self.flexible_time_window = input;
        self
    }
    /// <p>Allows you to configure a time window during which EventBridge Scheduler invokes the schedule.</p>
    pub fn get_flexible_time_window(&self) -> &::std::option::Option<crate::types::FlexibleTimeWindow> {
        &self.flexible_time_window
    }
    /// <p> Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. </p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p> Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. </p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p> Unique, case-sensitive identifier you provide to ensure the idempotency of the request. If you do not specify a client token, EventBridge Scheduler uses a randomly generated token for the request to ensure idempotency. </p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// <p>Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.</p>
    pub fn action_after_completion(mut self, input: crate::types::ActionAfterCompletion) -> Self {
        self.action_after_completion = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.</p>
    pub fn set_action_after_completion(mut self, input: ::std::option::Option<crate::types::ActionAfterCompletion>) -> Self {
        self.action_after_completion = input;
        self
    }
    /// <p>Specifies the action that EventBridge Scheduler applies to the schedule after the schedule completes invoking the target.</p>
    pub fn get_action_after_completion(&self) -> &::std::option::Option<crate::types::ActionAfterCompletion> {
        &self.action_after_completion
    }
    /// Consumes the builder and constructs a [`UpdateScheduleInput`](crate::operation::update_schedule::UpdateScheduleInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::update_schedule::UpdateScheduleInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::update_schedule::UpdateScheduleInput {
            name: self.name,
            group_name: self.group_name,
            schedule_expression: self.schedule_expression,
            start_date: self.start_date,
            end_date: self.end_date,
            description: self.description,
            schedule_expression_timezone: self.schedule_expression_timezone,
            state: self.state,
            kms_key_arn: self.kms_key_arn,
            target: self.target,
            flexible_time_window: self.flexible_time_window,
            client_token: self.client_token,
            action_after_completion: self.action_after_completion,
        })
    }
}
