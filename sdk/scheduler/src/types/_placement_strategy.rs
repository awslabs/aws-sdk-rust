// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The task placement strategy for a task or service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PlacementStrategy  {
    /// <p>The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::types::PlacementStrategyType>,
    /// <p>The field to apply the placement strategy against. For the spread placement strategy, valid values are <code>instanceId</code> (or <code>instanceId</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>. For the binpack placement strategy, valid values are <code>cpu</code> and <code>memory</code>. For the random placement strategy, this field is not used.</p>
    #[doc(hidden)]
    pub field: std::option::Option<std::string::String>,
}
impl PlacementStrategy {
    /// <p>The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).</p>
    pub fn r#type(&self) -> std::option::Option<& crate::types::PlacementStrategyType> {
        self.r#type.as_ref()
    }
    /// <p>The field to apply the placement strategy against. For the spread placement strategy, valid values are <code>instanceId</code> (or <code>instanceId</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>. For the binpack placement strategy, valid values are <code>cpu</code> and <code>memory</code>. For the random placement strategy, this field is not used.</p>
    pub fn field(&self) -> std::option::Option<& str> {
        self.field.as_deref()
    }
}
impl PlacementStrategy {
    /// Creates a new builder-style object to manufacture [`PlacementStrategy`](crate::types::PlacementStrategy).
    pub fn builder() -> crate::types::builders::PlacementStrategyBuilder {
        crate::types::builders::PlacementStrategyBuilder::default()
    }
}

/// A builder for [`PlacementStrategy`](crate::types::PlacementStrategy).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct PlacementStrategyBuilder {
    pub(crate) r#type: std::option::Option<crate::types::PlacementStrategyType>,
    pub(crate) field: std::option::Option<std::string::String>,
}
impl PlacementStrategyBuilder {
    /// <p>The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).</p>
    pub fn r#type(mut self, input: crate::types::PlacementStrategyType) -> Self {
        self.r#type = Some(input);
        self
    }
    /// <p>The type of placement strategy. The random placement strategy randomly places tasks on available candidates. The spread placement strategy spreads placement across available candidates evenly based on the field parameter. The binpack strategy places tasks on available candidates that have the least available amount of the resource that is specified with the field parameter. For example, if you binpack on memory, a task is placed on the instance with the least amount of remaining memory (but still enough to run the task).</p>
    pub fn set_type(mut self, input: std::option::Option<crate::types::PlacementStrategyType>) -> Self {
        self.r#type = input; self
    }
    /// <p>The field to apply the placement strategy against. For the spread placement strategy, valid values are <code>instanceId</code> (or <code>instanceId</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>. For the binpack placement strategy, valid values are <code>cpu</code> and <code>memory</code>. For the random placement strategy, this field is not used.</p>
    pub fn field(mut self, input: impl Into<std::string::String>) -> Self {
        self.field = Some(input.into());
        self
    }
    /// <p>The field to apply the placement strategy against. For the spread placement strategy, valid values are <code>instanceId</code> (or <code>instanceId</code>, which has the same effect), or any platform or custom attribute that is applied to a container instance, such as <code>attribute:ecs.availability-zone</code>. For the binpack placement strategy, valid values are <code>cpu</code> and <code>memory</code>. For the random placement strategy, this field is not used.</p>
    pub fn set_field(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.field = input; self
    }
    /// Consumes the builder and constructs a [`PlacementStrategy`](crate::types::PlacementStrategy).
    pub fn build(self) -> crate::types::PlacementStrategy {
        crate::types::PlacementStrategy {
            r#type: self.r#type
            ,
            field: self.field
            ,
        }
    }
}

