// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn create_access_point(&self) -> fluent_builders::CreateAccessPoint<C> {
        fluent_builders::CreateAccessPoint::new(self.handle.clone())
    }
    pub fn create_access_point_for_object_lambda(
        &self,
    ) -> fluent_builders::CreateAccessPointForObjectLambda<C> {
        fluent_builders::CreateAccessPointForObjectLambda::new(self.handle.clone())
    }
    pub fn create_bucket(&self) -> fluent_builders::CreateBucket<C> {
        fluent_builders::CreateBucket::new(self.handle.clone())
    }
    pub fn create_job(&self) -> fluent_builders::CreateJob<C> {
        fluent_builders::CreateJob::new(self.handle.clone())
    }
    pub fn delete_access_point(&self) -> fluent_builders::DeleteAccessPoint<C> {
        fluent_builders::DeleteAccessPoint::new(self.handle.clone())
    }
    pub fn delete_access_point_for_object_lambda(
        &self,
    ) -> fluent_builders::DeleteAccessPointForObjectLambda<C> {
        fluent_builders::DeleteAccessPointForObjectLambda::new(self.handle.clone())
    }
    pub fn delete_access_point_policy(&self) -> fluent_builders::DeleteAccessPointPolicy<C> {
        fluent_builders::DeleteAccessPointPolicy::new(self.handle.clone())
    }
    pub fn delete_access_point_policy_for_object_lambda(
        &self,
    ) -> fluent_builders::DeleteAccessPointPolicyForObjectLambda<C> {
        fluent_builders::DeleteAccessPointPolicyForObjectLambda::new(self.handle.clone())
    }
    pub fn delete_bucket(&self) -> fluent_builders::DeleteBucket<C> {
        fluent_builders::DeleteBucket::new(self.handle.clone())
    }
    pub fn delete_bucket_lifecycle_configuration(
        &self,
    ) -> fluent_builders::DeleteBucketLifecycleConfiguration<C> {
        fluent_builders::DeleteBucketLifecycleConfiguration::new(self.handle.clone())
    }
    pub fn delete_bucket_policy(&self) -> fluent_builders::DeleteBucketPolicy<C> {
        fluent_builders::DeleteBucketPolicy::new(self.handle.clone())
    }
    pub fn delete_bucket_tagging(&self) -> fluent_builders::DeleteBucketTagging<C> {
        fluent_builders::DeleteBucketTagging::new(self.handle.clone())
    }
    pub fn delete_job_tagging(&self) -> fluent_builders::DeleteJobTagging<C> {
        fluent_builders::DeleteJobTagging::new(self.handle.clone())
    }
    pub fn delete_public_access_block(&self) -> fluent_builders::DeletePublicAccessBlock<C> {
        fluent_builders::DeletePublicAccessBlock::new(self.handle.clone())
    }
    pub fn delete_storage_lens_configuration(
        &self,
    ) -> fluent_builders::DeleteStorageLensConfiguration<C> {
        fluent_builders::DeleteStorageLensConfiguration::new(self.handle.clone())
    }
    pub fn delete_storage_lens_configuration_tagging(
        &self,
    ) -> fluent_builders::DeleteStorageLensConfigurationTagging<C> {
        fluent_builders::DeleteStorageLensConfigurationTagging::new(self.handle.clone())
    }
    pub fn describe_job(&self) -> fluent_builders::DescribeJob<C> {
        fluent_builders::DescribeJob::new(self.handle.clone())
    }
    pub fn get_access_point(&self) -> fluent_builders::GetAccessPoint<C> {
        fluent_builders::GetAccessPoint::new(self.handle.clone())
    }
    pub fn get_access_point_configuration_for_object_lambda(
        &self,
    ) -> fluent_builders::GetAccessPointConfigurationForObjectLambda<C> {
        fluent_builders::GetAccessPointConfigurationForObjectLambda::new(self.handle.clone())
    }
    pub fn get_access_point_for_object_lambda(
        &self,
    ) -> fluent_builders::GetAccessPointForObjectLambda<C> {
        fluent_builders::GetAccessPointForObjectLambda::new(self.handle.clone())
    }
    pub fn get_access_point_policy(&self) -> fluent_builders::GetAccessPointPolicy<C> {
        fluent_builders::GetAccessPointPolicy::new(self.handle.clone())
    }
    pub fn get_access_point_policy_for_object_lambda(
        &self,
    ) -> fluent_builders::GetAccessPointPolicyForObjectLambda<C> {
        fluent_builders::GetAccessPointPolicyForObjectLambda::new(self.handle.clone())
    }
    pub fn get_access_point_policy_status(&self) -> fluent_builders::GetAccessPointPolicyStatus<C> {
        fluent_builders::GetAccessPointPolicyStatus::new(self.handle.clone())
    }
    pub fn get_access_point_policy_status_for_object_lambda(
        &self,
    ) -> fluent_builders::GetAccessPointPolicyStatusForObjectLambda<C> {
        fluent_builders::GetAccessPointPolicyStatusForObjectLambda::new(self.handle.clone())
    }
    pub fn get_bucket(&self) -> fluent_builders::GetBucket<C> {
        fluent_builders::GetBucket::new(self.handle.clone())
    }
    pub fn get_bucket_lifecycle_configuration(
        &self,
    ) -> fluent_builders::GetBucketLifecycleConfiguration<C> {
        fluent_builders::GetBucketLifecycleConfiguration::new(self.handle.clone())
    }
    pub fn get_bucket_policy(&self) -> fluent_builders::GetBucketPolicy<C> {
        fluent_builders::GetBucketPolicy::new(self.handle.clone())
    }
    pub fn get_bucket_tagging(&self) -> fluent_builders::GetBucketTagging<C> {
        fluent_builders::GetBucketTagging::new(self.handle.clone())
    }
    pub fn get_job_tagging(&self) -> fluent_builders::GetJobTagging<C> {
        fluent_builders::GetJobTagging::new(self.handle.clone())
    }
    pub fn get_public_access_block(&self) -> fluent_builders::GetPublicAccessBlock<C> {
        fluent_builders::GetPublicAccessBlock::new(self.handle.clone())
    }
    pub fn get_storage_lens_configuration(
        &self,
    ) -> fluent_builders::GetStorageLensConfiguration<C> {
        fluent_builders::GetStorageLensConfiguration::new(self.handle.clone())
    }
    pub fn get_storage_lens_configuration_tagging(
        &self,
    ) -> fluent_builders::GetStorageLensConfigurationTagging<C> {
        fluent_builders::GetStorageLensConfigurationTagging::new(self.handle.clone())
    }
    pub fn list_access_points(&self) -> fluent_builders::ListAccessPoints<C> {
        fluent_builders::ListAccessPoints::new(self.handle.clone())
    }
    pub fn list_access_points_for_object_lambda(
        &self,
    ) -> fluent_builders::ListAccessPointsForObjectLambda<C> {
        fluent_builders::ListAccessPointsForObjectLambda::new(self.handle.clone())
    }
    pub fn list_jobs(&self) -> fluent_builders::ListJobs<C> {
        fluent_builders::ListJobs::new(self.handle.clone())
    }
    pub fn list_regional_buckets(&self) -> fluent_builders::ListRegionalBuckets<C> {
        fluent_builders::ListRegionalBuckets::new(self.handle.clone())
    }
    pub fn list_storage_lens_configurations(
        &self,
    ) -> fluent_builders::ListStorageLensConfigurations<C> {
        fluent_builders::ListStorageLensConfigurations::new(self.handle.clone())
    }
    pub fn put_access_point_configuration_for_object_lambda(
        &self,
    ) -> fluent_builders::PutAccessPointConfigurationForObjectLambda<C> {
        fluent_builders::PutAccessPointConfigurationForObjectLambda::new(self.handle.clone())
    }
    pub fn put_access_point_policy(&self) -> fluent_builders::PutAccessPointPolicy<C> {
        fluent_builders::PutAccessPointPolicy::new(self.handle.clone())
    }
    pub fn put_access_point_policy_for_object_lambda(
        &self,
    ) -> fluent_builders::PutAccessPointPolicyForObjectLambda<C> {
        fluent_builders::PutAccessPointPolicyForObjectLambda::new(self.handle.clone())
    }
    pub fn put_bucket_lifecycle_configuration(
        &self,
    ) -> fluent_builders::PutBucketLifecycleConfiguration<C> {
        fluent_builders::PutBucketLifecycleConfiguration::new(self.handle.clone())
    }
    pub fn put_bucket_policy(&self) -> fluent_builders::PutBucketPolicy<C> {
        fluent_builders::PutBucketPolicy::new(self.handle.clone())
    }
    pub fn put_bucket_tagging(&self) -> fluent_builders::PutBucketTagging<C> {
        fluent_builders::PutBucketTagging::new(self.handle.clone())
    }
    pub fn put_job_tagging(&self) -> fluent_builders::PutJobTagging<C> {
        fluent_builders::PutJobTagging::new(self.handle.clone())
    }
    pub fn put_public_access_block(&self) -> fluent_builders::PutPublicAccessBlock<C> {
        fluent_builders::PutPublicAccessBlock::new(self.handle.clone())
    }
    pub fn put_storage_lens_configuration(
        &self,
    ) -> fluent_builders::PutStorageLensConfiguration<C> {
        fluent_builders::PutStorageLensConfiguration::new(self.handle.clone())
    }
    pub fn put_storage_lens_configuration_tagging(
        &self,
    ) -> fluent_builders::PutStorageLensConfigurationTagging<C> {
        fluent_builders::PutStorageLensConfigurationTagging::new(self.handle.clone())
    }
    pub fn update_job_priority(&self) -> fluent_builders::UpdateJobPriority<C> {
        fluent_builders::UpdateJobPriority::new(self.handle.clone())
    }
    pub fn update_job_status(&self) -> fluent_builders::UpdateJobStatus<C> {
        fluent_builders::UpdateJobStatus::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CreateAccessPoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_access_point_input::Builder,
    }
    impl<C> CreateAccessPoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAccessPointOutput,
            smithy_http::result::SdkError<crate::error::CreateAccessPointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID for the owner of the bucket for which you want to create an access point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name you want to assign to this access point.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The name of the bucket that you want to associate this access point with.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
        /// <p>If you include this field, Amazon S3 restricts access to this access point to requests from the
        /// specified virtual private cloud (VPC).</p>
        /// <note>
        /// <p>This is required for creating an access point for Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn vpc_configuration(mut self, input: crate::model::VpcConfiguration) -> Self {
            self.inner = self.inner.vpc_configuration(input);
            self
        }
        pub fn set_vpc_configuration(
            mut self,
            input: std::option::Option<crate::model::VpcConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_vpc_configuration(input);
            self
        }
        /// <p>
        /// The <code>PublicAccessBlock</code> configuration that you want to apply to the access point.
        /// </p>
        pub fn public_access_block_configuration(
            mut self,
            input: crate::model::PublicAccessBlockConfiguration,
        ) -> Self {
            self.inner = self.inner.public_access_block_configuration(input);
            self
        }
        pub fn set_public_access_block_configuration(
            mut self,
            input: std::option::Option<crate::model::PublicAccessBlockConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_public_access_block_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateAccessPointForObjectLambda<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_access_point_for_object_lambda_input::Builder,
    }
    impl<C> CreateAccessPointForObjectLambda<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateAccessPointForObjectLambdaOutput,
            smithy_http::result::SdkError<crate::error::CreateAccessPointForObjectLambdaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID for owner of the specified Object Lambda Access Point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name you want to assign to this Object Lambda Access Point.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Object Lambda Access Point configuration as a JSON document.</p>
        pub fn configuration(mut self, input: crate::model::ObjectLambdaConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ObjectLambdaConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateBucket<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_bucket_input::Builder,
    }
    impl<C> CreateBucket<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateBucketOutput,
            smithy_http::result::SdkError<crate::error::CreateBucketError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The canned ACL to apply to the bucket.</p>
        /// <note>
        /// <p>This is not supported by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn acl(mut self, input: crate::model::BucketCannedAcl) -> Self {
            self.inner = self.inner.acl(input);
            self
        }
        pub fn set_acl(
            mut self,
            input: std::option::Option<crate::model::BucketCannedAcl>,
        ) -> Self {
            self.inner = self.inner.set_acl(input);
            self
        }
        /// <p>The name of the bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
        /// <p>Allows grantee the read, write, read ACP, and write ACP permissions on the bucket.</p>
        /// <note>
        /// <p>This is not supported by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn grant_full_control(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_full_control(input);
            self
        }
        pub fn set_grant_full_control(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_full_control(input);
            self
        }
        /// <p>Allows grantee to list the objects in the bucket.</p>
        /// <note>
        /// <p>This is not supported by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn grant_read(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read(input);
            self
        }
        pub fn set_grant_read(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_read(input);
            self
        }
        /// <p>Allows grantee to read the bucket ACL.</p>
        /// <note>
        /// <p>This is not supported by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn grant_read_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_read_acp(input);
            self
        }
        pub fn set_grant_read_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_read_acp(input);
            self
        }
        /// <p>Allows grantee to create, overwrite, and delete any object in the bucket.</p>
        /// <note>
        /// <p>This is not supported by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn grant_write(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write(input);
            self
        }
        pub fn set_grant_write(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_grant_write(input);
            self
        }
        /// <p>Allows grantee to write the ACL for the applicable bucket.</p>
        /// <note>
        /// <p>This is not supported by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn grant_write_acp(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.grant_write_acp(input);
            self
        }
        pub fn set_grant_write_acp(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_grant_write_acp(input);
            self
        }
        /// <p>Specifies whether you want S3 Object Lock to be enabled for the new bucket.</p>
        /// <note>
        /// <p>This is not supported by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn object_lock_enabled_for_bucket(mut self, input: bool) -> Self {
            self.inner = self.inner.object_lock_enabled_for_bucket(input);
            self
        }
        pub fn set_object_lock_enabled_for_bucket(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_object_lock_enabled_for_bucket(input);
            self
        }
        /// <p>The ID of the Outposts where the bucket is being created.</p>
        /// <note>
        /// <p>This is required by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn outpost_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.outpost_id(input);
            self
        }
        pub fn set_outpost_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_outpost_id(input);
            self
        }
        /// <p>The configuration information for the bucket.</p>
        /// <note>
        /// <p>This is not supported by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn create_bucket_configuration(
            mut self,
            input: crate::model::CreateBucketConfiguration,
        ) -> Self {
            self.inner = self.inner.create_bucket_configuration(input);
            self
        }
        pub fn set_create_bucket_configuration(
            mut self,
            input: std::option::Option<crate::model::CreateBucketConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_create_bucket_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_job_input::Builder,
    }
    impl<C> CreateJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateJobOutput,
            smithy_http::result::SdkError<crate::error::CreateJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID that creates the job.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>Indicates whether confirmation is required before Amazon S3 runs the job. Confirmation is only required for jobs created through the Amazon S3 console.</p>
        pub fn confirmation_required(mut self, input: bool) -> Self {
            self.inner = self.inner.confirmation_required(input);
            self
        }
        pub fn set_confirmation_required(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_confirmation_required(input);
            self
        }
        /// <p>The action that you want this job to perform on every object listed in the manifest.
        /// For more information about the available actions, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-actions.html">Operations</a> in the
        /// <i>Amazon S3 User Guide</i>.</p>
        pub fn operation(mut self, input: crate::model::JobOperation) -> Self {
            self.inner = self.inner.operation(input);
            self
        }
        pub fn set_operation(
            mut self,
            input: std::option::Option<crate::model::JobOperation>,
        ) -> Self {
            self.inner = self.inner.set_operation(input);
            self
        }
        /// <p>Configuration parameters for the optional job-completion report.</p>
        pub fn report(mut self, input: crate::model::JobReport) -> Self {
            self.inner = self.inner.report(input);
            self
        }
        pub fn set_report(mut self, input: std::option::Option<crate::model::JobReport>) -> Self {
            self.inner = self.inner.set_report(input);
            self
        }
        /// <p>An idempotency token to ensure that you don't accidentally submit the same request twice. You can use any string up to the maximum length.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>Configuration parameters for the manifest.</p>
        pub fn manifest(mut self, input: crate::model::JobManifest) -> Self {
            self.inner = self.inner.manifest(input);
            self
        }
        pub fn set_manifest(
            mut self,
            input: std::option::Option<crate::model::JobManifest>,
        ) -> Self {
            self.inner = self.inner.set_manifest(input);
            self
        }
        /// <p>A description for this job. You can use any string within the permitted length. Descriptions don't need to be unique and can be used for multiple jobs.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The numerical priority for this job. Higher numbers indicate higher priority.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.inner = self.inner.priority(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) for the AWS Identity and Access Management (IAM) role
        /// that Batch Operations will use to run this job's action on every object in the
        /// manifest.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.role_arn(input);
            self
        }
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_role_arn(input);
            self
        }
        /// <p>A set of tags to associate with the S3 Batch Operations job. This is an optional parameter. </p>
        pub fn tags(mut self, inp: impl Into<crate::model::S3Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::S3Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccessPoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_access_point_input::Builder,
    }
    impl<C> DeleteAccessPoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAccessPointOutput,
            smithy_http::result::SdkError<crate::error::DeleteAccessPointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified access point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the access point you want to delete.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the access point accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/accesspoint/<my-accesspoint-name></code>. For example, to access the access point <code>reports-ap</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap</code>. The value must be URL encoded. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccessPointForObjectLambda<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_access_point_for_object_lambda_input::Builder,
    }
    impl<C> DeleteAccessPointForObjectLambda<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAccessPointForObjectLambdaOutput,
            smithy_http::result::SdkError<crate::error::DeleteAccessPointForObjectLambdaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the access point you want to delete.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccessPointPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_access_point_policy_input::Builder,
    }
    impl<C> DeleteAccessPointPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAccessPointPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteAccessPointPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified access point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the access point whose policy you want to delete.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the access point accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/accesspoint/<my-accesspoint-name></code>. For example, to access the access point <code>reports-ap</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap</code>. The value must be URL encoded. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteAccessPointPolicyForObjectLambda<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_access_point_policy_for_object_lambda_input::Builder,
    }
    impl<C> DeleteAccessPointPolicyForObjectLambda<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteAccessPointPolicyForObjectLambdaOutput,
            smithy_http::result::SdkError<
                crate::error::DeleteAccessPointPolicyForObjectLambdaError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the Object Lambda Access Point you want to delete the policy for.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucket<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_input::Builder,
    }
    impl<C> DeleteBucket<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBucketOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID that owns the Outposts bucket.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>Specifies the bucket being deleted.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketLifecycleConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_lifecycle_configuration_input::Builder,
    }
    impl<C> DeleteBucketLifecycleConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBucketLifecycleConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketLifecycleConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID of the lifecycle configuration to delete.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>Specifies the bucket.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_policy_input::Builder,
    }
    impl<C> DeleteBucketPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBucketPolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID of the Outposts bucket.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>Specifies the bucket.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBucketTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_bucket_tagging_input::Builder,
    }
    impl<C> DeleteBucketTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBucketTaggingOutput,
            smithy_http::result::SdkError<crate::error::DeleteBucketTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID of the Outposts bucket tag set to be removed.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The bucket ARN that has the tag set to be removed.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteJobTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_job_tagging_input::Builder,
    }
    impl<C> DeleteJobTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteJobTaggingOutput,
            smithy_http::result::SdkError<crate::error::DeleteJobTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The ID for the S3 Batch Operations job whose tags you want to delete.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePublicAccessBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_public_access_block_input::Builder,
    }
    impl<C> DeletePublicAccessBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePublicAccessBlockOutput,
            smithy_http::result::SdkError<crate::error::DeletePublicAccessBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the AWS account whose <code>PublicAccessBlock</code> configuration you want
        /// to remove.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStorageLensConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_storage_lens_configuration_input::Builder,
    }
    impl<C> DeleteStorageLensConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStorageLensConfigurationOutput,
            smithy_http::result::SdkError<crate::error::DeleteStorageLensConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the S3 Storage Lens configuration.</p>
        pub fn config_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.config_id(input);
            self
        }
        pub fn set_config_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_config_id(input);
            self
        }
        /// <p>The account ID of the requester.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteStorageLensConfigurationTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_storage_lens_configuration_tagging_input::Builder,
    }
    impl<C> DeleteStorageLensConfigurationTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteStorageLensConfigurationTaggingOutput,
            smithy_http::result::SdkError<crate::error::DeleteStorageLensConfigurationTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the S3 Storage Lens configuration.</p>
        pub fn config_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.config_id(input);
            self
        }
        pub fn set_config_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_config_id(input);
            self
        }
        /// <p>The account ID of the requester.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeJob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_job_input::Builder,
    }
    impl<C> DescribeJob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeJobOutput,
            smithy_http::result::SdkError<crate::error::DescribeJobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The ID for the job whose information you want to retrieve.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccessPoint<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_access_point_input::Builder,
    }
    impl<C> GetAccessPoint<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccessPointOutput,
            smithy_http::result::SdkError<crate::error::GetAccessPointError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified access point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the access point whose configuration information you want to retrieve.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the access point accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/accesspoint/<my-accesspoint-name></code>. For example, to access the access point <code>reports-ap</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap</code>. The value must be URL encoded. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccessPointConfigurationForObjectLambda<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_access_point_configuration_for_object_lambda_input::Builder,
    }
    impl<C> GetAccessPointConfigurationForObjectLambda<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccessPointConfigurationForObjectLambdaOutput,
            smithy_http::result::SdkError<
                crate::error::GetAccessPointConfigurationForObjectLambdaError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the Object Lambda Access Point you want to return the configuration for.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccessPointForObjectLambda<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_access_point_for_object_lambda_input::Builder,
    }
    impl<C> GetAccessPointForObjectLambda<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccessPointForObjectLambdaOutput,
            smithy_http::result::SdkError<crate::error::GetAccessPointForObjectLambdaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the Object Lambda Access Point.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccessPointPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_access_point_policy_input::Builder,
    }
    impl<C> GetAccessPointPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccessPointPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetAccessPointPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified access point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the access point whose policy you want to retrieve.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the access point accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/accesspoint/<my-accesspoint-name></code>. For example, to access the access point <code>reports-ap</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap</code>. The value must be URL encoded. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccessPointPolicyForObjectLambda<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_access_point_policy_for_object_lambda_input::Builder,
    }
    impl<C> GetAccessPointPolicyForObjectLambda<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccessPointPolicyForObjectLambdaOutput,
            smithy_http::result::SdkError<crate::error::GetAccessPointPolicyForObjectLambdaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the Object Lambda Access Point.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccessPointPolicyStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_access_point_policy_status_input::Builder,
    }
    impl<C> GetAccessPointPolicyStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccessPointPolicyStatusOutput,
            smithy_http::result::SdkError<crate::error::GetAccessPointPolicyStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified access point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the access point whose policy status you want to retrieve.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetAccessPointPolicyStatusForObjectLambda<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_access_point_policy_status_for_object_lambda_input::Builder,
    }
    impl<C> GetAccessPointPolicyStatusForObjectLambda<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetAccessPointPolicyStatusForObjectLambdaOutput,
            smithy_http::result::SdkError<
                crate::error::GetAccessPointPolicyStatusForObjectLambdaError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the Object Lambda Access Point.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucket<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_input::Builder,
    }
    impl<C> GetBucket<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBucketOutput,
            smithy_http::result::SdkError<crate::error::GetBucketError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID of the Outposts bucket.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>Specifies the bucket.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketLifecycleConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_lifecycle_configuration_input::Builder,
    }
    impl<C> GetBucketLifecycleConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBucketLifecycleConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetBucketLifecycleConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID of the Outposts bucket.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the bucket.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_policy_input::Builder,
    }
    impl<C> GetBucketPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBucketPolicyOutput,
            smithy_http::result::SdkError<crate::error::GetBucketPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID of the Outposts bucket.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>Specifies the bucket.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBucketTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_bucket_tagging_input::Builder,
    }
    impl<C> GetBucketTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBucketTaggingOutput,
            smithy_http::result::SdkError<crate::error::GetBucketTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID of the Outposts bucket.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>Specifies the bucket.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetJobTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_job_tagging_input::Builder,
    }
    impl<C> GetJobTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetJobTaggingOutput,
            smithy_http::result::SdkError<crate::error::GetJobTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The ID for the S3 Batch Operations job whose tags you want to retrieve.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPublicAccessBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_public_access_block_input::Builder,
    }
    impl<C> GetPublicAccessBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPublicAccessBlockOutput,
            smithy_http::result::SdkError<crate::error::GetPublicAccessBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the AWS account whose <code>PublicAccessBlock</code> configuration you want
        /// to retrieve.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStorageLensConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_storage_lens_configuration_input::Builder,
    }
    impl<C> GetStorageLensConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStorageLensConfigurationOutput,
            smithy_http::result::SdkError<crate::error::GetStorageLensConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Amazon S3 Storage Lens configuration.</p>
        pub fn config_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.config_id(input);
            self
        }
        pub fn set_config_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_config_id(input);
            self
        }
        /// <p>The account ID of the requester.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetStorageLensConfigurationTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_storage_lens_configuration_tagging_input::Builder,
    }
    impl<C> GetStorageLensConfigurationTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetStorageLensConfigurationTaggingOutput,
            smithy_http::result::SdkError<crate::error::GetStorageLensConfigurationTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the Amazon S3 Storage Lens configuration.</p>
        pub fn config_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.config_id(input);
            self
        }
        pub fn set_config_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_config_id(input);
            self
        }
        /// <p>The account ID of the requester.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAccessPoints<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_access_points_input::Builder,
    }
    impl<C> ListAccessPoints<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAccessPointsOutput,
            smithy_http::result::SdkError<crate::error::ListAccessPointsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID for owner of the bucket whose access points you want to list.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the bucket whose associated access points you want to list.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
        /// <p>A continuation token. If a previous call to <code>ListAccessPoints</code> returned a continuation token in the <code>NextToken</code> field, then providing that value here causes Amazon S3 to retrieve the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of access points that you want to include in the list. If the specified
        /// bucket has more than this number of access points, then the response will include a
        /// continuation token in the <code>NextToken</code> field that you can use to retrieve the
        /// next page of access points.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAccessPointsForObjectLambda<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_access_points_for_object_lambda_input::Builder,
    }
    impl<C> ListAccessPointsForObjectLambda<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAccessPointsForObjectLambdaOutput,
            smithy_http::result::SdkError<crate::error::ListAccessPointsForObjectLambdaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>If the list has more access points than can be returned in one call to this
        /// API, this field contains a continuation token that you can provide in subsequent calls to
        /// this API to retrieve additional access points.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of access points that you want to include in the list. If there are more than this number of access points, then the response will include a continuation token in the <code>NextToken</code> field that you can use to retrieve the next page of access points.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListJobs<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_jobs_input::Builder,
    }
    impl<C> ListJobs<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListJobsOutput,
            smithy_http::result::SdkError<crate::error::ListJobsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The <code>List Jobs</code> request returns jobs that match the statuses listed in this element.</p>
        pub fn job_statuses(mut self, inp: impl Into<crate::model::JobStatus>) -> Self {
            self.inner = self.inner.job_statuses(inp);
            self
        }
        pub fn set_job_statuses(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::JobStatus>>,
        ) -> Self {
            self.inner = self.inner.set_job_statuses(input);
            self
        }
        /// <p>A pagination token to request the next page of results. Use the token that Amazon S3 returned in the <code>NextToken</code> element of the <code>ListJobsResult</code> from the previous <code>List Jobs</code> request.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The maximum number of jobs that Amazon S3 will include in the <code>List Jobs</code> response. If there are more jobs than this number, the response will include a pagination token in the <code>NextToken</code> field to enable you to retrieve the next page of results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRegionalBuckets<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_regional_buckets_input::Builder,
    }
    impl<C> ListRegionalBuckets<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRegionalBucketsOutput,
            smithy_http::result::SdkError<crate::error::ListRegionalBucketsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID of the Outposts bucket.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p></p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p></p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>The ID of the AWS Outposts.</p>
        /// <note>
        /// <p>This is required by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn outpost_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.outpost_id(input);
            self
        }
        pub fn set_outpost_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_outpost_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListStorageLensConfigurations<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_storage_lens_configurations_input::Builder,
    }
    impl<C> ListStorageLensConfigurations<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListStorageLensConfigurationsOutput,
            smithy_http::result::SdkError<crate::error::ListStorageLensConfigurationsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID of the requester.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>A pagination token to request the next page of results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAccessPointConfigurationForObjectLambda<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_access_point_configuration_for_object_lambda_input::Builder,
    }
    impl<C> PutAccessPointConfigurationForObjectLambda<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAccessPointConfigurationForObjectLambdaOutput,
            smithy_http::result::SdkError<
                crate::error::PutAccessPointConfigurationForObjectLambdaError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the Object Lambda Access Point.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Object Lambda Access Point configuration document.</p>
        pub fn configuration(mut self, input: crate::model::ObjectLambdaConfiguration) -> Self {
            self.inner = self.inner.configuration(input);
            self
        }
        pub fn set_configuration(
            mut self,
            input: std::option::Option<crate::model::ObjectLambdaConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAccessPointPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_access_point_policy_input::Builder,
    }
    impl<C> PutAccessPointPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAccessPointPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutAccessPointPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID for owner of the bucket associated with the specified access point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the access point that you want to associate with the specified policy.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the access point accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/accesspoint/<my-accesspoint-name></code>. For example, to access the access point <code>reports-ap</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/accesspoint/reports-ap</code>. The value must be URL encoded. </p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The policy that you want to apply to the specified access point. For more information about access point policies, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-points.html">Managing data access with Amazon S3 access points</a> in the <i>Amazon S3 User Guide</i>.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutAccessPointPolicyForObjectLambda<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_access_point_policy_for_object_lambda_input::Builder,
    }
    impl<C> PutAccessPointPolicyForObjectLambda<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutAccessPointPolicyForObjectLambdaOutput,
            smithy_http::result::SdkError<crate::error::PutAccessPointPolicyForObjectLambdaError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the account that owns the specified Object Lambda Access Point.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the Object Lambda Access Point.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>Object Lambda Access Point resource policy document.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketLifecycleConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_lifecycle_configuration_input::Builder,
    }
    impl<C> PutBucketLifecycleConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutBucketLifecycleConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutBucketLifecycleConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID of the Outposts bucket.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The name of the bucket for which to set the configuration.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
        /// <p>Container for lifecycle rules. You can add as many as 1,000 rules.</p>
        pub fn lifecycle_configuration(
            mut self,
            input: crate::model::LifecycleConfiguration,
        ) -> Self {
            self.inner = self.inner.lifecycle_configuration(input);
            self
        }
        pub fn set_lifecycle_configuration(
            mut self,
            input: std::option::Option<crate::model::LifecycleConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_lifecycle_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketPolicy<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_policy_input::Builder,
    }
    impl<C> PutBucketPolicy<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutBucketPolicyOutput,
            smithy_http::result::SdkError<crate::error::PutBucketPolicyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID of the Outposts bucket.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>Specifies the bucket.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
        /// <p>Set this parameter to true to confirm that you want to remove your permissions to change this bucket policy in the future.</p>
        /// <note>
        /// <p>This is not supported by Amazon S3 on Outposts buckets.</p>
        /// </note>
        pub fn confirm_remove_self_bucket_access(mut self, input: bool) -> Self {
            self.inner = self.inner.confirm_remove_self_bucket_access(input);
            self
        }
        pub fn set_confirm_remove_self_bucket_access(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_confirm_remove_self_bucket_access(input);
            self
        }
        /// <p>The bucket policy as a JSON document.</p>
        pub fn policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.policy(input);
            self
        }
        pub fn set_policy(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutBucketTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_bucket_tagging_input::Builder,
    }
    impl<C> PutBucketTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutBucketTaggingOutput,
            smithy_http::result::SdkError<crate::error::PutBucketTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID of the Outposts bucket.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the bucket.</p>
        /// <p>For using this parameter with Amazon S3 on Outposts with the REST API, you must specify the name and the x-amz-outpost-id as well.</p>
        /// <p>For using this parameter with S3 on Outposts with the AWS SDK and CLI, you must  specify the ARN of the bucket accessed in the format <code>arn:aws:s3-outposts:<Region>:<account-id>:outpost/<outpost-id>/bucket/<my-bucket-name></code>. For example, to access the bucket <code>reports</code> through outpost <code>my-outpost</code> owned by account <code>123456789012</code> in Region <code>us-west-2</code>, use the URL encoding of <code>arn:aws:s3-outposts:us-west-2:123456789012:outpost/my-outpost/bucket/reports</code>. The value must be URL encoded.  </p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.bucket(input);
            self
        }
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_bucket(input);
            self
        }
        /// <p></p>
        pub fn tagging(mut self, input: crate::model::Tagging) -> Self {
            self.inner = self.inner.tagging(input);
            self
        }
        pub fn set_tagging(mut self, input: std::option::Option<crate::model::Tagging>) -> Self {
            self.inner = self.inner.set_tagging(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutJobTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_job_tagging_input::Builder,
    }
    impl<C> PutJobTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutJobTaggingOutput,
            smithy_http::result::SdkError<crate::error::PutJobTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The ID for the S3 Batch Operations job whose tags you want to replace.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The set of tags to associate with the S3 Batch Operations job.</p>
        pub fn tags(mut self, inp: impl Into<crate::model::S3Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::S3Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutPublicAccessBlock<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_public_access_block_input::Builder,
    }
    impl<C> PutPublicAccessBlock<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutPublicAccessBlockOutput,
            smithy_http::result::SdkError<crate::error::PutPublicAccessBlockError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The account ID for the AWS account whose <code>PublicAccessBlock</code> configuration you want
        /// to set.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The <code>PublicAccessBlock</code> configuration that you want to apply to the specified AWS
        /// account.</p>
        pub fn public_access_block_configuration(
            mut self,
            input: crate::model::PublicAccessBlockConfiguration,
        ) -> Self {
            self.inner = self.inner.public_access_block_configuration(input);
            self
        }
        pub fn set_public_access_block_configuration(
            mut self,
            input: std::option::Option<crate::model::PublicAccessBlockConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_public_access_block_configuration(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutStorageLensConfiguration<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_storage_lens_configuration_input::Builder,
    }
    impl<C> PutStorageLensConfiguration<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutStorageLensConfigurationOutput,
            smithy_http::result::SdkError<crate::error::PutStorageLensConfigurationError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the S3 Storage Lens configuration.</p>
        pub fn config_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.config_id(input);
            self
        }
        pub fn set_config_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_config_id(input);
            self
        }
        /// <p>The account ID of the requester.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The S3 Storage Lens configuration.</p>
        pub fn storage_lens_configuration(
            mut self,
            input: crate::model::StorageLensConfiguration,
        ) -> Self {
            self.inner = self.inner.storage_lens_configuration(input);
            self
        }
        pub fn set_storage_lens_configuration(
            mut self,
            input: std::option::Option<crate::model::StorageLensConfiguration>,
        ) -> Self {
            self.inner = self.inner.set_storage_lens_configuration(input);
            self
        }
        /// <p>The tag set of the S3 Storage Lens configuration.</p>
        /// <note>
        /// <p>You can set up to a maximum of 50 tags.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::StorageLensTag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StorageLensTag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutStorageLensConfigurationTagging<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_storage_lens_configuration_tagging_input::Builder,
    }
    impl<C> PutStorageLensConfigurationTagging<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutStorageLensConfigurationTaggingOutput,
            smithy_http::result::SdkError<crate::error::PutStorageLensConfigurationTaggingError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the S3 Storage Lens configuration.</p>
        pub fn config_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.config_id(input);
            self
        }
        pub fn set_config_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_config_id(input);
            self
        }
        /// <p>The account ID of the requester.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The tag set of the S3 Storage Lens configuration.</p>
        /// <note>
        /// <p>You can set up to a maximum of 50 tags.</p>
        /// </note>
        pub fn tags(mut self, inp: impl Into<crate::model::StorageLensTag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::StorageLensTag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateJobPriority<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_job_priority_input::Builder,
    }
    impl<C> UpdateJobPriority<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateJobPriorityOutput,
            smithy_http::result::SdkError<crate::error::UpdateJobPriorityError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The ID for the job whose priority you want to update.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The priority you want to assign to this job.</p>
        pub fn priority(mut self, input: i32) -> Self {
            self.inner = self.inner.priority(input);
            self
        }
        pub fn set_priority(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_priority(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateJobStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_job_status_input::Builder,
    }
    impl<C> UpdateJobStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateJobStatusOutput,
            smithy_http::result::SdkError<crate::error::UpdateJobStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The AWS account ID associated with the S3 Batch Operations job.</p>
        pub fn account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.account_id(input);
            self
        }
        pub fn set_account_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_account_id(input);
            self
        }
        /// <p>The ID of the job whose status you want to update.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.job_id(input);
            self
        }
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_job_id(input);
            self
        }
        /// <p>The status that you want to move the specified job to.</p>
        pub fn requested_job_status(mut self, input: crate::model::RequestedJobStatus) -> Self {
            self.inner = self.inner.requested_job_status(input);
            self
        }
        pub fn set_requested_job_status(
            mut self,
            input: std::option::Option<crate::model::RequestedJobStatus>,
        ) -> Self {
            self.inner = self.inner.set_requested_job_status(input);
            self
        }
        /// <p>A description of the reason why you want to change the specified job's status. This field can be any string up to the maximum length.</p>
        pub fn status_update_reason(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.status_update_reason(input);
            self
        }
        pub fn set_status_update_reason(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_status_update_reason(input);
            self
        }
    }
}
