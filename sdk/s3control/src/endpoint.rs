// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Temporary shim to allow new and old endpoint resolvers to co-exist
                ///
                /// This enables converting from the actual parameters type to the placeholder parameters type that
                /// contains a region
                #[doc(hidden)]
                impl From<crate::endpoint::Params> for aws_endpoint::Params {
                    fn from(params: crate::endpoint::Params) -> Self {
                        Self::new(params.region().map(|r|aws_types::region::Region::new(r.to_string())))
                    }
                }

/// 
#[cfg(test)]
mod test {
    
    /// Vanilla outposts without ARN region + access point ARN@us-west-2
                #[test]
                fn test_1() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-west-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-west-2.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// Vanilla outposts with ARN region + access point ARN@us-west-2
                #[test]
                fn test_2() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-east-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// accept an access point ARN@us-west-2
                #[test]
                fn test_3() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-west-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-west-2.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// vanilla outposts china@cn-north-1
                #[test]
                fn test_4() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws-cn:s3-outposts:cn-north-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("cn-north-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.cn-north-1.amazonaws.com.cn");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.cn-north-1.amazonaws.com.cn")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "cn-north-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// gov region@us-west-2
                #[test]
                fn test_5() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-west-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-west-2.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// gov cloud with fips@us-west-2
                #[test]
                fn test_6() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-west-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-west-2.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// govcloud with fips + arn region@us-gov-west-1
                #[test]
                fn test_7() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws-us-gov:s3-outposts:us-gov-east-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-gov-west-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-gov-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-gov-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-gov-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// gov region@cn-north-1
                #[test]
                fn test_8() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws-cn:s3-outposts:cn-north-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("cn-north-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.cn-north-1.amazonaws.com.cn");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.cn-north-1.amazonaws.com.cn")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "cn-north-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// gov cloud with fips@cn-north-1
                #[test]
                fn test_9() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws-cn:s3-outposts:cn-north-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("cn-north-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.cn-north-1.amazonaws.com.cn");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.cn-north-1.amazonaws.com.cn")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "cn-north-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// govcloud with fips + arn region@us-gov-west-1
                #[test]
                fn test_10() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws-us-gov:s3-outposts:us-gov-east-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-gov-west-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-gov-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-gov-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-gov-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// gov region@af-south-1
                #[test]
                fn test_11() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:af-south-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("af-south-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.af-south-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.af-south-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "af-south-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// gov cloud with fips@af-south-1
                #[test]
                fn test_12() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:af-south-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("af-south-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.af-south-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.af-south-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "af-south-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// govcloud with fips + arn region@us-gov-west-1
                #[test]
                fn test_13() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws-us-gov:s3-outposts:us-gov-east-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-gov-west-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-gov-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-gov-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-gov-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// CreateBucket + OutpostId = outposts endpoint@us-east-2
                #[test]
                fn test_14() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("blah".to_string())
    .outpost_id("123".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(false)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-east-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-east-2.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// CreateBucket + OutpostId with fips = outposts endpoint@us-east-2
                #[test]
                fn test_15() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("blah".to_string())
    .outpost_id("123".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(false)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-east-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-east-2.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// CreateBucket without OutpostId = regular endpoint@us-east-2
                #[test]
                fn test_16() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("blah".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(false)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-control.us-east-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-control.us-east-2.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// ListRegionalBuckets + OutpostId = outposts endpoint@us-east-2
                #[test]
                fn test_17() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("123".to_string())
    .outpost_id("op-123".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-east-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-east-2.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// ListRegionalBuckets without OutpostId = regular endpoint@us-east-2
                #[test]
                fn test_18() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("123".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://123.s3-control.us-east-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://123.s3-control.us-east-2.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// ListRegionalBucket + OutpostId with fips = outposts endpoint@us-east-2
                #[test]
                fn test_19() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("123".to_string())
    .outpost_id("op-123".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-east-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-east-2.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// outpost access points do not support dualstack@us-west-2
                #[test]
                fn test_20() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: Outpost Access Points do not support dual-stack [outpost access points do not support dualstack@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid configuration: Outpost Access Points do not support dual-stack")
                }
    
    /// outpost access points do not support dualstack@cn-north-1
                #[test]
                fn test_21() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("cn-north-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: Outpost Access Points do not support dual-stack [outpost access points do not support dualstack@cn-north-1]");
                            assert_eq!(format!("{}", error), "Invalid configuration: Outpost Access Points do not support dual-stack")
                }
    
    /// outpost access points do not support dualstack@af-south-1
                #[test]
                fn test_22() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("af-south-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: Outpost Access Points do not support dual-stack [outpost access points do not support dualstack@af-south-1]");
                            assert_eq!(format!("{}", error), "Invalid configuration: Outpost Access Points do not support dual-stack")
                }
    
    /// invalid ARN: must be include outpost ID@us-west-2
                #[test]
                fn test_23() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: The Outpost Id was not set [invalid ARN: must be include outpost ID@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid ARN: The Outpost Id was not set")
                }
    
    /// invalid ARN: must specify access point@us-west-2
                #[test]
                fn test_24() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: Expected a 4-component resource [invalid ARN: must specify access point@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid ARN: Expected a 4-component resource")
                }
    
    /// invalid ARN@us-west-2
                #[test]
                fn test_25() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:myaccesspoint".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: Expected a 4-component resource [invalid ARN@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid ARN: Expected a 4-component resource")
                }
    
    /// when set, AccountId drives AP construction@us-west-2
                #[test]
                fn test_26() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("myaccesspoint".to_string())
    .account_id("myid-1234".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://myid-1234.s3-control.us-west-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://myid-1234.s3-control.us-west-2.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// Account ID set inline and in ARN but they both match@us-west-2
                #[test]
                fn test_27() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_arn_region(false)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-west-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-west-2.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// Account ID set inline and in ARN and they do not match@us-west-2
                #[test]
                fn test_28() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("9999999".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_arn_region(false)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: the accountId specified in the ARN (`123456789012`) does not match the parameter (`9999999`) [Account ID set inline and in ARN and they do not match@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid ARN: the accountId specified in the ARN (`123456789012`) does not match the parameter (`9999999`)")
                }
    
    /// get access point prefixed with account id using endpoint url@us-west-2
                #[test]
                fn test_29() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("apname".to_string())
    .account_id("123456789012".to_string())
    .endpoint("https://control.vpce-1a2b3c4d-5e6f.s3.us-west-2.vpce.amazonaws.com".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://123456789012.control.vpce-1a2b3c4d-5e6f.s3.us-west-2.vpce.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://123456789012.control.vpce-1a2b3c4d-5e6f.s3.us-west-2.vpce.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// endpoint url with s3-outposts@us-west-2
                #[test]
                fn test_30() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .endpoint("https://beta.example.com".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://beta.example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://beta.example.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// access point name with a bucket arn@us-west-2
                #[test]
                fn test_31() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .endpoint("beta.example.com".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Expected an outpost type `accesspoint`, found `bucket` [access point name with a bucket arn@us-west-2]");
                            assert_eq!(format!("{}", error), "Expected an outpost type `accesspoint`, found `bucket`")
                }
    
    /// bucket arn with access point name@us-west-2
                #[test]
                fn test_32() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .endpoint("beta.example.com".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: Expected an outpost type `bucket`, found `accesspoint` [bucket arn with access point name@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid ARN: Expected an outpost type `bucket`, found `accesspoint`")
                }
    
    /// create bucket with outposts@us-west-2
                #[test]
                fn test_33() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("bucketname".to_string())
    .endpoint("https://beta.example.com".to_string())
    .outpost_id("op-123".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(false)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://beta.example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://beta.example.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// get bucket with endpoint_url@us-west-2
                #[test]
                fn test_34() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .endpoint("https://beta.example.com".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://beta.example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://beta.example.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// ListRegionalBucket + OutpostId endpoint url@us-east-2
                #[test]
                fn test_35() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("123".to_string())
    .endpoint("https://beta.example.com".to_string())
    .outpost_id("op-123".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://beta.example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://beta.example.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// ListRegionalBucket + OutpostId + fips + endpoint url@us-east-2
                #[test]
                fn test_36() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("123".to_string())
    .endpoint("https://beta.example.com".to_string())
    .outpost_id("op-123".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://beta.example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://beta.example.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// CreateBucket + OutpostId endpoint url@us-east-2
                #[test]
                fn test_37() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("blah".to_string())
    .endpoint("https://beta.example.com".to_string())
    .outpost_id("123".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(false)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://beta.example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://beta.example.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// dualstack cannot be used with outposts when an endpoint URL is set@us-west-2.
                #[test]
                fn test_38() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .endpoint("https://beta.example.com".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: Outpost Access Points do not support dual-stack [dualstack cannot be used with outposts when an endpoint URL is set@us-west-2.]");
                            assert_eq!(format!("{}", error), "Invalid configuration: Outpost Access Points do not support dual-stack")
                }
    
    /// Dual-stack cannot be used with outposts@us-west-2
                #[test]
                fn test_39() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("bucketname".to_string())
    .endpoint("https://beta.example.com".to_string())
    .outpost_id("op-123".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(false)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: Outposts do not support dual-stack [Dual-stack cannot be used with outposts@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid configuration: Outposts do not support dual-stack")
                }
    
    /// vanilla bucket arn requires account id@us-west-2
                #[test]
                fn test_40() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-west-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-west-2.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket arn with UseArnRegion = true (arn region supercedes client configured region)@us-west-2
                #[test]
                fn test_41() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-east-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket ARN in gov partition (non-fips)@us-gov-east-1
                #[test]
                fn test_42() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws-us-gov:s3-outposts:us-gov-east-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-gov-east-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-gov-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-gov-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-gov-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket ARN in gov partition with FIPS@us-gov-west-1
                #[test]
                fn test_43() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws-us-gov:s3-outposts:us-gov-west-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-gov-west-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-gov-west-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-gov-west-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-gov-west-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket ARN in aws partition with FIPS@us-east-2
                #[test]
                fn test_44() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-east-2:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-east-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-east-2.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// Outposts do not support dualstack@us-west-2
                #[test]
                fn test_45() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: Outpost buckets do not support dual-stack [Outposts do not support dualstack@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid configuration: Outpost buckets do not support dual-stack")
                }
    
    /// vanilla bucket arn requires account id@cn-north-1
                #[test]
                fn test_46() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws-cn:s3-outposts:cn-north-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("cn-north-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.cn-north-1.amazonaws.com.cn");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.cn-north-1.amazonaws.com.cn")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "cn-north-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket arn with UseArnRegion = true (arn region supercedes client configured region)@us-west-2
                #[test]
                fn test_47() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-east-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket ARN in gov partition (non-fips)@us-gov-east-1
                #[test]
                fn test_48() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws-us-gov:s3-outposts:us-gov-east-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-gov-east-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-gov-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-gov-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-gov-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket ARN in gov partition with FIPS@us-gov-west-1
                #[test]
                fn test_49() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws-us-gov:s3-outposts:us-gov-west-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-gov-west-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-gov-west-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-gov-west-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-gov-west-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket ARN in aws partition with FIPS@us-east-2
                #[test]
                fn test_50() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-east-2:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-east-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-east-2.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// Outposts do not support dualstack@us-west-2
                #[test]
                fn test_51() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: Outpost buckets do not support dual-stack [Outposts do not support dualstack@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid configuration: Outpost buckets do not support dual-stack")
                }
    
    /// vanilla bucket arn requires account id@af-south-1
                #[test]
                fn test_52() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:af-south-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("af-south-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.af-south-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.af-south-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "af-south-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket arn with UseArnRegion = true (arn region supercedes client configured region)@us-west-2
                #[test]
                fn test_53() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-east-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket ARN in gov partition (non-fips)@us-gov-east-1
                #[test]
                fn test_54() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws-us-gov:s3-outposts:us-gov-east-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-gov-east-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-gov-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-gov-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-gov-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket ARN in gov partition with FIPS@us-gov-west-1
                #[test]
                fn test_55() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws-us-gov:s3-outposts:us-gov-west-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-gov-west-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-gov-west-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-gov-west-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-gov-west-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// bucket ARN in aws partition with FIPS@us-east-2
                #[test]
                fn test_56() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-east-2:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts-fips.us-east-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts-fips.us-east-2.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// Outposts do not support dualstack@us-west-2
                #[test]
                fn test_57() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: Outpost buckets do not support dual-stack [Outposts do not support dualstack@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid configuration: Outpost buckets do not support dual-stack")
                }
    
    /// Invalid ARN: missing outpost id and bucket@us-west-2
                #[test]
                fn test_58() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: The Outpost Id was not set [Invalid ARN: missing outpost id and bucket@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid ARN: The Outpost Id was not set")
                }
    
    /// Invalid ARN: missing bucket@us-west-2
                #[test]
                fn test_59() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: Expected a 4-component resource [Invalid ARN: missing bucket@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid ARN: Expected a 4-component resource")
                }
    
    /// Invalid ARN: missing outpost and bucket ids@us-west-2
                #[test]
                fn test_60() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost:bucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: Expected a 4-component resource [Invalid ARN: missing outpost and bucket ids@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid ARN: Expected a 4-component resource")
                }
    
    /// Invalid ARN: missing bucket id@us-west-2
                #[test]
                fn test_61() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:bucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: expected a bucket name [Invalid ARN: missing bucket id@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid ARN: expected a bucket name")
                }
    
    /// account id inserted into hostname@us-west-2
                #[test]
                fn test_62() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("1234567890".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://1234567890.s3-control.us-west-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://1234567890.s3-control.us-west-2.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// account id prefix with dualstack@us-east-1
                #[test]
                fn test_63() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("1234567890".to_string())
    .region("us-east-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://1234567890.s3-control.dualstack.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://1234567890.s3-control.dualstack.us-east-1.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// account id prefix with fips@us-east-1
                #[test]
                fn test_64() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("1234567890".to_string())
    .region("us-east-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://1234567890.s3-control-fips.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://1234567890.s3-control-fips.us-east-1.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// custom account id prefix with fips@us-east-1
                #[test]
                fn test_65() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("1234567890-aBC".to_string())
    .region("us-east-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://1234567890-aBC.s3-control-fips.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://1234567890-aBC.s3-control-fips.us-east-1.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// standard url @ us-east-1
                #[test]
                fn test_66() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("us-east-1".to_string())
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-control.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-control.us-east-1.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// fips url @ us-east-1
                #[test]
                fn test_67() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("us-east-1".to_string())
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-control-fips.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-control-fips.us-east-1.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// dualstack url @ us-east-1
                #[test]
                fn test_68() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("us-east-1".to_string())
    .use_dual_stack(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-control.dualstack.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-control.dualstack.us-east-1.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// fips,dualstack url @ us-east-1
                #[test]
                fn test_69() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("us-east-1".to_string())
    .use_dual_stack(true)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-control-fips.dualstack.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-control-fips.dualstack.us-east-1.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// standard url @ cn-north-1
                #[test]
                fn test_70() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("cn-north-1".to_string())
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-control.cn-north-1.amazonaws.com.cn");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-control.cn-north-1.amazonaws.com.cn")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "cn-north-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// fips @ cn-north-1
                #[test]
                fn test_71() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("cn-north-1".to_string())
    .use_dual_stack(true)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Partition does not support FIPS [fips @ cn-north-1]");
                            assert_eq!(format!("{}", error), "Partition does not support FIPS")
                }
    
    /// custom account id prefix @us-east-1
                #[test]
                fn test_72() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("1234567890-aBC".to_string())
    .region("us-east-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://1234567890-aBC.s3-control.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://1234567890-aBC.s3-control.us-east-1.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// invalid account id prefix @us-east-1
                #[test]
                fn test_73() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("/?invalid&not-host*label".to_string())
    .region("us-east-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: AccountId must only contain a-z, A-Z, 0-9 and `-`. [invalid account id prefix @us-east-1]");
                            assert_eq!(format!("{}", error), "AccountId must only contain a-z, A-Z, 0-9 and `-`.")
                }
    
    /// custom account id prefix with fips@us-east-1
                #[test]
                fn test_74() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("1234567890-aBC".to_string())
    .region("us-east-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://1234567890-aBC.s3-control-fips.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://1234567890-aBC.s3-control-fips.us-east-1.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// custom account id prefix with dualstack,fips@us-east-1
                #[test]
                fn test_75() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("1234567890-aBC".to_string())
    .region("us-east-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://1234567890-aBC.s3-control-fips.dualstack.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://1234567890-aBC.s3-control-fips.dualstack.us-east-1.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// custom account id with custom endpoint
                #[test]
                fn test_76() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("1234567890-aBC".to_string())
    .region("us-east-1".to_string())
    .requires_account_id(true)
    .endpoint("https://example.com".to_string())
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://1234567890-aBC.example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://1234567890-aBC.example.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// RequiresAccountId with AccountId unset
                #[test]
                fn test_77() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("us-east-1".to_string())
    .requires_account_id(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: AccountId is required but not set [RequiresAccountId with AccountId unset]");
                            assert_eq!(format!("{}", error), "AccountId is required but not set")
                }
    
    /// RequiresAccountId with AccountId unset and custom endpoint
                #[test]
                fn test_78() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("us-east-1".to_string())
    .endpoint("https://beta.example.com".to_string())
    .requires_account_id(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: AccountId is required but not set [RequiresAccountId with AccountId unset and custom endpoint]");
                            assert_eq!(format!("{}", error), "AccountId is required but not set")
                }
    
    /// RequiresAccountId with invalid AccountId and custom endpoint
                #[test]
                fn test_79() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("us-east-1".to_string())
    .endpoint("https://beta.example.com".to_string())
    .account_id("/?invalid&not-host*label".to_string())
    .requires_account_id(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: AccountId must only contain a-z, A-Z, 0-9 and `-`. [RequiresAccountId with invalid AccountId and custom endpoint]");
                            assert_eq!(format!("{}", error), "AccountId must only contain a-z, A-Z, 0-9 and `-`.")
                }
    
    /// account id with custom endpoint, fips and dualstack
                #[test]
                fn test_80() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("1234567890-aBC".to_string())
    .region("us-east-1".to_string())
    .requires_account_id(true)
    .endpoint("https://example.com".to_string())
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://1234567890-aBC.example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://1234567890-aBC.example.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// custom endpoint, fips and dualstack
                #[test]
                fn test_81() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("us-east-1".to_string())
    .endpoint("https://example.com".to_string())
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://example.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// custom endpoint, fips
                #[test]
                fn test_82() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("us-east-1".to_string())
    .endpoint("https://example.com".to_string())
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://example.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// custom endpoint, dualstack
                #[test]
                fn test_83() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("us-east-1".to_string())
    .endpoint("https://example.com".to_string())
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://example.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// region not set
                #[test]
                fn test_84() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Region must be set [region not set]");
                            assert_eq!(format!("{}", error), "Region must be set")
                }
    
    /// invalid partition
                #[test]
                fn test_85() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .region("invalid-region 42".to_string())
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid region: region was not a valid DNS name. [invalid partition]");
                            assert_eq!(format!("{}", error), "Invalid region: region was not a valid DNS name.")
                }
    
    /// ListRegionalBuckets + OutpostId without accountId set.
                #[test]
                fn test_86() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .outpost_id("op-123".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: AccountId is required but not set [ListRegionalBuckets + OutpostId without accountId set.]");
                            assert_eq!(format!("{}", error), "AccountId is required but not set")
                }
    
    /// ListRegionalBuckets + OutpostId with invalid accountId set.
                #[test]
                fn test_87() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("/?invalid&not-host*label".to_string())
    .outpost_id("op-123".to_string())
    .region("us-east-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: AccountId must only contain a-z, A-Z, 0-9 and `-`. [ListRegionalBuckets + OutpostId with invalid accountId set.]");
                            assert_eq!(format!("{}", error), "AccountId must only contain a-z, A-Z, 0-9 and `-`.")
                }
    
    /// accesspoint set but missing accountId
                #[test]
                fn test_88() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("myaccesspoint".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: AccountId is required but not set [accesspoint set but missing accountId]");
                            assert_eq!(format!("{}", error), "AccountId is required but not set")
                }
    
    /// outpost accesspoint ARN with missing accountId
                #[test]
                fn test_89() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2::outpost:op-01234567890123456:outpost:op1".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: missing account ID [outpost accesspoint ARN with missing accountId]");
                            assert_eq!(format!("{}", error), "Invalid ARN: missing account ID")
                }
    
    /// bucket ARN with missing accountId
                #[test]
                fn test_90() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2::outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: missing account ID [bucket ARN with missing accountId]");
                            assert_eq!(format!("{}", error), "Invalid ARN: missing account ID")
                }
    
    /// endpoint url with accesspoint (non-arn)
                #[test]
                fn test_91() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("apname".to_string())
    .endpoint("https://beta.example.com".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://123456789012.beta.example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://123456789012.beta.example.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// access point name with an accesspoint arn@us-west-2
                #[test]
                fn test_92() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .endpoint("https://beta.example.com".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://beta.example.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://beta.example.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// Dualstack + Custom endpoint is not supported(non-arn)
                #[test]
                fn test_93() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("apname".to_string())
    .endpoint("https://beta.example.com".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid Configuration: Dualstack and custom endpoint are not supported [Dualstack + Custom endpoint is not supported(non-arn)]");
                            assert_eq!(format!("{}", error), "Invalid Configuration: Dualstack and custom endpoint are not supported")
                }
    
    /// get bucket with endpoint_url and dualstack is not supported@us-west-2
                #[test]
                fn test_94() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .endpoint("https://beta.example.com".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: Outpost buckets do not support dual-stack [get bucket with endpoint_url and dualstack is not supported@us-west-2]");
                            assert_eq!(format!("{}", error), "Invalid configuration: Outpost buckets do not support dual-stack")
                }
    
    /// ListRegionalBuckets + OutpostId with fips in CN.
                #[test]
                fn test_95() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("0123456789012".to_string())
    .outpost_id("op-123".to_string())
    .region("cn-north-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(true)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Partition does not support FIPS [ListRegionalBuckets + OutpostId with fips in CN.]");
                            assert_eq!(format!("{}", error), "Partition does not support FIPS")
                }
    
    /// ListRegionalBuckets + invalid OutpostId.
                #[test]
                fn test_96() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .account_id("0123456789012".to_string())
    .outpost_id("?outpost/invalid+".to_string())
    .region("us-west-1".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: OutpostId must only contain a-z, A-Z, 0-9 and `-`. [ListRegionalBuckets + invalid OutpostId.]");
                            assert_eq!(format!("{}", error), "OutpostId must only contain a-z, A-Z, 0-9 and `-`.")
                }
    
    /// bucket ARN with mismatched accountId
                #[test]
                fn test_97() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-west-2:999999:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .account_id("0123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid ARN: the accountId specified in the ARN (`999999`) does not match the parameter (`0123456789012`) [bucket ARN with mismatched accountId]");
                            assert_eq!(format!("{}", error), "Invalid ARN: the accountId specified in the ARN (`999999`) does not match the parameter (`0123456789012`)")
                }
    
    /// OutpostId with invalid region
                #[test]
                fn test_98() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .outpost_id("op-123".to_string())
    .region("invalid-region 42".to_string())
    .account_id("0123456".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid region: region was not a valid DNS name. [OutpostId with invalid region]");
                            assert_eq!(format!("{}", error), "Invalid region: region was not a valid DNS name.")
                }
    
    /// OutpostId with RequireAccountId unset
                #[test]
                fn test_99() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .outpost_id("op-123".to_string())
    .region("us-west-2".to_string())
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-west-2.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-west-2.amazonaws.com")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-west-2".to_string().into());
        out
    })])
    .build());
                }
    
    /// Outpost Accesspoint ARN with arn region and client region mismatch with UseArnRegion=false
                #[test]
                fn test_100() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-east-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_arn_region(false)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: region from ARN `us-east-1` does not match client region `us-west-2` and UseArnRegion is `false` [Outpost Accesspoint ARN with arn region and client region mismatch with UseArnRegion=false]");
                            assert_eq!(format!("{}", error), "Invalid configuration: region from ARN `us-east-1` does not match client region `us-west-2` and UseArnRegion is `false`")
                }
    
    /// Outpost Bucket ARN with arn region and client region mismatch with UseArnRegion=false
                #[test]
                fn test_101() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-east-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .endpoint("https://beta.example.com".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_arn_region(false)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: region from ARN `us-east-1` does not match client region `us-west-2` and UseArnRegion is `false` [Outpost Bucket ARN with arn region and client region mismatch with UseArnRegion=false]");
                            assert_eq!(format!("{}", error), "Invalid configuration: region from ARN `us-east-1` does not match client region `us-west-2` and UseArnRegion is `false`")
                }
    
    /// Accesspoint ARN with region mismatch and UseArnRegion unset
                #[test]
                fn test_102() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:us-east-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// Bucket ARN with region mismatch and UseArnRegion unset
                #[test]
                fn test_103() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:us-east-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let endpoint = endpoint.expect("Expected valid endpoint: https://s3-outposts.us-east-1.amazonaws.com");
                            assert_eq!(endpoint, aws_smithy_types::endpoint::Endpoint::builder().url("https://s3-outposts.us-east-1.amazonaws.com")
    .header("x-amz-account-id", "123456789012")
    .header("x-amz-outpost-id", "op-01234567890123456")
    .property("authSchemes", vec![aws_smithy_types::Document::from( {
        let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
        out.insert("disableDoubleEncoding".to_string(), true.into());
        out.insert("name".to_string(), "sigv4".to_string().into());
        out.insert("signingName".to_string(), "s3-outposts".to_string().into());
        out.insert("signingRegion".to_string(), "us-east-1".to_string().into());
        out
    })])
    .build());
                }
    
    /// Outpost Bucket ARN with partition mismatch with UseArnRegion=true
                #[test]
                fn test_104() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .bucket("arn:aws:s3-outposts:cn-north-1:123456789012:outpost:op-01234567890123456:bucket:mybucket".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_arn_region(true)
    .use_dual_stack(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Client was configured for partition `aws` but ARN has `aws-cn` [Outpost Bucket ARN with partition mismatch with UseArnRegion=true]");
                            assert_eq!(format!("{}", error), "Client was configured for partition `aws` but ARN has `aws-cn`")
                }
    
    /// Accesspoint ARN with partition mismatch and UseArnRegion=true
                #[test]
                fn test_105() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:cn-north-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .account_id("123456789012".to_string())
    .region("us-west-2".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_arn_region(true)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Client was configured for partition `aws` but ARN has `aws-cn` [Accesspoint ARN with partition mismatch and UseArnRegion=true]");
                            assert_eq!(format!("{}", error), "Client was configured for partition `aws` but ARN has `aws-cn`")
                }
    
    /// Accesspoint ARN with region mismatch, UseArnRegion=false and custom endpoint
                #[test]
                fn test_106() {
                    use aws_smithy_http::endpoint::ResolveEndpoint;
                    let params = crate::endpoint::Params::builder()
    .access_point_name("arn:aws:s3-outposts:cn-north-1:123456789012:outpost:op-01234567890123456:accesspoint:myaccesspoint".to_string())
    .region("us-west-2".to_string())
    .endpoint("https://example.com".to_string())
    .requires_account_id(true)
    .use_dual_stack(false)
    .use_arn_region(false)
    .use_fips(false)
    .build().expect("invalid params");
                    let resolver = crate::endpoint::DefaultResolver::new();
                    let endpoint = resolver.resolve_endpoint(&params);
                    let error = endpoint.expect_err("expected error: Invalid configuration: region from ARN `cn-north-1` does not match client region `us-west-2` and UseArnRegion is `false` [Accesspoint ARN with region mismatch, UseArnRegion=false and custom endpoint]");
                            assert_eq!(format!("{}", error), "Invalid configuration: region from ARN `cn-north-1` does not match client region `us-west-2` and UseArnRegion is `false`")
                }
    
    
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
/// Configuration parameters for resolving the correct endpoint
pub struct Params {
    /// The AWS region used to dispatch the request.
    pub(crate) region: std::option::Option<std::string::String>,
    /// When true, send this request to the FIPS-compliant regional endpoint. If the configured endpoint does not have a FIPS compliant endpoint, dispatching the request will return an error.
    pub(crate) use_fips: bool,
    /// When true, use the dual-stack endpoint. If the configured endpoint does not support dual-stack, dispatching the request MAY return an error.
    pub(crate) use_dual_stack: bool,
    /// Override the endpoint used to send this request
    pub(crate) endpoint: std::option::Option<std::string::String>,
    /// The Account ID used to send the request. This is an optional parameter that will be set automatically for operations that require it.
    pub(crate) account_id: std::option::Option<std::string::String>,
    /// Internal parameter for operations that require account id host prefix.
    pub(crate) requires_account_id: std::option::Option<bool>,
    /// The Outpost ID.  Some operations have an optional OutpostId which should be used in endpoint construction.
    pub(crate) outpost_id: std::option::Option<std::string::String>,
    /// The S3 bucket used to send the request. This is an optional parameter that will be set automatically for operations that are scoped to an S3 bucket.
    pub(crate) bucket: std::option::Option<std::string::String>,
    /// The S3 AccessPointName used to send the request. This is an optional parameter that will be set automatically for operations that are scoped to an S3 AccessPoint.
    pub(crate) access_point_name: std::option::Option<std::string::String>,
    /// When an Access Point ARN is provided and this flag is enabled, the SDK MUST use the ARN's region when constructing the endpoint instead of the client's configured region.
    pub(crate) use_arn_region: std::option::Option<bool>,
}
impl Params {
    /// Create a builder for [`Params`]
                    pub fn builder() -> crate::endpoint::ParamsBuilder {
                        crate::endpoint::ParamsBuilder::default()
                    }
    /// The AWS region used to dispatch the request.
    pub fn region(&self) -> std::option::Option<& str> {
                            self.region.as_deref()
                        }
    /// When true, send this request to the FIPS-compliant regional endpoint. If the configured endpoint does not have a FIPS compliant endpoint, dispatching the request will return an error.
    pub fn use_fips(&self) -> std::option::Option<bool> {
                            Some(self.use_fips)
                        }
    /// When true, use the dual-stack endpoint. If the configured endpoint does not support dual-stack, dispatching the request MAY return an error.
    pub fn use_dual_stack(&self) -> std::option::Option<bool> {
                            Some(self.use_dual_stack)
                        }
    /// Override the endpoint used to send this request
    pub fn endpoint(&self) -> std::option::Option<& str> {
                            self.endpoint.as_deref()
                        }
    /// The Account ID used to send the request. This is an optional parameter that will be set automatically for operations that require it.
    pub fn account_id(&self) -> std::option::Option<& str> {
                            self.account_id.as_deref()
                        }
    /// Internal parameter for operations that require account id host prefix.
    pub fn requires_account_id(&self) -> std::option::Option<bool> {
                            self.requires_account_id
                        }
    /// The Outpost ID.  Some operations have an optional OutpostId which should be used in endpoint construction.
    pub fn outpost_id(&self) -> std::option::Option<& str> {
                            self.outpost_id.as_deref()
                        }
    /// The S3 bucket used to send the request. This is an optional parameter that will be set automatically for operations that are scoped to an S3 bucket.
    pub fn bucket(&self) -> std::option::Option<& str> {
                            self.bucket.as_deref()
                        }
    /// The S3 AccessPointName used to send the request. This is an optional parameter that will be set automatically for operations that are scoped to an S3 AccessPoint.
    pub fn access_point_name(&self) -> std::option::Option<& str> {
                            self.access_point_name.as_deref()
                        }
    /// When an Access Point ARN is provided and this flag is enabled, the SDK MUST use the ARN's region when constructing the endpoint instead of the client's configured region.
    pub fn use_arn_region(&self) -> std::option::Option<bool> {
                            self.use_arn_region
                        }
}

/// The default endpoint resolver
                #[derive(Default)]
                pub struct DefaultResolver {
                    partition_resolver: crate::endpoint_lib::partition::PartitionResolver
                }

                impl DefaultResolver {
                    /// Create a new endpoint resolver with default settings
                    pub fn new() -> Self {
                        Self { partition_resolver: crate::endpoint_lib::partition::PartitionResolver::new_from_json(b"{\"version\":\"1.1\",\"partitions\":[{\"id\":\"aws\",\"regionRegex\":\"^(us|eu|ap|sa|ca|me|af)-\\\\w+-\\\\d+$\",\"regions\":{\"af-south-1\":{},\"ap-east-1\":{},\"ap-northeast-1\":{},\"ap-northeast-2\":{},\"ap-northeast-3\":{},\"ap-south-1\":{},\"ap-southeast-1\":{},\"ap-southeast-2\":{},\"ap-southeast-3\":{},\"ca-central-1\":{},\"eu-central-1\":{},\"eu-north-1\":{},\"eu-south-1\":{},\"eu-west-1\":{},\"eu-west-2\":{},\"eu-west-3\":{},\"me-central-1\":{},\"me-south-1\":{},\"sa-east-1\":{},\"us-east-1\":{},\"us-east-2\":{},\"us-west-1\":{},\"us-west-2\":{},\"aws-global\":{}},\"outputs\":{\"name\":\"aws\",\"dnsSuffix\":\"amazonaws.com\",\"dualStackDnsSuffix\":\"api.aws\",\"supportsFIPS\":true,\"supportsDualStack\":true}},{\"id\":\"aws-us-gov\",\"regionRegex\":\"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$\",\"regions\":{\"us-gov-west-1\":{},\"us-gov-east-1\":{},\"aws-us-gov-global\":{}},\"outputs\":{\"name\":\"aws-us-gov\",\"dnsSuffix\":\"amazonaws.com\",\"dualStackDnsSuffix\":\"api.aws\",\"supportsFIPS\":true,\"supportsDualStack\":true}},{\"id\":\"aws-cn\",\"regionRegex\":\"^cn\\\\-\\\\w+\\\\-\\\\d+$\",\"regions\":{\"cn-north-1\":{},\"cn-northwest-1\":{},\"aws-cn-global\":{}},\"outputs\":{\"name\":\"aws-cn\",\"dnsSuffix\":\"amazonaws.com.cn\",\"dualStackDnsSuffix\":\"api.amazonwebservices.com.cn\",\"supportsFIPS\":true,\"supportsDualStack\":true}},{\"id\":\"aws-iso\",\"regionRegex\":\"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$\",\"outputs\":{\"name\":\"aws-iso\",\"dnsSuffix\":\"c2s.ic.gov\",\"supportsFIPS\":true,\"supportsDualStack\":false,\"dualStackDnsSuffix\":\"c2s.ic.gov\"},\"regions\":{\"us-iso-east-1\":{},\"us-iso-west-1\":{},\"aws-iso-global\":{}}},{\"id\":\"aws-iso-b\",\"regionRegex\":\"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$\",\"outputs\":{\"name\":\"aws-iso-b\",\"dnsSuffix\":\"sc2s.sgov.gov\",\"supportsFIPS\":true,\"supportsDualStack\":false,\"dualStackDnsSuffix\":\"sc2s.sgov.gov\"},\"regions\":{\"us-isob-east-1\":{},\"aws-iso-b-global\":{}}}]}").expect("valid JSON") }
                    }
                }

                impl aws_smithy_http::endpoint::ResolveEndpoint<crate::endpoint::Params> for DefaultResolver {
                    fn resolve_endpoint(&self, params: &Params) -> aws_smithy_http::endpoint::Result {
                        let mut diagnostic_collector = crate::endpoint_lib::diagnostic::DiagnosticCollector::new();
                        crate::endpoint::internals::resolve_endpoint(params, &mut diagnostic_collector, &self.partition_resolver)
                            .map_err(|err|err.with_source(diagnostic_collector.take_last_error()))
                    }
                }

/// Builder for [`Params`]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ParamsBuilder {
    region: std::option::Option<std::string::String>,
    use_fips: std::option::Option<bool>,
    use_dual_stack: std::option::Option<bool>,
    endpoint: std::option::Option<std::string::String>,
    account_id: std::option::Option<std::string::String>,
    requires_account_id: std::option::Option<bool>,
    outpost_id: std::option::Option<std::string::String>,
    bucket: std::option::Option<std::string::String>,
    access_point_name: std::option::Option<std::string::String>,
    use_arn_region: std::option::Option<bool>,
}
impl ParamsBuilder {
    /// Consume this builder, creating [`Params`].
    pub fn build(self) -> Result<crate::endpoint::Params, crate::endpoint::InvalidParams> {
        Ok(#[allow(clippy::unnecessary_lazy_evaluations)]
        crate::endpoint::Params {
            region: self.region
            ,
            use_fips: self.use_fips
            .or_else(||Some(false))
            .ok_or_else(||crate::endpoint::InvalidParams::missing("use_fips"))?
            ,
            use_dual_stack: self.use_dual_stack
            .or_else(||Some(false))
            .ok_or_else(||crate::endpoint::InvalidParams::missing("use_dual_stack"))?
            ,
            endpoint: self.endpoint
            ,
            account_id: self.account_id
            ,
            requires_account_id: self.requires_account_id
            ,
            outpost_id: self.outpost_id
            ,
            bucket: self.bucket
            ,
            access_point_name: self.access_point_name
            ,
            use_arn_region: self.use_arn_region
            ,
        })
    }
    /// Sets the value for region 
    /// 
    /// The AWS region used to dispatch the request.
                        pub fn region(mut self, value: impl Into<std::string::String>) -> Self {
                            self.region = Some(value.into());
                            self
                        }
    
                        /// Sets the value for region 
    /// 
    /// The AWS region used to dispatch the request.
                        pub fn set_region(mut self, param: Option<std::string::String>) -> Self {
                            self.region = param;
                            self
                        }
    /// Sets the value for use_fips 
    /// 
    /// When unset, this parameter has a default value of `false`.
    /// When true, send this request to the FIPS-compliant regional endpoint. If the configured endpoint does not have a FIPS compliant endpoint, dispatching the request will return an error.
                        pub fn use_fips(mut self, value: impl Into<bool>) -> Self {
                            self.use_fips = Some(value.into());
                            self
                        }
    
                        /// Sets the value for use_fips 
    /// 
    /// When unset, this parameter has a default value of `false`.
    /// When true, send this request to the FIPS-compliant regional endpoint. If the configured endpoint does not have a FIPS compliant endpoint, dispatching the request will return an error.
                        pub fn set_use_fips(mut self, param: Option<bool>) -> Self {
                            self.use_fips = param;
                            self
                        }
    /// Sets the value for use_dual_stack 
    /// 
    /// When unset, this parameter has a default value of `false`.
    /// When true, use the dual-stack endpoint. If the configured endpoint does not support dual-stack, dispatching the request MAY return an error.
                        pub fn use_dual_stack(mut self, value: impl Into<bool>) -> Self {
                            self.use_dual_stack = Some(value.into());
                            self
                        }
    
                        /// Sets the value for use_dual_stack 
    /// 
    /// When unset, this parameter has a default value of `false`.
    /// When true, use the dual-stack endpoint. If the configured endpoint does not support dual-stack, dispatching the request MAY return an error.
                        pub fn set_use_dual_stack(mut self, param: Option<bool>) -> Self {
                            self.use_dual_stack = param;
                            self
                        }
    /// Sets the value for endpoint 
    /// 
    /// Override the endpoint used to send this request
                        pub fn endpoint(mut self, value: impl Into<std::string::String>) -> Self {
                            self.endpoint = Some(value.into());
                            self
                        }
    
                        /// Sets the value for endpoint 
    /// 
    /// Override the endpoint used to send this request
                        pub fn set_endpoint(mut self, param: Option<std::string::String>) -> Self {
                            self.endpoint = param;
                            self
                        }
    /// Sets the value for account_id 
    /// 
    /// The Account ID used to send the request. This is an optional parameter that will be set automatically for operations that require it.
                        pub fn account_id(mut self, value: impl Into<std::string::String>) -> Self {
                            self.account_id = Some(value.into());
                            self
                        }
    
                        /// Sets the value for account_id 
    /// 
    /// The Account ID used to send the request. This is an optional parameter that will be set automatically for operations that require it.
                        pub fn set_account_id(mut self, param: Option<std::string::String>) -> Self {
                            self.account_id = param;
                            self
                        }
    /// Sets the value for requires_account_id 
    /// 
    /// Internal parameter for operations that require account id host prefix.
                        pub fn requires_account_id(mut self, value: impl Into<bool>) -> Self {
                            self.requires_account_id = Some(value.into());
                            self
                        }
    
                        /// Sets the value for requires_account_id 
    /// 
    /// Internal parameter for operations that require account id host prefix.
                        pub fn set_requires_account_id(mut self, param: Option<bool>) -> Self {
                            self.requires_account_id = param;
                            self
                        }
    /// Sets the value for outpost_id 
    /// 
    /// The Outpost ID.  Some operations have an optional OutpostId which should be used in endpoint construction.
                        pub fn outpost_id(mut self, value: impl Into<std::string::String>) -> Self {
                            self.outpost_id = Some(value.into());
                            self
                        }
    
                        /// Sets the value for outpost_id 
    /// 
    /// The Outpost ID.  Some operations have an optional OutpostId which should be used in endpoint construction.
                        pub fn set_outpost_id(mut self, param: Option<std::string::String>) -> Self {
                            self.outpost_id = param;
                            self
                        }
    /// Sets the value for bucket 
    /// 
    /// The S3 bucket used to send the request. This is an optional parameter that will be set automatically for operations that are scoped to an S3 bucket.
                        pub fn bucket(mut self, value: impl Into<std::string::String>) -> Self {
                            self.bucket = Some(value.into());
                            self
                        }
    
                        /// Sets the value for bucket 
    /// 
    /// The S3 bucket used to send the request. This is an optional parameter that will be set automatically for operations that are scoped to an S3 bucket.
                        pub fn set_bucket(mut self, param: Option<std::string::String>) -> Self {
                            self.bucket = param;
                            self
                        }
    /// Sets the value for access_point_name 
    /// 
    /// The S3 AccessPointName used to send the request. This is an optional parameter that will be set automatically for operations that are scoped to an S3 AccessPoint.
                        pub fn access_point_name(mut self, value: impl Into<std::string::String>) -> Self {
                            self.access_point_name = Some(value.into());
                            self
                        }
    
                        /// Sets the value for access_point_name 
    /// 
    /// The S3 AccessPointName used to send the request. This is an optional parameter that will be set automatically for operations that are scoped to an S3 AccessPoint.
                        pub fn set_access_point_name(mut self, param: Option<std::string::String>) -> Self {
                            self.access_point_name = param;
                            self
                        }
    /// Sets the value for use_arn_region 
    /// 
    /// When an Access Point ARN is provided and this flag is enabled, the SDK MUST use the ARN's region when constructing the endpoint instead of the client's configured region.
                        pub fn use_arn_region(mut self, value: impl Into<bool>) -> Self {
                            self.use_arn_region = Some(value.into());
                            self
                        }
    
                        /// Sets the value for use_arn_region 
    /// 
    /// When an Access Point ARN is provided and this flag is enabled, the SDK MUST use the ARN's region when constructing the endpoint instead of the client's configured region.
                        pub fn set_use_arn_region(mut self, param: Option<bool>) -> Self {
                            self.use_arn_region = param;
                            self
                        }
}

/// An error that occurred during endpoint resolution
            #[derive(Debug)]
            pub struct InvalidParams {
                field: std::borrow::Cow<'static, str>
            }

            impl InvalidParams {
                #[allow(dead_code)]
                fn missing(field: &'static str) -> Self {
                    Self { field: field.into() }
                }
            }

            impl std::fmt::Display for InvalidParams {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    write!(f, "a required field was missing: `{}`", self.field)
                }
            }

            impl std::error::Error for InvalidParams { }

mod internals;

