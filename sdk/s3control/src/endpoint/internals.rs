// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::collapsible_if, clippy::bool_comparison, clippy::nonminimal_bool, clippy::comparison_to_empty, clippy::redundant_pattern_matching)]
pub(super) fn resolve_endpoint(_params: &crate::endpoint::Params, _diagnostic_collector: &mut crate::endpoint_lib::diagnostic::DiagnosticCollector, partition_resolver: &crate::endpoint_lib::partition::PartitionResolver) -> aws_smithy_http::endpoint::Result {
                  #[allow(unused_variables)]
let region = &_params.region;
#[allow(unused_variables)]
let use_fips = &_params.use_fips;
#[allow(unused_variables)]
let use_dual_stack = &_params.use_dual_stack;
#[allow(unused_variables)]
let endpoint = &_params.endpoint;
#[allow(unused_variables)]
let account_id = &_params.account_id;
#[allow(unused_variables)]
let requires_account_id = &_params.requires_account_id;
#[allow(unused_variables)]
let outpost_id = &_params.outpost_id;
#[allow(unused_variables)]
let bucket = &_params.bucket;
#[allow(unused_variables)]
let access_point_name = &_params.access_point_name;
#[allow(unused_variables)]
let use_arn_region = &_params.use_arn_region;
#[allow(unused_variables)]
if let Some(region) = region { #[allow(unused_variables)]
if let Some(outpost_id) = outpost_id { #[allow(unused_variables)]
if let Some(partition_result) = partition_resolver.resolve_partition(region, _diagnostic_collector) { if (*use_fips) == (true) {
                                if (partition_result.name()) == ("aws-cn") {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Partition does not support FIPS"
.to_string()));
                            }
                            }
#[allow(unused_variables)]
if let Some(requires_account_id) = requires_account_id { if (*requires_account_id) == (true) {
                                if !(account_id.is_some()) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("AccountId is required but not set"
.to_string()));
                            }
                            } }
#[allow(unused_variables)]
if let Some(account_id) = account_id { if !(crate::endpoint_lib::host::is_valid_host_label(account_id
,false, _diagnostic_collector)) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("AccountId must only contain a-z, A-Z, 0-9 and `-`."
.to_string()));
                            } }
if !(crate::endpoint_lib::host::is_valid_host_label(outpost_id
,false, _diagnostic_collector)) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("OutpostId must only contain a-z, A-Z, 0-9 and `-`."
.to_string()));
                            }
if crate::endpoint_lib::host::is_valid_host_label(region
,true, _diagnostic_collector) {
                                if (*use_dual_stack) == (true) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid configuration: Outposts do not support dual-stack"
.to_string()));
                            }
#[allow(unused_variables)]
if let Some(endpoint) = endpoint { #[allow(unused_variables)]
if let Some(url) = crate::endpoint_lib::parse_url::parse_url(endpoint, _diagnostic_collector) { return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
#[allow(clippy::needless_borrow)]
out.push_str(&url.scheme());
out.push_str("://");
#[allow(clippy::needless_borrow)]
out.push_str(&url.authority());
#[allow(clippy::needless_borrow)]
out.push_str(&url.path());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3-outposts"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build()); } }
if (*use_fips) == (true) {
                                return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://s3-outposts-fips.");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.dns_suffix());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3-outposts"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build());
                            }
return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://s3-outposts.");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.dns_suffix());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3-outposts"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build());
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid region: region was not a valid DNS name."
.to_string())); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("A valid partition could not be determined"
.to_string())); }
#[allow(unused_variables)]
if let Some(access_point_name) = access_point_name { #[allow(unused_variables)]
if let Some(access_point_arn) = crate::endpoint_lib::arn::parse_arn(access_point_name, _diagnostic_collector) { #[allow(unused_variables)]
if let Some(arn_type) = access_point_arn.resource_id()
.first().cloned() { if !((arn_type) == ("")) {
                                if (access_point_arn.service()) == ("s3-outposts") {
                                if (*use_dual_stack) == (true) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid configuration: Outpost Access Points do not support dual-stack"
.to_string()));
                            }
#[allow(unused_variables)]
if let Some(outpost_id) = access_point_arn.resource_id()
.get(1).cloned() { if crate::endpoint_lib::host::is_valid_host_label(outpost_id
,false, _diagnostic_collector) {
                                #[allow(unused_variables)]
if let Some(use_arn_region) = use_arn_region { if (*use_arn_region) == (false) {
                                if !((access_point_arn.region()) == (region)) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid configuration: region from ARN `");
#[allow(clippy::needless_borrow)]
out.push_str(&access_point_arn.region());
out.push_str("` does not match client region `");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push_str("` and UseArnRegion is `false`");
out }));
                            }
                            } }
#[allow(unused_variables)]
if let Some(partition_result) = partition_resolver.resolve_partition(region, _diagnostic_collector) { #[allow(unused_variables)]
if let Some(arn_partition) = partition_resolver.resolve_partition(access_point_arn.region(), _diagnostic_collector) { if (arn_partition.name()) == (partition_result.name()) {
                                if crate::endpoint_lib::host::is_valid_host_label(access_point_arn.region()
,true, _diagnostic_collector) {
                                if !((access_point_arn.account_id()) == ("")) {
                                if crate::endpoint_lib::host::is_valid_host_label(access_point_arn.account_id()
,false, _diagnostic_collector) {
                                #[allow(unused_variables)]
if let Some(account_id) = account_id { if !((account_id) == (access_point_arn.account_id())) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid ARN: the accountId specified in the ARN (`");
#[allow(clippy::needless_borrow)]
out.push_str(&access_point_arn.account_id());
out.push_str("`) does not match the parameter (`");
#[allow(clippy::needless_borrow)]
out.push_str(&account_id);
out.push_str("`)");
out }));
                            } }
#[allow(unused_variables)]
if let Some(outpost_type) = access_point_arn.resource_id()
.get(2).cloned() { #[allow(unused_variables)]
if let Some(access_point_name) = access_point_arn.resource_id()
.get(3).cloned() { if (outpost_type) == ("accesspoint") {
                                if (*use_fips) == (true) {
                                return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://s3-outposts-fips.");
#[allow(clippy::needless_borrow)]
out.push_str(&access_point_arn.region());
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&arn_partition.dns_suffix());
out })
.header("x-amz-account-id", access_point_arn.account_id()
.to_owned())
.header("x-amz-outpost-id", outpost_id.to_owned())
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3-outposts"
    .to_string().into());
    out.insert("signingRegion".to_string(), access_point_arn.region()
    .to_owned().into());
    out
}),])
.build());
                            }
#[allow(unused_variables)]
if let Some(endpoint) = endpoint { #[allow(unused_variables)]
if let Some(url) = crate::endpoint_lib::parse_url::parse_url(endpoint, _diagnostic_collector) { return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
#[allow(clippy::needless_borrow)]
out.push_str(&url.scheme());
out.push_str("://");
#[allow(clippy::needless_borrow)]
out.push_str(&url.authority());
#[allow(clippy::needless_borrow)]
out.push_str(&url.path());
out })
.header("x-amz-account-id", access_point_arn.account_id()
.to_owned())
.header("x-amz-outpost-id", outpost_id.to_owned())
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3-outposts"
    .to_string().into());
    out.insert("signingRegion".to_string(), access_point_arn.region()
    .to_owned().into());
    out
}),])
.build()); } }
return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://s3-outposts.");
#[allow(clippy::needless_borrow)]
out.push_str(&access_point_arn.region());
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&arn_partition.dns_suffix());
out })
.header("x-amz-account-id", access_point_arn.account_id()
.to_owned())
.header("x-amz-outpost-id", outpost_id.to_owned())
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3-outposts"
    .to_string().into());
    out.insert("signingRegion".to_string(), access_point_arn.region()
    .to_owned().into());
    out
}),])
.build());
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Expected an outpost type `accesspoint`, found `");
#[allow(clippy::needless_borrow)]
out.push_str(&outpost_type);
out.push('`');
out })); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid ARN: expected an access point name"
.to_string())); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid ARN: Expected a 4-component resource"
.to_string()));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `");
#[allow(clippy::needless_borrow)]
out.push_str(&access_point_arn.account_id());
out.push('`');
out }));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid ARN: missing account ID"
.to_string()));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid region in ARN: `");
#[allow(clippy::needless_borrow)]
out.push_str(&access_point_arn.region());
out.push_str("` (invalid DNS name)");
out }));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Client was configured for partition `");
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.name());
out.push_str("` but ARN has `");
#[allow(clippy::needless_borrow)]
out.push_str(&arn_partition.name());
out.push('`');
out })); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Could not load partition for ARN region `");
#[allow(clippy::needless_borrow)]
out.push_str(&access_point_arn.region());
out.push('`');
out })); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("A valid partition could not be determined"
.to_string()));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`., found: `");
#[allow(clippy::needless_borrow)]
out.push_str(&outpost_id);
out.push('`');
out })); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid ARN: The Outpost Id was not set"
.to_string()));
                            }
#[allow(unreachable_code)]
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message(format!("No rules matched these parameters. This is a bug. {:?}", _params)));
                            } }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid ARN: No ARN type specified"
.to_string())); } }
#[allow(unused_variables)]
if let Some(bucket) = bucket { #[allow(unused_variables)]
if let Some(bucket_arn) = crate::endpoint_lib::arn::parse_arn(bucket, _diagnostic_collector) { #[allow(unused_variables)]
if let Some(arn_type) = bucket_arn.resource_id()
.first().cloned() { if !((arn_type) == ("")) {
                                if (bucket_arn.service()) == ("s3-outposts") {
                                if (*use_dual_stack) == (true) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid configuration: Outpost buckets do not support dual-stack"
.to_string()));
                            }
#[allow(unused_variables)]
if let Some(outpost_id) = bucket_arn.resource_id()
.get(1).cloned() { if crate::endpoint_lib::host::is_valid_host_label(outpost_id
,false, _diagnostic_collector) {
                                #[allow(unused_variables)]
if let Some(use_arn_region) = use_arn_region { if (*use_arn_region) == (false) {
                                if !((bucket_arn.region()) == (region)) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid configuration: region from ARN `");
#[allow(clippy::needless_borrow)]
out.push_str(&bucket_arn.region());
out.push_str("` does not match client region `");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push_str("` and UseArnRegion is `false`");
out }));
                            }
                            } }
#[allow(unused_variables)]
if let Some(arn_partition) = partition_resolver.resolve_partition(bucket_arn.region(), _diagnostic_collector) { #[allow(unused_variables)]
if let Some(partition_result) = partition_resolver.resolve_partition(region, _diagnostic_collector) { if (arn_partition.name()) == (partition_result.name()) {
                                if crate::endpoint_lib::host::is_valid_host_label(bucket_arn.region()
,true, _diagnostic_collector) {
                                if !((bucket_arn.account_id()) == ("")) {
                                if crate::endpoint_lib::host::is_valid_host_label(bucket_arn.account_id()
,false, _diagnostic_collector) {
                                #[allow(unused_variables)]
if let Some(account_id) = account_id { if !((account_id) == (bucket_arn.account_id())) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid ARN: the accountId specified in the ARN (`");
#[allow(clippy::needless_borrow)]
out.push_str(&bucket_arn.account_id());
out.push_str("`) does not match the parameter (`");
#[allow(clippy::needless_borrow)]
out.push_str(&account_id);
out.push_str("`)");
out }));
                            } }
#[allow(unused_variables)]
if let Some(outpost_type) = bucket_arn.resource_id()
.get(2).cloned() { #[allow(unused_variables)]
if let Some(bucket_name) = bucket_arn.resource_id()
.get(3).cloned() { if (outpost_type) == ("bucket") {
                                if (*use_fips) == (true) {
                                return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://s3-outposts-fips.");
#[allow(clippy::needless_borrow)]
out.push_str(&bucket_arn.region());
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&arn_partition.dns_suffix());
out })
.header("x-amz-account-id", bucket_arn.account_id()
.to_owned())
.header("x-amz-outpost-id", outpost_id.to_owned())
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3-outposts"
    .to_string().into());
    out.insert("signingRegion".to_string(), bucket_arn.region()
    .to_owned().into());
    out
}),])
.build());
                            }
#[allow(unused_variables)]
if let Some(endpoint) = endpoint { #[allow(unused_variables)]
if let Some(url) = crate::endpoint_lib::parse_url::parse_url(endpoint, _diagnostic_collector) { return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
#[allow(clippy::needless_borrow)]
out.push_str(&url.scheme());
out.push_str("://");
#[allow(clippy::needless_borrow)]
out.push_str(&url.authority());
#[allow(clippy::needless_borrow)]
out.push_str(&url.path());
out })
.header("x-amz-account-id", bucket_arn.account_id()
.to_owned())
.header("x-amz-outpost-id", outpost_id.to_owned())
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3-outposts"
    .to_string().into());
    out.insert("signingRegion".to_string(), bucket_arn.region()
    .to_owned().into());
    out
}),])
.build()); } }
return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://s3-outposts.");
#[allow(clippy::needless_borrow)]
out.push_str(&bucket_arn.region());
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&arn_partition.dns_suffix());
out })
.header("x-amz-account-id", bucket_arn.account_id()
.to_owned())
.header("x-amz-outpost-id", outpost_id.to_owned())
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3-outposts"
    .to_string().into());
    out.insert("signingRegion".to_string(), bucket_arn.region()
    .to_owned().into());
    out
}),])
.build());
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid ARN: Expected an outpost type `bucket`, found `");
#[allow(clippy::needless_borrow)]
out.push_str(&outpost_type);
out.push('`');
out })); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid ARN: expected a bucket name"
.to_string())); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid ARN: Expected a 4-component resource"
.to_string()));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `");
#[allow(clippy::needless_borrow)]
out.push_str(&bucket_arn.account_id());
out.push('`');
out }));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid ARN: missing account ID"
.to_string()));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid region in ARN: `");
#[allow(clippy::needless_borrow)]
out.push_str(&bucket_arn.region());
out.push_str("` (invalid DNS name)");
out }));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Client was configured for partition `");
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.name());
out.push_str("` but ARN has `");
#[allow(clippy::needless_borrow)]
out.push_str(&arn_partition.name());
out.push('`');
out })); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("A valid partition could not be determined"
.to_string())); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Could not load partition for ARN region `");
#[allow(clippy::needless_borrow)]
out.push_str(&bucket_arn.region());
out.push('`');
out }));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message({ let mut out = String::new();
out.push_str("Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`., found: `");
#[allow(clippy::needless_borrow)]
out.push_str(&outpost_id);
out.push('`');
out })); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid ARN: The Outpost Id was not set"
.to_string()));
                            }
#[allow(unreachable_code)]
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message(format!("No rules matched these parameters. This is a bug. {:?}", _params)));
                            } }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid ARN: No ARN type specified"
.to_string())); } }
#[allow(unused_variables)]
if let Some(partition_result) = partition_resolver.resolve_partition(region, _diagnostic_collector) { if crate::endpoint_lib::host::is_valid_host_label(region
,true, _diagnostic_collector) {
                                if (*use_fips) == (true) {
                                if (partition_result.name()) == ("aws-cn") {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Partition does not support FIPS"
.to_string()));
                            }
                            }
#[allow(unused_variables)]
if let Some(requires_account_id) = requires_account_id { if (*requires_account_id) == (true) {
                                if !(account_id.is_some()) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("AccountId is required but not set"
.to_string()));
                            }
                            } }
#[allow(unused_variables)]
if let Some(account_id) = account_id { if !(crate::endpoint_lib::host::is_valid_host_label(account_id
,false, _diagnostic_collector)) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("AccountId must only contain a-z, A-Z, 0-9 and `-`."
.to_string()));
                            } }
#[allow(unused_variables)]
if let Some(endpoint) = endpoint { #[allow(unused_variables)]
if let Some(url) = crate::endpoint_lib::parse_url::parse_url(endpoint, _diagnostic_collector) { if (*use_dual_stack) == (true) {
                                return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid Configuration: Dualstack and custom endpoint are not supported"
.to_string()));
                            }
#[allow(unused_variables)]
if let Some(requires_account_id) = requires_account_id { if (*requires_account_id) == (true) {
                                #[allow(unused_variables)]
if let Some(account_id) = account_id { return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
#[allow(clippy::needless_borrow)]
out.push_str(&url.scheme());
out.push_str("://");
#[allow(clippy::needless_borrow)]
out.push_str(&account_id);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&url.authority());
#[allow(clippy::needless_borrow)]
out.push_str(&url.path());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build()); }
                            } }
return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
#[allow(clippy::needless_borrow)]
out.push_str(&url.scheme());
out.push_str("://");
#[allow(clippy::needless_borrow)]
out.push_str(&url.authority());
#[allow(clippy::needless_borrow)]
out.push_str(&url.path());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build()); } }
if (*use_fips) == (true) {
                                if (*use_dual_stack) == (true) {
                                #[allow(unused_variables)]
if let Some(requires_account_id) = requires_account_id { if (*requires_account_id) == (true) {
                                #[allow(unused_variables)]
if let Some(account_id) = account_id { return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://");
#[allow(clippy::needless_borrow)]
out.push_str(&account_id);
out.push_str(".s3-control-fips.dualstack.");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.dns_suffix());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build()); }
                            } }
                            }
                            }
if (*use_fips) == (true) {
                                if (*use_dual_stack) == (true) {
                                return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://s3-control-fips.dualstack.");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.dns_suffix());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build());
                            }
                            }
if (*use_fips) == (true) {
                                if (*use_dual_stack) == (false) {
                                #[allow(unused_variables)]
if let Some(requires_account_id) = requires_account_id { if (*requires_account_id) == (true) {
                                #[allow(unused_variables)]
if let Some(account_id) = account_id { return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://");
#[allow(clippy::needless_borrow)]
out.push_str(&account_id);
out.push_str(".s3-control-fips.");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.dns_suffix());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build()); }
                            } }
                            }
                            }
if (*use_fips) == (true) {
                                if (*use_dual_stack) == (false) {
                                return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://s3-control-fips.");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.dns_suffix());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build());
                            }
                            }
if (*use_fips) == (false) {
                                if (*use_dual_stack) == (true) {
                                #[allow(unused_variables)]
if let Some(requires_account_id) = requires_account_id { if (*requires_account_id) == (true) {
                                #[allow(unused_variables)]
if let Some(account_id) = account_id { return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://");
#[allow(clippy::needless_borrow)]
out.push_str(&account_id);
out.push_str(".s3-control.dualstack.");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.dns_suffix());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build()); }
                            } }
                            }
                            }
if (*use_fips) == (false) {
                                if (*use_dual_stack) == (true) {
                                return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://s3-control.dualstack.");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.dns_suffix());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build());
                            }
                            }
if (*use_fips) == (false) {
                                if (*use_dual_stack) == (false) {
                                #[allow(unused_variables)]
if let Some(requires_account_id) = requires_account_id { if (*requires_account_id) == (true) {
                                #[allow(unused_variables)]
if let Some(account_id) = account_id { return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://");
#[allow(clippy::needless_borrow)]
out.push_str(&account_id);
out.push_str(".s3-control.");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.dns_suffix());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build()); }
                            } }
                            }
                            }
if (*use_fips) == (false) {
                                if (*use_dual_stack) == (false) {
                                return Ok(aws_smithy_types::endpoint::Endpoint::builder().url({ let mut out = String::new();
out.push_str("https://s3-control.");
#[allow(clippy::needless_borrow)]
out.push_str(&region);
out.push('.');
#[allow(clippy::needless_borrow)]
out.push_str(&partition_result.dns_suffix());
out })
.property("authSchemes", vec![aws_smithy_types::Document::from( {
    let mut out = std::collections::HashMap::<String, aws_smithy_types::Document>::new();
    out.insert("disableDoubleEncoding".to_string(), true.into());
    out.insert("name".to_string(), "sigv4"
    .to_string().into());
    out.insert("signingName".to_string(), "s3"
    .to_string().into());
    out.insert("signingRegion".to_string(), region.to_owned().into());
    out
}),])
.build());
                            }
                            }
#[allow(unreachable_code)]
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message(format!("No rules matched these parameters. This is a bug. {:?}", _params)));
                            }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Invalid region: region was not a valid DNS name."
.to_string())); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("A valid partition could not be determined"
.to_string())); }
return Err(aws_smithy_http::endpoint::ResolveEndpointError::message("Region must be set"
.to_string()));
                }

