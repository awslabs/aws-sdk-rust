// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `ApiAccess`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let apiaccess = unimplemented!();
/// match apiaccess {
///     ApiAccess::Disabled => { /* ... */ },
///     ApiAccess::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `apiaccess` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ApiAccess::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ApiAccess::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ApiAccess::NewFeature` is defined.
/// Specifically, when `apiaccess` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ApiAccess::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApiAccess {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ApiAccess {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => ApiAccess::Disabled,
            "ENABLED" => ApiAccess::Enabled,
            other => ApiAccess::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ApiAccess {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApiAccess::from(s))
    }
}
impl ApiAccess {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApiAccess::Disabled => "DISABLED",
            ApiAccess::Enabled => "ENABLED",
            ApiAccess::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for ApiAccess {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UserType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let usertype = unimplemented!();
/// match usertype {
///     UserType::AppUser => { /* ... */ },
///     UserType::SuperUser => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `usertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UserType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UserType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UserType::NewFeature` is defined.
/// Specifically, when `usertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UserType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UserType {
    #[allow(missing_docs)] // documentation missing in model
    AppUser,
    #[allow(missing_docs)] // documentation missing in model
    SuperUser,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UserType {
    fn from(s: &str) -> Self {
        match s {
            "APP_USER" => UserType::AppUser,
            "SUPER_USER" => UserType::SuperUser,
            other => UserType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UserType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UserType::from(s))
    }
}
impl UserType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UserType::AppUser => "APP_USER",
            UserType::SuperUser => "SUPER_USER",
            UserType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["APP_USER", "SUPER_USER"]
    }
}
impl AsRef<str> for UserType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ApplicationPermission`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let applicationpermission = unimplemented!();
/// match applicationpermission {
///     ApplicationPermission::AccessNotebooks => { /* ... */ },
///     ApplicationPermission::CreateDataset => { /* ... */ },
///     ApplicationPermission::GetTemporaryCredentials => { /* ... */ },
///     ApplicationPermission::ManageAttributeSets => { /* ... */ },
///     ApplicationPermission::ManageClusters => { /* ... */ },
///     ApplicationPermission::ManageUsersAndGroups => { /* ... */ },
///     ApplicationPermission::ViewAuditData => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `applicationpermission` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ApplicationPermission::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ApplicationPermission::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ApplicationPermission::NewFeature` is defined.
/// Specifically, when `applicationpermission` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ApplicationPermission::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationPermission {
    #[allow(missing_docs)] // documentation missing in model
    AccessNotebooks,
    #[allow(missing_docs)] // documentation missing in model
    CreateDataset,
    #[allow(missing_docs)] // documentation missing in model
    GetTemporaryCredentials,
    #[allow(missing_docs)] // documentation missing in model
    ManageAttributeSets,
    #[allow(missing_docs)] // documentation missing in model
    ManageClusters,
    #[allow(missing_docs)] // documentation missing in model
    ManageUsersAndGroups,
    #[allow(missing_docs)] // documentation missing in model
    ViewAuditData,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ApplicationPermission {
    fn from(s: &str) -> Self {
        match s {
            "AccessNotebooks" => ApplicationPermission::AccessNotebooks,
            "CreateDataset" => ApplicationPermission::CreateDataset,
            "GetTemporaryCredentials" => ApplicationPermission::GetTemporaryCredentials,
            "ManageAttributeSets" => ApplicationPermission::ManageAttributeSets,
            "ManageClusters" => ApplicationPermission::ManageClusters,
            "ManageUsersAndGroups" => ApplicationPermission::ManageUsersAndGroups,
            "ViewAuditData" => ApplicationPermission::ViewAuditData,
            other => {
                ApplicationPermission::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ApplicationPermission {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationPermission::from(s))
    }
}
impl ApplicationPermission {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationPermission::AccessNotebooks => "AccessNotebooks",
            ApplicationPermission::CreateDataset => "CreateDataset",
            ApplicationPermission::GetTemporaryCredentials => "GetTemporaryCredentials",
            ApplicationPermission::ManageAttributeSets => "ManageAttributeSets",
            ApplicationPermission::ManageClusters => "ManageClusters",
            ApplicationPermission::ManageUsersAndGroups => "ManageUsersAndGroups",
            ApplicationPermission::ViewAuditData => "ViewAuditData",
            ApplicationPermission::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "AccessNotebooks",
            "CreateDataset",
            "GetTemporaryCredentials",
            "ManageAttributeSets",
            "ManageClusters",
            "ManageUsersAndGroups",
            "ViewAuditData",
        ]
    }
}
impl AsRef<str> for ApplicationPermission {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A union of schema types.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaUnion {
    /// <p>The configuration for a schema on a tabular Dataset.</p>
    #[doc(hidden)]
    pub tabular_schema_config: std::option::Option<crate::model::SchemaDefinition>,
}
impl SchemaUnion {
    /// <p>The configuration for a schema on a tabular Dataset.</p>
    pub fn tabular_schema_config(&self) -> std::option::Option<&crate::model::SchemaDefinition> {
        self.tabular_schema_config.as_ref()
    }
}
/// See [`SchemaUnion`](crate::model::SchemaUnion).
pub mod schema_union {

    /// A builder for [`SchemaUnion`](crate::model::SchemaUnion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) tabular_schema_config: std::option::Option<crate::model::SchemaDefinition>,
    }
    impl Builder {
        /// <p>The configuration for a schema on a tabular Dataset.</p>
        pub fn tabular_schema_config(mut self, input: crate::model::SchemaDefinition) -> Self {
            self.tabular_schema_config = Some(input);
            self
        }
        /// <p>The configuration for a schema on a tabular Dataset.</p>
        pub fn set_tabular_schema_config(
            mut self,
            input: std::option::Option<crate::model::SchemaDefinition>,
        ) -> Self {
            self.tabular_schema_config = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaUnion`](crate::model::SchemaUnion).
        pub fn build(self) -> crate::model::SchemaUnion {
            crate::model::SchemaUnion {
                tabular_schema_config: self.tabular_schema_config,
            }
        }
    }
}
impl SchemaUnion {
    /// Creates a new builder-style object to manufacture [`SchemaUnion`](crate::model::SchemaUnion).
    pub fn builder() -> crate::model::schema_union::Builder {
        crate::model::schema_union::Builder::default()
    }
}

/// <p>Definition for a schema on a tabular Dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SchemaDefinition {
    /// <p>List of column definitions.</p>
    #[doc(hidden)]
    pub columns: std::option::Option<std::vec::Vec<crate::model::ColumnDefinition>>,
    /// <p>List of column names used for primary key.</p>
    #[doc(hidden)]
    pub primary_key_columns: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl SchemaDefinition {
    /// <p>List of column definitions.</p>
    pub fn columns(&self) -> std::option::Option<&[crate::model::ColumnDefinition]> {
        self.columns.as_deref()
    }
    /// <p>List of column names used for primary key.</p>
    pub fn primary_key_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.primary_key_columns.as_deref()
    }
}
/// See [`SchemaDefinition`](crate::model::SchemaDefinition).
pub mod schema_definition {

    /// A builder for [`SchemaDefinition`](crate::model::SchemaDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) columns: std::option::Option<std::vec::Vec<crate::model::ColumnDefinition>>,
        pub(crate) primary_key_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// Appends an item to `columns`.
        ///
        /// To override the contents of this collection use [`set_columns`](Self::set_columns).
        ///
        /// <p>List of column definitions.</p>
        pub fn columns(mut self, input: crate::model::ColumnDefinition) -> Self {
            let mut v = self.columns.unwrap_or_default();
            v.push(input);
            self.columns = Some(v);
            self
        }
        /// <p>List of column definitions.</p>
        pub fn set_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ColumnDefinition>>,
        ) -> Self {
            self.columns = input;
            self
        }
        /// Appends an item to `primary_key_columns`.
        ///
        /// To override the contents of this collection use [`set_primary_key_columns`](Self::set_primary_key_columns).
        ///
        /// <p>List of column names used for primary key.</p>
        pub fn primary_key_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.primary_key_columns.unwrap_or_default();
            v.push(input.into());
            self.primary_key_columns = Some(v);
            self
        }
        /// <p>List of column names used for primary key.</p>
        pub fn set_primary_key_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.primary_key_columns = input;
            self
        }
        /// Consumes the builder and constructs a [`SchemaDefinition`](crate::model::SchemaDefinition).
        pub fn build(self) -> crate::model::SchemaDefinition {
            crate::model::SchemaDefinition {
                columns: self.columns,
                primary_key_columns: self.primary_key_columns,
            }
        }
    }
}
impl SchemaDefinition {
    /// Creates a new builder-style object to manufacture [`SchemaDefinition`](crate::model::SchemaDefinition).
    pub fn builder() -> crate::model::schema_definition::Builder {
        crate::model::schema_definition::Builder::default()
    }
}

/// <p>The definition of a column in a tabular Dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ColumnDefinition {
    /// <p>Data type of a column.</p>
    /// <ul>
    /// <li> <p> <code>STRING</code> – A String data type.</p> <p> <code>CHAR</code> – A char data type.</p> <p> <code>INTEGER</code> – An integer data type.</p> <p> <code>TINYINT</code> – A tinyint data type.</p> <p> <code>SMALLINT</code> – A smallint data type.</p> <p> <code>BIGINT</code> – A bigint data type.</p> <p> <code>FLOAT</code> – A float data type.</p> <p> <code>DOUBLE</code> – A double data type.</p> <p> <code>DATE</code> – A date data type.</p> <p> <code>DATETIME</code> – A datetime data type.</p> <p> <code>BOOLEAN</code> – A boolean data type.</p> <p> <code>BINARY</code> – A binary data type.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub data_type: std::option::Option<crate::model::ColumnDataType>,
    /// <p>The name of a column.</p>
    #[doc(hidden)]
    pub column_name: std::option::Option<std::string::String>,
    /// <p>Description for a column.</p>
    #[doc(hidden)]
    pub column_description: std::option::Option<std::string::String>,
}
impl ColumnDefinition {
    /// <p>Data type of a column.</p>
    /// <ul>
    /// <li> <p> <code>STRING</code> – A String data type.</p> <p> <code>CHAR</code> – A char data type.</p> <p> <code>INTEGER</code> – An integer data type.</p> <p> <code>TINYINT</code> – A tinyint data type.</p> <p> <code>SMALLINT</code> – A smallint data type.</p> <p> <code>BIGINT</code> – A bigint data type.</p> <p> <code>FLOAT</code> – A float data type.</p> <p> <code>DOUBLE</code> – A double data type.</p> <p> <code>DATE</code> – A date data type.</p> <p> <code>DATETIME</code> – A datetime data type.</p> <p> <code>BOOLEAN</code> – A boolean data type.</p> <p> <code>BINARY</code> – A binary data type.</p> </li>
    /// </ul>
    pub fn data_type(&self) -> std::option::Option<&crate::model::ColumnDataType> {
        self.data_type.as_ref()
    }
    /// <p>The name of a column.</p>
    pub fn column_name(&self) -> std::option::Option<&str> {
        self.column_name.as_deref()
    }
    /// <p>Description for a column.</p>
    pub fn column_description(&self) -> std::option::Option<&str> {
        self.column_description.as_deref()
    }
}
/// See [`ColumnDefinition`](crate::model::ColumnDefinition).
pub mod column_definition {

    /// A builder for [`ColumnDefinition`](crate::model::ColumnDefinition).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_type: std::option::Option<crate::model::ColumnDataType>,
        pub(crate) column_name: std::option::Option<std::string::String>,
        pub(crate) column_description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Data type of a column.</p>
        /// <ul>
        /// <li> <p> <code>STRING</code> – A String data type.</p> <p> <code>CHAR</code> – A char data type.</p> <p> <code>INTEGER</code> – An integer data type.</p> <p> <code>TINYINT</code> – A tinyint data type.</p> <p> <code>SMALLINT</code> – A smallint data type.</p> <p> <code>BIGINT</code> – A bigint data type.</p> <p> <code>FLOAT</code> – A float data type.</p> <p> <code>DOUBLE</code> – A double data type.</p> <p> <code>DATE</code> – A date data type.</p> <p> <code>DATETIME</code> – A datetime data type.</p> <p> <code>BOOLEAN</code> – A boolean data type.</p> <p> <code>BINARY</code> – A binary data type.</p> </li>
        /// </ul>
        pub fn data_type(mut self, input: crate::model::ColumnDataType) -> Self {
            self.data_type = Some(input);
            self
        }
        /// <p>Data type of a column.</p>
        /// <ul>
        /// <li> <p> <code>STRING</code> – A String data type.</p> <p> <code>CHAR</code> – A char data type.</p> <p> <code>INTEGER</code> – An integer data type.</p> <p> <code>TINYINT</code> – A tinyint data type.</p> <p> <code>SMALLINT</code> – A smallint data type.</p> <p> <code>BIGINT</code> – A bigint data type.</p> <p> <code>FLOAT</code> – A float data type.</p> <p> <code>DOUBLE</code> – A double data type.</p> <p> <code>DATE</code> – A date data type.</p> <p> <code>DATETIME</code> – A datetime data type.</p> <p> <code>BOOLEAN</code> – A boolean data type.</p> <p> <code>BINARY</code> – A binary data type.</p> </li>
        /// </ul>
        pub fn set_data_type(
            mut self,
            input: std::option::Option<crate::model::ColumnDataType>,
        ) -> Self {
            self.data_type = input;
            self
        }
        /// <p>The name of a column.</p>
        pub fn column_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_name = Some(input.into());
            self
        }
        /// <p>The name of a column.</p>
        pub fn set_column_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.column_name = input;
            self
        }
        /// <p>Description for a column.</p>
        pub fn column_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.column_description = Some(input.into());
            self
        }
        /// <p>Description for a column.</p>
        pub fn set_column_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.column_description = input;
            self
        }
        /// Consumes the builder and constructs a [`ColumnDefinition`](crate::model::ColumnDefinition).
        pub fn build(self) -> crate::model::ColumnDefinition {
            crate::model::ColumnDefinition {
                data_type: self.data_type,
                column_name: self.column_name,
                column_description: self.column_description,
            }
        }
    }
}
impl ColumnDefinition {
    /// Creates a new builder-style object to manufacture [`ColumnDefinition`](crate::model::ColumnDefinition).
    pub fn builder() -> crate::model::column_definition::Builder {
        crate::model::column_definition::Builder::default()
    }
}

/// When writing a match expression against `ColumnDataType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let columndatatype = unimplemented!();
/// match columndatatype {
///     ColumnDataType::Bigint => { /* ... */ },
///     ColumnDataType::Binary => { /* ... */ },
///     ColumnDataType::Boolean => { /* ... */ },
///     ColumnDataType::Char => { /* ... */ },
///     ColumnDataType::Date => { /* ... */ },
///     ColumnDataType::Datetime => { /* ... */ },
///     ColumnDataType::Double => { /* ... */ },
///     ColumnDataType::Float => { /* ... */ },
///     ColumnDataType::Integer => { /* ... */ },
///     ColumnDataType::Smallint => { /* ... */ },
///     ColumnDataType::String => { /* ... */ },
///     ColumnDataType::Tinyint => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `columndatatype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ColumnDataType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ColumnDataType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ColumnDataType::NewFeature` is defined.
/// Specifically, when `columndatatype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ColumnDataType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Data type of a column.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ColumnDataType {
    #[allow(missing_docs)] // documentation missing in model
    Bigint,
    #[allow(missing_docs)] // documentation missing in model
    Binary,
    #[allow(missing_docs)] // documentation missing in model
    Boolean,
    #[allow(missing_docs)] // documentation missing in model
    Char,
    #[allow(missing_docs)] // documentation missing in model
    Date,
    #[allow(missing_docs)] // documentation missing in model
    Datetime,
    #[allow(missing_docs)] // documentation missing in model
    Double,
    #[allow(missing_docs)] // documentation missing in model
    Float,
    #[allow(missing_docs)] // documentation missing in model
    Integer,
    #[allow(missing_docs)] // documentation missing in model
    Smallint,
    #[allow(missing_docs)] // documentation missing in model
    String,
    #[allow(missing_docs)] // documentation missing in model
    Tinyint,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ColumnDataType {
    fn from(s: &str) -> Self {
        match s {
            "BIGINT" => ColumnDataType::Bigint,
            "BINARY" => ColumnDataType::Binary,
            "BOOLEAN" => ColumnDataType::Boolean,
            "CHAR" => ColumnDataType::Char,
            "DATE" => ColumnDataType::Date,
            "DATETIME" => ColumnDataType::Datetime,
            "DOUBLE" => ColumnDataType::Double,
            "FLOAT" => ColumnDataType::Float,
            "INTEGER" => ColumnDataType::Integer,
            "SMALLINT" => ColumnDataType::Smallint,
            "STRING" => ColumnDataType::String,
            "TINYINT" => ColumnDataType::Tinyint,
            other => ColumnDataType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ColumnDataType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ColumnDataType::from(s))
    }
}
impl ColumnDataType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ColumnDataType::Bigint => "BIGINT",
            ColumnDataType::Binary => "BINARY",
            ColumnDataType::Boolean => "BOOLEAN",
            ColumnDataType::Char => "CHAR",
            ColumnDataType::Date => "DATE",
            ColumnDataType::Datetime => "DATETIME",
            ColumnDataType::Double => "DOUBLE",
            ColumnDataType::Float => "FLOAT",
            ColumnDataType::Integer => "INTEGER",
            ColumnDataType::Smallint => "SMALLINT",
            ColumnDataType::String => "STRING",
            ColumnDataType::Tinyint => "TINYINT",
            ColumnDataType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BIGINT", "BINARY", "BOOLEAN", "CHAR", "DATE", "DATETIME", "DOUBLE", "FLOAT",
            "INTEGER", "SMALLINT", "STRING", "TINYINT",
        ]
    }
}
impl AsRef<str> for ColumnDataType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DatasetKind`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasetkind = unimplemented!();
/// match datasetkind {
///     DatasetKind::NonTabular => { /* ... */ },
///     DatasetKind::Tabular => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasetkind` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DatasetKind::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DatasetKind::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DatasetKind::NewFeature` is defined.
/// Specifically, when `datasetkind` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DatasetKind::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Dataset Kind
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DatasetKind {
    #[allow(missing_docs)] // documentation missing in model
    NonTabular,
    #[allow(missing_docs)] // documentation missing in model
    Tabular,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DatasetKind {
    fn from(s: &str) -> Self {
        match s {
            "NON_TABULAR" => DatasetKind::NonTabular,
            "TABULAR" => DatasetKind::Tabular,
            other => DatasetKind::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DatasetKind {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DatasetKind::from(s))
    }
}
impl DatasetKind {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DatasetKind::NonTabular => "NON_TABULAR",
            DatasetKind::Tabular => "TABULAR",
            DatasetKind::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NON_TABULAR", "TABULAR"]
    }
}
impl AsRef<str> for DatasetKind {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The structure of a user account associated with a permission group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UserByPermissionGroup {
    /// <p>The unique identifier for the user.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The current status of the user account. </p>
    /// <ul>
    /// <li> <p> <code>CREATING</code> – The user account creation is in progress.</p> </li>
    /// <li> <p> <code>ENABLED</code> – The user account is created and is currently active.</p> </li>
    /// <li> <p> <code>DISABLED</code> – The user account is currently inactive.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::UserStatus>,
    /// <p>The first name of the user.</p>
    #[doc(hidden)]
    pub first_name: std::option::Option<std::string::String>,
    /// <p>The last name of the user.</p>
    #[doc(hidden)]
    pub last_name: std::option::Option<std::string::String>,
    /// <p>The email address of the user. The email address serves as a unique identifier for each user and cannot be changed after it's created.</p>
    #[doc(hidden)]
    pub email_address: std::option::Option<std::string::String>,
    /// <p> Indicates the type of user.</p>
    /// <ul>
    /// <li> <p> <code>SUPER_USER</code> – A user with permission to all the functionality and data in FinSpace.</p> </li>
    /// <li> <p> <code>APP_USER</code> – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::UserType>,
    /// <p>Indicates whether the user can access FinSpace API operations.</p>
    /// <ul>
    /// <li> <p> <code>ENABLED</code> – The user has permissions to use the API operations.</p> </li>
    /// <li> <p> <code>DISABLED</code> – The user does not have permissions to use any API operations.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub api_access: std::option::Option<crate::model::ApiAccess>,
    /// <p>The IAM ARN identifier that is attached to FinSpace API calls.</p>
    #[doc(hidden)]
    pub api_access_principal_arn: std::option::Option<std::string::String>,
    /// <p>Indicates the status of the user account within a permission group.</p>
    /// <ul>
    /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
    /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
    /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub membership_status: std::option::Option<crate::model::PermissionGroupMembershipStatus>,
}
impl UserByPermissionGroup {
    /// <p>The unique identifier for the user.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The current status of the user account. </p>
    /// <ul>
    /// <li> <p> <code>CREATING</code> – The user account creation is in progress.</p> </li>
    /// <li> <p> <code>ENABLED</code> – The user account is created and is currently active.</p> </li>
    /// <li> <p> <code>DISABLED</code> – The user account is currently inactive.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::UserStatus> {
        self.status.as_ref()
    }
    /// <p>The first name of the user.</p>
    pub fn first_name(&self) -> std::option::Option<&str> {
        self.first_name.as_deref()
    }
    /// <p>The last name of the user.</p>
    pub fn last_name(&self) -> std::option::Option<&str> {
        self.last_name.as_deref()
    }
    /// <p>The email address of the user. The email address serves as a unique identifier for each user and cannot be changed after it's created.</p>
    pub fn email_address(&self) -> std::option::Option<&str> {
        self.email_address.as_deref()
    }
    /// <p> Indicates the type of user.</p>
    /// <ul>
    /// <li> <p> <code>SUPER_USER</code> – A user with permission to all the functionality and data in FinSpace.</p> </li>
    /// <li> <p> <code>APP_USER</code> – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::UserType> {
        self.r#type.as_ref()
    }
    /// <p>Indicates whether the user can access FinSpace API operations.</p>
    /// <ul>
    /// <li> <p> <code>ENABLED</code> – The user has permissions to use the API operations.</p> </li>
    /// <li> <p> <code>DISABLED</code> – The user does not have permissions to use any API operations.</p> </li>
    /// </ul>
    pub fn api_access(&self) -> std::option::Option<&crate::model::ApiAccess> {
        self.api_access.as_ref()
    }
    /// <p>The IAM ARN identifier that is attached to FinSpace API calls.</p>
    pub fn api_access_principal_arn(&self) -> std::option::Option<&str> {
        self.api_access_principal_arn.as_deref()
    }
    /// <p>Indicates the status of the user account within a permission group.</p>
    /// <ul>
    /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
    /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
    /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
    /// </ul>
    pub fn membership_status(
        &self,
    ) -> std::option::Option<&crate::model::PermissionGroupMembershipStatus> {
        self.membership_status.as_ref()
    }
}
impl std::fmt::Debug for UserByPermissionGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UserByPermissionGroup");
        formatter.field("user_id", &self.user_id);
        formatter.field("status", &self.status);
        formatter.field("first_name", &"*** Sensitive Data Redacted ***");
        formatter.field("last_name", &"*** Sensitive Data Redacted ***");
        formatter.field("email_address", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &self.r#type);
        formatter.field("api_access", &self.api_access);
        formatter.field("api_access_principal_arn", &self.api_access_principal_arn);
        formatter.field("membership_status", &self.membership_status);
        formatter.finish()
    }
}
/// See [`UserByPermissionGroup`](crate::model::UserByPermissionGroup).
pub mod user_by_permission_group {

    /// A builder for [`UserByPermissionGroup`](crate::model::UserByPermissionGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::UserStatus>,
        pub(crate) first_name: std::option::Option<std::string::String>,
        pub(crate) last_name: std::option::Option<std::string::String>,
        pub(crate) email_address: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::UserType>,
        pub(crate) api_access: std::option::Option<crate::model::ApiAccess>,
        pub(crate) api_access_principal_arn: std::option::Option<std::string::String>,
        pub(crate) membership_status:
            std::option::Option<crate::model::PermissionGroupMembershipStatus>,
    }
    impl Builder {
        /// <p>The unique identifier for the user.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the user.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The current status of the user account. </p>
        /// <ul>
        /// <li> <p> <code>CREATING</code> – The user account creation is in progress.</p> </li>
        /// <li> <p> <code>ENABLED</code> – The user account is created and is currently active.</p> </li>
        /// <li> <p> <code>DISABLED</code> – The user account is currently inactive.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::UserStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the user account. </p>
        /// <ul>
        /// <li> <p> <code>CREATING</code> – The user account creation is in progress.</p> </li>
        /// <li> <p> <code>ENABLED</code> – The user account is created and is currently active.</p> </li>
        /// <li> <p> <code>DISABLED</code> – The user account is currently inactive.</p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<crate::model::UserStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The first name of the user.</p>
        pub fn first_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_name = Some(input.into());
            self
        }
        /// <p>The first name of the user.</p>
        pub fn set_first_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.first_name = input;
            self
        }
        /// <p>The last name of the user.</p>
        pub fn last_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_name = Some(input.into());
            self
        }
        /// <p>The last name of the user.</p>
        pub fn set_last_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_name = input;
            self
        }
        /// <p>The email address of the user. The email address serves as a unique identifier for each user and cannot be changed after it's created.</p>
        pub fn email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.email_address = Some(input.into());
            self
        }
        /// <p>The email address of the user. The email address serves as a unique identifier for each user and cannot be changed after it's created.</p>
        pub fn set_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.email_address = input;
            self
        }
        /// <p> Indicates the type of user.</p>
        /// <ul>
        /// <li> <p> <code>SUPER_USER</code> – A user with permission to all the functionality and data in FinSpace.</p> </li>
        /// <li> <p> <code>APP_USER</code> – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::UserType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p> Indicates the type of user.</p>
        /// <ul>
        /// <li> <p> <code>SUPER_USER</code> – A user with permission to all the functionality and data in FinSpace.</p> </li>
        /// <li> <p> <code>APP_USER</code> – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.</p> </li>
        /// </ul>
        pub fn set_type(mut self, input: std::option::Option<crate::model::UserType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Indicates whether the user can access FinSpace API operations.</p>
        /// <ul>
        /// <li> <p> <code>ENABLED</code> – The user has permissions to use the API operations.</p> </li>
        /// <li> <p> <code>DISABLED</code> – The user does not have permissions to use any API operations.</p> </li>
        /// </ul>
        pub fn api_access(mut self, input: crate::model::ApiAccess) -> Self {
            self.api_access = Some(input);
            self
        }
        /// <p>Indicates whether the user can access FinSpace API operations.</p>
        /// <ul>
        /// <li> <p> <code>ENABLED</code> – The user has permissions to use the API operations.</p> </li>
        /// <li> <p> <code>DISABLED</code> – The user does not have permissions to use any API operations.</p> </li>
        /// </ul>
        pub fn set_api_access(
            mut self,
            input: std::option::Option<crate::model::ApiAccess>,
        ) -> Self {
            self.api_access = input;
            self
        }
        /// <p>The IAM ARN identifier that is attached to FinSpace API calls.</p>
        pub fn api_access_principal_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.api_access_principal_arn = Some(input.into());
            self
        }
        /// <p>The IAM ARN identifier that is attached to FinSpace API calls.</p>
        pub fn set_api_access_principal_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.api_access_principal_arn = input;
            self
        }
        /// <p>Indicates the status of the user account within a permission group.</p>
        /// <ul>
        /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
        /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
        /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
        /// </ul>
        pub fn membership_status(
            mut self,
            input: crate::model::PermissionGroupMembershipStatus,
        ) -> Self {
            self.membership_status = Some(input);
            self
        }
        /// <p>Indicates the status of the user account within a permission group.</p>
        /// <ul>
        /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
        /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
        /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
        /// </ul>
        pub fn set_membership_status(
            mut self,
            input: std::option::Option<crate::model::PermissionGroupMembershipStatus>,
        ) -> Self {
            self.membership_status = input;
            self
        }
        /// Consumes the builder and constructs a [`UserByPermissionGroup`](crate::model::UserByPermissionGroup).
        pub fn build(self) -> crate::model::UserByPermissionGroup {
            crate::model::UserByPermissionGroup {
                user_id: self.user_id,
                status: self.status,
                first_name: self.first_name,
                last_name: self.last_name,
                email_address: self.email_address,
                r#type: self.r#type,
                api_access: self.api_access,
                api_access_principal_arn: self.api_access_principal_arn,
                membership_status: self.membership_status,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("user_id", &self.user_id);
            formatter.field("status", &self.status);
            formatter.field("first_name", &"*** Sensitive Data Redacted ***");
            formatter.field("last_name", &"*** Sensitive Data Redacted ***");
            formatter.field("email_address", &"*** Sensitive Data Redacted ***");
            formatter.field("r#type", &self.r#type);
            formatter.field("api_access", &self.api_access);
            formatter.field("api_access_principal_arn", &self.api_access_principal_arn);
            formatter.field("membership_status", &self.membership_status);
            formatter.finish()
        }
    }
}
impl UserByPermissionGroup {
    /// Creates a new builder-style object to manufacture [`UserByPermissionGroup`](crate::model::UserByPermissionGroup).
    pub fn builder() -> crate::model::user_by_permission_group::Builder {
        crate::model::user_by_permission_group::Builder::default()
    }
}

/// When writing a match expression against `PermissionGroupMembershipStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let permissiongroupmembershipstatus = unimplemented!();
/// match permissiongroupmembershipstatus {
///     PermissionGroupMembershipStatus::AdditionInProgress => { /* ... */ },
///     PermissionGroupMembershipStatus::AdditionSuccess => { /* ... */ },
///     PermissionGroupMembershipStatus::RemovalInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `permissiongroupmembershipstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PermissionGroupMembershipStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PermissionGroupMembershipStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PermissionGroupMembershipStatus::NewFeature` is defined.
/// Specifically, when `permissiongroupmembershipstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PermissionGroupMembershipStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PermissionGroupMembershipStatus {
    #[allow(missing_docs)] // documentation missing in model
    AdditionInProgress,
    #[allow(missing_docs)] // documentation missing in model
    AdditionSuccess,
    #[allow(missing_docs)] // documentation missing in model
    RemovalInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PermissionGroupMembershipStatus {
    fn from(s: &str) -> Self {
        match s {
            "ADDITION_IN_PROGRESS" => PermissionGroupMembershipStatus::AdditionInProgress,
            "ADDITION_SUCCESS" => PermissionGroupMembershipStatus::AdditionSuccess,
            "REMOVAL_IN_PROGRESS" => PermissionGroupMembershipStatus::RemovalInProgress,
            other => PermissionGroupMembershipStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PermissionGroupMembershipStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PermissionGroupMembershipStatus::from(s))
    }
}
impl PermissionGroupMembershipStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PermissionGroupMembershipStatus::AdditionInProgress => "ADDITION_IN_PROGRESS",
            PermissionGroupMembershipStatus::AdditionSuccess => "ADDITION_SUCCESS",
            PermissionGroupMembershipStatus::RemovalInProgress => "REMOVAL_IN_PROGRESS",
            PermissionGroupMembershipStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ADDITION_IN_PROGRESS",
            "ADDITION_SUCCESS",
            "REMOVAL_IN_PROGRESS",
        ]
    }
}
impl AsRef<str> for PermissionGroupMembershipStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `UserStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let userstatus = unimplemented!();
/// match userstatus {
///     UserStatus::Creating => { /* ... */ },
///     UserStatus::Disabled => { /* ... */ },
///     UserStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `userstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `UserStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `UserStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `UserStatus::NewFeature` is defined.
/// Specifically, when `userstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `UserStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum UserStatus {
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for UserStatus {
    fn from(s: &str) -> Self {
        match s {
            "CREATING" => UserStatus::Creating,
            "DISABLED" => UserStatus::Disabled,
            "ENABLED" => UserStatus::Enabled,
            other => UserStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for UserStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(UserStatus::from(s))
    }
}
impl UserStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            UserStatus::Creating => "CREATING",
            UserStatus::Disabled => "DISABLED",
            UserStatus::Enabled => "ENABLED",
            UserStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATING", "DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for UserStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The details of the user account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct User {
    /// <p>The unique identifier for the user.</p>
    #[doc(hidden)]
    pub user_id: std::option::Option<std::string::String>,
    /// <p>The current status of the user account. </p>
    /// <ul>
    /// <li> <p> <code>CREATING</code> – The user account creation is in progress.</p> </li>
    /// <li> <p> <code>ENABLED</code> – The user account is created and is currently active.</p> </li>
    /// <li> <p> <code>DISABLED</code> – The user account is currently inactive.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::UserStatus>,
    /// <p>The first name of the user.</p>
    #[doc(hidden)]
    pub first_name: std::option::Option<std::string::String>,
    /// <p> The last name of the user.</p>
    #[doc(hidden)]
    pub last_name: std::option::Option<std::string::String>,
    /// <p>The email address of the user. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.</p>
    #[doc(hidden)]
    pub email_address: std::option::Option<std::string::String>,
    /// <p> Indicates the type of user.</p>
    /// <ul>
    /// <li> <p> <code>SUPER_USER</code> – A user with permission to all the functionality and data in FinSpace.</p> </li>
    /// <li> <p> <code>APP_USER</code> – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::UserType>,
    /// <p>Indicates whether the user can use the <code>GetProgrammaticAccessCredentials</code> API to obtain credentials that can then be used to access other FinSpace Data API operations.</p>
    /// <ul>
    /// <li> <p> <code>ENABLED</code> – The user has permissions to use the APIs.</p> </li>
    /// <li> <p> <code>DISABLED</code> – The user does not have permissions to use any APIs.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub api_access: std::option::Option<crate::model::ApiAccess>,
    /// <p>The ARN identifier of an AWS user or role that is allowed to call the <code>GetProgrammaticAccessCredentials</code> API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.</p>
    #[doc(hidden)]
    pub api_access_principal_arn: std::option::Option<std::string::String>,
    /// <p>The timestamp at which the user account was created in FinSpace. The value is determined as epoch time in milliseconds. </p>
    #[doc(hidden)]
    pub create_time: i64,
    /// <p> Describes the last time the user account was enabled. The value is determined as epoch time in milliseconds. </p>
    #[doc(hidden)]
    pub last_enabled_time: i64,
    /// <p>Describes the last time the user account was disabled. The value is determined as epoch time in milliseconds.</p>
    #[doc(hidden)]
    pub last_disabled_time: i64,
    /// <p>Describes the last time the user account was updated. The value is determined as epoch time in milliseconds. </p>
    #[doc(hidden)]
    pub last_modified_time: i64,
    /// <p>Describes the last time that the user logged into their account. The value is determined as epoch time in milliseconds. </p>
    #[doc(hidden)]
    pub last_login_time: i64,
}
impl User {
    /// <p>The unique identifier for the user.</p>
    pub fn user_id(&self) -> std::option::Option<&str> {
        self.user_id.as_deref()
    }
    /// <p>The current status of the user account. </p>
    /// <ul>
    /// <li> <p> <code>CREATING</code> – The user account creation is in progress.</p> </li>
    /// <li> <p> <code>ENABLED</code> – The user account is created and is currently active.</p> </li>
    /// <li> <p> <code>DISABLED</code> – The user account is currently inactive.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::UserStatus> {
        self.status.as_ref()
    }
    /// <p>The first name of the user.</p>
    pub fn first_name(&self) -> std::option::Option<&str> {
        self.first_name.as_deref()
    }
    /// <p> The last name of the user.</p>
    pub fn last_name(&self) -> std::option::Option<&str> {
        self.last_name.as_deref()
    }
    /// <p>The email address of the user. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.</p>
    pub fn email_address(&self) -> std::option::Option<&str> {
        self.email_address.as_deref()
    }
    /// <p> Indicates the type of user.</p>
    /// <ul>
    /// <li> <p> <code>SUPER_USER</code> – A user with permission to all the functionality and data in FinSpace.</p> </li>
    /// <li> <p> <code>APP_USER</code> – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.</p> </li>
    /// </ul>
    pub fn r#type(&self) -> std::option::Option<&crate::model::UserType> {
        self.r#type.as_ref()
    }
    /// <p>Indicates whether the user can use the <code>GetProgrammaticAccessCredentials</code> API to obtain credentials that can then be used to access other FinSpace Data API operations.</p>
    /// <ul>
    /// <li> <p> <code>ENABLED</code> – The user has permissions to use the APIs.</p> </li>
    /// <li> <p> <code>DISABLED</code> – The user does not have permissions to use any APIs.</p> </li>
    /// </ul>
    pub fn api_access(&self) -> std::option::Option<&crate::model::ApiAccess> {
        self.api_access.as_ref()
    }
    /// <p>The ARN identifier of an AWS user or role that is allowed to call the <code>GetProgrammaticAccessCredentials</code> API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.</p>
    pub fn api_access_principal_arn(&self) -> std::option::Option<&str> {
        self.api_access_principal_arn.as_deref()
    }
    /// <p>The timestamp at which the user account was created in FinSpace. The value is determined as epoch time in milliseconds. </p>
    pub fn create_time(&self) -> i64 {
        self.create_time
    }
    /// <p> Describes the last time the user account was enabled. The value is determined as epoch time in milliseconds. </p>
    pub fn last_enabled_time(&self) -> i64 {
        self.last_enabled_time
    }
    /// <p>Describes the last time the user account was disabled. The value is determined as epoch time in milliseconds.</p>
    pub fn last_disabled_time(&self) -> i64 {
        self.last_disabled_time
    }
    /// <p>Describes the last time the user account was updated. The value is determined as epoch time in milliseconds. </p>
    pub fn last_modified_time(&self) -> i64 {
        self.last_modified_time
    }
    /// <p>Describes the last time that the user logged into their account. The value is determined as epoch time in milliseconds. </p>
    pub fn last_login_time(&self) -> i64 {
        self.last_login_time
    }
}
impl std::fmt::Debug for User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("User");
        formatter.field("user_id", &self.user_id);
        formatter.field("status", &self.status);
        formatter.field("first_name", &"*** Sensitive Data Redacted ***");
        formatter.field("last_name", &"*** Sensitive Data Redacted ***");
        formatter.field("email_address", &"*** Sensitive Data Redacted ***");
        formatter.field("r#type", &self.r#type);
        formatter.field("api_access", &self.api_access);
        formatter.field("api_access_principal_arn", &self.api_access_principal_arn);
        formatter.field("create_time", &self.create_time);
        formatter.field("last_enabled_time", &self.last_enabled_time);
        formatter.field("last_disabled_time", &self.last_disabled_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("last_login_time", &self.last_login_time);
        formatter.finish()
    }
}
/// See [`User`](crate::model::User).
pub mod user {

    /// A builder for [`User`](crate::model::User).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) user_id: std::option::Option<std::string::String>,
        pub(crate) status: std::option::Option<crate::model::UserStatus>,
        pub(crate) first_name: std::option::Option<std::string::String>,
        pub(crate) last_name: std::option::Option<std::string::String>,
        pub(crate) email_address: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::UserType>,
        pub(crate) api_access: std::option::Option<crate::model::ApiAccess>,
        pub(crate) api_access_principal_arn: std::option::Option<std::string::String>,
        pub(crate) create_time: std::option::Option<i64>,
        pub(crate) last_enabled_time: std::option::Option<i64>,
        pub(crate) last_disabled_time: std::option::Option<i64>,
        pub(crate) last_modified_time: std::option::Option<i64>,
        pub(crate) last_login_time: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The unique identifier for the user.</p>
        pub fn user_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the user.</p>
        pub fn set_user_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_id = input;
            self
        }
        /// <p>The current status of the user account. </p>
        /// <ul>
        /// <li> <p> <code>CREATING</code> – The user account creation is in progress.</p> </li>
        /// <li> <p> <code>ENABLED</code> – The user account is created and is currently active.</p> </li>
        /// <li> <p> <code>DISABLED</code> – The user account is currently inactive.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::UserStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The current status of the user account. </p>
        /// <ul>
        /// <li> <p> <code>CREATING</code> – The user account creation is in progress.</p> </li>
        /// <li> <p> <code>ENABLED</code> – The user account is created and is currently active.</p> </li>
        /// <li> <p> <code>DISABLED</code> – The user account is currently inactive.</p> </li>
        /// </ul>
        pub fn set_status(mut self, input: std::option::Option<crate::model::UserStatus>) -> Self {
            self.status = input;
            self
        }
        /// <p>The first name of the user.</p>
        pub fn first_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.first_name = Some(input.into());
            self
        }
        /// <p>The first name of the user.</p>
        pub fn set_first_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.first_name = input;
            self
        }
        /// <p> The last name of the user.</p>
        pub fn last_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_name = Some(input.into());
            self
        }
        /// <p> The last name of the user.</p>
        pub fn set_last_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.last_name = input;
            self
        }
        /// <p>The email address of the user. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.</p>
        pub fn email_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.email_address = Some(input.into());
            self
        }
        /// <p>The email address of the user. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.</p>
        pub fn set_email_address(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.email_address = input;
            self
        }
        /// <p> Indicates the type of user.</p>
        /// <ul>
        /// <li> <p> <code>SUPER_USER</code> – A user with permission to all the functionality and data in FinSpace.</p> </li>
        /// <li> <p> <code>APP_USER</code> – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.</p> </li>
        /// </ul>
        pub fn r#type(mut self, input: crate::model::UserType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p> Indicates the type of user.</p>
        /// <ul>
        /// <li> <p> <code>SUPER_USER</code> – A user with permission to all the functionality and data in FinSpace.</p> </li>
        /// <li> <p> <code>APP_USER</code> – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.</p> </li>
        /// </ul>
        pub fn set_type(mut self, input: std::option::Option<crate::model::UserType>) -> Self {
            self.r#type = input;
            self
        }
        /// <p>Indicates whether the user can use the <code>GetProgrammaticAccessCredentials</code> API to obtain credentials that can then be used to access other FinSpace Data API operations.</p>
        /// <ul>
        /// <li> <p> <code>ENABLED</code> – The user has permissions to use the APIs.</p> </li>
        /// <li> <p> <code>DISABLED</code> – The user does not have permissions to use any APIs.</p> </li>
        /// </ul>
        pub fn api_access(mut self, input: crate::model::ApiAccess) -> Self {
            self.api_access = Some(input);
            self
        }
        /// <p>Indicates whether the user can use the <code>GetProgrammaticAccessCredentials</code> API to obtain credentials that can then be used to access other FinSpace Data API operations.</p>
        /// <ul>
        /// <li> <p> <code>ENABLED</code> – The user has permissions to use the APIs.</p> </li>
        /// <li> <p> <code>DISABLED</code> – The user does not have permissions to use any APIs.</p> </li>
        /// </ul>
        pub fn set_api_access(
            mut self,
            input: std::option::Option<crate::model::ApiAccess>,
        ) -> Self {
            self.api_access = input;
            self
        }
        /// <p>The ARN identifier of an AWS user or role that is allowed to call the <code>GetProgrammaticAccessCredentials</code> API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.</p>
        pub fn api_access_principal_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.api_access_principal_arn = Some(input.into());
            self
        }
        /// <p>The ARN identifier of an AWS user or role that is allowed to call the <code>GetProgrammaticAccessCredentials</code> API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.</p>
        pub fn set_api_access_principal_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.api_access_principal_arn = input;
            self
        }
        /// <p>The timestamp at which the user account was created in FinSpace. The value is determined as epoch time in milliseconds. </p>
        pub fn create_time(mut self, input: i64) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The timestamp at which the user account was created in FinSpace. The value is determined as epoch time in milliseconds. </p>
        pub fn set_create_time(mut self, input: std::option::Option<i64>) -> Self {
            self.create_time = input;
            self
        }
        /// <p> Describes the last time the user account was enabled. The value is determined as epoch time in milliseconds. </p>
        pub fn last_enabled_time(mut self, input: i64) -> Self {
            self.last_enabled_time = Some(input);
            self
        }
        /// <p> Describes the last time the user account was enabled. The value is determined as epoch time in milliseconds. </p>
        pub fn set_last_enabled_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_enabled_time = input;
            self
        }
        /// <p>Describes the last time the user account was disabled. The value is determined as epoch time in milliseconds.</p>
        pub fn last_disabled_time(mut self, input: i64) -> Self {
            self.last_disabled_time = Some(input);
            self
        }
        /// <p>Describes the last time the user account was disabled. The value is determined as epoch time in milliseconds.</p>
        pub fn set_last_disabled_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_disabled_time = input;
            self
        }
        /// <p>Describes the last time the user account was updated. The value is determined as epoch time in milliseconds. </p>
        pub fn last_modified_time(mut self, input: i64) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>Describes the last time the user account was updated. The value is determined as epoch time in milliseconds. </p>
        pub fn set_last_modified_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Describes the last time that the user logged into their account. The value is determined as epoch time in milliseconds. </p>
        pub fn last_login_time(mut self, input: i64) -> Self {
            self.last_login_time = Some(input);
            self
        }
        /// <p>Describes the last time that the user logged into their account. The value is determined as epoch time in milliseconds. </p>
        pub fn set_last_login_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_login_time = input;
            self
        }
        /// Consumes the builder and constructs a [`User`](crate::model::User).
        pub fn build(self) -> crate::model::User {
            crate::model::User {
                user_id: self.user_id,
                status: self.status,
                first_name: self.first_name,
                last_name: self.last_name,
                email_address: self.email_address,
                r#type: self.r#type,
                api_access: self.api_access,
                api_access_principal_arn: self.api_access_principal_arn,
                create_time: self.create_time.unwrap_or_default(),
                last_enabled_time: self.last_enabled_time.unwrap_or_default(),
                last_disabled_time: self.last_disabled_time.unwrap_or_default(),
                last_modified_time: self.last_modified_time.unwrap_or_default(),
                last_login_time: self.last_login_time.unwrap_or_default(),
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("user_id", &self.user_id);
            formatter.field("status", &self.status);
            formatter.field("first_name", &"*** Sensitive Data Redacted ***");
            formatter.field("last_name", &"*** Sensitive Data Redacted ***");
            formatter.field("email_address", &"*** Sensitive Data Redacted ***");
            formatter.field("r#type", &self.r#type);
            formatter.field("api_access", &self.api_access);
            formatter.field("api_access_principal_arn", &self.api_access_principal_arn);
            formatter.field("create_time", &self.create_time);
            formatter.field("last_enabled_time", &self.last_enabled_time);
            formatter.field("last_disabled_time", &self.last_disabled_time);
            formatter.field("last_modified_time", &self.last_modified_time);
            formatter.field("last_login_time", &self.last_login_time);
            formatter.finish()
        }
    }
}
impl User {
    /// Creates a new builder-style object to manufacture [`User`](crate::model::User).
    pub fn builder() -> crate::model::user::Builder {
        crate::model::user::Builder::default()
    }
}

/// <p>The structure of a permission group associated with a user account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PermissionGroupByUser {
    /// <p>The unique identifier for the permission group.</p>
    #[doc(hidden)]
    pub permission_group_id: std::option::Option<std::string::String>,
    /// <p>The name of the permission group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Indicates the status of the user account within a permission group.</p>
    /// <ul>
    /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
    /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
    /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub membership_status: std::option::Option<crate::model::PermissionGroupMembershipStatus>,
}
impl PermissionGroupByUser {
    /// <p>The unique identifier for the permission group.</p>
    pub fn permission_group_id(&self) -> std::option::Option<&str> {
        self.permission_group_id.as_deref()
    }
    /// <p>The name of the permission group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Indicates the status of the user account within a permission group.</p>
    /// <ul>
    /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
    /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
    /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
    /// </ul>
    pub fn membership_status(
        &self,
    ) -> std::option::Option<&crate::model::PermissionGroupMembershipStatus> {
        self.membership_status.as_ref()
    }
}
impl std::fmt::Debug for PermissionGroupByUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PermissionGroupByUser");
        formatter.field("permission_group_id", &self.permission_group_id);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("membership_status", &self.membership_status);
        formatter.finish()
    }
}
/// See [`PermissionGroupByUser`](crate::model::PermissionGroupByUser).
pub mod permission_group_by_user {

    /// A builder for [`PermissionGroupByUser`](crate::model::PermissionGroupByUser).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) permission_group_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) membership_status:
            std::option::Option<crate::model::PermissionGroupMembershipStatus>,
    }
    impl Builder {
        /// <p>The unique identifier for the permission group.</p>
        pub fn permission_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.permission_group_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the permission group.</p>
        pub fn set_permission_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.permission_group_id = input;
            self
        }
        /// <p>The name of the permission group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the permission group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Indicates the status of the user account within a permission group.</p>
        /// <ul>
        /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
        /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
        /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
        /// </ul>
        pub fn membership_status(
            mut self,
            input: crate::model::PermissionGroupMembershipStatus,
        ) -> Self {
            self.membership_status = Some(input);
            self
        }
        /// <p>Indicates the status of the user account within a permission group.</p>
        /// <ul>
        /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
        /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
        /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
        /// </ul>
        pub fn set_membership_status(
            mut self,
            input: std::option::Option<crate::model::PermissionGroupMembershipStatus>,
        ) -> Self {
            self.membership_status = input;
            self
        }
        /// Consumes the builder and constructs a [`PermissionGroupByUser`](crate::model::PermissionGroupByUser).
        pub fn build(self) -> crate::model::PermissionGroupByUser {
            crate::model::PermissionGroupByUser {
                permission_group_id: self.permission_group_id,
                name: self.name,
                membership_status: self.membership_status,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("permission_group_id", &self.permission_group_id);
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("membership_status", &self.membership_status);
            formatter.finish()
        }
    }
}
impl PermissionGroupByUser {
    /// Creates a new builder-style object to manufacture [`PermissionGroupByUser`](crate::model::PermissionGroupByUser).
    pub fn builder() -> crate::model::permission_group_by_user::Builder {
        crate::model::permission_group_by_user::Builder::default()
    }
}

/// <p>The structure for a permission group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PermissionGroup {
    /// <p> The unique identifier for the permission group.</p>
    #[doc(hidden)]
    pub permission_group_id: std::option::Option<std::string::String>,
    /// <p>The name of the permission group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p> A brief description for the permission group.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>Indicates the permissions that are granted to a specific group for accessing the FinSpace application.</p> <important>
    /// <p>When assigning application permissions, be aware that the permission <code>ManageUsersAndGroups</code> allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.</p>
    /// </important>
    /// <ul>
    /// <li> <p> <code>CreateDataset</code> – Group members can create new datasets.</p> </li>
    /// <li> <p> <code>ManageClusters</code> – Group members can manage Apache Spark clusters from FinSpace notebooks.</p> </li>
    /// <li> <p> <code>ManageUsersAndGroups</code> – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.</p> </li>
    /// <li> <p> <code>ManageAttributeSets</code> – Group members can manage attribute sets.</p> </li>
    /// <li> <p> <code>ViewAuditData</code> – Group members can view audit data.</p> </li>
    /// <li> <p> <code>AccessNotebooks</code> – Group members will have access to FinSpace notebooks.</p> </li>
    /// <li> <p> <code>GetTemporaryCredentials</code> – Group members can get temporary API credentials.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub application_permissions:
        std::option::Option<std::vec::Vec<crate::model::ApplicationPermission>>,
    /// <p>The timestamp at which the group was created in FinSpace. The value is determined as epoch time in milliseconds. </p>
    #[doc(hidden)]
    pub create_time: i64,
    /// <p>Describes the last time the permission group was updated. The value is determined as epoch time in milliseconds. </p>
    #[doc(hidden)]
    pub last_modified_time: i64,
    /// <p>Indicates the status of the user account within a permission group.</p>
    /// <ul>
    /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
    /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
    /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub membership_status: std::option::Option<crate::model::PermissionGroupMembershipStatus>,
}
impl PermissionGroup {
    /// <p> The unique identifier for the permission group.</p>
    pub fn permission_group_id(&self) -> std::option::Option<&str> {
        self.permission_group_id.as_deref()
    }
    /// <p>The name of the permission group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p> A brief description for the permission group.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>Indicates the permissions that are granted to a specific group for accessing the FinSpace application.</p> <important>
    /// <p>When assigning application permissions, be aware that the permission <code>ManageUsersAndGroups</code> allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.</p>
    /// </important>
    /// <ul>
    /// <li> <p> <code>CreateDataset</code> – Group members can create new datasets.</p> </li>
    /// <li> <p> <code>ManageClusters</code> – Group members can manage Apache Spark clusters from FinSpace notebooks.</p> </li>
    /// <li> <p> <code>ManageUsersAndGroups</code> – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.</p> </li>
    /// <li> <p> <code>ManageAttributeSets</code> – Group members can manage attribute sets.</p> </li>
    /// <li> <p> <code>ViewAuditData</code> – Group members can view audit data.</p> </li>
    /// <li> <p> <code>AccessNotebooks</code> – Group members will have access to FinSpace notebooks.</p> </li>
    /// <li> <p> <code>GetTemporaryCredentials</code> – Group members can get temporary API credentials.</p> </li>
    /// </ul>
    pub fn application_permissions(
        &self,
    ) -> std::option::Option<&[crate::model::ApplicationPermission]> {
        self.application_permissions.as_deref()
    }
    /// <p>The timestamp at which the group was created in FinSpace. The value is determined as epoch time in milliseconds. </p>
    pub fn create_time(&self) -> i64 {
        self.create_time
    }
    /// <p>Describes the last time the permission group was updated. The value is determined as epoch time in milliseconds. </p>
    pub fn last_modified_time(&self) -> i64 {
        self.last_modified_time
    }
    /// <p>Indicates the status of the user account within a permission group.</p>
    /// <ul>
    /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
    /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
    /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
    /// </ul>
    pub fn membership_status(
        &self,
    ) -> std::option::Option<&crate::model::PermissionGroupMembershipStatus> {
        self.membership_status.as_ref()
    }
}
impl std::fmt::Debug for PermissionGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PermissionGroup");
        formatter.field("permission_group_id", &self.permission_group_id);
        formatter.field("name", &"*** Sensitive Data Redacted ***");
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("application_permissions", &self.application_permissions);
        formatter.field("create_time", &self.create_time);
        formatter.field("last_modified_time", &self.last_modified_time);
        formatter.field("membership_status", &self.membership_status);
        formatter.finish()
    }
}
/// See [`PermissionGroup`](crate::model::PermissionGroup).
pub mod permission_group {

    /// A builder for [`PermissionGroup`](crate::model::PermissionGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) permission_group_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) application_permissions:
            std::option::Option<std::vec::Vec<crate::model::ApplicationPermission>>,
        pub(crate) create_time: std::option::Option<i64>,
        pub(crate) last_modified_time: std::option::Option<i64>,
        pub(crate) membership_status:
            std::option::Option<crate::model::PermissionGroupMembershipStatus>,
    }
    impl Builder {
        /// <p> The unique identifier for the permission group.</p>
        pub fn permission_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.permission_group_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the permission group.</p>
        pub fn set_permission_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.permission_group_id = input;
            self
        }
        /// <p>The name of the permission group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the permission group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p> A brief description for the permission group.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p> A brief description for the permission group.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Appends an item to `application_permissions`.
        ///
        /// To override the contents of this collection use [`set_application_permissions`](Self::set_application_permissions).
        ///
        /// <p>Indicates the permissions that are granted to a specific group for accessing the FinSpace application.</p> <important>
        /// <p>When assigning application permissions, be aware that the permission <code>ManageUsersAndGroups</code> allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.</p>
        /// </important>
        /// <ul>
        /// <li> <p> <code>CreateDataset</code> – Group members can create new datasets.</p> </li>
        /// <li> <p> <code>ManageClusters</code> – Group members can manage Apache Spark clusters from FinSpace notebooks.</p> </li>
        /// <li> <p> <code>ManageUsersAndGroups</code> – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.</p> </li>
        /// <li> <p> <code>ManageAttributeSets</code> – Group members can manage attribute sets.</p> </li>
        /// <li> <p> <code>ViewAuditData</code> – Group members can view audit data.</p> </li>
        /// <li> <p> <code>AccessNotebooks</code> – Group members will have access to FinSpace notebooks.</p> </li>
        /// <li> <p> <code>GetTemporaryCredentials</code> – Group members can get temporary API credentials.</p> </li>
        /// </ul>
        pub fn application_permissions(
            mut self,
            input: crate::model::ApplicationPermission,
        ) -> Self {
            let mut v = self.application_permissions.unwrap_or_default();
            v.push(input);
            self.application_permissions = Some(v);
            self
        }
        /// <p>Indicates the permissions that are granted to a specific group for accessing the FinSpace application.</p> <important>
        /// <p>When assigning application permissions, be aware that the permission <code>ManageUsersAndGroups</code> allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.</p>
        /// </important>
        /// <ul>
        /// <li> <p> <code>CreateDataset</code> – Group members can create new datasets.</p> </li>
        /// <li> <p> <code>ManageClusters</code> – Group members can manage Apache Spark clusters from FinSpace notebooks.</p> </li>
        /// <li> <p> <code>ManageUsersAndGroups</code> – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.</p> </li>
        /// <li> <p> <code>ManageAttributeSets</code> – Group members can manage attribute sets.</p> </li>
        /// <li> <p> <code>ViewAuditData</code> – Group members can view audit data.</p> </li>
        /// <li> <p> <code>AccessNotebooks</code> – Group members will have access to FinSpace notebooks.</p> </li>
        /// <li> <p> <code>GetTemporaryCredentials</code> – Group members can get temporary API credentials.</p> </li>
        /// </ul>
        pub fn set_application_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ApplicationPermission>>,
        ) -> Self {
            self.application_permissions = input;
            self
        }
        /// <p>The timestamp at which the group was created in FinSpace. The value is determined as epoch time in milliseconds. </p>
        pub fn create_time(mut self, input: i64) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The timestamp at which the group was created in FinSpace. The value is determined as epoch time in milliseconds. </p>
        pub fn set_create_time(mut self, input: std::option::Option<i64>) -> Self {
            self.create_time = input;
            self
        }
        /// <p>Describes the last time the permission group was updated. The value is determined as epoch time in milliseconds. </p>
        pub fn last_modified_time(mut self, input: i64) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>Describes the last time the permission group was updated. The value is determined as epoch time in milliseconds. </p>
        pub fn set_last_modified_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Indicates the status of the user account within a permission group.</p>
        /// <ul>
        /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
        /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
        /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
        /// </ul>
        pub fn membership_status(
            mut self,
            input: crate::model::PermissionGroupMembershipStatus,
        ) -> Self {
            self.membership_status = Some(input);
            self
        }
        /// <p>Indicates the status of the user account within a permission group.</p>
        /// <ul>
        /// <li> <p> <code>ADDITION_IN_PROGRESS</code> – The user account is currently being added to the permission group.</p> </li>
        /// <li> <p> <code>ADDITION_SUCCESS</code> – The user account is successfully added to the permission group.</p> </li>
        /// <li> <p> <code>REMOVAL_IN_PROGRESS</code> – The user is currently being removed from the permission group.</p> </li>
        /// </ul>
        pub fn set_membership_status(
            mut self,
            input: std::option::Option<crate::model::PermissionGroupMembershipStatus>,
        ) -> Self {
            self.membership_status = input;
            self
        }
        /// Consumes the builder and constructs a [`PermissionGroup`](crate::model::PermissionGroup).
        pub fn build(self) -> crate::model::PermissionGroup {
            crate::model::PermissionGroup {
                permission_group_id: self.permission_group_id,
                name: self.name,
                description: self.description,
                application_permissions: self.application_permissions,
                create_time: self.create_time.unwrap_or_default(),
                last_modified_time: self.last_modified_time.unwrap_or_default(),
                membership_status: self.membership_status,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("permission_group_id", &self.permission_group_id);
            formatter.field("name", &"*** Sensitive Data Redacted ***");
            formatter.field("description", &"*** Sensitive Data Redacted ***");
            formatter.field("application_permissions", &self.application_permissions);
            formatter.field("create_time", &self.create_time);
            formatter.field("last_modified_time", &self.last_modified_time);
            formatter.field("membership_status", &self.membership_status);
            formatter.finish()
        }
    }
}
impl PermissionGroup {
    /// Creates a new builder-style object to manufacture [`PermissionGroup`](crate::model::PermissionGroup).
    pub fn builder() -> crate::model::permission_group::Builder {
        crate::model::permission_group::Builder::default()
    }
}

/// <p>Structure for the summary of a Dataview.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataViewSummary {
    /// <p>The unique identifier for the Dataview.</p>
    #[doc(hidden)]
    pub data_view_id: std::option::Option<std::string::String>,
    /// <p>The ARN identifier of the Dataview.</p>
    #[doc(hidden)]
    pub data_view_arn: std::option::Option<std::string::String>,
    /// <p>Th unique identifier for the Dataview Dataset.</p>
    #[doc(hidden)]
    pub dataset_id: std::option::Option<std::string::String>,
    /// <p>Time range to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    #[doc(hidden)]
    pub as_of_timestamp: std::option::Option<i64>,
    /// <p>Ordered set of column names used to partition data.</p>
    #[doc(hidden)]
    pub partition_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>Columns to be used for sorting the data.</p>
    #[doc(hidden)]
    pub sort_columns: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The status of a Dataview creation.</p>
    /// <ul>
    /// <li> <p> <code>RUNNING</code> – Dataview creation is running.</p> </li>
    /// <li> <p> <code>STARTING</code> – Dataview creation is starting.</p> </li>
    /// <li> <p> <code>FAILED</code> – Dataview creation has failed.</p> </li>
    /// <li> <p> <code>CANCELLED</code> – Dataview creation has been cancelled.</p> </li>
    /// <li> <p> <code>TIMEOUT</code> – Dataview creation has timed out.</p> </li>
    /// <li> <p> <code>SUCCESS</code> – Dataview creation has succeeded.</p> </li>
    /// <li> <p> <code>PENDING</code> – Dataview creation is pending.</p> </li>
    /// <li> <p> <code>FAILED_CLEANUP_FAILED</code> – Dataview creation failed and resource cleanup failed.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::DataViewStatus>,
    /// <p>The structure with error messages.</p>
    #[doc(hidden)]
    pub error_info: std::option::Option<crate::model::DataViewErrorInfo>,
    /// <p>Information about the Dataview destination.</p>
    #[doc(hidden)]
    pub destination_type_properties:
        std::option::Option<crate::model::DataViewDestinationTypeParams>,
    /// <p>The flag to indicate Dataview should be updated automatically.</p>
    #[doc(hidden)]
    pub auto_update: bool,
    /// <p>The timestamp at which the Dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    #[doc(hidden)]
    pub create_time: i64,
    /// <p>The last time that a Dataview was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    #[doc(hidden)]
    pub last_modified_time: i64,
}
impl DataViewSummary {
    /// <p>The unique identifier for the Dataview.</p>
    pub fn data_view_id(&self) -> std::option::Option<&str> {
        self.data_view_id.as_deref()
    }
    /// <p>The ARN identifier of the Dataview.</p>
    pub fn data_view_arn(&self) -> std::option::Option<&str> {
        self.data_view_arn.as_deref()
    }
    /// <p>Th unique identifier for the Dataview Dataset.</p>
    pub fn dataset_id(&self) -> std::option::Option<&str> {
        self.dataset_id.as_deref()
    }
    /// <p>Time range to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn as_of_timestamp(&self) -> std::option::Option<i64> {
        self.as_of_timestamp
    }
    /// <p>Ordered set of column names used to partition data.</p>
    pub fn partition_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.partition_columns.as_deref()
    }
    /// <p>Columns to be used for sorting the data.</p>
    pub fn sort_columns(&self) -> std::option::Option<&[std::string::String]> {
        self.sort_columns.as_deref()
    }
    /// <p>The status of a Dataview creation.</p>
    /// <ul>
    /// <li> <p> <code>RUNNING</code> – Dataview creation is running.</p> </li>
    /// <li> <p> <code>STARTING</code> – Dataview creation is starting.</p> </li>
    /// <li> <p> <code>FAILED</code> – Dataview creation has failed.</p> </li>
    /// <li> <p> <code>CANCELLED</code> – Dataview creation has been cancelled.</p> </li>
    /// <li> <p> <code>TIMEOUT</code> – Dataview creation has timed out.</p> </li>
    /// <li> <p> <code>SUCCESS</code> – Dataview creation has succeeded.</p> </li>
    /// <li> <p> <code>PENDING</code> – Dataview creation is pending.</p> </li>
    /// <li> <p> <code>FAILED_CLEANUP_FAILED</code> – Dataview creation failed and resource cleanup failed.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::DataViewStatus> {
        self.status.as_ref()
    }
    /// <p>The structure with error messages.</p>
    pub fn error_info(&self) -> std::option::Option<&crate::model::DataViewErrorInfo> {
        self.error_info.as_ref()
    }
    /// <p>Information about the Dataview destination.</p>
    pub fn destination_type_properties(
        &self,
    ) -> std::option::Option<&crate::model::DataViewDestinationTypeParams> {
        self.destination_type_properties.as_ref()
    }
    /// <p>The flag to indicate Dataview should be updated automatically.</p>
    pub fn auto_update(&self) -> bool {
        self.auto_update
    }
    /// <p>The timestamp at which the Dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn create_time(&self) -> i64 {
        self.create_time
    }
    /// <p>The last time that a Dataview was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn last_modified_time(&self) -> i64 {
        self.last_modified_time
    }
}
/// See [`DataViewSummary`](crate::model::DataViewSummary).
pub mod data_view_summary {

    /// A builder for [`DataViewSummary`](crate::model::DataViewSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_view_id: std::option::Option<std::string::String>,
        pub(crate) data_view_arn: std::option::Option<std::string::String>,
        pub(crate) dataset_id: std::option::Option<std::string::String>,
        pub(crate) as_of_timestamp: std::option::Option<i64>,
        pub(crate) partition_columns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) sort_columns: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) status: std::option::Option<crate::model::DataViewStatus>,
        pub(crate) error_info: std::option::Option<crate::model::DataViewErrorInfo>,
        pub(crate) destination_type_properties:
            std::option::Option<crate::model::DataViewDestinationTypeParams>,
        pub(crate) auto_update: std::option::Option<bool>,
        pub(crate) create_time: std::option::Option<i64>,
        pub(crate) last_modified_time: std::option::Option<i64>,
    }
    impl Builder {
        /// <p>The unique identifier for the Dataview.</p>
        pub fn data_view_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_view_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the Dataview.</p>
        pub fn set_data_view_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.data_view_id = input;
            self
        }
        /// <p>The ARN identifier of the Dataview.</p>
        pub fn data_view_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.data_view_arn = Some(input.into());
            self
        }
        /// <p>The ARN identifier of the Dataview.</p>
        pub fn set_data_view_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.data_view_arn = input;
            self
        }
        /// <p>Th unique identifier for the Dataview Dataset.</p>
        pub fn dataset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_id = Some(input.into());
            self
        }
        /// <p>Th unique identifier for the Dataview Dataset.</p>
        pub fn set_dataset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dataset_id = input;
            self
        }
        /// <p>Time range to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn as_of_timestamp(mut self, input: i64) -> Self {
            self.as_of_timestamp = Some(input);
            self
        }
        /// <p>Time range to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn set_as_of_timestamp(mut self, input: std::option::Option<i64>) -> Self {
            self.as_of_timestamp = input;
            self
        }
        /// Appends an item to `partition_columns`.
        ///
        /// To override the contents of this collection use [`set_partition_columns`](Self::set_partition_columns).
        ///
        /// <p>Ordered set of column names used to partition data.</p>
        pub fn partition_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.partition_columns.unwrap_or_default();
            v.push(input.into());
            self.partition_columns = Some(v);
            self
        }
        /// <p>Ordered set of column names used to partition data.</p>
        pub fn set_partition_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.partition_columns = input;
            self
        }
        /// Appends an item to `sort_columns`.
        ///
        /// To override the contents of this collection use [`set_sort_columns`](Self::set_sort_columns).
        ///
        /// <p>Columns to be used for sorting the data.</p>
        pub fn sort_columns(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.sort_columns.unwrap_or_default();
            v.push(input.into());
            self.sort_columns = Some(v);
            self
        }
        /// <p>Columns to be used for sorting the data.</p>
        pub fn set_sort_columns(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.sort_columns = input;
            self
        }
        /// <p>The status of a Dataview creation.</p>
        /// <ul>
        /// <li> <p> <code>RUNNING</code> – Dataview creation is running.</p> </li>
        /// <li> <p> <code>STARTING</code> – Dataview creation is starting.</p> </li>
        /// <li> <p> <code>FAILED</code> – Dataview creation has failed.</p> </li>
        /// <li> <p> <code>CANCELLED</code> – Dataview creation has been cancelled.</p> </li>
        /// <li> <p> <code>TIMEOUT</code> – Dataview creation has timed out.</p> </li>
        /// <li> <p> <code>SUCCESS</code> – Dataview creation has succeeded.</p> </li>
        /// <li> <p> <code>PENDING</code> – Dataview creation is pending.</p> </li>
        /// <li> <p> <code>FAILED_CLEANUP_FAILED</code> – Dataview creation failed and resource cleanup failed.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::DataViewStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of a Dataview creation.</p>
        /// <ul>
        /// <li> <p> <code>RUNNING</code> – Dataview creation is running.</p> </li>
        /// <li> <p> <code>STARTING</code> – Dataview creation is starting.</p> </li>
        /// <li> <p> <code>FAILED</code> – Dataview creation has failed.</p> </li>
        /// <li> <p> <code>CANCELLED</code> – Dataview creation has been cancelled.</p> </li>
        /// <li> <p> <code>TIMEOUT</code> – Dataview creation has timed out.</p> </li>
        /// <li> <p> <code>SUCCESS</code> – Dataview creation has succeeded.</p> </li>
        /// <li> <p> <code>PENDING</code> – Dataview creation is pending.</p> </li>
        /// <li> <p> <code>FAILED_CLEANUP_FAILED</code> – Dataview creation failed and resource cleanup failed.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::DataViewStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The structure with error messages.</p>
        pub fn error_info(mut self, input: crate::model::DataViewErrorInfo) -> Self {
            self.error_info = Some(input);
            self
        }
        /// <p>The structure with error messages.</p>
        pub fn set_error_info(
            mut self,
            input: std::option::Option<crate::model::DataViewErrorInfo>,
        ) -> Self {
            self.error_info = input;
            self
        }
        /// <p>Information about the Dataview destination.</p>
        pub fn destination_type_properties(
            mut self,
            input: crate::model::DataViewDestinationTypeParams,
        ) -> Self {
            self.destination_type_properties = Some(input);
            self
        }
        /// <p>Information about the Dataview destination.</p>
        pub fn set_destination_type_properties(
            mut self,
            input: std::option::Option<crate::model::DataViewDestinationTypeParams>,
        ) -> Self {
            self.destination_type_properties = input;
            self
        }
        /// <p>The flag to indicate Dataview should be updated automatically.</p>
        pub fn auto_update(mut self, input: bool) -> Self {
            self.auto_update = Some(input);
            self
        }
        /// <p>The flag to indicate Dataview should be updated automatically.</p>
        pub fn set_auto_update(mut self, input: std::option::Option<bool>) -> Self {
            self.auto_update = input;
            self
        }
        /// <p>The timestamp at which the Dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn create_time(mut self, input: i64) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The timestamp at which the Dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn set_create_time(mut self, input: std::option::Option<i64>) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The last time that a Dataview was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn last_modified_time(mut self, input: i64) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last time that a Dataview was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn set_last_modified_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_modified_time = input;
            self
        }
        /// Consumes the builder and constructs a [`DataViewSummary`](crate::model::DataViewSummary).
        pub fn build(self) -> crate::model::DataViewSummary {
            crate::model::DataViewSummary {
                data_view_id: self.data_view_id,
                data_view_arn: self.data_view_arn,
                dataset_id: self.dataset_id,
                as_of_timestamp: self.as_of_timestamp,
                partition_columns: self.partition_columns,
                sort_columns: self.sort_columns,
                status: self.status,
                error_info: self.error_info,
                destination_type_properties: self.destination_type_properties,
                auto_update: self.auto_update.unwrap_or_default(),
                create_time: self.create_time.unwrap_or_default(),
                last_modified_time: self.last_modified_time.unwrap_or_default(),
            }
        }
    }
}
impl DataViewSummary {
    /// Creates a new builder-style object to manufacture [`DataViewSummary`](crate::model::DataViewSummary).
    pub fn builder() -> crate::model::data_view_summary::Builder {
        crate::model::data_view_summary::Builder::default()
    }
}

/// <p>Structure for the Dataview destination type parameters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataViewDestinationTypeParams {
    /// <p>Destination type for a Dataview.</p>
    /// <ul>
    /// <li> <p> <code>GLUE_TABLE</code> – Glue table destination type.</p> </li>
    /// <li> <p> <code>S3</code> – S3 destination type.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub destination_type: std::option::Option<std::string::String>,
    /// <p>Dataview export file format.</p>
    /// <ul>
    /// <li> <p> <code>PARQUET</code> – Parquet export file format.</p> </li>
    /// <li> <p> <code>DELIMITED_TEXT</code> – Delimited text export file format.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub s3_destination_export_file_format: std::option::Option<crate::model::ExportFileFormat>,
    /// <p>Format Options for S3 Destination type.</p>
    /// <p>Here is an example of how you could specify the <code>s3DestinationExportFileFormatOptions</code> </p>
    /// <p> <code> { "header": "true", "delimiter": ",", "compression": "gzip" }</code> </p>
    #[doc(hidden)]
    pub s3_destination_export_file_format_options:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DataViewDestinationTypeParams {
    /// <p>Destination type for a Dataview.</p>
    /// <ul>
    /// <li> <p> <code>GLUE_TABLE</code> – Glue table destination type.</p> </li>
    /// <li> <p> <code>S3</code> – S3 destination type.</p> </li>
    /// </ul>
    pub fn destination_type(&self) -> std::option::Option<&str> {
        self.destination_type.as_deref()
    }
    /// <p>Dataview export file format.</p>
    /// <ul>
    /// <li> <p> <code>PARQUET</code> – Parquet export file format.</p> </li>
    /// <li> <p> <code>DELIMITED_TEXT</code> – Delimited text export file format.</p> </li>
    /// </ul>
    pub fn s3_destination_export_file_format(
        &self,
    ) -> std::option::Option<&crate::model::ExportFileFormat> {
        self.s3_destination_export_file_format.as_ref()
    }
    /// <p>Format Options for S3 Destination type.</p>
    /// <p>Here is an example of how you could specify the <code>s3DestinationExportFileFormatOptions</code> </p>
    /// <p> <code> { "header": "true", "delimiter": ",", "compression": "gzip" }</code> </p>
    pub fn s3_destination_export_file_format_options(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.s3_destination_export_file_format_options.as_ref()
    }
}
/// See [`DataViewDestinationTypeParams`](crate::model::DataViewDestinationTypeParams).
pub mod data_view_destination_type_params {

    /// A builder for [`DataViewDestinationTypeParams`](crate::model::DataViewDestinationTypeParams).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) destination_type: std::option::Option<std::string::String>,
        pub(crate) s3_destination_export_file_format:
            std::option::Option<crate::model::ExportFileFormat>,
        pub(crate) s3_destination_export_file_format_options: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>Destination type for a Dataview.</p>
        /// <ul>
        /// <li> <p> <code>GLUE_TABLE</code> – Glue table destination type.</p> </li>
        /// <li> <p> <code>S3</code> – S3 destination type.</p> </li>
        /// </ul>
        pub fn destination_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_type = Some(input.into());
            self
        }
        /// <p>Destination type for a Dataview.</p>
        /// <ul>
        /// <li> <p> <code>GLUE_TABLE</code> – Glue table destination type.</p> </li>
        /// <li> <p> <code>S3</code> – S3 destination type.</p> </li>
        /// </ul>
        pub fn set_destination_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_type = input;
            self
        }
        /// <p>Dataview export file format.</p>
        /// <ul>
        /// <li> <p> <code>PARQUET</code> – Parquet export file format.</p> </li>
        /// <li> <p> <code>DELIMITED_TEXT</code> – Delimited text export file format.</p> </li>
        /// </ul>
        pub fn s3_destination_export_file_format(
            mut self,
            input: crate::model::ExportFileFormat,
        ) -> Self {
            self.s3_destination_export_file_format = Some(input);
            self
        }
        /// <p>Dataview export file format.</p>
        /// <ul>
        /// <li> <p> <code>PARQUET</code> – Parquet export file format.</p> </li>
        /// <li> <p> <code>DELIMITED_TEXT</code> – Delimited text export file format.</p> </li>
        /// </ul>
        pub fn set_s3_destination_export_file_format(
            mut self,
            input: std::option::Option<crate::model::ExportFileFormat>,
        ) -> Self {
            self.s3_destination_export_file_format = input;
            self
        }
        /// Adds a key-value pair to `s3_destination_export_file_format_options`.
        ///
        /// To override the contents of this collection use [`set_s3_destination_export_file_format_options`](Self::set_s3_destination_export_file_format_options).
        ///
        /// <p>Format Options for S3 Destination type.</p>
        /// <p>Here is an example of how you could specify the <code>s3DestinationExportFileFormatOptions</code> </p>
        /// <p> <code> { "header": "true", "delimiter": ",", "compression": "gzip" }</code> </p>
        pub fn s3_destination_export_file_format_options(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self
                .s3_destination_export_file_format_options
                .unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.s3_destination_export_file_format_options = Some(hash_map);
            self
        }
        /// <p>Format Options for S3 Destination type.</p>
        /// <p>Here is an example of how you could specify the <code>s3DestinationExportFileFormatOptions</code> </p>
        /// <p> <code> { "header": "true", "delimiter": ",", "compression": "gzip" }</code> </p>
        pub fn set_s3_destination_export_file_format_options(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.s3_destination_export_file_format_options = input;
            self
        }
        /// Consumes the builder and constructs a [`DataViewDestinationTypeParams`](crate::model::DataViewDestinationTypeParams).
        pub fn build(self) -> crate::model::DataViewDestinationTypeParams {
            crate::model::DataViewDestinationTypeParams {
                destination_type: self.destination_type,
                s3_destination_export_file_format: self.s3_destination_export_file_format,
                s3_destination_export_file_format_options: self
                    .s3_destination_export_file_format_options,
            }
        }
    }
}
impl DataViewDestinationTypeParams {
    /// Creates a new builder-style object to manufacture [`DataViewDestinationTypeParams`](crate::model::DataViewDestinationTypeParams).
    pub fn builder() -> crate::model::data_view_destination_type_params::Builder {
        crate::model::data_view_destination_type_params::Builder::default()
    }
}

/// When writing a match expression against `ExportFileFormat`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let exportfileformat = unimplemented!();
/// match exportfileformat {
///     ExportFileFormat::DelimitedText => { /* ... */ },
///     ExportFileFormat::Parquet => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `exportfileformat` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExportFileFormat::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExportFileFormat::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExportFileFormat::NewFeature` is defined.
/// Specifically, when `exportfileformat` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExportFileFormat::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Data View Export File Format
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExportFileFormat {
    #[allow(missing_docs)] // documentation missing in model
    DelimitedText,
    #[allow(missing_docs)] // documentation missing in model
    Parquet,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExportFileFormat {
    fn from(s: &str) -> Self {
        match s {
            "DELIMITED_TEXT" => ExportFileFormat::DelimitedText,
            "PARQUET" => ExportFileFormat::Parquet,
            other => ExportFileFormat::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ExportFileFormat {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExportFileFormat::from(s))
    }
}
impl ExportFileFormat {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExportFileFormat::DelimitedText => "DELIMITED_TEXT",
            ExportFileFormat::Parquet => "PARQUET",
            ExportFileFormat::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DELIMITED_TEXT", "PARQUET"]
    }
}
impl AsRef<str> for ExportFileFormat {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The structure with error messages.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DataViewErrorInfo {
    /// <p>The text of the error message.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The category of the error.</p>
    /// <ul>
    /// <li> <p> <code>VALIDATION</code> – The inputs to this request are invalid.</p> </li>
    /// <li> <p> <code>SERVICE_QUOTA_EXCEEDED</code> – Service quotas have been exceeded. Please contact AWS support to increase quotas.</p> </li>
    /// <li> <p> <code>ACCESS_DENIED</code> – Missing required permission to perform this request.</p> </li>
    /// <li> <p> <code>RESOURCE_NOT_FOUND</code> – One or more inputs to this request were not found.</p> </li>
    /// <li> <p> <code>THROTTLING</code> – The system temporarily lacks sufficient resources to process the request.</p> </li>
    /// <li> <p> <code>INTERNAL_SERVICE_EXCEPTION</code> – An internal service error has occurred.</p> </li>
    /// <li> <p> <code>CANCELLED</code> – Cancelled.</p> </li>
    /// <li> <p> <code>USER_RECOVERABLE</code> – A user recoverable error has occurred.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub error_category: std::option::Option<crate::model::ErrorCategory>,
}
impl DataViewErrorInfo {
    /// <p>The text of the error message.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The category of the error.</p>
    /// <ul>
    /// <li> <p> <code>VALIDATION</code> – The inputs to this request are invalid.</p> </li>
    /// <li> <p> <code>SERVICE_QUOTA_EXCEEDED</code> – Service quotas have been exceeded. Please contact AWS support to increase quotas.</p> </li>
    /// <li> <p> <code>ACCESS_DENIED</code> – Missing required permission to perform this request.</p> </li>
    /// <li> <p> <code>RESOURCE_NOT_FOUND</code> – One or more inputs to this request were not found.</p> </li>
    /// <li> <p> <code>THROTTLING</code> – The system temporarily lacks sufficient resources to process the request.</p> </li>
    /// <li> <p> <code>INTERNAL_SERVICE_EXCEPTION</code> – An internal service error has occurred.</p> </li>
    /// <li> <p> <code>CANCELLED</code> – Cancelled.</p> </li>
    /// <li> <p> <code>USER_RECOVERABLE</code> – A user recoverable error has occurred.</p> </li>
    /// </ul>
    pub fn error_category(&self) -> std::option::Option<&crate::model::ErrorCategory> {
        self.error_category.as_ref()
    }
}
/// See [`DataViewErrorInfo`](crate::model::DataViewErrorInfo).
pub mod data_view_error_info {

    /// A builder for [`DataViewErrorInfo`](crate::model::DataViewErrorInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) error_category: std::option::Option<crate::model::ErrorCategory>,
    }
    impl Builder {
        /// <p>The text of the error message.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The text of the error message.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The category of the error.</p>
        /// <ul>
        /// <li> <p> <code>VALIDATION</code> – The inputs to this request are invalid.</p> </li>
        /// <li> <p> <code>SERVICE_QUOTA_EXCEEDED</code> – Service quotas have been exceeded. Please contact AWS support to increase quotas.</p> </li>
        /// <li> <p> <code>ACCESS_DENIED</code> – Missing required permission to perform this request.</p> </li>
        /// <li> <p> <code>RESOURCE_NOT_FOUND</code> – One or more inputs to this request were not found.</p> </li>
        /// <li> <p> <code>THROTTLING</code> – The system temporarily lacks sufficient resources to process the request.</p> </li>
        /// <li> <p> <code>INTERNAL_SERVICE_EXCEPTION</code> – An internal service error has occurred.</p> </li>
        /// <li> <p> <code>CANCELLED</code> – Cancelled.</p> </li>
        /// <li> <p> <code>USER_RECOVERABLE</code> – A user recoverable error has occurred.</p> </li>
        /// </ul>
        pub fn error_category(mut self, input: crate::model::ErrorCategory) -> Self {
            self.error_category = Some(input);
            self
        }
        /// <p>The category of the error.</p>
        /// <ul>
        /// <li> <p> <code>VALIDATION</code> – The inputs to this request are invalid.</p> </li>
        /// <li> <p> <code>SERVICE_QUOTA_EXCEEDED</code> – Service quotas have been exceeded. Please contact AWS support to increase quotas.</p> </li>
        /// <li> <p> <code>ACCESS_DENIED</code> – Missing required permission to perform this request.</p> </li>
        /// <li> <p> <code>RESOURCE_NOT_FOUND</code> – One or more inputs to this request were not found.</p> </li>
        /// <li> <p> <code>THROTTLING</code> – The system temporarily lacks sufficient resources to process the request.</p> </li>
        /// <li> <p> <code>INTERNAL_SERVICE_EXCEPTION</code> – An internal service error has occurred.</p> </li>
        /// <li> <p> <code>CANCELLED</code> – Cancelled.</p> </li>
        /// <li> <p> <code>USER_RECOVERABLE</code> – A user recoverable error has occurred.</p> </li>
        /// </ul>
        pub fn set_error_category(
            mut self,
            input: std::option::Option<crate::model::ErrorCategory>,
        ) -> Self {
            self.error_category = input;
            self
        }
        /// Consumes the builder and constructs a [`DataViewErrorInfo`](crate::model::DataViewErrorInfo).
        pub fn build(self) -> crate::model::DataViewErrorInfo {
            crate::model::DataViewErrorInfo {
                error_message: self.error_message,
                error_category: self.error_category,
            }
        }
    }
}
impl DataViewErrorInfo {
    /// Creates a new builder-style object to manufacture [`DataViewErrorInfo`](crate::model::DataViewErrorInfo).
    pub fn builder() -> crate::model::data_view_error_info::Builder {
        crate::model::data_view_error_info::Builder::default()
    }
}

/// When writing a match expression against `ErrorCategory`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let errorcategory = unimplemented!();
/// match errorcategory {
///     ErrorCategory::AccessDenied => { /* ... */ },
///     ErrorCategory::Cancelled => { /* ... */ },
///     ErrorCategory::InternalServiceException => { /* ... */ },
///     ErrorCategory::ResourceNotFound => { /* ... */ },
///     ErrorCategory::ServiceQuotaExceeded => { /* ... */ },
///     ErrorCategory::Throttling => { /* ... */ },
///     ErrorCategory::UserRecoverable => { /* ... */ },
///     ErrorCategory::Validation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `errorcategory` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ErrorCategory::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ErrorCategory::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ErrorCategory::NewFeature` is defined.
/// Specifically, when `errorcategory` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ErrorCategory::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Changeset Error Category
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ErrorCategory {
    #[allow(missing_docs)] // documentation missing in model
    AccessDenied,
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    InternalServiceException,
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFound,
    #[allow(missing_docs)] // documentation missing in model
    ServiceQuotaExceeded,
    #[allow(missing_docs)] // documentation missing in model
    Throttling,
    #[allow(missing_docs)] // documentation missing in model
    UserRecoverable,
    #[allow(missing_docs)] // documentation missing in model
    Validation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ErrorCategory {
    fn from(s: &str) -> Self {
        match s {
            "ACCESS_DENIED" => ErrorCategory::AccessDenied,
            "CANCELLED" => ErrorCategory::Cancelled,
            "INTERNAL_SERVICE_EXCEPTION" => ErrorCategory::InternalServiceException,
            "RESOURCE_NOT_FOUND" => ErrorCategory::ResourceNotFound,
            "SERVICE_QUOTA_EXCEEDED" => ErrorCategory::ServiceQuotaExceeded,
            "THROTTLING" => ErrorCategory::Throttling,
            "USER_RECOVERABLE" => ErrorCategory::UserRecoverable,
            "VALIDATION" => ErrorCategory::Validation,
            other => ErrorCategory::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ErrorCategory {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ErrorCategory::from(s))
    }
}
impl ErrorCategory {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ErrorCategory::AccessDenied => "ACCESS_DENIED",
            ErrorCategory::Cancelled => "CANCELLED",
            ErrorCategory::InternalServiceException => "INTERNAL_SERVICE_EXCEPTION",
            ErrorCategory::ResourceNotFound => "RESOURCE_NOT_FOUND",
            ErrorCategory::ServiceQuotaExceeded => "SERVICE_QUOTA_EXCEEDED",
            ErrorCategory::Throttling => "THROTTLING",
            ErrorCategory::UserRecoverable => "USER_RECOVERABLE",
            ErrorCategory::Validation => "VALIDATION",
            ErrorCategory::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ACCESS_DENIED",
            "CANCELLED",
            "INTERNAL_SERVICE_EXCEPTION",
            "RESOURCE_NOT_FOUND",
            "SERVICE_QUOTA_EXCEEDED",
            "THROTTLING",
            "USER_RECOVERABLE",
            "VALIDATION",
        ]
    }
}
impl AsRef<str> for ErrorCategory {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DataViewStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dataviewstatus = unimplemented!();
/// match dataviewstatus {
///     DataViewStatus::Cancelled => { /* ... */ },
///     DataViewStatus::Failed => { /* ... */ },
///     DataViewStatus::FailedCleanupFailed => { /* ... */ },
///     DataViewStatus::Pending => { /* ... */ },
///     DataViewStatus::Running => { /* ... */ },
///     DataViewStatus::Starting => { /* ... */ },
///     DataViewStatus::Success => { /* ... */ },
///     DataViewStatus::Timeout => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dataviewstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DataViewStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DataViewStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DataViewStatus::NewFeature` is defined.
/// Specifically, when `dataviewstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DataViewStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Status of a DataView
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DataViewStatus {
    #[allow(missing_docs)] // documentation missing in model
    Cancelled,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    FailedCleanupFailed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    #[allow(missing_docs)] // documentation missing in model
    Timeout,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DataViewStatus {
    fn from(s: &str) -> Self {
        match s {
            "CANCELLED" => DataViewStatus::Cancelled,
            "FAILED" => DataViewStatus::Failed,
            "FAILED_CLEANUP_FAILED" => DataViewStatus::FailedCleanupFailed,
            "PENDING" => DataViewStatus::Pending,
            "RUNNING" => DataViewStatus::Running,
            "STARTING" => DataViewStatus::Starting,
            "SUCCESS" => DataViewStatus::Success,
            "TIMEOUT" => DataViewStatus::Timeout,
            other => DataViewStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DataViewStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DataViewStatus::from(s))
    }
}
impl DataViewStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DataViewStatus::Cancelled => "CANCELLED",
            DataViewStatus::Failed => "FAILED",
            DataViewStatus::FailedCleanupFailed => "FAILED_CLEANUP_FAILED",
            DataViewStatus::Pending => "PENDING",
            DataViewStatus::Running => "RUNNING",
            DataViewStatus::Starting => "STARTING",
            DataViewStatus::Success => "SUCCESS",
            DataViewStatus::Timeout => "TIMEOUT",
            DataViewStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CANCELLED",
            "FAILED",
            "FAILED_CLEANUP_FAILED",
            "PENDING",
            "RUNNING",
            "STARTING",
            "SUCCESS",
            "TIMEOUT",
        ]
    }
}
impl AsRef<str> for DataViewStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The structure for a Dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Dataset {
    /// <p>An identifier for a Dataset.</p>
    #[doc(hidden)]
    pub dataset_id: std::option::Option<std::string::String>,
    /// <p>The ARN identifier of the Dataset.</p>
    #[doc(hidden)]
    pub dataset_arn: std::option::Option<std::string::String>,
    /// <p>Display title for a Dataset.</p>
    #[doc(hidden)]
    pub dataset_title: std::option::Option<std::string::String>,
    /// <p>The format in which Dataset data is structured.</p>
    /// <ul>
    /// <li> <p> <code>TABULAR</code> – Data is structured in a tabular format.</p> </li>
    /// <li> <p> <code>NON_TABULAR</code> – Data is structured in a non-tabular format.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub kind: std::option::Option<crate::model::DatasetKind>,
    /// <p>Description for a Dataset.</p>
    #[doc(hidden)]
    pub dataset_description: std::option::Option<std::string::String>,
    /// <p>Contact information for a Dataset owner.</p>
    #[doc(hidden)]
    pub owner_info: std::option::Option<crate::model::DatasetOwnerInfo>,
    /// <p>The timestamp at which the Dataset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    #[doc(hidden)]
    pub create_time: i64,
    /// <p>The last time that the Dataset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    #[doc(hidden)]
    pub last_modified_time: i64,
    /// <p>Definition for a schema on a tabular Dataset.</p>
    #[doc(hidden)]
    pub schema_definition: std::option::Option<crate::model::SchemaUnion>,
    /// <p>The unique resource identifier for a Dataset.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
}
impl Dataset {
    /// <p>An identifier for a Dataset.</p>
    pub fn dataset_id(&self) -> std::option::Option<&str> {
        self.dataset_id.as_deref()
    }
    /// <p>The ARN identifier of the Dataset.</p>
    pub fn dataset_arn(&self) -> std::option::Option<&str> {
        self.dataset_arn.as_deref()
    }
    /// <p>Display title for a Dataset.</p>
    pub fn dataset_title(&self) -> std::option::Option<&str> {
        self.dataset_title.as_deref()
    }
    /// <p>The format in which Dataset data is structured.</p>
    /// <ul>
    /// <li> <p> <code>TABULAR</code> – Data is structured in a tabular format.</p> </li>
    /// <li> <p> <code>NON_TABULAR</code> – Data is structured in a non-tabular format.</p> </li>
    /// </ul>
    pub fn kind(&self) -> std::option::Option<&crate::model::DatasetKind> {
        self.kind.as_ref()
    }
    /// <p>Description for a Dataset.</p>
    pub fn dataset_description(&self) -> std::option::Option<&str> {
        self.dataset_description.as_deref()
    }
    /// <p>Contact information for a Dataset owner.</p>
    pub fn owner_info(&self) -> std::option::Option<&crate::model::DatasetOwnerInfo> {
        self.owner_info.as_ref()
    }
    /// <p>The timestamp at which the Dataset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn create_time(&self) -> i64 {
        self.create_time
    }
    /// <p>The last time that the Dataset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn last_modified_time(&self) -> i64 {
        self.last_modified_time
    }
    /// <p>Definition for a schema on a tabular Dataset.</p>
    pub fn schema_definition(&self) -> std::option::Option<&crate::model::SchemaUnion> {
        self.schema_definition.as_ref()
    }
    /// <p>The unique resource identifier for a Dataset.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
}
/// See [`Dataset`](crate::model::Dataset).
pub mod dataset {

    /// A builder for [`Dataset`](crate::model::Dataset).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dataset_id: std::option::Option<std::string::String>,
        pub(crate) dataset_arn: std::option::Option<std::string::String>,
        pub(crate) dataset_title: std::option::Option<std::string::String>,
        pub(crate) kind: std::option::Option<crate::model::DatasetKind>,
        pub(crate) dataset_description: std::option::Option<std::string::String>,
        pub(crate) owner_info: std::option::Option<crate::model::DatasetOwnerInfo>,
        pub(crate) create_time: std::option::Option<i64>,
        pub(crate) last_modified_time: std::option::Option<i64>,
        pub(crate) schema_definition: std::option::Option<crate::model::SchemaUnion>,
        pub(crate) alias: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>An identifier for a Dataset.</p>
        pub fn dataset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_id = Some(input.into());
            self
        }
        /// <p>An identifier for a Dataset.</p>
        pub fn set_dataset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dataset_id = input;
            self
        }
        /// <p>The ARN identifier of the Dataset.</p>
        pub fn dataset_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_arn = Some(input.into());
            self
        }
        /// <p>The ARN identifier of the Dataset.</p>
        pub fn set_dataset_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dataset_arn = input;
            self
        }
        /// <p>Display title for a Dataset.</p>
        pub fn dataset_title(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_title = Some(input.into());
            self
        }
        /// <p>Display title for a Dataset.</p>
        pub fn set_dataset_title(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_title = input;
            self
        }
        /// <p>The format in which Dataset data is structured.</p>
        /// <ul>
        /// <li> <p> <code>TABULAR</code> – Data is structured in a tabular format.</p> </li>
        /// <li> <p> <code>NON_TABULAR</code> – Data is structured in a non-tabular format.</p> </li>
        /// </ul>
        pub fn kind(mut self, input: crate::model::DatasetKind) -> Self {
            self.kind = Some(input);
            self
        }
        /// <p>The format in which Dataset data is structured.</p>
        /// <ul>
        /// <li> <p> <code>TABULAR</code> – Data is structured in a tabular format.</p> </li>
        /// <li> <p> <code>NON_TABULAR</code> – Data is structured in a non-tabular format.</p> </li>
        /// </ul>
        pub fn set_kind(mut self, input: std::option::Option<crate::model::DatasetKind>) -> Self {
            self.kind = input;
            self
        }
        /// <p>Description for a Dataset.</p>
        pub fn dataset_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_description = Some(input.into());
            self
        }
        /// <p>Description for a Dataset.</p>
        pub fn set_dataset_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dataset_description = input;
            self
        }
        /// <p>Contact information for a Dataset owner.</p>
        pub fn owner_info(mut self, input: crate::model::DatasetOwnerInfo) -> Self {
            self.owner_info = Some(input);
            self
        }
        /// <p>Contact information for a Dataset owner.</p>
        pub fn set_owner_info(
            mut self,
            input: std::option::Option<crate::model::DatasetOwnerInfo>,
        ) -> Self {
            self.owner_info = input;
            self
        }
        /// <p>The timestamp at which the Dataset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn create_time(mut self, input: i64) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The timestamp at which the Dataset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn set_create_time(mut self, input: std::option::Option<i64>) -> Self {
            self.create_time = input;
            self
        }
        /// <p>The last time that the Dataset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn last_modified_time(mut self, input: i64) -> Self {
            self.last_modified_time = Some(input);
            self
        }
        /// <p>The last time that the Dataset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn set_last_modified_time(mut self, input: std::option::Option<i64>) -> Self {
            self.last_modified_time = input;
            self
        }
        /// <p>Definition for a schema on a tabular Dataset.</p>
        pub fn schema_definition(mut self, input: crate::model::SchemaUnion) -> Self {
            self.schema_definition = Some(input);
            self
        }
        /// <p>Definition for a schema on a tabular Dataset.</p>
        pub fn set_schema_definition(
            mut self,
            input: std::option::Option<crate::model::SchemaUnion>,
        ) -> Self {
            self.schema_definition = input;
            self
        }
        /// <p>The unique resource identifier for a Dataset.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The unique resource identifier for a Dataset.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// Consumes the builder and constructs a [`Dataset`](crate::model::Dataset).
        pub fn build(self) -> crate::model::Dataset {
            crate::model::Dataset {
                dataset_id: self.dataset_id,
                dataset_arn: self.dataset_arn,
                dataset_title: self.dataset_title,
                kind: self.kind,
                dataset_description: self.dataset_description,
                owner_info: self.owner_info,
                create_time: self.create_time.unwrap_or_default(),
                last_modified_time: self.last_modified_time.unwrap_or_default(),
                schema_definition: self.schema_definition,
                alias: self.alias,
            }
        }
    }
}
impl Dataset {
    /// Creates a new builder-style object to manufacture [`Dataset`](crate::model::Dataset).
    pub fn builder() -> crate::model::dataset::Builder {
        crate::model::dataset::Builder::default()
    }
}

/// <p>A structure for Dataset owner info.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DatasetOwnerInfo {
    /// <p>The name of the Dataset owner.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>Phone number for the Dataset owner.</p>
    #[doc(hidden)]
    pub phone_number: std::option::Option<std::string::String>,
    /// <p>Email address for the Dataset owner.</p>
    #[doc(hidden)]
    pub email: std::option::Option<std::string::String>,
}
impl DatasetOwnerInfo {
    /// <p>The name of the Dataset owner.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>Phone number for the Dataset owner.</p>
    pub fn phone_number(&self) -> std::option::Option<&str> {
        self.phone_number.as_deref()
    }
    /// <p>Email address for the Dataset owner.</p>
    pub fn email(&self) -> std::option::Option<&str> {
        self.email.as_deref()
    }
}
impl std::fmt::Debug for DatasetOwnerInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DatasetOwnerInfo");
        formatter.field("name", &self.name);
        formatter.field("phone_number", &self.phone_number);
        formatter.field("email", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
/// See [`DatasetOwnerInfo`](crate::model::DatasetOwnerInfo).
pub mod dataset_owner_info {

    /// A builder for [`DatasetOwnerInfo`](crate::model::DatasetOwnerInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) phone_number: std::option::Option<std::string::String>,
        pub(crate) email: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The name of the Dataset owner.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the Dataset owner.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>Phone number for the Dataset owner.</p>
        pub fn phone_number(mut self, input: impl Into<std::string::String>) -> Self {
            self.phone_number = Some(input.into());
            self
        }
        /// <p>Phone number for the Dataset owner.</p>
        pub fn set_phone_number(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.phone_number = input;
            self
        }
        /// <p>Email address for the Dataset owner.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.email = Some(input.into());
            self
        }
        /// <p>Email address for the Dataset owner.</p>
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.email = input;
            self
        }
        /// Consumes the builder and constructs a [`DatasetOwnerInfo`](crate::model::DatasetOwnerInfo).
        pub fn build(self) -> crate::model::DatasetOwnerInfo {
            crate::model::DatasetOwnerInfo {
                name: self.name,
                phone_number: self.phone_number,
                email: self.email,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("name", &self.name);
            formatter.field("phone_number", &self.phone_number);
            formatter.field("email", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
impl DatasetOwnerInfo {
    /// Creates a new builder-style object to manufacture [`DatasetOwnerInfo`](crate::model::DatasetOwnerInfo).
    pub fn builder() -> crate::model::dataset_owner_info::Builder {
        crate::model::dataset_owner_info::Builder::default()
    }
}

/// <p>A Changeset is unit of data in a Dataset.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChangesetSummary {
    /// <p>The unique identifier for a Changeset.</p>
    #[doc(hidden)]
    pub changeset_id: std::option::Option<std::string::String>,
    /// <p>The ARN identifier of the Changeset.</p>
    #[doc(hidden)]
    pub changeset_arn: std::option::Option<std::string::String>,
    /// <p>The unique identifier for the FinSpace Dataset in which the Changeset is created.</p>
    #[doc(hidden)]
    pub dataset_id: std::option::Option<std::string::String>,
    /// <p>Type that indicates how a Changeset is applied to a Dataset.</p>
    /// <ul>
    /// <li> <p> <code>REPLACE</code> – Changeset is considered as a replacement to all prior loaded Changesets.</p> </li>
    /// <li> <p> <code>APPEND</code> – Changeset is considered as an addition to the end of all prior loaded Changesets.</p> </li>
    /// <li> <p> <code>MODIFY</code> – Changeset is considered as a replacement to a specific prior ingested Changeset.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub change_type: std::option::Option<crate::model::ChangeType>,
    /// <p>Options that define the location of the data being ingested.</p>
    #[doc(hidden)]
    pub source_params:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>Options that define the structure of the source file(s).</p>
    #[doc(hidden)]
    pub format_params:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
    /// <p>The timestamp at which the Changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    #[doc(hidden)]
    pub create_time: i64,
    /// <p>Status of the Changeset ingestion.</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> – Changeset is pending creation.</p> </li>
    /// <li> <p> <code>FAILED</code> – Changeset creation has failed.</p> </li>
    /// <li> <p> <code>SUCCESS</code> – Changeset creation has succeeded.</p> </li>
    /// <li> <p> <code>RUNNING</code> – Changeset creation is running.</p> </li>
    /// <li> <p> <code>STOP_REQUESTED</code> – User requested Changeset creation to stop.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::IngestionStatus>,
    /// <p>The structure with error messages.</p>
    #[doc(hidden)]
    pub error_info: std::option::Option<crate::model::ChangesetErrorInfo>,
    /// <p>Time until which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    #[doc(hidden)]
    pub active_until_timestamp: std::option::Option<i64>,
    /// <p>Beginning time from which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    #[doc(hidden)]
    pub active_from_timestamp: std::option::Option<i64>,
    /// <p>The unique identifier of the Changeset that is updated.</p>
    #[doc(hidden)]
    pub updates_changeset_id: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the updated Changeset.</p>
    #[doc(hidden)]
    pub updated_by_changeset_id: std::option::Option<std::string::String>,
}
impl ChangesetSummary {
    /// <p>The unique identifier for a Changeset.</p>
    pub fn changeset_id(&self) -> std::option::Option<&str> {
        self.changeset_id.as_deref()
    }
    /// <p>The ARN identifier of the Changeset.</p>
    pub fn changeset_arn(&self) -> std::option::Option<&str> {
        self.changeset_arn.as_deref()
    }
    /// <p>The unique identifier for the FinSpace Dataset in which the Changeset is created.</p>
    pub fn dataset_id(&self) -> std::option::Option<&str> {
        self.dataset_id.as_deref()
    }
    /// <p>Type that indicates how a Changeset is applied to a Dataset.</p>
    /// <ul>
    /// <li> <p> <code>REPLACE</code> – Changeset is considered as a replacement to all prior loaded Changesets.</p> </li>
    /// <li> <p> <code>APPEND</code> – Changeset is considered as an addition to the end of all prior loaded Changesets.</p> </li>
    /// <li> <p> <code>MODIFY</code> – Changeset is considered as a replacement to a specific prior ingested Changeset.</p> </li>
    /// </ul>
    pub fn change_type(&self) -> std::option::Option<&crate::model::ChangeType> {
        self.change_type.as_ref()
    }
    /// <p>Options that define the location of the data being ingested.</p>
    pub fn source_params(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.source_params.as_ref()
    }
    /// <p>Options that define the structure of the source file(s).</p>
    pub fn format_params(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.format_params.as_ref()
    }
    /// <p>The timestamp at which the Changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn create_time(&self) -> i64 {
        self.create_time
    }
    /// <p>Status of the Changeset ingestion.</p>
    /// <ul>
    /// <li> <p> <code>PENDING</code> – Changeset is pending creation.</p> </li>
    /// <li> <p> <code>FAILED</code> – Changeset creation has failed.</p> </li>
    /// <li> <p> <code>SUCCESS</code> – Changeset creation has succeeded.</p> </li>
    /// <li> <p> <code>RUNNING</code> – Changeset creation is running.</p> </li>
    /// <li> <p> <code>STOP_REQUESTED</code> – User requested Changeset creation to stop.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::IngestionStatus> {
        self.status.as_ref()
    }
    /// <p>The structure with error messages.</p>
    pub fn error_info(&self) -> std::option::Option<&crate::model::ChangesetErrorInfo> {
        self.error_info.as_ref()
    }
    /// <p>Time until which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn active_until_timestamp(&self) -> std::option::Option<i64> {
        self.active_until_timestamp
    }
    /// <p>Beginning time from which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
    pub fn active_from_timestamp(&self) -> std::option::Option<i64> {
        self.active_from_timestamp
    }
    /// <p>The unique identifier of the Changeset that is updated.</p>
    pub fn updates_changeset_id(&self) -> std::option::Option<&str> {
        self.updates_changeset_id.as_deref()
    }
    /// <p>The unique identifier of the updated Changeset.</p>
    pub fn updated_by_changeset_id(&self) -> std::option::Option<&str> {
        self.updated_by_changeset_id.as_deref()
    }
}
/// See [`ChangesetSummary`](crate::model::ChangesetSummary).
pub mod changeset_summary {

    /// A builder for [`ChangesetSummary`](crate::model::ChangesetSummary).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) changeset_id: std::option::Option<std::string::String>,
        pub(crate) changeset_arn: std::option::Option<std::string::String>,
        pub(crate) dataset_id: std::option::Option<std::string::String>,
        pub(crate) change_type: std::option::Option<crate::model::ChangeType>,
        pub(crate) source_params: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) format_params: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
        pub(crate) create_time: std::option::Option<i64>,
        pub(crate) status: std::option::Option<crate::model::IngestionStatus>,
        pub(crate) error_info: std::option::Option<crate::model::ChangesetErrorInfo>,
        pub(crate) active_until_timestamp: std::option::Option<i64>,
        pub(crate) active_from_timestamp: std::option::Option<i64>,
        pub(crate) updates_changeset_id: std::option::Option<std::string::String>,
        pub(crate) updated_by_changeset_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The unique identifier for a Changeset.</p>
        pub fn changeset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.changeset_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for a Changeset.</p>
        pub fn set_changeset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.changeset_id = input;
            self
        }
        /// <p>The ARN identifier of the Changeset.</p>
        pub fn changeset_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.changeset_arn = Some(input.into());
            self
        }
        /// <p>The ARN identifier of the Changeset.</p>
        pub fn set_changeset_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.changeset_arn = input;
            self
        }
        /// <p>The unique identifier for the FinSpace Dataset in which the Changeset is created.</p>
        pub fn dataset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.dataset_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the FinSpace Dataset in which the Changeset is created.</p>
        pub fn set_dataset_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dataset_id = input;
            self
        }
        /// <p>Type that indicates how a Changeset is applied to a Dataset.</p>
        /// <ul>
        /// <li> <p> <code>REPLACE</code> – Changeset is considered as a replacement to all prior loaded Changesets.</p> </li>
        /// <li> <p> <code>APPEND</code> – Changeset is considered as an addition to the end of all prior loaded Changesets.</p> </li>
        /// <li> <p> <code>MODIFY</code> – Changeset is considered as a replacement to a specific prior ingested Changeset.</p> </li>
        /// </ul>
        pub fn change_type(mut self, input: crate::model::ChangeType) -> Self {
            self.change_type = Some(input);
            self
        }
        /// <p>Type that indicates how a Changeset is applied to a Dataset.</p>
        /// <ul>
        /// <li> <p> <code>REPLACE</code> – Changeset is considered as a replacement to all prior loaded Changesets.</p> </li>
        /// <li> <p> <code>APPEND</code> – Changeset is considered as an addition to the end of all prior loaded Changesets.</p> </li>
        /// <li> <p> <code>MODIFY</code> – Changeset is considered as a replacement to a specific prior ingested Changeset.</p> </li>
        /// </ul>
        pub fn set_change_type(
            mut self,
            input: std::option::Option<crate::model::ChangeType>,
        ) -> Self {
            self.change_type = input;
            self
        }
        /// Adds a key-value pair to `source_params`.
        ///
        /// To override the contents of this collection use [`set_source_params`](Self::set_source_params).
        ///
        /// <p>Options that define the location of the data being ingested.</p>
        pub fn source_params(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.source_params.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.source_params = Some(hash_map);
            self
        }
        /// <p>Options that define the location of the data being ingested.</p>
        pub fn set_source_params(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.source_params = input;
            self
        }
        /// Adds a key-value pair to `format_params`.
        ///
        /// To override the contents of this collection use [`set_format_params`](Self::set_format_params).
        ///
        /// <p>Options that define the structure of the source file(s).</p>
        pub fn format_params(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.format_params.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.format_params = Some(hash_map);
            self
        }
        /// <p>Options that define the structure of the source file(s).</p>
        pub fn set_format_params(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.format_params = input;
            self
        }
        /// <p>The timestamp at which the Changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn create_time(mut self, input: i64) -> Self {
            self.create_time = Some(input);
            self
        }
        /// <p>The timestamp at which the Changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn set_create_time(mut self, input: std::option::Option<i64>) -> Self {
            self.create_time = input;
            self
        }
        /// <p>Status of the Changeset ingestion.</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> – Changeset is pending creation.</p> </li>
        /// <li> <p> <code>FAILED</code> – Changeset creation has failed.</p> </li>
        /// <li> <p> <code>SUCCESS</code> – Changeset creation has succeeded.</p> </li>
        /// <li> <p> <code>RUNNING</code> – Changeset creation is running.</p> </li>
        /// <li> <p> <code>STOP_REQUESTED</code> – User requested Changeset creation to stop.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::IngestionStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Status of the Changeset ingestion.</p>
        /// <ul>
        /// <li> <p> <code>PENDING</code> – Changeset is pending creation.</p> </li>
        /// <li> <p> <code>FAILED</code> – Changeset creation has failed.</p> </li>
        /// <li> <p> <code>SUCCESS</code> – Changeset creation has succeeded.</p> </li>
        /// <li> <p> <code>RUNNING</code> – Changeset creation is running.</p> </li>
        /// <li> <p> <code>STOP_REQUESTED</code> – User requested Changeset creation to stop.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::IngestionStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The structure with error messages.</p>
        pub fn error_info(mut self, input: crate::model::ChangesetErrorInfo) -> Self {
            self.error_info = Some(input);
            self
        }
        /// <p>The structure with error messages.</p>
        pub fn set_error_info(
            mut self,
            input: std::option::Option<crate::model::ChangesetErrorInfo>,
        ) -> Self {
            self.error_info = input;
            self
        }
        /// <p>Time until which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn active_until_timestamp(mut self, input: i64) -> Self {
            self.active_until_timestamp = Some(input);
            self
        }
        /// <p>Time until which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn set_active_until_timestamp(mut self, input: std::option::Option<i64>) -> Self {
            self.active_until_timestamp = input;
            self
        }
        /// <p>Beginning time from which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn active_from_timestamp(mut self, input: i64) -> Self {
            self.active_from_timestamp = Some(input);
            self
        }
        /// <p>Beginning time from which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.</p>
        pub fn set_active_from_timestamp(mut self, input: std::option::Option<i64>) -> Self {
            self.active_from_timestamp = input;
            self
        }
        /// <p>The unique identifier of the Changeset that is updated.</p>
        pub fn updates_changeset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.updates_changeset_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the Changeset that is updated.</p>
        pub fn set_updates_changeset_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.updates_changeset_id = input;
            self
        }
        /// <p>The unique identifier of the updated Changeset.</p>
        pub fn updated_by_changeset_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.updated_by_changeset_id = Some(input.into());
            self
        }
        /// <p>The unique identifier of the updated Changeset.</p>
        pub fn set_updated_by_changeset_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.updated_by_changeset_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangesetSummary`](crate::model::ChangesetSummary).
        pub fn build(self) -> crate::model::ChangesetSummary {
            crate::model::ChangesetSummary {
                changeset_id: self.changeset_id,
                changeset_arn: self.changeset_arn,
                dataset_id: self.dataset_id,
                change_type: self.change_type,
                source_params: self.source_params,
                format_params: self.format_params,
                create_time: self.create_time.unwrap_or_default(),
                status: self.status,
                error_info: self.error_info,
                active_until_timestamp: self.active_until_timestamp,
                active_from_timestamp: self.active_from_timestamp,
                updates_changeset_id: self.updates_changeset_id,
                updated_by_changeset_id: self.updated_by_changeset_id,
            }
        }
    }
}
impl ChangesetSummary {
    /// Creates a new builder-style object to manufacture [`ChangesetSummary`](crate::model::ChangesetSummary).
    pub fn builder() -> crate::model::changeset_summary::Builder {
        crate::model::changeset_summary::Builder::default()
    }
}

/// <p>The structure with error messages.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ChangesetErrorInfo {
    /// <p>The text of the error message.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The category of the error.</p>
    /// <ul>
    /// <li> <p> <code>VALIDATION</code> – The inputs to this request are invalid.</p> </li>
    /// <li> <p> <code>SERVICE_QUOTA_EXCEEDED</code> – Service quotas have been exceeded. Please contact AWS support to increase quotas.</p> </li>
    /// <li> <p> <code>ACCESS_DENIED</code> – Missing required permission to perform this request.</p> </li>
    /// <li> <p> <code>RESOURCE_NOT_FOUND</code> – One or more inputs to this request were not found.</p> </li>
    /// <li> <p> <code>THROTTLING</code> – The system temporarily lacks sufficient resources to process the request.</p> </li>
    /// <li> <p> <code>INTERNAL_SERVICE_EXCEPTION</code> – An internal service error has occurred.</p> </li>
    /// <li> <p> <code>CANCELLED</code> – Cancelled.</p> </li>
    /// <li> <p> <code>USER_RECOVERABLE</code> – A user recoverable error has occurred.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub error_category: std::option::Option<crate::model::ErrorCategory>,
}
impl ChangesetErrorInfo {
    /// <p>The text of the error message.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The category of the error.</p>
    /// <ul>
    /// <li> <p> <code>VALIDATION</code> – The inputs to this request are invalid.</p> </li>
    /// <li> <p> <code>SERVICE_QUOTA_EXCEEDED</code> – Service quotas have been exceeded. Please contact AWS support to increase quotas.</p> </li>
    /// <li> <p> <code>ACCESS_DENIED</code> – Missing required permission to perform this request.</p> </li>
    /// <li> <p> <code>RESOURCE_NOT_FOUND</code> – One or more inputs to this request were not found.</p> </li>
    /// <li> <p> <code>THROTTLING</code> – The system temporarily lacks sufficient resources to process the request.</p> </li>
    /// <li> <p> <code>INTERNAL_SERVICE_EXCEPTION</code> – An internal service error has occurred.</p> </li>
    /// <li> <p> <code>CANCELLED</code> – Cancelled.</p> </li>
    /// <li> <p> <code>USER_RECOVERABLE</code> – A user recoverable error has occurred.</p> </li>
    /// </ul>
    pub fn error_category(&self) -> std::option::Option<&crate::model::ErrorCategory> {
        self.error_category.as_ref()
    }
}
/// See [`ChangesetErrorInfo`](crate::model::ChangesetErrorInfo).
pub mod changeset_error_info {

    /// A builder for [`ChangesetErrorInfo`](crate::model::ChangesetErrorInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) error_category: std::option::Option<crate::model::ErrorCategory>,
    }
    impl Builder {
        /// <p>The text of the error message.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The text of the error message.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The category of the error.</p>
        /// <ul>
        /// <li> <p> <code>VALIDATION</code> – The inputs to this request are invalid.</p> </li>
        /// <li> <p> <code>SERVICE_QUOTA_EXCEEDED</code> – Service quotas have been exceeded. Please contact AWS support to increase quotas.</p> </li>
        /// <li> <p> <code>ACCESS_DENIED</code> – Missing required permission to perform this request.</p> </li>
        /// <li> <p> <code>RESOURCE_NOT_FOUND</code> – One or more inputs to this request were not found.</p> </li>
        /// <li> <p> <code>THROTTLING</code> – The system temporarily lacks sufficient resources to process the request.</p> </li>
        /// <li> <p> <code>INTERNAL_SERVICE_EXCEPTION</code> – An internal service error has occurred.</p> </li>
        /// <li> <p> <code>CANCELLED</code> – Cancelled.</p> </li>
        /// <li> <p> <code>USER_RECOVERABLE</code> – A user recoverable error has occurred.</p> </li>
        /// </ul>
        pub fn error_category(mut self, input: crate::model::ErrorCategory) -> Self {
            self.error_category = Some(input);
            self
        }
        /// <p>The category of the error.</p>
        /// <ul>
        /// <li> <p> <code>VALIDATION</code> – The inputs to this request are invalid.</p> </li>
        /// <li> <p> <code>SERVICE_QUOTA_EXCEEDED</code> – Service quotas have been exceeded. Please contact AWS support to increase quotas.</p> </li>
        /// <li> <p> <code>ACCESS_DENIED</code> – Missing required permission to perform this request.</p> </li>
        /// <li> <p> <code>RESOURCE_NOT_FOUND</code> – One or more inputs to this request were not found.</p> </li>
        /// <li> <p> <code>THROTTLING</code> – The system temporarily lacks sufficient resources to process the request.</p> </li>
        /// <li> <p> <code>INTERNAL_SERVICE_EXCEPTION</code> – An internal service error has occurred.</p> </li>
        /// <li> <p> <code>CANCELLED</code> – Cancelled.</p> </li>
        /// <li> <p> <code>USER_RECOVERABLE</code> – A user recoverable error has occurred.</p> </li>
        /// </ul>
        pub fn set_error_category(
            mut self,
            input: std::option::Option<crate::model::ErrorCategory>,
        ) -> Self {
            self.error_category = input;
            self
        }
        /// Consumes the builder and constructs a [`ChangesetErrorInfo`](crate::model::ChangesetErrorInfo).
        pub fn build(self) -> crate::model::ChangesetErrorInfo {
            crate::model::ChangesetErrorInfo {
                error_message: self.error_message,
                error_category: self.error_category,
            }
        }
    }
}
impl ChangesetErrorInfo {
    /// Creates a new builder-style object to manufacture [`ChangesetErrorInfo`](crate::model::ChangesetErrorInfo).
    pub fn builder() -> crate::model::changeset_error_info::Builder {
        crate::model::changeset_error_info::Builder::default()
    }
}

/// When writing a match expression against `IngestionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let ingestionstatus = unimplemented!();
/// match ingestionstatus {
///     IngestionStatus::Failed => { /* ... */ },
///     IngestionStatus::Pending => { /* ... */ },
///     IngestionStatus::Running => { /* ... */ },
///     IngestionStatus::StopRequested => { /* ... */ },
///     IngestionStatus::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `ingestionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IngestionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IngestionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IngestionStatus::NewFeature` is defined.
/// Specifically, when `ingestionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IngestionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Status of the ingestion process returned from scheduler service.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IngestionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    StopRequested,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IngestionStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => IngestionStatus::Failed,
            "PENDING" => IngestionStatus::Pending,
            "RUNNING" => IngestionStatus::Running,
            "STOP_REQUESTED" => IngestionStatus::StopRequested,
            "SUCCESS" => IngestionStatus::Success,
            other => IngestionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IngestionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IngestionStatus::from(s))
    }
}
impl IngestionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IngestionStatus::Failed => "FAILED",
            IngestionStatus::Pending => "PENDING",
            IngestionStatus::Running => "RUNNING",
            IngestionStatus::StopRequested => "STOP_REQUESTED",
            IngestionStatus::Success => "SUCCESS",
            IngestionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "PENDING", "RUNNING", "STOP_REQUESTED", "SUCCESS"]
    }
}
impl AsRef<str> for IngestionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ChangeType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let changetype = unimplemented!();
/// match changetype {
///     ChangeType::Append => { /* ... */ },
///     ChangeType::Modify => { /* ... */ },
///     ChangeType::Replace => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `changetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ChangeType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ChangeType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ChangeType::NewFeature` is defined.
/// Specifically, when `changetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ChangeType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Indicates how the given change will be applied to the dataset.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ChangeType {
    #[allow(missing_docs)] // documentation missing in model
    Append,
    #[allow(missing_docs)] // documentation missing in model
    Modify,
    #[allow(missing_docs)] // documentation missing in model
    Replace,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ChangeType {
    fn from(s: &str) -> Self {
        match s {
            "APPEND" => ChangeType::Append,
            "MODIFY" => ChangeType::Modify,
            "REPLACE" => ChangeType::Replace,
            other => ChangeType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ChangeType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ChangeType::from(s))
    }
}
impl ChangeType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ChangeType::Append => "APPEND",
            ChangeType::Modify => "MODIFY",
            ChangeType::Replace => "REPLACE",
            ChangeType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["APPEND", "MODIFY", "REPLACE"]
    }
}
impl AsRef<str> for ChangeType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `LocationType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let locationtype = unimplemented!();
/// match locationtype {
///     LocationType::Ingestion => { /* ... */ },
///     LocationType::Sagemaker => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `locationtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LocationType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LocationType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LocationType::NewFeature` is defined.
/// Specifically, when `locationtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LocationType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LocationType {
    #[allow(missing_docs)] // documentation missing in model
    Ingestion,
    #[allow(missing_docs)] // documentation missing in model
    Sagemaker,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LocationType {
    fn from(s: &str) -> Self {
        match s {
            "INGESTION" => LocationType::Ingestion,
            "SAGEMAKER" => LocationType::Sagemaker,
            other => LocationType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LocationType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LocationType::from(s))
    }
}
impl LocationType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LocationType::Ingestion => "INGESTION",
            LocationType::Sagemaker => "SAGEMAKER",
            LocationType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["INGESTION", "SAGEMAKER"]
    }
}
impl AsRef<str> for LocationType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Short term API credentials.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Credentials {
    /// <p>The access key identifier.</p>
    #[doc(hidden)]
    pub access_key_id: std::option::Option<std::string::String>,
    /// <p>The access key.</p>
    #[doc(hidden)]
    pub secret_access_key: std::option::Option<std::string::String>,
    /// <p>The session token.</p>
    #[doc(hidden)]
    pub session_token: std::option::Option<std::string::String>,
}
impl Credentials {
    /// <p>The access key identifier.</p>
    pub fn access_key_id(&self) -> std::option::Option<&str> {
        self.access_key_id.as_deref()
    }
    /// <p>The access key.</p>
    pub fn secret_access_key(&self) -> std::option::Option<&str> {
        self.secret_access_key.as_deref()
    }
    /// <p>The session token.</p>
    pub fn session_token(&self) -> std::option::Option<&str> {
        self.session_token.as_deref()
    }
}
/// See [`Credentials`](crate::model::Credentials).
pub mod credentials {

    /// A builder for [`Credentials`](crate::model::Credentials).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) access_key_id: std::option::Option<std::string::String>,
        pub(crate) secret_access_key: std::option::Option<std::string::String>,
        pub(crate) session_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The access key identifier.</p>
        pub fn access_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_key_id = Some(input.into());
            self
        }
        /// <p>The access key identifier.</p>
        pub fn set_access_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_key_id = input;
            self
        }
        /// <p>The access key.</p>
        pub fn secret_access_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_access_key = Some(input.into());
            self
        }
        /// <p>The access key.</p>
        pub fn set_secret_access_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.secret_access_key = input;
            self
        }
        /// <p>The session token.</p>
        pub fn session_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_token = Some(input.into());
            self
        }
        /// <p>The session token.</p>
        pub fn set_session_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.session_token = input;
            self
        }
        /// Consumes the builder and constructs a [`Credentials`](crate::model::Credentials).
        pub fn build(self) -> crate::model::Credentials {
            crate::model::Credentials {
                access_key_id: self.access_key_id,
                secret_access_key: self.secret_access_key,
                session_token: self.session_token,
            }
        }
    }
}
impl Credentials {
    /// Creates a new builder-style object to manufacture [`Credentials`](crate::model::Credentials).
    pub fn builder() -> crate::model::credentials::Builder {
        crate::model::credentials::Builder::default()
    }
}

/// <p>The location of an external Dataview in an S3 bucket.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct S3Location {
    /// <p> The name of the S3 bucket.</p>
    #[doc(hidden)]
    pub bucket: std::option::Option<std::string::String>,
    /// <p> The path of the folder, within the S3 bucket that contains the Dataset.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
}
impl S3Location {
    /// <p> The name of the S3 bucket.</p>
    pub fn bucket(&self) -> std::option::Option<&str> {
        self.bucket.as_deref()
    }
    /// <p> The path of the folder, within the S3 bucket that contains the Dataset.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
}
/// See [`S3Location`](crate::model::S3Location).
pub mod s3_location {

    /// A builder for [`S3Location`](crate::model::S3Location).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bucket: std::option::Option<std::string::String>,
        pub(crate) key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The name of the S3 bucket.</p>
        pub fn bucket(mut self, input: impl Into<std::string::String>) -> Self {
            self.bucket = Some(input.into());
            self
        }
        /// <p> The name of the S3 bucket.</p>
        pub fn set_bucket(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bucket = input;
            self
        }
        /// <p> The path of the folder, within the S3 bucket that contains the Dataset.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p> The path of the folder, within the S3 bucket that contains the Dataset.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// Consumes the builder and constructs a [`S3Location`](crate::model::S3Location).
        pub fn build(self) -> crate::model::S3Location {
            crate::model::S3Location {
                bucket: self.bucket,
                key: self.key,
            }
        }
    }
}
impl S3Location {
    /// Creates a new builder-style object to manufacture [`S3Location`](crate::model::S3Location).
    pub fn builder() -> crate::model::s3_location::Builder {
        crate::model::s3_location::Builder::default()
    }
}

/// <p> The credentials required to access the external Dataview from the S3 location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AwsCredentials {
    /// <p> The unique identifier for the security credentials.</p>
    #[doc(hidden)]
    pub access_key_id: std::option::Option<std::string::String>,
    /// <p> The secret access key that can be used to sign requests.</p>
    #[doc(hidden)]
    pub secret_access_key: std::option::Option<std::string::String>,
    /// <p> The token that users must pass to use the credentials.</p>
    #[doc(hidden)]
    pub session_token: std::option::Option<std::string::String>,
    /// <p> The Epoch time when the current credentials expire.</p>
    #[doc(hidden)]
    pub expiration: i64,
}
impl AwsCredentials {
    /// <p> The unique identifier for the security credentials.</p>
    pub fn access_key_id(&self) -> std::option::Option<&str> {
        self.access_key_id.as_deref()
    }
    /// <p> The secret access key that can be used to sign requests.</p>
    pub fn secret_access_key(&self) -> std::option::Option<&str> {
        self.secret_access_key.as_deref()
    }
    /// <p> The token that users must pass to use the credentials.</p>
    pub fn session_token(&self) -> std::option::Option<&str> {
        self.session_token.as_deref()
    }
    /// <p> The Epoch time when the current credentials expire.</p>
    pub fn expiration(&self) -> i64 {
        self.expiration
    }
}
impl std::fmt::Debug for AwsCredentials {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AwsCredentials");
        formatter.field("access_key_id", &self.access_key_id);
        formatter.field("secret_access_key", &"*** Sensitive Data Redacted ***");
        formatter.field("session_token", &"*** Sensitive Data Redacted ***");
        formatter.field("expiration", &self.expiration);
        formatter.finish()
    }
}
/// See [`AwsCredentials`](crate::model::AwsCredentials).
pub mod aws_credentials {

    /// A builder for [`AwsCredentials`](crate::model::AwsCredentials).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) access_key_id: std::option::Option<std::string::String>,
        pub(crate) secret_access_key: std::option::Option<std::string::String>,
        pub(crate) session_token: std::option::Option<std::string::String>,
        pub(crate) expiration: std::option::Option<i64>,
    }
    impl Builder {
        /// <p> The unique identifier for the security credentials.</p>
        pub fn access_key_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.access_key_id = Some(input.into());
            self
        }
        /// <p> The unique identifier for the security credentials.</p>
        pub fn set_access_key_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.access_key_id = input;
            self
        }
        /// <p> The secret access key that can be used to sign requests.</p>
        pub fn secret_access_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.secret_access_key = Some(input.into());
            self
        }
        /// <p> The secret access key that can be used to sign requests.</p>
        pub fn set_secret_access_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.secret_access_key = input;
            self
        }
        /// <p> The token that users must pass to use the credentials.</p>
        pub fn session_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.session_token = Some(input.into());
            self
        }
        /// <p> The token that users must pass to use the credentials.</p>
        pub fn set_session_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.session_token = input;
            self
        }
        /// <p> The Epoch time when the current credentials expire.</p>
        pub fn expiration(mut self, input: i64) -> Self {
            self.expiration = Some(input);
            self
        }
        /// <p> The Epoch time when the current credentials expire.</p>
        pub fn set_expiration(mut self, input: std::option::Option<i64>) -> Self {
            self.expiration = input;
            self
        }
        /// Consumes the builder and constructs a [`AwsCredentials`](crate::model::AwsCredentials).
        pub fn build(self) -> crate::model::AwsCredentials {
            crate::model::AwsCredentials {
                access_key_id: self.access_key_id,
                secret_access_key: self.secret_access_key,
                session_token: self.session_token,
                expiration: self.expiration.unwrap_or_default(),
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("access_key_id", &self.access_key_id);
            formatter.field("secret_access_key", &"*** Sensitive Data Redacted ***");
            formatter.field("session_token", &"*** Sensitive Data Redacted ***");
            formatter.field("expiration", &self.expiration);
            formatter.finish()
        }
    }
}
impl AwsCredentials {
    /// Creates a new builder-style object to manufacture [`AwsCredentials`](crate::model::AwsCredentials).
    pub fn builder() -> crate::model::aws_credentials::Builder {
        crate::model::aws_credentials::Builder::default()
    }
}

/// When writing a match expression against `DatasetStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let datasetstatus = unimplemented!();
/// match datasetstatus {
///     DatasetStatus::Failed => { /* ... */ },
///     DatasetStatus::Pending => { /* ... */ },
///     DatasetStatus::Running => { /* ... */ },
///     DatasetStatus::Success => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `datasetstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DatasetStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DatasetStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DatasetStatus::NewFeature` is defined.
/// Specifically, when `datasetstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DatasetStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// Status of the dataset process returned from scheduler service.
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DatasetStatus {
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Running,
    #[allow(missing_docs)] // documentation missing in model
    Success,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DatasetStatus {
    fn from(s: &str) -> Self {
        match s {
            "FAILED" => DatasetStatus::Failed,
            "PENDING" => DatasetStatus::Pending,
            "RUNNING" => DatasetStatus::Running,
            "SUCCESS" => DatasetStatus::Success,
            other => DatasetStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DatasetStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DatasetStatus::from(s))
    }
}
impl DatasetStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DatasetStatus::Failed => "FAILED",
            DatasetStatus::Pending => "PENDING",
            DatasetStatus::Running => "RUNNING",
            DatasetStatus::Success => "SUCCESS",
            DatasetStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["FAILED", "PENDING", "RUNNING", "SUCCESS"]
    }
}
impl AsRef<str> for DatasetStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Permission group parameters for Dataset permissions.</p>
/// <p>Here is an example of how you could specify the <code>PermissionGroupParams</code>:</p>
/// <p> <code> { "permissionGroupId": "0r6fCRtSTUk4XPfXQe3M0g", "datasetPermissions": [ {"permission": "ViewDatasetDetails"}, {"permission": "AddDatasetData"}, {"permission": "EditDatasetMetadata"}, {"permission": "DeleteDataset"} ] } </code> </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PermissionGroupParams {
    /// <p>The unique identifier for the <code>PermissionGroup</code>.</p>
    #[doc(hidden)]
    pub permission_group_id: std::option::Option<std::string::String>,
    /// <p>List of resource permissions.</p>
    #[doc(hidden)]
    pub dataset_permissions: std::option::Option<std::vec::Vec<crate::model::ResourcePermission>>,
}
impl PermissionGroupParams {
    /// <p>The unique identifier for the <code>PermissionGroup</code>.</p>
    pub fn permission_group_id(&self) -> std::option::Option<&str> {
        self.permission_group_id.as_deref()
    }
    /// <p>List of resource permissions.</p>
    pub fn dataset_permissions(&self) -> std::option::Option<&[crate::model::ResourcePermission]> {
        self.dataset_permissions.as_deref()
    }
}
/// See [`PermissionGroupParams`](crate::model::PermissionGroupParams).
pub mod permission_group_params {

    /// A builder for [`PermissionGroupParams`](crate::model::PermissionGroupParams).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) permission_group_id: std::option::Option<std::string::String>,
        pub(crate) dataset_permissions:
            std::option::Option<std::vec::Vec<crate::model::ResourcePermission>>,
    }
    impl Builder {
        /// <p>The unique identifier for the <code>PermissionGroup</code>.</p>
        pub fn permission_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.permission_group_id = Some(input.into());
            self
        }
        /// <p>The unique identifier for the <code>PermissionGroup</code>.</p>
        pub fn set_permission_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.permission_group_id = input;
            self
        }
        /// Appends an item to `dataset_permissions`.
        ///
        /// To override the contents of this collection use [`set_dataset_permissions`](Self::set_dataset_permissions).
        ///
        /// <p>List of resource permissions.</p>
        pub fn dataset_permissions(mut self, input: crate::model::ResourcePermission) -> Self {
            let mut v = self.dataset_permissions.unwrap_or_default();
            v.push(input);
            self.dataset_permissions = Some(v);
            self
        }
        /// <p>List of resource permissions.</p>
        pub fn set_dataset_permissions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ResourcePermission>>,
        ) -> Self {
            self.dataset_permissions = input;
            self
        }
        /// Consumes the builder and constructs a [`PermissionGroupParams`](crate::model::PermissionGroupParams).
        pub fn build(self) -> crate::model::PermissionGroupParams {
            crate::model::PermissionGroupParams {
                permission_group_id: self.permission_group_id,
                dataset_permissions: self.dataset_permissions,
            }
        }
    }
}
impl PermissionGroupParams {
    /// Creates a new builder-style object to manufacture [`PermissionGroupParams`](crate::model::PermissionGroupParams).
    pub fn builder() -> crate::model::permission_group_params::Builder {
        crate::model::permission_group_params::Builder::default()
    }
}

/// <p>Resource permission for a dataset. When you create a dataset, all the other members of the same user group inherit access to the dataset. You can only create a dataset if your user group has application permission for Create Datasets.</p>
/// <p>The following is a list of valid dataset permissions that you can apply: </p>
/// <ul>
/// <li> <p> <code>ViewDatasetDetails</code> </p> </li>
/// <li> <p> <code>ReadDatasetDetails</code> </p> </li>
/// <li> <p> <code>AddDatasetData</code> </p> </li>
/// <li> <p> <code>CreateDataView</code> </p> </li>
/// <li> <p> <code>EditDatasetMetadata</code> </p> </li>
/// <li> <p> <code>DeleteDataset</code> </p> </li>
/// </ul>
/// <p>For more information on the dataset permissions, see <a href="https://docs.aws.amazon.com/finspace/latest/userguide/managing-user-permissions.html#supported-dataset-permissions">Supported Dataset Permissions</a> in the FinSpace User Guide.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourcePermission {
    /// <p>Permission for a resource.</p>
    #[doc(hidden)]
    pub permission: std::option::Option<std::string::String>,
}
impl ResourcePermission {
    /// <p>Permission for a resource.</p>
    pub fn permission(&self) -> std::option::Option<&str> {
        self.permission.as_deref()
    }
}
/// See [`ResourcePermission`](crate::model::ResourcePermission).
pub mod resource_permission {

    /// A builder for [`ResourcePermission`](crate::model::ResourcePermission).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) permission: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Permission for a resource.</p>
        pub fn permission(mut self, input: impl Into<std::string::String>) -> Self {
            self.permission = Some(input.into());
            self
        }
        /// <p>Permission for a resource.</p>
        pub fn set_permission(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.permission = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourcePermission`](crate::model::ResourcePermission).
        pub fn build(self) -> crate::model::ResourcePermission {
            crate::model::ResourcePermission {
                permission: self.permission,
            }
        }
    }
}
impl ResourcePermission {
    /// Creates a new builder-style object to manufacture [`ResourcePermission`](crate::model::ResourcePermission).
    pub fn builder() -> crate::model::resource_permission::Builder {
        crate::model::resource_permission::Builder::default()
    }
}
