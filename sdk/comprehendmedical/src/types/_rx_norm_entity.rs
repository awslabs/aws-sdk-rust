// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned. </p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct RxNormEntity {
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub id: ::std::option::Option<i32>,
    /// <p>The segment of input text extracted from which the entity was detected.</p>
    pub text: ::std::option::Option<::std::string::String>,
    /// <p>The category of the entity. The recognized categories are <code>GENERIC</code> or <code>BRAND_NAME</code>.</p>
    pub category: ::std::option::Option<crate::types::RxNormEntityCategory>,
    /// <p> Describes the specific type of entity. For InferRxNorm, the recognized entity type is <code>MEDICATION</code>.</p>
    pub r#type: ::std::option::Option<crate::types::RxNormEntityType>,
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.</p>
    pub score: ::std::option::Option<f32>,
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.</p>
    pub begin_offset: ::std::option::Option<i32>,
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.</p>
    pub end_offset: ::std::option::Option<i32>,
    /// <p>The extracted attributes that relate to the entity. The attributes recognized by InferRxNorm are <code>DOSAGE</code>, <code>DURATION</code>, <code>FORM</code>, <code>FREQUENCY</code>, <code>RATE</code>, <code>ROUTE_OR_MODE</code>, and <code>STRENGTH</code>.</p>
    pub attributes: ::std::option::Option<::std::vec::Vec<crate::types::RxNormAttribute>>,
    /// <p>Contextual information for the entity.</p>
    pub traits: ::std::option::Option<::std::vec::Vec<crate::types::RxNormTrait>>,
    /// <p>The RxNorm concepts that the entity could refer to, along with a score indicating the likelihood of the match.</p>
    pub rx_norm_concepts: ::std::option::Option<::std::vec::Vec<crate::types::RxNormConcept>>,
}
impl RxNormEntity {
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn id(&self) -> ::std::option::Option<i32> {
        self.id
    }
    /// <p>The segment of input text extracted from which the entity was detected.</p>
    pub fn text(&self) -> ::std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The category of the entity. The recognized categories are <code>GENERIC</code> or <code>BRAND_NAME</code>.</p>
    pub fn category(&self) -> ::std::option::Option<&crate::types::RxNormEntityCategory> {
        self.category.as_ref()
    }
    /// <p> Describes the specific type of entity. For InferRxNorm, the recognized entity type is <code>MEDICATION</code>.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::RxNormEntityType> {
        self.r#type.as_ref()
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.</p>
    pub fn score(&self) -> ::std::option::Option<f32> {
        self.score
    }
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn begin_offset(&self) -> ::std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn end_offset(&self) -> ::std::option::Option<i32> {
        self.end_offset
    }
    /// <p>The extracted attributes that relate to the entity. The attributes recognized by InferRxNorm are <code>DOSAGE</code>, <code>DURATION</code>, <code>FORM</code>, <code>FREQUENCY</code>, <code>RATE</code>, <code>ROUTE_OR_MODE</code>, and <code>STRENGTH</code>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.attributes.is_none()`.
    pub fn attributes(&self) -> &[crate::types::RxNormAttribute] {
        self.attributes.as_deref().unwrap_or_default()
    }
    /// <p>Contextual information for the entity.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.traits.is_none()`.
    pub fn traits(&self) -> &[crate::types::RxNormTrait] {
        self.traits.as_deref().unwrap_or_default()
    }
    /// <p>The RxNorm concepts that the entity could refer to, along with a score indicating the likelihood of the match.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.rx_norm_concepts.is_none()`.
    pub fn rx_norm_concepts(&self) -> &[crate::types::RxNormConcept] {
        self.rx_norm_concepts.as_deref().unwrap_or_default()
    }
}
impl RxNormEntity {
    /// Creates a new builder-style object to manufacture [`RxNormEntity`](crate::types::RxNormEntity).
    pub fn builder() -> crate::types::builders::RxNormEntityBuilder {
        crate::types::builders::RxNormEntityBuilder::default()
    }
}

/// A builder for [`RxNormEntity`](crate::types::RxNormEntity).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct RxNormEntityBuilder {
    pub(crate) id: ::std::option::Option<i32>,
    pub(crate) text: ::std::option::Option<::std::string::String>,
    pub(crate) category: ::std::option::Option<crate::types::RxNormEntityCategory>,
    pub(crate) r#type: ::std::option::Option<crate::types::RxNormEntityType>,
    pub(crate) score: ::std::option::Option<f32>,
    pub(crate) begin_offset: ::std::option::Option<i32>,
    pub(crate) end_offset: ::std::option::Option<i32>,
    pub(crate) attributes: ::std::option::Option<::std::vec::Vec<crate::types::RxNormAttribute>>,
    pub(crate) traits: ::std::option::Option<::std::vec::Vec<crate::types::RxNormTrait>>,
    pub(crate) rx_norm_concepts: ::std::option::Option<::std::vec::Vec<crate::types::RxNormConcept>>,
}
impl RxNormEntityBuilder {
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn id(mut self, input: i32) -> Self {
        self.id = ::std::option::Option::Some(input);
        self
    }
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn set_id(mut self, input: ::std::option::Option<i32>) -> Self {
        self.id = input;
        self
    }
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn get_id(&self) -> &::std::option::Option<i32> {
        &self.id
    }
    /// <p>The segment of input text extracted from which the entity was detected.</p>
    pub fn text(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.text = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The segment of input text extracted from which the entity was detected.</p>
    pub fn set_text(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.text = input;
        self
    }
    /// <p>The segment of input text extracted from which the entity was detected.</p>
    pub fn get_text(&self) -> &::std::option::Option<::std::string::String> {
        &self.text
    }
    /// <p>The category of the entity. The recognized categories are <code>GENERIC</code> or <code>BRAND_NAME</code>.</p>
    pub fn category(mut self, input: crate::types::RxNormEntityCategory) -> Self {
        self.category = ::std::option::Option::Some(input);
        self
    }
    /// <p>The category of the entity. The recognized categories are <code>GENERIC</code> or <code>BRAND_NAME</code>.</p>
    pub fn set_category(mut self, input: ::std::option::Option<crate::types::RxNormEntityCategory>) -> Self {
        self.category = input;
        self
    }
    /// <p>The category of the entity. The recognized categories are <code>GENERIC</code> or <code>BRAND_NAME</code>.</p>
    pub fn get_category(&self) -> &::std::option::Option<crate::types::RxNormEntityCategory> {
        &self.category
    }
    /// <p> Describes the specific type of entity. For InferRxNorm, the recognized entity type is <code>MEDICATION</code>.</p>
    pub fn r#type(mut self, input: crate::types::RxNormEntityType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p> Describes the specific type of entity. For InferRxNorm, the recognized entity type is <code>MEDICATION</code>.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::RxNormEntityType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p> Describes the specific type of entity. For InferRxNorm, the recognized entity type is <code>MEDICATION</code>.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::RxNormEntityType> {
        &self.r#type
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.</p>
    pub fn score(mut self, input: f32) -> Self {
        self.score = ::std::option::Option::Some(input);
        self
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.</p>
    pub fn set_score(mut self, input: ::std::option::Option<f32>) -> Self {
        self.score = input;
        self
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detected entity.</p>
    pub fn get_score(&self) -> &::std::option::Option<f32> {
        &self.score
    }
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn begin_offset(mut self, input: i32) -> Self {
        self.begin_offset = ::std::option::Option::Some(input);
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn set_begin_offset(mut self, input: ::std::option::Option<i32>) -> Self {
        self.begin_offset = input;
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn get_begin_offset(&self) -> &::std::option::Option<i32> {
        &self.begin_offset
    }
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn end_offset(mut self, input: i32) -> Self {
        self.end_offset = ::std::option::Option::Some(input);
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn set_end_offset(mut self, input: ::std::option::Option<i32>) -> Self {
        self.end_offset = input;
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn get_end_offset(&self) -> &::std::option::Option<i32> {
        &self.end_offset
    }
    /// Appends an item to `attributes`.
    ///
    /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
    ///
    /// <p>The extracted attributes that relate to the entity. The attributes recognized by InferRxNorm are <code>DOSAGE</code>, <code>DURATION</code>, <code>FORM</code>, <code>FREQUENCY</code>, <code>RATE</code>, <code>ROUTE_OR_MODE</code>, and <code>STRENGTH</code>.</p>
    pub fn attributes(mut self, input: crate::types::RxNormAttribute) -> Self {
        let mut v = self.attributes.unwrap_or_default();
        v.push(input);
        self.attributes = ::std::option::Option::Some(v);
        self
    }
    /// <p>The extracted attributes that relate to the entity. The attributes recognized by InferRxNorm are <code>DOSAGE</code>, <code>DURATION</code>, <code>FORM</code>, <code>FREQUENCY</code>, <code>RATE</code>, <code>ROUTE_OR_MODE</code>, and <code>STRENGTH</code>.</p>
    pub fn set_attributes(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RxNormAttribute>>) -> Self {
        self.attributes = input;
        self
    }
    /// <p>The extracted attributes that relate to the entity. The attributes recognized by InferRxNorm are <code>DOSAGE</code>, <code>DURATION</code>, <code>FORM</code>, <code>FREQUENCY</code>, <code>RATE</code>, <code>ROUTE_OR_MODE</code>, and <code>STRENGTH</code>.</p>
    pub fn get_attributes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RxNormAttribute>> {
        &self.attributes
    }
    /// Appends an item to `traits`.
    ///
    /// To override the contents of this collection use [`set_traits`](Self::set_traits).
    ///
    /// <p>Contextual information for the entity.</p>
    pub fn traits(mut self, input: crate::types::RxNormTrait) -> Self {
        let mut v = self.traits.unwrap_or_default();
        v.push(input);
        self.traits = ::std::option::Option::Some(v);
        self
    }
    /// <p>Contextual information for the entity.</p>
    pub fn set_traits(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RxNormTrait>>) -> Self {
        self.traits = input;
        self
    }
    /// <p>Contextual information for the entity.</p>
    pub fn get_traits(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RxNormTrait>> {
        &self.traits
    }
    /// Appends an item to `rx_norm_concepts`.
    ///
    /// To override the contents of this collection use [`set_rx_norm_concepts`](Self::set_rx_norm_concepts).
    ///
    /// <p>The RxNorm concepts that the entity could refer to, along with a score indicating the likelihood of the match.</p>
    pub fn rx_norm_concepts(mut self, input: crate::types::RxNormConcept) -> Self {
        let mut v = self.rx_norm_concepts.unwrap_or_default();
        v.push(input);
        self.rx_norm_concepts = ::std::option::Option::Some(v);
        self
    }
    /// <p>The RxNorm concepts that the entity could refer to, along with a score indicating the likelihood of the match.</p>
    pub fn set_rx_norm_concepts(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::RxNormConcept>>) -> Self {
        self.rx_norm_concepts = input;
        self
    }
    /// <p>The RxNorm concepts that the entity could refer to, along with a score indicating the likelihood of the match.</p>
    pub fn get_rx_norm_concepts(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::RxNormConcept>> {
        &self.rx_norm_concepts
    }
    /// Consumes the builder and constructs a [`RxNormEntity`](crate::types::RxNormEntity).
    pub fn build(self) -> crate::types::RxNormEntity {
        crate::types::RxNormEntity {
            id: self.id,
            text: self.text,
            category: self.category,
            r#type: self.r#type,
            score: self.score,
            begin_offset: self.begin_offset,
            end_offset: self.end_offset,
            attributes: self.attributes,
            traits: self.traits,
            rx_norm_concepts: self.rx_norm_concepts,
        }
    }
}
