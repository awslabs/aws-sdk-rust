// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Icd10CmEntity {
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub id: ::std::option::Option<i32>,
    /// <p>The segment of input text that is matched to the detected entity.</p>
    pub text: ::std::option::Option<::std::string::String>,
    /// <p>The category of the entity. InferICD10CM detects entities in the <code>MEDICAL_CONDITION</code> category.</p>
    pub category: ::std::option::Option<crate::types::Icd10CmEntityCategory>,
    /// <p>Describes the specific type of entity with category of entities. InferICD10CM detects entities of the type <code>DX_NAME</code> and <code>TIME_EXPRESSION</code>.</p>
    pub r#type: ::std::option::Option<crate::types::Icd10CmEntityType>,
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.</p>
    pub score: ::std::option::Option<f32>,
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.</p>
    pub begin_offset: ::std::option::Option<i32>,
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.</p>
    pub end_offset: ::std::option::Option<i32>,
    /// <p>The detected attributes that relate to the entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the nature of a medical condition.</p>
    pub attributes: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmAttribute>>,
    /// <p>Provides Contextual information for the entity. The traits recognized by InferICD10CM are <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and <code>NEGATION.</code></p>
    pub traits: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmTrait>>,
    /// <p>The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.</p>
    pub icd10_cm_concepts: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmConcept>>,
}
impl Icd10CmEntity {
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn id(&self) -> ::std::option::Option<i32> {
        self.id
    }
    /// <p>The segment of input text that is matched to the detected entity.</p>
    pub fn text(&self) -> ::std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The category of the entity. InferICD10CM detects entities in the <code>MEDICAL_CONDITION</code> category.</p>
    pub fn category(&self) -> ::std::option::Option<&crate::types::Icd10CmEntityCategory> {
        self.category.as_ref()
    }
    /// <p>Describes the specific type of entity with category of entities. InferICD10CM detects entities of the type <code>DX_NAME</code> and <code>TIME_EXPRESSION</code>.</p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::Icd10CmEntityType> {
        self.r#type.as_ref()
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.</p>
    pub fn score(&self) -> ::std::option::Option<f32> {
        self.score
    }
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn begin_offset(&self) -> ::std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn end_offset(&self) -> ::std::option::Option<i32> {
        self.end_offset
    }
    /// <p>The detected attributes that relate to the entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the nature of a medical condition.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.attributes.is_none()`.
    pub fn attributes(&self) -> &[crate::types::Icd10CmAttribute] {
        self.attributes.as_deref().unwrap_or_default()
    }
    /// <p>Provides Contextual information for the entity. The traits recognized by InferICD10CM are <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and <code>NEGATION.</code></p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.traits.is_none()`.
    pub fn traits(&self) -> &[crate::types::Icd10CmTrait] {
        self.traits.as_deref().unwrap_or_default()
    }
    /// <p>The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.icd10_cm_concepts.is_none()`.
    pub fn icd10_cm_concepts(&self) -> &[crate::types::Icd10CmConcept] {
        self.icd10_cm_concepts.as_deref().unwrap_or_default()
    }
}
impl Icd10CmEntity {
    /// Creates a new builder-style object to manufacture [`Icd10CmEntity`](crate::types::Icd10CmEntity).
    pub fn builder() -> crate::types::builders::Icd10CmEntityBuilder {
        crate::types::builders::Icd10CmEntityBuilder::default()
    }
}

/// A builder for [`Icd10CmEntity`](crate::types::Icd10CmEntity).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct Icd10CmEntityBuilder {
    pub(crate) id: ::std::option::Option<i32>,
    pub(crate) text: ::std::option::Option<::std::string::String>,
    pub(crate) category: ::std::option::Option<crate::types::Icd10CmEntityCategory>,
    pub(crate) r#type: ::std::option::Option<crate::types::Icd10CmEntityType>,
    pub(crate) score: ::std::option::Option<f32>,
    pub(crate) begin_offset: ::std::option::Option<i32>,
    pub(crate) end_offset: ::std::option::Option<i32>,
    pub(crate) attributes: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmAttribute>>,
    pub(crate) traits: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmTrait>>,
    pub(crate) icd10_cm_concepts: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmConcept>>,
}
impl Icd10CmEntityBuilder {
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn id(mut self, input: i32) -> Self {
        self.id = ::std::option::Option::Some(input);
        self
    }
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn set_id(mut self, input: ::std::option::Option<i32>) -> Self {
        self.id = input;
        self
    }
    /// <p>The numeric identifier for the entity. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn get_id(&self) -> &::std::option::Option<i32> {
        &self.id
    }
    /// <p>The segment of input text that is matched to the detected entity.</p>
    pub fn text(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.text = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The segment of input text that is matched to the detected entity.</p>
    pub fn set_text(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.text = input;
        self
    }
    /// <p>The segment of input text that is matched to the detected entity.</p>
    pub fn get_text(&self) -> &::std::option::Option<::std::string::String> {
        &self.text
    }
    /// <p>The category of the entity. InferICD10CM detects entities in the <code>MEDICAL_CONDITION</code> category.</p>
    pub fn category(mut self, input: crate::types::Icd10CmEntityCategory) -> Self {
        self.category = ::std::option::Option::Some(input);
        self
    }
    /// <p>The category of the entity. InferICD10CM detects entities in the <code>MEDICAL_CONDITION</code> category.</p>
    pub fn set_category(mut self, input: ::std::option::Option<crate::types::Icd10CmEntityCategory>) -> Self {
        self.category = input;
        self
    }
    /// <p>The category of the entity. InferICD10CM detects entities in the <code>MEDICAL_CONDITION</code> category.</p>
    pub fn get_category(&self) -> &::std::option::Option<crate::types::Icd10CmEntityCategory> {
        &self.category
    }
    /// <p>Describes the specific type of entity with category of entities. InferICD10CM detects entities of the type <code>DX_NAME</code> and <code>TIME_EXPRESSION</code>.</p>
    pub fn r#type(mut self, input: crate::types::Icd10CmEntityType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Describes the specific type of entity with category of entities. InferICD10CM detects entities of the type <code>DX_NAME</code> and <code>TIME_EXPRESSION</code>.</p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::Icd10CmEntityType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>Describes the specific type of entity with category of entities. InferICD10CM detects entities of the type <code>DX_NAME</code> and <code>TIME_EXPRESSION</code>.</p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::Icd10CmEntityType> {
        &self.r#type
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.</p>
    pub fn score(mut self, input: f32) -> Self {
        self.score = ::std::option::Option::Some(input);
        self
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.</p>
    pub fn set_score(mut self, input: ::std::option::Option<f32>) -> Self {
        self.score = input;
        self
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has in the accuracy of the detection.</p>
    pub fn get_score(&self) -> &::std::option::Option<f32> {
        &self.score
    }
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn begin_offset(mut self, input: i32) -> Self {
        self.begin_offset = ::std::option::Option::Some(input);
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn set_begin_offset(mut self, input: ::std::option::Option<i32>) -> Self {
        self.begin_offset = input;
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the entity begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn get_begin_offset(&self) -> &::std::option::Option<i32> {
        &self.begin_offset
    }
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn end_offset(mut self, input: i32) -> Self {
        self.end_offset = ::std::option::Option::Some(input);
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn set_end_offset(mut self, input: ::std::option::Option<i32>) -> Self {
        self.end_offset = input;
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the entity ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn get_end_offset(&self) -> &::std::option::Option<i32> {
        &self.end_offset
    }
    /// Appends an item to `attributes`.
    ///
    /// To override the contents of this collection use [`set_attributes`](Self::set_attributes).
    ///
    /// <p>The detected attributes that relate to the entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the nature of a medical condition.</p>
    pub fn attributes(mut self, input: crate::types::Icd10CmAttribute) -> Self {
        let mut v = self.attributes.unwrap_or_default();
        v.push(input);
        self.attributes = ::std::option::Option::Some(v);
        self
    }
    /// <p>The detected attributes that relate to the entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the nature of a medical condition.</p>
    pub fn set_attributes(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmAttribute>>) -> Self {
        self.attributes = input;
        self
    }
    /// <p>The detected attributes that relate to the entity. An extracted segment of the text that is an attribute of an entity, or otherwise related to an entity, such as the nature of a medical condition.</p>
    pub fn get_attributes(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Icd10CmAttribute>> {
        &self.attributes
    }
    /// Appends an item to `traits`.
    ///
    /// To override the contents of this collection use [`set_traits`](Self::set_traits).
    ///
    /// <p>Provides Contextual information for the entity. The traits recognized by InferICD10CM are <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and <code>NEGATION.</code></p>
    pub fn traits(mut self, input: crate::types::Icd10CmTrait) -> Self {
        let mut v = self.traits.unwrap_or_default();
        v.push(input);
        self.traits = ::std::option::Option::Some(v);
        self
    }
    /// <p>Provides Contextual information for the entity. The traits recognized by InferICD10CM are <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and <code>NEGATION.</code></p>
    pub fn set_traits(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmTrait>>) -> Self {
        self.traits = input;
        self
    }
    /// <p>Provides Contextual information for the entity. The traits recognized by InferICD10CM are <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and <code>NEGATION.</code></p>
    pub fn get_traits(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Icd10CmTrait>> {
        &self.traits
    }
    /// Appends an item to `icd10_cm_concepts`.
    ///
    /// To override the contents of this collection use [`set_icd10_cm_concepts`](Self::set_icd10_cm_concepts).
    ///
    /// <p>The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.</p>
    pub fn icd10_cm_concepts(mut self, input: crate::types::Icd10CmConcept) -> Self {
        let mut v = self.icd10_cm_concepts.unwrap_or_default();
        v.push(input);
        self.icd10_cm_concepts = ::std::option::Option::Some(v);
        self
    }
    /// <p>The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.</p>
    pub fn set_icd10_cm_concepts(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmConcept>>) -> Self {
        self.icd10_cm_concepts = input;
        self
    }
    /// <p>The ICD-10-CM concepts that the entity could refer to, along with a score indicating the likelihood of the match.</p>
    pub fn get_icd10_cm_concepts(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Icd10CmConcept>> {
        &self.icd10_cm_concepts
    }
    /// Consumes the builder and constructs a [`Icd10CmEntity`](crate::types::Icd10CmEntity).
    pub fn build(self) -> crate::types::Icd10CmEntity {
        crate::types::Icd10CmEntity {
            id: self.id,
            text: self.text,
            category: self.category,
            r#type: self.r#type,
            score: self.score,
            begin_offset: self.begin_offset,
            end_offset: self.end_offset,
            attributes: self.attributes,
            traits: self.traits,
            icd10_cm_concepts: self.icd10_cm_concepts,
        }
    }
}
