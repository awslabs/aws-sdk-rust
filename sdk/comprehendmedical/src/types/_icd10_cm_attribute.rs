// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The detected attributes that relate to an entity. This includes an extracted segment of the text that is an attribute of an entity, or otherwise related to an entity. InferICD10CM detects the following attributes: <code>Direction</code>, <code>System, Organ or Site</code>, and <code>Acuity</code>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Icd10CmAttribute {
    /// <p>The type of attribute. InferICD10CM detects entities of the type <code>DX_NAME</code>. </p>
    pub r#type: ::std::option::Option<crate::types::Icd10CmAttributeType>,
    /// <p>The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.</p>
    pub score: ::std::option::Option<f32>,
    /// <p>The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.</p>
    pub relationship_score: ::std::option::Option<f32>,
    /// <p>The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub id: ::std::option::Option<i32>,
    /// <p>The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.</p>
    pub begin_offset: ::std::option::Option<i32>,
    /// <p>The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.</p>
    pub end_offset: ::std::option::Option<i32>,
    /// <p>The segment of input text which contains the detected attribute.</p>
    pub text: ::std::option::Option<::std::string::String>,
    /// <p>The contextual information for the attribute. The traits recognized by InferICD10CM are <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and <code>NEGATION</code>.</p>
    pub traits: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmTrait>>,
    /// <p>The category of attribute. Can be either of <code>DX_NAME</code> or <code>TIME_EXPRESSION</code>.</p>
    pub category: ::std::option::Option<crate::types::Icd10CmEntityType>,
    /// <p>The type of relationship between the entity and attribute. Type for the relationship can be either of <code>OVERLAP</code> or <code>SYSTEM_ORGAN_SITE</code>.</p>
    pub relationship_type: ::std::option::Option<crate::types::Icd10CmRelationshipType>,
}
impl Icd10CmAttribute {
    /// <p>The type of attribute. InferICD10CM detects entities of the type <code>DX_NAME</code>. </p>
    pub fn r#type(&self) -> ::std::option::Option<&crate::types::Icd10CmAttributeType> {
        self.r#type.as_ref()
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.</p>
    pub fn score(&self) -> ::std::option::Option<f32> {
        self.score
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.</p>
    pub fn relationship_score(&self) -> ::std::option::Option<f32> {
        self.relationship_score
    }
    /// <p>The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn id(&self) -> ::std::option::Option<i32> {
        self.id
    }
    /// <p>The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn begin_offset(&self) -> ::std::option::Option<i32> {
        self.begin_offset
    }
    /// <p>The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn end_offset(&self) -> ::std::option::Option<i32> {
        self.end_offset
    }
    /// <p>The segment of input text which contains the detected attribute.</p>
    pub fn text(&self) -> ::std::option::Option<&str> {
        self.text.as_deref()
    }
    /// <p>The contextual information for the attribute. The traits recognized by InferICD10CM are <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and <code>NEGATION</code>.</p>
    ///
    /// If no value was sent for this field, a default will be set. If you want to determine if no value was sent, use `.traits.is_none()`.
    pub fn traits(&self) -> &[crate::types::Icd10CmTrait] {
        self.traits.as_deref().unwrap_or_default()
    }
    /// <p>The category of attribute. Can be either of <code>DX_NAME</code> or <code>TIME_EXPRESSION</code>.</p>
    pub fn category(&self) -> ::std::option::Option<&crate::types::Icd10CmEntityType> {
        self.category.as_ref()
    }
    /// <p>The type of relationship between the entity and attribute. Type for the relationship can be either of <code>OVERLAP</code> or <code>SYSTEM_ORGAN_SITE</code>.</p>
    pub fn relationship_type(&self) -> ::std::option::Option<&crate::types::Icd10CmRelationshipType> {
        self.relationship_type.as_ref()
    }
}
impl Icd10CmAttribute {
    /// Creates a new builder-style object to manufacture [`Icd10CmAttribute`](crate::types::Icd10CmAttribute).
    pub fn builder() -> crate::types::builders::Icd10CmAttributeBuilder {
        crate::types::builders::Icd10CmAttributeBuilder::default()
    }
}

/// A builder for [`Icd10CmAttribute`](crate::types::Icd10CmAttribute).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct Icd10CmAttributeBuilder {
    pub(crate) r#type: ::std::option::Option<crate::types::Icd10CmAttributeType>,
    pub(crate) score: ::std::option::Option<f32>,
    pub(crate) relationship_score: ::std::option::Option<f32>,
    pub(crate) id: ::std::option::Option<i32>,
    pub(crate) begin_offset: ::std::option::Option<i32>,
    pub(crate) end_offset: ::std::option::Option<i32>,
    pub(crate) text: ::std::option::Option<::std::string::String>,
    pub(crate) traits: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmTrait>>,
    pub(crate) category: ::std::option::Option<crate::types::Icd10CmEntityType>,
    pub(crate) relationship_type: ::std::option::Option<crate::types::Icd10CmRelationshipType>,
}
impl Icd10CmAttributeBuilder {
    /// <p>The type of attribute. InferICD10CM detects entities of the type <code>DX_NAME</code>. </p>
    pub fn r#type(mut self, input: crate::types::Icd10CmAttributeType) -> Self {
        self.r#type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of attribute. InferICD10CM detects entities of the type <code>DX_NAME</code>. </p>
    pub fn set_type(mut self, input: ::std::option::Option<crate::types::Icd10CmAttributeType>) -> Self {
        self.r#type = input;
        self
    }
    /// <p>The type of attribute. InferICD10CM detects entities of the type <code>DX_NAME</code>. </p>
    pub fn get_type(&self) -> &::std::option::Option<crate::types::Icd10CmAttributeType> {
        &self.r#type
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.</p>
    pub fn score(mut self, input: f32) -> Self {
        self.score = ::std::option::Option::Some(input);
        self
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.</p>
    pub fn set_score(mut self, input: ::std::option::Option<f32>) -> Self {
        self.score = input;
        self
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has that the segment of text is correctly recognized as an attribute.</p>
    pub fn get_score(&self) -> &::std::option::Option<f32> {
        &self.score
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.</p>
    pub fn relationship_score(mut self, input: f32) -> Self {
        self.relationship_score = ::std::option::Option::Some(input);
        self
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.</p>
    pub fn set_relationship_score(mut self, input: ::std::option::Option<f32>) -> Self {
        self.relationship_score = input;
        self
    }
    /// <p>The level of confidence that Amazon Comprehend Medical has that this attribute is correctly related to this entity.</p>
    pub fn get_relationship_score(&self) -> &::std::option::Option<f32> {
        &self.relationship_score
    }
    /// <p>The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn id(mut self, input: i32) -> Self {
        self.id = ::std::option::Option::Some(input);
        self
    }
    /// <p>The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn set_id(mut self, input: ::std::option::Option<i32>) -> Self {
        self.id = input;
        self
    }
    /// <p>The numeric identifier for this attribute. This is a monotonically increasing id unique within this response rather than a global unique identifier.</p>
    pub fn get_id(&self) -> &::std::option::Option<i32> {
        &self.id
    }
    /// <p>The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn begin_offset(mut self, input: i32) -> Self {
        self.begin_offset = ::std::option::Option::Some(input);
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn set_begin_offset(mut self, input: ::std::option::Option<i32>) -> Self {
        self.begin_offset = input;
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the attribute begins. The offset returns the UTF-8 code point in the string.</p>
    pub fn get_begin_offset(&self) -> &::std::option::Option<i32> {
        &self.begin_offset
    }
    /// <p>The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn end_offset(mut self, input: i32) -> Self {
        self.end_offset = ::std::option::Option::Some(input);
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn set_end_offset(mut self, input: ::std::option::Option<i32>) -> Self {
        self.end_offset = input;
        self
    }
    /// <p>The 0-based character offset in the input text that shows where the attribute ends. The offset returns the UTF-8 code point in the string.</p>
    pub fn get_end_offset(&self) -> &::std::option::Option<i32> {
        &self.end_offset
    }
    /// <p>The segment of input text which contains the detected attribute.</p>
    pub fn text(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.text = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The segment of input text which contains the detected attribute.</p>
    pub fn set_text(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.text = input;
        self
    }
    /// <p>The segment of input text which contains the detected attribute.</p>
    pub fn get_text(&self) -> &::std::option::Option<::std::string::String> {
        &self.text
    }
    /// Appends an item to `traits`.
    ///
    /// To override the contents of this collection use [`set_traits`](Self::set_traits).
    ///
    /// <p>The contextual information for the attribute. The traits recognized by InferICD10CM are <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and <code>NEGATION</code>.</p>
    pub fn traits(mut self, input: crate::types::Icd10CmTrait) -> Self {
        let mut v = self.traits.unwrap_or_default();
        v.push(input);
        self.traits = ::std::option::Option::Some(v);
        self
    }
    /// <p>The contextual information for the attribute. The traits recognized by InferICD10CM are <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and <code>NEGATION</code>.</p>
    pub fn set_traits(mut self, input: ::std::option::Option<::std::vec::Vec<crate::types::Icd10CmTrait>>) -> Self {
        self.traits = input;
        self
    }
    /// <p>The contextual information for the attribute. The traits recognized by InferICD10CM are <code>DIAGNOSIS</code>, <code>SIGN</code>, <code>SYMPTOM</code>, and <code>NEGATION</code>.</p>
    pub fn get_traits(&self) -> &::std::option::Option<::std::vec::Vec<crate::types::Icd10CmTrait>> {
        &self.traits
    }
    /// <p>The category of attribute. Can be either of <code>DX_NAME</code> or <code>TIME_EXPRESSION</code>.</p>
    pub fn category(mut self, input: crate::types::Icd10CmEntityType) -> Self {
        self.category = ::std::option::Option::Some(input);
        self
    }
    /// <p>The category of attribute. Can be either of <code>DX_NAME</code> or <code>TIME_EXPRESSION</code>.</p>
    pub fn set_category(mut self, input: ::std::option::Option<crate::types::Icd10CmEntityType>) -> Self {
        self.category = input;
        self
    }
    /// <p>The category of attribute. Can be either of <code>DX_NAME</code> or <code>TIME_EXPRESSION</code>.</p>
    pub fn get_category(&self) -> &::std::option::Option<crate::types::Icd10CmEntityType> {
        &self.category
    }
    /// <p>The type of relationship between the entity and attribute. Type for the relationship can be either of <code>OVERLAP</code> or <code>SYSTEM_ORGAN_SITE</code>.</p>
    pub fn relationship_type(mut self, input: crate::types::Icd10CmRelationshipType) -> Self {
        self.relationship_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The type of relationship between the entity and attribute. Type for the relationship can be either of <code>OVERLAP</code> or <code>SYSTEM_ORGAN_SITE</code>.</p>
    pub fn set_relationship_type(mut self, input: ::std::option::Option<crate::types::Icd10CmRelationshipType>) -> Self {
        self.relationship_type = input;
        self
    }
    /// <p>The type of relationship between the entity and attribute. Type for the relationship can be either of <code>OVERLAP</code> or <code>SYSTEM_ORGAN_SITE</code>.</p>
    pub fn get_relationship_type(&self) -> &::std::option::Option<crate::types::Icd10CmRelationshipType> {
        &self.relationship_type
    }
    /// Consumes the builder and constructs a [`Icd10CmAttribute`](crate::types::Icd10CmAttribute).
    pub fn build(self) -> crate::types::Icd10CmAttribute {
        crate::types::Icd10CmAttribute {
            r#type: self.r#type,
            score: self.score,
            relationship_score: self.relationship_score,
            id: self.id,
            begin_offset: self.begin_offset,
            end_offset: self.end_offset,
            text: self.text,
            traits: self.traits,
            category: self.category,
            relationship_type: self.relationship_type,
        }
    }
}
