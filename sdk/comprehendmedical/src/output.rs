// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopRxNormInferenceJobOutput {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with
    /// the <code>DescribeRxNormInferenceJob</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopRxNormInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopRxNormInferenceJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StopRxNormInferenceJobOutput`](crate::output::StopRxNormInferenceJobOutput)
pub mod stop_rx_norm_inference_job_output {
    /// A builder for [`StopRxNormInferenceJobOutput`](crate::output::StopRxNormInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with
        /// the <code>DescribeRxNormInferenceJob</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with
        /// the <code>DescribeRxNormInferenceJob</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopRxNormInferenceJobOutput`](crate::output::StopRxNormInferenceJobOutput)
        pub fn build(self) -> crate::output::StopRxNormInferenceJobOutput {
            crate::output::StopRxNormInferenceJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StopRxNormInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`StopRxNormInferenceJobOutput`](crate::output::StopRxNormInferenceJobOutput)
    pub fn builder() -> crate::output::stop_rx_norm_inference_job_output::Builder {
        crate::output::stop_rx_norm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopPhiDetectionJobOutput {
    /// <p>The identifier of the PHI detection job that was stopped.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopPhiDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopPhiDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StopPhiDetectionJobOutput`](crate::output::StopPhiDetectionJobOutput)
pub mod stop_phi_detection_job_output {
    /// A builder for [`StopPhiDetectionJobOutput`](crate::output::StopPhiDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the PHI detection job that was stopped.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the PHI detection job that was stopped.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopPhiDetectionJobOutput`](crate::output::StopPhiDetectionJobOutput)
        pub fn build(self) -> crate::output::StopPhiDetectionJobOutput {
            crate::output::StopPhiDetectionJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StopPhiDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopPhiDetectionJobOutput`](crate::output::StopPhiDetectionJobOutput)
    pub fn builder() -> crate::output::stop_phi_detection_job_output::Builder {
        crate::output::stop_phi_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopIcd10CmInferenceJobOutput {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with
    /// the <code>DescribeICD10CMInferenceJob</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopIcd10CmInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopIcd10CmInferenceJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StopIcd10CmInferenceJobOutput`](crate::output::StopIcd10CmInferenceJobOutput)
pub mod stop_icd10_cm_inference_job_output {
    /// A builder for [`StopIcd10CmInferenceJobOutput`](crate::output::StopIcd10CmInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with
        /// the <code>DescribeICD10CMInferenceJob</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with
        /// the <code>DescribeICD10CMInferenceJob</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopIcd10CmInferenceJobOutput`](crate::output::StopIcd10CmInferenceJobOutput)
        pub fn build(self) -> crate::output::StopIcd10CmInferenceJobOutput {
            crate::output::StopIcd10CmInferenceJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StopIcd10CmInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`StopIcd10CmInferenceJobOutput`](crate::output::StopIcd10CmInferenceJobOutput)
    pub fn builder() -> crate::output::stop_icd10_cm_inference_job_output::Builder {
        crate::output::stop_icd10_cm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopEntitiesDetectionV2JobOutput {
    /// <p>The identifier of the medical entities detection job that was stopped.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopEntitiesDetectionV2JobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopEntitiesDetectionV2JobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StopEntitiesDetectionV2JobOutput`](crate::output::StopEntitiesDetectionV2JobOutput)
pub mod stop_entities_detection_v2_job_output {
    /// A builder for [`StopEntitiesDetectionV2JobOutput`](crate::output::StopEntitiesDetectionV2JobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the medical entities detection job that was stopped.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the medical entities detection job that was stopped.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopEntitiesDetectionV2JobOutput`](crate::output::StopEntitiesDetectionV2JobOutput)
        pub fn build(self) -> crate::output::StopEntitiesDetectionV2JobOutput {
            crate::output::StopEntitiesDetectionV2JobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StopEntitiesDetectionV2JobOutput {
    /// Creates a new builder-style object to manufacture [`StopEntitiesDetectionV2JobOutput`](crate::output::StopEntitiesDetectionV2JobOutput)
    pub fn builder() -> crate::output::stop_entities_detection_v2_job_output::Builder {
        crate::output::stop_entities_detection_v2_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartRxNormInferenceJobOutput {
    /// <p>The identifier of the job.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartRxNormInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartRxNormInferenceJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StartRxNormInferenceJobOutput`](crate::output::StartRxNormInferenceJobOutput)
pub mod start_rx_norm_inference_job_output {
    /// A builder for [`StartRxNormInferenceJobOutput`](crate::output::StartRxNormInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartRxNormInferenceJobOutput`](crate::output::StartRxNormInferenceJobOutput)
        pub fn build(self) -> crate::output::StartRxNormInferenceJobOutput {
            crate::output::StartRxNormInferenceJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StartRxNormInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`StartRxNormInferenceJobOutput`](crate::output::StartRxNormInferenceJobOutput)
    pub fn builder() -> crate::output::start_rx_norm_inference_job_output::Builder {
        crate::output::start_rx_norm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartPhiDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    /// the <code>DescribePHIDetectionJob</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartPhiDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartPhiDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StartPhiDetectionJobOutput`](crate::output::StartPhiDetectionJobOutput)
pub mod start_phi_detection_job_output {
    /// A builder for [`StartPhiDetectionJobOutput`](crate::output::StartPhiDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
        /// the <code>DescribePHIDetectionJob</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
        /// the <code>DescribePHIDetectionJob</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartPhiDetectionJobOutput`](crate::output::StartPhiDetectionJobOutput)
        pub fn build(self) -> crate::output::StartPhiDetectionJobOutput {
            crate::output::StartPhiDetectionJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StartPhiDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartPhiDetectionJobOutput`](crate::output::StartPhiDetectionJobOutput)
    pub fn builder() -> crate::output::start_phi_detection_job_output::Builder {
        crate::output::start_phi_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartIcd10CmInferenceJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    /// the <code>StartICD10CMInferenceJob</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartIcd10CmInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartIcd10CmInferenceJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StartIcd10CmInferenceJobOutput`](crate::output::StartIcd10CmInferenceJobOutput)
pub mod start_icd10_cm_inference_job_output {
    /// A builder for [`StartIcd10CmInferenceJobOutput`](crate::output::StartIcd10CmInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
        /// the <code>StartICD10CMInferenceJob</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
        /// the <code>StartICD10CMInferenceJob</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartIcd10CmInferenceJobOutput`](crate::output::StartIcd10CmInferenceJobOutput)
        pub fn build(self) -> crate::output::StartIcd10CmInferenceJobOutput {
            crate::output::StartIcd10CmInferenceJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StartIcd10CmInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`StartIcd10CmInferenceJobOutput`](crate::output::StartIcd10CmInferenceJobOutput)
    pub fn builder() -> crate::output::start_icd10_cm_inference_job_output::Builder {
        crate::output::start_icd10_cm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartEntitiesDetectionV2JobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
    /// the <code>DescribeEntitiesDetectionV2Job</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StartEntitiesDetectionV2JobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartEntitiesDetectionV2JobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StartEntitiesDetectionV2JobOutput`](crate::output::StartEntitiesDetectionV2JobOutput)
pub mod start_entities_detection_v2_job_output {
    /// A builder for [`StartEntitiesDetectionV2JobOutput`](crate::output::StartEntitiesDetectionV2JobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
        /// the <code>DescribeEntitiesDetectionV2Job</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with
        /// the <code>DescribeEntitiesDetectionV2Job</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartEntitiesDetectionV2JobOutput`](crate::output::StartEntitiesDetectionV2JobOutput)
        pub fn build(self) -> crate::output::StartEntitiesDetectionV2JobOutput {
            crate::output::StartEntitiesDetectionV2JobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StartEntitiesDetectionV2JobOutput {
    /// Creates a new builder-style object to manufacture [`StartEntitiesDetectionV2JobOutput`](crate::output::StartEntitiesDetectionV2JobOutput)
    pub fn builder() -> crate::output::start_entities_detection_v2_job_output::Builder {
        crate::output::start_entities_detection_v2_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRxNormInferenceJobsOutput {
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    pub comprehend_medical_async_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListRxNormInferenceJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRxNormInferenceJobsOutput");
        formatter.field(
            "comprehend_medical_async_job_properties_list",
            &self.comprehend_medical_async_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListRxNormInferenceJobsOutput`](crate::output::ListRxNormInferenceJobsOutput)
pub mod list_rx_norm_inference_jobs_output {
    /// A builder for [`ListRxNormInferenceJobsOutput`](crate::output::ListRxNormInferenceJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `comprehend_medical_async_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_comprehend_medical_async_job_properties_list`](Self::set_comprehend_medical_async_job_properties_list).
        ///
        /// <p>The maximum number of results to return in each page. The default is 100.</p>
        pub fn comprehend_medical_async_job_properties_list(
            mut self,
            input: impl Into<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            let mut v = self
                .comprehend_medical_async_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.comprehend_medical_async_job_properties_list = Some(v);
            self
        }
        /// <p>The maximum number of results to return in each page. The default is 100.</p>
        pub fn set_comprehend_medical_async_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>,
            >,
        ) -> Self {
            self.comprehend_medical_async_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRxNormInferenceJobsOutput`](crate::output::ListRxNormInferenceJobsOutput)
        pub fn build(self) -> crate::output::ListRxNormInferenceJobsOutput {
            crate::output::ListRxNormInferenceJobsOutput {
                comprehend_medical_async_job_properties_list: self
                    .comprehend_medical_async_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListRxNormInferenceJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListRxNormInferenceJobsOutput`](crate::output::ListRxNormInferenceJobsOutput)
    pub fn builder() -> crate::output::list_rx_norm_inference_jobs_output::Builder {
        crate::output::list_rx_norm_inference_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPhiDetectionJobsOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub comprehend_medical_async_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListPhiDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPhiDetectionJobsOutput");
        formatter.field(
            "comprehend_medical_async_job_properties_list",
            &self.comprehend_medical_async_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListPhiDetectionJobsOutput`](crate::output::ListPhiDetectionJobsOutput)
pub mod list_phi_detection_jobs_output {
    /// A builder for [`ListPhiDetectionJobsOutput`](crate::output::ListPhiDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `comprehend_medical_async_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_comprehend_medical_async_job_properties_list`](Self::set_comprehend_medical_async_job_properties_list).
        ///
        /// <p>A list containing the properties of each job returned.</p>
        pub fn comprehend_medical_async_job_properties_list(
            mut self,
            input: impl Into<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            let mut v = self
                .comprehend_medical_async_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.comprehend_medical_async_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job returned.</p>
        pub fn set_comprehend_medical_async_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>,
            >,
        ) -> Self {
            self.comprehend_medical_async_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPhiDetectionJobsOutput`](crate::output::ListPhiDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListPhiDetectionJobsOutput {
            crate::output::ListPhiDetectionJobsOutput {
                comprehend_medical_async_job_properties_list: self
                    .comprehend_medical_async_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListPhiDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListPhiDetectionJobsOutput`](crate::output::ListPhiDetectionJobsOutput)
    pub fn builder() -> crate::output::list_phi_detection_jobs_output::Builder {
        crate::output::list_phi_detection_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListIcd10CmInferenceJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub comprehend_medical_async_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListIcd10CmInferenceJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListIcd10CmInferenceJobsOutput");
        formatter.field(
            "comprehend_medical_async_job_properties_list",
            &self.comprehend_medical_async_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListIcd10CmInferenceJobsOutput`](crate::output::ListIcd10CmInferenceJobsOutput)
pub mod list_icd10_cm_inference_jobs_output {
    /// A builder for [`ListIcd10CmInferenceJobsOutput`](crate::output::ListIcd10CmInferenceJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `comprehend_medical_async_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_comprehend_medical_async_job_properties_list`](Self::set_comprehend_medical_async_job_properties_list).
        ///
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn comprehend_medical_async_job_properties_list(
            mut self,
            input: impl Into<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            let mut v = self
                .comprehend_medical_async_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.comprehend_medical_async_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn set_comprehend_medical_async_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>,
            >,
        ) -> Self {
            self.comprehend_medical_async_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListIcd10CmInferenceJobsOutput`](crate::output::ListIcd10CmInferenceJobsOutput)
        pub fn build(self) -> crate::output::ListIcd10CmInferenceJobsOutput {
            crate::output::ListIcd10CmInferenceJobsOutput {
                comprehend_medical_async_job_properties_list: self
                    .comprehend_medical_async_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListIcd10CmInferenceJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListIcd10CmInferenceJobsOutput`](crate::output::ListIcd10CmInferenceJobsOutput)
    pub fn builder() -> crate::output::list_icd10_cm_inference_jobs_output::Builder {
        crate::output::list_icd10_cm_inference_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEntitiesDetectionV2JobsOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub comprehend_medical_async_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListEntitiesDetectionV2JobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEntitiesDetectionV2JobsOutput");
        formatter.field(
            "comprehend_medical_async_job_properties_list",
            &self.comprehend_medical_async_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEntitiesDetectionV2JobsOutput`](crate::output::ListEntitiesDetectionV2JobsOutput)
pub mod list_entities_detection_v2_jobs_output {
    /// A builder for [`ListEntitiesDetectionV2JobsOutput`](crate::output::ListEntitiesDetectionV2JobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `comprehend_medical_async_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_comprehend_medical_async_job_properties_list`](Self::set_comprehend_medical_async_job_properties_list).
        ///
        /// <p>A list containing the properties of each job returned.</p>
        pub fn comprehend_medical_async_job_properties_list(
            mut self,
            input: impl Into<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            let mut v = self
                .comprehend_medical_async_job_properties_list
                .unwrap_or_default();
            v.push(input.into());
            self.comprehend_medical_async_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job returned.</p>
        pub fn set_comprehend_medical_async_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>,
            >,
        ) -> Self {
            self.comprehend_medical_async_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEntitiesDetectionV2JobsOutput`](crate::output::ListEntitiesDetectionV2JobsOutput)
        pub fn build(self) -> crate::output::ListEntitiesDetectionV2JobsOutput {
            crate::output::ListEntitiesDetectionV2JobsOutput {
                comprehend_medical_async_job_properties_list: self
                    .comprehend_medical_async_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEntitiesDetectionV2JobsOutput {
    /// Creates a new builder-style object to manufacture [`ListEntitiesDetectionV2JobsOutput`](crate::output::ListEntitiesDetectionV2JobsOutput)
    pub fn builder() -> crate::output::list_entities_detection_v2_jobs_output::Builder {
        crate::output::list_entities_detection_v2_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferRxNormOutput {
    /// <p>The medication entities detected in the text linked to RxNorm concepts. If the action is
    /// successful, the service sends back an HTTP 200 response, as well as the entities
    /// detected.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::RxNormEntity>>,
    /// <p>If the result of the previous request to <code>InferRxNorm</code> was truncated, include
    /// the <code>PaginationToken</code> to fetch the next page of medication entities.</p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>The version of the model used to analyze the documents, in the format
    /// <i>n</i>.<i>n</i>.<i>n</i> You can use this
    /// information to track the model used for a particular batch of documents.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InferRxNormOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferRxNormOutput");
        formatter.field("entities", &self.entities);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`InferRxNormOutput`](crate::output::InferRxNormOutput)
pub mod infer_rx_norm_output {
    /// A builder for [`InferRxNormOutput`](crate::output::InferRxNormOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::RxNormEntity>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>The medication entities detected in the text linked to RxNorm concepts. If the action is
        /// successful, the service sends back an HTTP 200 response, as well as the entities
        /// detected.</p>
        pub fn entities(mut self, input: impl Into<crate::model::RxNormEntity>) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input.into());
            self.entities = Some(v);
            self
        }
        /// <p>The medication entities detected in the text linked to RxNorm concepts. If the action is
        /// successful, the service sends back an HTTP 200 response, as well as the entities
        /// detected.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RxNormEntity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// <p>If the result of the previous request to <code>InferRxNorm</code> was truncated, include
        /// the <code>PaginationToken</code> to fetch the next page of medication entities.</p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p>If the result of the previous request to <code>InferRxNorm</code> was truncated, include
        /// the <code>PaginationToken</code> to fetch the next page of medication entities.</p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>The version of the model used to analyze the documents, in the format
        /// <i>n</i>.<i>n</i>.<i>n</i> You can use this
        /// information to track the model used for a particular batch of documents.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used to analyze the documents, in the format
        /// <i>n</i>.<i>n</i>.<i>n</i> You can use this
        /// information to track the model used for a particular batch of documents.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`InferRxNormOutput`](crate::output::InferRxNormOutput)
        pub fn build(self) -> crate::output::InferRxNormOutput {
            crate::output::InferRxNormOutput {
                entities: self.entities,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
            }
        }
    }
}
impl InferRxNormOutput {
    /// Creates a new builder-style object to manufacture [`InferRxNormOutput`](crate::output::InferRxNormOutput)
    pub fn builder() -> crate::output::infer_rx_norm_output::Builder {
        crate::output::infer_rx_norm_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferIcd10CmOutput {
    /// <p>The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is
    /// successful, the service sends back an HTTP 200 response, as well as the entities
    /// detected.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::Icd10CmEntity>>,
    /// <p>If the result of the previous request to <code>InferICD10CM</code> was truncated, include
    /// the <code>PaginationToken</code> to fetch the next page of medical condition entities. </p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>The version of the model used to analyze the documents, in the format
    /// <i>n</i>.<i>n</i>.<i>n</i> You can use this
    /// information to track the model used for a particular batch of documents.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InferIcd10CmOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferIcd10CmOutput");
        formatter.field("entities", &self.entities);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`InferIcd10CmOutput`](crate::output::InferIcd10CmOutput)
pub mod infer_icd10_cm_output {
    /// A builder for [`InferIcd10CmOutput`](crate::output::InferIcd10CmOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Icd10CmEntity>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is
        /// successful, the service sends back an HTTP 200 response, as well as the entities
        /// detected.</p>
        pub fn entities(mut self, input: impl Into<crate::model::Icd10CmEntity>) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input.into());
            self.entities = Some(v);
            self
        }
        /// <p>The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is
        /// successful, the service sends back an HTTP 200 response, as well as the entities
        /// detected.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Icd10CmEntity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// <p>If the result of the previous request to <code>InferICD10CM</code> was truncated, include
        /// the <code>PaginationToken</code> to fetch the next page of medical condition entities. </p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p>If the result of the previous request to <code>InferICD10CM</code> was truncated, include
        /// the <code>PaginationToken</code> to fetch the next page of medical condition entities. </p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>The version of the model used to analyze the documents, in the format
        /// <i>n</i>.<i>n</i>.<i>n</i> You can use this
        /// information to track the model used for a particular batch of documents.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used to analyze the documents, in the format
        /// <i>n</i>.<i>n</i>.<i>n</i> You can use this
        /// information to track the model used for a particular batch of documents.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`InferIcd10CmOutput`](crate::output::InferIcd10CmOutput)
        pub fn build(self) -> crate::output::InferIcd10CmOutput {
            crate::output::InferIcd10CmOutput {
                entities: self.entities,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
            }
        }
    }
}
impl InferIcd10CmOutput {
    /// Creates a new builder-style object to manufacture [`InferIcd10CmOutput`](crate::output::InferIcd10CmOutput)
    pub fn builder() -> crate::output::infer_icd10_cm_output::Builder {
        crate::output::infer_icd10_cm_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectPhiOutput {
    /// <p> The collection of PHI entities extracted from the input text and their associated
    /// information. For each entity, the response provides the entity text, the entity category,
    /// where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in its
    /// detection. </p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    /// <p> If the result of the previous request to <code>DetectPHI</code> was truncated, include
    /// the <code>PaginationToken</code> to fetch the next page of PHI entities. </p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>The version of the model used to analyze the documents. The version number looks like
    /// X.X.X. You can use this information to track the model used for a particular batch of
    /// documents.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DetectPhiOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectPhiOutput");
        formatter.field("entities", &self.entities);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`DetectPhiOutput`](crate::output::DetectPhiOutput)
pub mod detect_phi_output {
    /// A builder for [`DetectPhiOutput`](crate::output::DetectPhiOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p> The collection of PHI entities extracted from the input text and their associated
        /// information. For each entity, the response provides the entity text, the entity category,
        /// where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in its
        /// detection. </p>
        pub fn entities(mut self, input: impl Into<crate::model::Entity>) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input.into());
            self.entities = Some(v);
            self
        }
        /// <p> The collection of PHI entities extracted from the input text and their associated
        /// information. For each entity, the response provides the entity text, the entity category,
        /// where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in its
        /// detection. </p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// <p> If the result of the previous request to <code>DetectPHI</code> was truncated, include
        /// the <code>PaginationToken</code> to fetch the next page of PHI entities. </p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p> If the result of the previous request to <code>DetectPHI</code> was truncated, include
        /// the <code>PaginationToken</code> to fetch the next page of PHI entities. </p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like
        /// X.X.X. You can use this information to track the model used for a particular batch of
        /// documents.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like
        /// X.X.X. You can use this information to track the model used for a particular batch of
        /// documents.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectPhiOutput`](crate::output::DetectPhiOutput)
        pub fn build(self) -> crate::output::DetectPhiOutput {
            crate::output::DetectPhiOutput {
                entities: self.entities,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
            }
        }
    }
}
impl DetectPhiOutput {
    /// Creates a new builder-style object to manufacture [`DetectPhiOutput`](crate::output::DetectPhiOutput)
    pub fn builder() -> crate::output::detect_phi_output::Builder {
        crate::output::detect_phi_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectEntitiesV2Output {
    /// <p>The collection of medical entities extracted from the input text and their associated
    /// information. For each entity, the response provides the entity text, the entity category,
    /// where the entity text begins and ends, and the level of confidence in the detection and
    /// analysis. Attributes and traits of the entity are also returned.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    /// <p>Attributes extracted from the input text that couldn't be related to an entity.</p>
    pub unmapped_attributes: std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
    /// <p>If the result to the <code>DetectEntitiesV2</code> operation was truncated, include the
    /// <code>PaginationToken</code> to fetch the next page of entities.</p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>The version of the model used to analyze the documents. The version number looks like
    /// X.X.X. You can use this information to track the model used for a particular batch of
    /// documents.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DetectEntitiesV2Output {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectEntitiesV2Output");
        formatter.field("entities", &self.entities);
        formatter.field("unmapped_attributes", &self.unmapped_attributes);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`DetectEntitiesV2Output`](crate::output::DetectEntitiesV2Output)
pub mod detect_entities_v2_output {
    /// A builder for [`DetectEntitiesV2Output`](crate::output::DetectEntitiesV2Output)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        pub(crate) unmapped_attributes:
            std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>The collection of medical entities extracted from the input text and their associated
        /// information. For each entity, the response provides the entity text, the entity category,
        /// where the entity text begins and ends, and the level of confidence in the detection and
        /// analysis. Attributes and traits of the entity are also returned.</p>
        pub fn entities(mut self, input: impl Into<crate::model::Entity>) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input.into());
            self.entities = Some(v);
            self
        }
        /// <p>The collection of medical entities extracted from the input text and their associated
        /// information. For each entity, the response provides the entity text, the entity category,
        /// where the entity text begins and ends, and the level of confidence in the detection and
        /// analysis. Attributes and traits of the entity are also returned.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Appends an item to `unmapped_attributes`.
        ///
        /// To override the contents of this collection use [`set_unmapped_attributes`](Self::set_unmapped_attributes).
        ///
        /// <p>Attributes extracted from the input text that couldn't be related to an entity.</p>
        pub fn unmapped_attributes(
            mut self,
            input: impl Into<crate::model::UnmappedAttribute>,
        ) -> Self {
            let mut v = self.unmapped_attributes.unwrap_or_default();
            v.push(input.into());
            self.unmapped_attributes = Some(v);
            self
        }
        /// <p>Attributes extracted from the input text that couldn't be related to an entity.</p>
        pub fn set_unmapped_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
        ) -> Self {
            self.unmapped_attributes = input;
            self
        }
        /// <p>If the result to the <code>DetectEntitiesV2</code> operation was truncated, include the
        /// <code>PaginationToken</code> to fetch the next page of entities.</p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p>If the result to the <code>DetectEntitiesV2</code> operation was truncated, include the
        /// <code>PaginationToken</code> to fetch the next page of entities.</p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like
        /// X.X.X. You can use this information to track the model used for a particular batch of
        /// documents.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like
        /// X.X.X. You can use this information to track the model used for a particular batch of
        /// documents.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectEntitiesV2Output`](crate::output::DetectEntitiesV2Output)
        pub fn build(self) -> crate::output::DetectEntitiesV2Output {
            crate::output::DetectEntitiesV2Output {
                entities: self.entities,
                unmapped_attributes: self.unmapped_attributes,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
            }
        }
    }
}
impl DetectEntitiesV2Output {
    /// Creates a new builder-style object to manufacture [`DetectEntitiesV2Output`](crate::output::DetectEntitiesV2Output)
    pub fn builder() -> crate::output::detect_entities_v2_output::Builder {
        crate::output::detect_entities_v2_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectEntitiesOutput {
    /// <p> The collection of medical entities extracted from the input text and their associated
    /// information. For each entity, the response provides the entity text, the entity category,
    /// where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the
    /// detection and analysis. Attributes and traits of the entity are also returned.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    /// <p> Attributes extracted from the input text that we were unable to relate to an
    /// entity.</p>
    pub unmapped_attributes: std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
    /// <p> If the result of the previous request to <code>DetectEntities</code> was truncated,
    /// include the <code>PaginationToken</code> to fetch the next page of entities.</p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>The version of the model used to analyze the documents. The version number looks like
    /// X.X.X. You can use this information to track the model used for a particular batch of
    /// documents.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DetectEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectEntitiesOutput");
        formatter.field("entities", &self.entities);
        formatter.field("unmapped_attributes", &self.unmapped_attributes);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
pub mod detect_entities_output {
    /// A builder for [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        pub(crate) unmapped_attributes:
            std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p> The collection of medical entities extracted from the input text and their associated
        /// information. For each entity, the response provides the entity text, the entity category,
        /// where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the
        /// detection and analysis. Attributes and traits of the entity are also returned.</p>
        pub fn entities(mut self, input: impl Into<crate::model::Entity>) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input.into());
            self.entities = Some(v);
            self
        }
        /// <p> The collection of medical entities extracted from the input text and their associated
        /// information. For each entity, the response provides the entity text, the entity category,
        /// where the entity text begins and ends, and the level of confidence that Amazon Comprehend Medical has in the
        /// detection and analysis. Attributes and traits of the entity are also returned.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Appends an item to `unmapped_attributes`.
        ///
        /// To override the contents of this collection use [`set_unmapped_attributes`](Self::set_unmapped_attributes).
        ///
        /// <p> Attributes extracted from the input text that we were unable to relate to an
        /// entity.</p>
        pub fn unmapped_attributes(
            mut self,
            input: impl Into<crate::model::UnmappedAttribute>,
        ) -> Self {
            let mut v = self.unmapped_attributes.unwrap_or_default();
            v.push(input.into());
            self.unmapped_attributes = Some(v);
            self
        }
        /// <p> Attributes extracted from the input text that we were unable to relate to an
        /// entity.</p>
        pub fn set_unmapped_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
        ) -> Self {
            self.unmapped_attributes = input;
            self
        }
        /// <p> If the result of the previous request to <code>DetectEntities</code> was truncated,
        /// include the <code>PaginationToken</code> to fetch the next page of entities.</p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p> If the result of the previous request to <code>DetectEntities</code> was truncated,
        /// include the <code>PaginationToken</code> to fetch the next page of entities.</p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like
        /// X.X.X. You can use this information to track the model used for a particular batch of
        /// documents.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like
        /// X.X.X. You can use this information to track the model used for a particular batch of
        /// documents.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
        pub fn build(self) -> crate::output::DetectEntitiesOutput {
            crate::output::DetectEntitiesOutput {
                entities: self.entities,
                unmapped_attributes: self.unmapped_attributes,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
            }
        }
    }
}
impl DetectEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
    pub fn builder() -> crate::output::detect_entities_output::Builder {
        crate::output::detect_entities_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeRxNormInferenceJobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub comprehend_medical_async_job_properties:
        std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
}
impl std::fmt::Debug for DescribeRxNormInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeRxNormInferenceJobOutput");
        formatter.field(
            "comprehend_medical_async_job_properties",
            &self.comprehend_medical_async_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeRxNormInferenceJobOutput`](crate::output::DescribeRxNormInferenceJobOutput)
pub mod describe_rx_norm_inference_job_output {
    /// A builder for [`DescribeRxNormInferenceJobOutput`](crate::output::DescribeRxNormInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties:
            std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn comprehend_medical_async_job_properties(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            self.comprehend_medical_async_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn set_comprehend_medical_async_job_properties(
            mut self,
            input: std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            self.comprehend_medical_async_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRxNormInferenceJobOutput`](crate::output::DescribeRxNormInferenceJobOutput)
        pub fn build(self) -> crate::output::DescribeRxNormInferenceJobOutput {
            crate::output::DescribeRxNormInferenceJobOutput {
                comprehend_medical_async_job_properties: self
                    .comprehend_medical_async_job_properties,
            }
        }
    }
}
impl DescribeRxNormInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeRxNormInferenceJobOutput`](crate::output::DescribeRxNormInferenceJobOutput)
    pub fn builder() -> crate::output::describe_rx_norm_inference_job_output::Builder {
        crate::output::describe_rx_norm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePhiDetectionJobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub comprehend_medical_async_job_properties:
        std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
}
impl std::fmt::Debug for DescribePhiDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePhiDetectionJobOutput");
        formatter.field(
            "comprehend_medical_async_job_properties",
            &self.comprehend_medical_async_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribePhiDetectionJobOutput`](crate::output::DescribePhiDetectionJobOutput)
pub mod describe_phi_detection_job_output {
    /// A builder for [`DescribePhiDetectionJobOutput`](crate::output::DescribePhiDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties:
            std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn comprehend_medical_async_job_properties(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            self.comprehend_medical_async_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn set_comprehend_medical_async_job_properties(
            mut self,
            input: std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            self.comprehend_medical_async_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribePhiDetectionJobOutput`](crate::output::DescribePhiDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribePhiDetectionJobOutput {
            crate::output::DescribePhiDetectionJobOutput {
                comprehend_medical_async_job_properties: self
                    .comprehend_medical_async_job_properties,
            }
        }
    }
}
impl DescribePhiDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribePhiDetectionJobOutput`](crate::output::DescribePhiDetectionJobOutput)
    pub fn builder() -> crate::output::describe_phi_detection_job_output::Builder {
        crate::output::describe_phi_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeIcd10CmInferenceJobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub comprehend_medical_async_job_properties:
        std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
}
impl std::fmt::Debug for DescribeIcd10CmInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeIcd10CmInferenceJobOutput");
        formatter.field(
            "comprehend_medical_async_job_properties",
            &self.comprehend_medical_async_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeIcd10CmInferenceJobOutput`](crate::output::DescribeIcd10CmInferenceJobOutput)
pub mod describe_icd10_cm_inference_job_output {
    /// A builder for [`DescribeIcd10CmInferenceJobOutput`](crate::output::DescribeIcd10CmInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties:
            std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn comprehend_medical_async_job_properties(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            self.comprehend_medical_async_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn set_comprehend_medical_async_job_properties(
            mut self,
            input: std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            self.comprehend_medical_async_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeIcd10CmInferenceJobOutput`](crate::output::DescribeIcd10CmInferenceJobOutput)
        pub fn build(self) -> crate::output::DescribeIcd10CmInferenceJobOutput {
            crate::output::DescribeIcd10CmInferenceJobOutput {
                comprehend_medical_async_job_properties: self
                    .comprehend_medical_async_job_properties,
            }
        }
    }
}
impl DescribeIcd10CmInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeIcd10CmInferenceJobOutput`](crate::output::DescribeIcd10CmInferenceJobOutput)
    pub fn builder() -> crate::output::describe_icd10_cm_inference_job_output::Builder {
        crate::output::describe_icd10_cm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEntitiesDetectionV2JobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub comprehend_medical_async_job_properties:
        std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
}
impl std::fmt::Debug for DescribeEntitiesDetectionV2JobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEntitiesDetectionV2JobOutput");
        formatter.field(
            "comprehend_medical_async_job_properties",
            &self.comprehend_medical_async_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeEntitiesDetectionV2JobOutput`](crate::output::DescribeEntitiesDetectionV2JobOutput)
pub mod describe_entities_detection_v2_job_output {
    /// A builder for [`DescribeEntitiesDetectionV2JobOutput`](crate::output::DescribeEntitiesDetectionV2JobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties:
            std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn comprehend_medical_async_job_properties(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            self.comprehend_medical_async_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn set_comprehend_medical_async_job_properties(
            mut self,
            input: std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            self.comprehend_medical_async_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEntitiesDetectionV2JobOutput`](crate::output::DescribeEntitiesDetectionV2JobOutput)
        pub fn build(self) -> crate::output::DescribeEntitiesDetectionV2JobOutput {
            crate::output::DescribeEntitiesDetectionV2JobOutput {
                comprehend_medical_async_job_properties: self
                    .comprehend_medical_async_job_properties,
            }
        }
    }
}
impl DescribeEntitiesDetectionV2JobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEntitiesDetectionV2JobOutput`](crate::output::DescribeEntitiesDetectionV2JobOutput)
    pub fn builder() -> crate::output::describe_entities_detection_v2_job_output::Builder {
        crate::output::describe_entities_detection_v2_job_output::Builder::default()
    }
}
