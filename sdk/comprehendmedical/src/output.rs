// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopSnomedctInferenceJobOutput {
    /// <p> The identifier generated for the job. To get the status of job, use this identifier with the DescribeSNOMEDCTInferenceJob operation. </p>
    pub job_id: std::option::Option<std::string::String>,
}
impl StopSnomedctInferenceJobOutput {
    /// <p> The identifier generated for the job. To get the status of job, use this identifier with the DescribeSNOMEDCTInferenceJob operation. </p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for StopSnomedctInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopSnomedctInferenceJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StopSnomedctInferenceJobOutput`](crate::output::StopSnomedctInferenceJobOutput)
pub mod stop_snomedct_inference_job_output {

    /// A builder for [`StopSnomedctInferenceJobOutput`](crate::output::StopSnomedctInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier generated for the job. To get the status of job, use this identifier with the DescribeSNOMEDCTInferenceJob operation. </p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p> The identifier generated for the job. To get the status of job, use this identifier with the DescribeSNOMEDCTInferenceJob operation. </p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopSnomedctInferenceJobOutput`](crate::output::StopSnomedctInferenceJobOutput)
        pub fn build(self) -> crate::output::StopSnomedctInferenceJobOutput {
            crate::output::StopSnomedctInferenceJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StopSnomedctInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`StopSnomedctInferenceJobOutput`](crate::output::StopSnomedctInferenceJobOutput)
    pub fn builder() -> crate::output::stop_snomedct_inference_job_output::Builder {
        crate::output::stop_snomedct_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopRxNormInferenceJobOutput {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with the <code>DescribeRxNormInferenceJob</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl StopRxNormInferenceJobOutput {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with the <code>DescribeRxNormInferenceJob</code> operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for StopRxNormInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopRxNormInferenceJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StopRxNormInferenceJobOutput`](crate::output::StopRxNormInferenceJobOutput)
pub mod stop_rx_norm_inference_job_output {

    /// A builder for [`StopRxNormInferenceJobOutput`](crate::output::StopRxNormInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with the <code>DescribeRxNormInferenceJob</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with the <code>DescribeRxNormInferenceJob</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopRxNormInferenceJobOutput`](crate::output::StopRxNormInferenceJobOutput)
        pub fn build(self) -> crate::output::StopRxNormInferenceJobOutput {
            crate::output::StopRxNormInferenceJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StopRxNormInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`StopRxNormInferenceJobOutput`](crate::output::StopRxNormInferenceJobOutput)
    pub fn builder() -> crate::output::stop_rx_norm_inference_job_output::Builder {
        crate::output::stop_rx_norm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopPhiDetectionJobOutput {
    /// <p>The identifier of the PHI detection job that was stopped.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl StopPhiDetectionJobOutput {
    /// <p>The identifier of the PHI detection job that was stopped.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for StopPhiDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopPhiDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StopPhiDetectionJobOutput`](crate::output::StopPhiDetectionJobOutput)
pub mod stop_phi_detection_job_output {

    /// A builder for [`StopPhiDetectionJobOutput`](crate::output::StopPhiDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the PHI detection job that was stopped.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the PHI detection job that was stopped.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopPhiDetectionJobOutput`](crate::output::StopPhiDetectionJobOutput)
        pub fn build(self) -> crate::output::StopPhiDetectionJobOutput {
            crate::output::StopPhiDetectionJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StopPhiDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StopPhiDetectionJobOutput`](crate::output::StopPhiDetectionJobOutput)
    pub fn builder() -> crate::output::stop_phi_detection_job_output::Builder {
        crate::output::stop_phi_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopIcd10CmInferenceJobOutput {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with the <code>DescribeICD10CMInferenceJob</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl StopIcd10CmInferenceJobOutput {
    /// <p>The identifier generated for the job. To get the status of job, use this identifier with the <code>DescribeICD10CMInferenceJob</code> operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for StopIcd10CmInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopIcd10CmInferenceJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StopIcd10CmInferenceJobOutput`](crate::output::StopIcd10CmInferenceJobOutput)
pub mod stop_icd10_cm_inference_job_output {

    /// A builder for [`StopIcd10CmInferenceJobOutput`](crate::output::StopIcd10CmInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with the <code>DescribeICD10CMInferenceJob</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of job, use this identifier with the <code>DescribeICD10CMInferenceJob</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopIcd10CmInferenceJobOutput`](crate::output::StopIcd10CmInferenceJobOutput)
        pub fn build(self) -> crate::output::StopIcd10CmInferenceJobOutput {
            crate::output::StopIcd10CmInferenceJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StopIcd10CmInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`StopIcd10CmInferenceJobOutput`](crate::output::StopIcd10CmInferenceJobOutput)
    pub fn builder() -> crate::output::stop_icd10_cm_inference_job_output::Builder {
        crate::output::stop_icd10_cm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopEntitiesDetectionV2JobOutput {
    /// <p>The identifier of the medical entities detection job that was stopped.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl StopEntitiesDetectionV2JobOutput {
    /// <p>The identifier of the medical entities detection job that was stopped.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for StopEntitiesDetectionV2JobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopEntitiesDetectionV2JobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StopEntitiesDetectionV2JobOutput`](crate::output::StopEntitiesDetectionV2JobOutput)
pub mod stop_entities_detection_v2_job_output {

    /// A builder for [`StopEntitiesDetectionV2JobOutput`](crate::output::StopEntitiesDetectionV2JobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the medical entities detection job that was stopped.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the medical entities detection job that was stopped.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopEntitiesDetectionV2JobOutput`](crate::output::StopEntitiesDetectionV2JobOutput)
        pub fn build(self) -> crate::output::StopEntitiesDetectionV2JobOutput {
            crate::output::StopEntitiesDetectionV2JobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StopEntitiesDetectionV2JobOutput {
    /// Creates a new builder-style object to manufacture [`StopEntitiesDetectionV2JobOutput`](crate::output::StopEntitiesDetectionV2JobOutput)
    pub fn builder() -> crate::output::stop_entities_detection_v2_job_output::Builder {
        crate::output::stop_entities_detection_v2_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartSnomedctInferenceJobOutput {
    /// <p> The identifier generated for the job. To get the status of a job, use this identifier with the StartSNOMEDCTInferenceJob operation. </p>
    pub job_id: std::option::Option<std::string::String>,
}
impl StartSnomedctInferenceJobOutput {
    /// <p> The identifier generated for the job. To get the status of a job, use this identifier with the StartSNOMEDCTInferenceJob operation. </p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for StartSnomedctInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartSnomedctInferenceJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StartSnomedctInferenceJobOutput`](crate::output::StartSnomedctInferenceJobOutput)
pub mod start_snomedct_inference_job_output {

    /// A builder for [`StartSnomedctInferenceJobOutput`](crate::output::StartSnomedctInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p> The identifier generated for the job. To get the status of a job, use this identifier with the StartSNOMEDCTInferenceJob operation. </p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p> The identifier generated for the job. To get the status of a job, use this identifier with the StartSNOMEDCTInferenceJob operation. </p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartSnomedctInferenceJobOutput`](crate::output::StartSnomedctInferenceJobOutput)
        pub fn build(self) -> crate::output::StartSnomedctInferenceJobOutput {
            crate::output::StartSnomedctInferenceJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StartSnomedctInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`StartSnomedctInferenceJobOutput`](crate::output::StartSnomedctInferenceJobOutput)
    pub fn builder() -> crate::output::start_snomedct_inference_job_output::Builder {
        crate::output::start_snomedct_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartRxNormInferenceJobOutput {
    /// <p>The identifier of the job.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl StartRxNormInferenceJobOutput {
    /// <p>The identifier of the job.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for StartRxNormInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartRxNormInferenceJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StartRxNormInferenceJobOutput`](crate::output::StartRxNormInferenceJobOutput)
pub mod start_rx_norm_inference_job_output {

    /// A builder for [`StartRxNormInferenceJobOutput`](crate::output::StartRxNormInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the job.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier of the job.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartRxNormInferenceJobOutput`](crate::output::StartRxNormInferenceJobOutput)
        pub fn build(self) -> crate::output::StartRxNormInferenceJobOutput {
            crate::output::StartRxNormInferenceJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StartRxNormInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`StartRxNormInferenceJobOutput`](crate::output::StartRxNormInferenceJobOutput)
    pub fn builder() -> crate::output::start_rx_norm_inference_job_output::Builder {
        crate::output::start_rx_norm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartPhiDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>DescribePHIDetectionJob</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl StartPhiDetectionJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>DescribePHIDetectionJob</code> operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for StartPhiDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartPhiDetectionJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StartPhiDetectionJobOutput`](crate::output::StartPhiDetectionJobOutput)
pub mod start_phi_detection_job_output {

    /// A builder for [`StartPhiDetectionJobOutput`](crate::output::StartPhiDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>DescribePHIDetectionJob</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>DescribePHIDetectionJob</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartPhiDetectionJobOutput`](crate::output::StartPhiDetectionJobOutput)
        pub fn build(self) -> crate::output::StartPhiDetectionJobOutput {
            crate::output::StartPhiDetectionJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StartPhiDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`StartPhiDetectionJobOutput`](crate::output::StartPhiDetectionJobOutput)
    pub fn builder() -> crate::output::start_phi_detection_job_output::Builder {
        crate::output::start_phi_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartIcd10CmInferenceJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>StartICD10CMInferenceJob</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl StartIcd10CmInferenceJobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>StartICD10CMInferenceJob</code> operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for StartIcd10CmInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartIcd10CmInferenceJobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StartIcd10CmInferenceJobOutput`](crate::output::StartIcd10CmInferenceJobOutput)
pub mod start_icd10_cm_inference_job_output {

    /// A builder for [`StartIcd10CmInferenceJobOutput`](crate::output::StartIcd10CmInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>StartICD10CMInferenceJob</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>StartICD10CMInferenceJob</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartIcd10CmInferenceJobOutput`](crate::output::StartIcd10CmInferenceJobOutput)
        pub fn build(self) -> crate::output::StartIcd10CmInferenceJobOutput {
            crate::output::StartIcd10CmInferenceJobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StartIcd10CmInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`StartIcd10CmInferenceJobOutput`](crate::output::StartIcd10CmInferenceJobOutput)
    pub fn builder() -> crate::output::start_icd10_cm_inference_job_output::Builder {
        crate::output::start_icd10_cm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StartEntitiesDetectionV2JobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>DescribeEntitiesDetectionV2Job</code> operation.</p>
    pub job_id: std::option::Option<std::string::String>,
}
impl StartEntitiesDetectionV2JobOutput {
    /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>DescribeEntitiesDetectionV2Job</code> operation.</p>
    pub fn job_id(&self) -> std::option::Option<&str> {
        self.job_id.as_deref()
    }
}
impl std::fmt::Debug for StartEntitiesDetectionV2JobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StartEntitiesDetectionV2JobOutput");
        formatter.field("job_id", &self.job_id);
        formatter.finish()
    }
}
/// See [`StartEntitiesDetectionV2JobOutput`](crate::output::StartEntitiesDetectionV2JobOutput)
pub mod start_entities_detection_v2_job_output {

    /// A builder for [`StartEntitiesDetectionV2JobOutput`](crate::output::StartEntitiesDetectionV2JobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) job_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>DescribeEntitiesDetectionV2Job</code> operation.</p>
        pub fn job_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.job_id = Some(input.into());
            self
        }
        /// <p>The identifier generated for the job. To get the status of a job, use this identifier with the <code>DescribeEntitiesDetectionV2Job</code> operation.</p>
        pub fn set_job_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.job_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartEntitiesDetectionV2JobOutput`](crate::output::StartEntitiesDetectionV2JobOutput)
        pub fn build(self) -> crate::output::StartEntitiesDetectionV2JobOutput {
            crate::output::StartEntitiesDetectionV2JobOutput {
                job_id: self.job_id,
            }
        }
    }
}
impl StartEntitiesDetectionV2JobOutput {
    /// Creates a new builder-style object to manufacture [`StartEntitiesDetectionV2JobOutput`](crate::output::StartEntitiesDetectionV2JobOutput)
    pub fn builder() -> crate::output::start_entities_detection_v2_job_output::Builder {
        crate::output::start_entities_detection_v2_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSnomedctInferenceJobsOutput {
    /// <p> A list containing the properties of each job that is returned. </p>
    pub comprehend_medical_async_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
    /// <p> Identifies the next page of results to return. </p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListSnomedctInferenceJobsOutput {
    /// <p> A list containing the properties of each job that is returned. </p>
    pub fn comprehend_medical_async_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::ComprehendMedicalAsyncJobProperties]> {
        self.comprehend_medical_async_job_properties_list.as_deref()
    }
    /// <p> Identifies the next page of results to return. </p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListSnomedctInferenceJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSnomedctInferenceJobsOutput");
        formatter.field(
            "comprehend_medical_async_job_properties_list",
            &self.comprehend_medical_async_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListSnomedctInferenceJobsOutput`](crate::output::ListSnomedctInferenceJobsOutput)
pub mod list_snomedct_inference_jobs_output {

    /// A builder for [`ListSnomedctInferenceJobsOutput`](crate::output::ListSnomedctInferenceJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `comprehend_medical_async_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_comprehend_medical_async_job_properties_list`](Self::set_comprehend_medical_async_job_properties_list).
        ///
        /// <p> A list containing the properties of each job that is returned. </p>
        pub fn comprehend_medical_async_job_properties_list(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            let mut v = self
                .comprehend_medical_async_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.comprehend_medical_async_job_properties_list = Some(v);
            self
        }
        /// <p> A list containing the properties of each job that is returned. </p>
        pub fn set_comprehend_medical_async_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>,
            >,
        ) -> Self {
            self.comprehend_medical_async_job_properties_list = input;
            self
        }
        /// <p> Identifies the next page of results to return. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p> Identifies the next page of results to return. </p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListSnomedctInferenceJobsOutput`](crate::output::ListSnomedctInferenceJobsOutput)
        pub fn build(self) -> crate::output::ListSnomedctInferenceJobsOutput {
            crate::output::ListSnomedctInferenceJobsOutput {
                comprehend_medical_async_job_properties_list: self
                    .comprehend_medical_async_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListSnomedctInferenceJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListSnomedctInferenceJobsOutput`](crate::output::ListSnomedctInferenceJobsOutput)
    pub fn builder() -> crate::output::list_snomedct_inference_jobs_output::Builder {
        crate::output::list_snomedct_inference_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListRxNormInferenceJobsOutput {
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    pub comprehend_medical_async_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListRxNormInferenceJobsOutput {
    /// <p>The maximum number of results to return in each page. The default is 100.</p>
    pub fn comprehend_medical_async_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::ComprehendMedicalAsyncJobProperties]> {
        self.comprehend_medical_async_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListRxNormInferenceJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListRxNormInferenceJobsOutput");
        formatter.field(
            "comprehend_medical_async_job_properties_list",
            &self.comprehend_medical_async_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListRxNormInferenceJobsOutput`](crate::output::ListRxNormInferenceJobsOutput)
pub mod list_rx_norm_inference_jobs_output {

    /// A builder for [`ListRxNormInferenceJobsOutput`](crate::output::ListRxNormInferenceJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `comprehend_medical_async_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_comprehend_medical_async_job_properties_list`](Self::set_comprehend_medical_async_job_properties_list).
        ///
        /// <p>The maximum number of results to return in each page. The default is 100.</p>
        pub fn comprehend_medical_async_job_properties_list(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            let mut v = self
                .comprehend_medical_async_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.comprehend_medical_async_job_properties_list = Some(v);
            self
        }
        /// <p>The maximum number of results to return in each page. The default is 100.</p>
        pub fn set_comprehend_medical_async_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>,
            >,
        ) -> Self {
            self.comprehend_medical_async_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListRxNormInferenceJobsOutput`](crate::output::ListRxNormInferenceJobsOutput)
        pub fn build(self) -> crate::output::ListRxNormInferenceJobsOutput {
            crate::output::ListRxNormInferenceJobsOutput {
                comprehend_medical_async_job_properties_list: self
                    .comprehend_medical_async_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListRxNormInferenceJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListRxNormInferenceJobsOutput`](crate::output::ListRxNormInferenceJobsOutput)
    pub fn builder() -> crate::output::list_rx_norm_inference_jobs_output::Builder {
        crate::output::list_rx_norm_inference_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListPhiDetectionJobsOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub comprehend_medical_async_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListPhiDetectionJobsOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub fn comprehend_medical_async_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::ComprehendMedicalAsyncJobProperties]> {
        self.comprehend_medical_async_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListPhiDetectionJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListPhiDetectionJobsOutput");
        formatter.field(
            "comprehend_medical_async_job_properties_list",
            &self.comprehend_medical_async_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListPhiDetectionJobsOutput`](crate::output::ListPhiDetectionJobsOutput)
pub mod list_phi_detection_jobs_output {

    /// A builder for [`ListPhiDetectionJobsOutput`](crate::output::ListPhiDetectionJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `comprehend_medical_async_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_comprehend_medical_async_job_properties_list`](Self::set_comprehend_medical_async_job_properties_list).
        ///
        /// <p>A list containing the properties of each job returned.</p>
        pub fn comprehend_medical_async_job_properties_list(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            let mut v = self
                .comprehend_medical_async_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.comprehend_medical_async_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job returned.</p>
        pub fn set_comprehend_medical_async_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>,
            >,
        ) -> Self {
            self.comprehend_medical_async_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListPhiDetectionJobsOutput`](crate::output::ListPhiDetectionJobsOutput)
        pub fn build(self) -> crate::output::ListPhiDetectionJobsOutput {
            crate::output::ListPhiDetectionJobsOutput {
                comprehend_medical_async_job_properties_list: self
                    .comprehend_medical_async_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListPhiDetectionJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListPhiDetectionJobsOutput`](crate::output::ListPhiDetectionJobsOutput)
    pub fn builder() -> crate::output::list_phi_detection_jobs_output::Builder {
        crate::output::list_phi_detection_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListIcd10CmInferenceJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub comprehend_medical_async_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListIcd10CmInferenceJobsOutput {
    /// <p>A list containing the properties of each job that is returned.</p>
    pub fn comprehend_medical_async_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::ComprehendMedicalAsyncJobProperties]> {
        self.comprehend_medical_async_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListIcd10CmInferenceJobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListIcd10CmInferenceJobsOutput");
        formatter.field(
            "comprehend_medical_async_job_properties_list",
            &self.comprehend_medical_async_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListIcd10CmInferenceJobsOutput`](crate::output::ListIcd10CmInferenceJobsOutput)
pub mod list_icd10_cm_inference_jobs_output {

    /// A builder for [`ListIcd10CmInferenceJobsOutput`](crate::output::ListIcd10CmInferenceJobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `comprehend_medical_async_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_comprehend_medical_async_job_properties_list`](Self::set_comprehend_medical_async_job_properties_list).
        ///
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn comprehend_medical_async_job_properties_list(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            let mut v = self
                .comprehend_medical_async_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.comprehend_medical_async_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job that is returned.</p>
        pub fn set_comprehend_medical_async_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>,
            >,
        ) -> Self {
            self.comprehend_medical_async_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListIcd10CmInferenceJobsOutput`](crate::output::ListIcd10CmInferenceJobsOutput)
        pub fn build(self) -> crate::output::ListIcd10CmInferenceJobsOutput {
            crate::output::ListIcd10CmInferenceJobsOutput {
                comprehend_medical_async_job_properties_list: self
                    .comprehend_medical_async_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListIcd10CmInferenceJobsOutput {
    /// Creates a new builder-style object to manufacture [`ListIcd10CmInferenceJobsOutput`](crate::output::ListIcd10CmInferenceJobsOutput)
    pub fn builder() -> crate::output::list_icd10_cm_inference_jobs_output::Builder {
        crate::output::list_icd10_cm_inference_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListEntitiesDetectionV2JobsOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub comprehend_medical_async_job_properties_list:
        std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
    /// <p>Identifies the next page of results to return.</p>
    pub next_token: std::option::Option<std::string::String>,
}
impl ListEntitiesDetectionV2JobsOutput {
    /// <p>A list containing the properties of each job returned.</p>
    pub fn comprehend_medical_async_job_properties_list(
        &self,
    ) -> std::option::Option<&[crate::model::ComprehendMedicalAsyncJobProperties]> {
        self.comprehend_medical_async_job_properties_list.as_deref()
    }
    /// <p>Identifies the next page of results to return.</p>
    pub fn next_token(&self) -> std::option::Option<&str> {
        self.next_token.as_deref()
    }
}
impl std::fmt::Debug for ListEntitiesDetectionV2JobsOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListEntitiesDetectionV2JobsOutput");
        formatter.field(
            "comprehend_medical_async_job_properties_list",
            &self.comprehend_medical_async_job_properties_list,
        );
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}
/// See [`ListEntitiesDetectionV2JobsOutput`](crate::output::ListEntitiesDetectionV2JobsOutput)
pub mod list_entities_detection_v2_jobs_output {

    /// A builder for [`ListEntitiesDetectionV2JobsOutput`](crate::output::ListEntitiesDetectionV2JobsOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties_list:
            std::option::Option<std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>>,
        pub(crate) next_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `comprehend_medical_async_job_properties_list`.
        ///
        /// To override the contents of this collection use [`set_comprehend_medical_async_job_properties_list`](Self::set_comprehend_medical_async_job_properties_list).
        ///
        /// <p>A list containing the properties of each job returned.</p>
        pub fn comprehend_medical_async_job_properties_list(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            let mut v = self
                .comprehend_medical_async_job_properties_list
                .unwrap_or_default();
            v.push(input);
            self.comprehend_medical_async_job_properties_list = Some(v);
            self
        }
        /// <p>A list containing the properties of each job returned.</p>
        pub fn set_comprehend_medical_async_job_properties_list(
            mut self,
            input: std::option::Option<
                std::vec::Vec<crate::model::ComprehendMedicalAsyncJobProperties>,
            >,
        ) -> Self {
            self.comprehend_medical_async_job_properties_list = input;
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.next_token = Some(input.into());
            self
        }
        /// <p>Identifies the next page of results to return.</p>
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.next_token = input;
            self
        }
        /// Consumes the builder and constructs a [`ListEntitiesDetectionV2JobsOutput`](crate::output::ListEntitiesDetectionV2JobsOutput)
        pub fn build(self) -> crate::output::ListEntitiesDetectionV2JobsOutput {
            crate::output::ListEntitiesDetectionV2JobsOutput {
                comprehend_medical_async_job_properties_list: self
                    .comprehend_medical_async_job_properties_list,
                next_token: self.next_token,
            }
        }
    }
}
impl ListEntitiesDetectionV2JobsOutput {
    /// Creates a new builder-style object to manufacture [`ListEntitiesDetectionV2JobsOutput`](crate::output::ListEntitiesDetectionV2JobsOutput)
    pub fn builder() -> crate::output::list_entities_detection_v2_jobs_output::Builder {
        crate::output::list_entities_detection_v2_jobs_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferSnomedctOutput {
    /// <p> The collection of medical concept entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned. </p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::SnomedctEntity>>,
    /// <p> If the result of the request is truncated, the pagination token can be used to fetch the next page of entities. </p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p> The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents. </p>
    pub model_version: std::option::Option<std::string::String>,
    /// <p> The details of the SNOMED-CT revision, including the edition, language, and version date. </p>
    pub snomedct_details: std::option::Option<crate::model::SnomedctDetails>,
    /// <p> The number of characters in the input request documentation. </p>
    pub characters: std::option::Option<crate::model::Characters>,
}
impl InferSnomedctOutput {
    /// <p> The collection of medical concept entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned. </p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::SnomedctEntity]> {
        self.entities.as_deref()
    }
    /// <p> If the result of the request is truncated, the pagination token can be used to fetch the next page of entities. </p>
    pub fn pagination_token(&self) -> std::option::Option<&str> {
        self.pagination_token.as_deref()
    }
    /// <p> The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents. </p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
    /// <p> The details of the SNOMED-CT revision, including the edition, language, and version date. </p>
    pub fn snomedct_details(&self) -> std::option::Option<&crate::model::SnomedctDetails> {
        self.snomedct_details.as_ref()
    }
    /// <p> The number of characters in the input request documentation. </p>
    pub fn characters(&self) -> std::option::Option<&crate::model::Characters> {
        self.characters.as_ref()
    }
}
impl std::fmt::Debug for InferSnomedctOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferSnomedctOutput");
        formatter.field("entities", &self.entities);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.field("snomedct_details", &self.snomedct_details);
        formatter.field("characters", &self.characters);
        formatter.finish()
    }
}
/// See [`InferSnomedctOutput`](crate::output::InferSnomedctOutput)
pub mod infer_snomedct_output {

    /// A builder for [`InferSnomedctOutput`](crate::output::InferSnomedctOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::SnomedctEntity>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
        pub(crate) snomedct_details: std::option::Option<crate::model::SnomedctDetails>,
        pub(crate) characters: std::option::Option<crate::model::Characters>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p> The collection of medical concept entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned. </p>
        pub fn entities(mut self, input: crate::model::SnomedctEntity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p> The collection of medical concept entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical has in the detection and analysis. Attributes and traits of the entity are also returned. </p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SnomedctEntity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// <p> If the result of the request is truncated, the pagination token can be used to fetch the next page of entities. </p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p> If the result of the request is truncated, the pagination token can be used to fetch the next page of entities. </p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p> The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents. </p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p> The version of the model used to analyze the documents, in the format n.n.n You can use this information to track the model used for a particular batch of documents. </p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// <p> The details of the SNOMED-CT revision, including the edition, language, and version date. </p>
        pub fn snomedct_details(mut self, input: crate::model::SnomedctDetails) -> Self {
            self.snomedct_details = Some(input);
            self
        }
        /// <p> The details of the SNOMED-CT revision, including the edition, language, and version date. </p>
        pub fn set_snomedct_details(
            mut self,
            input: std::option::Option<crate::model::SnomedctDetails>,
        ) -> Self {
            self.snomedct_details = input;
            self
        }
        /// <p> The number of characters in the input request documentation. </p>
        pub fn characters(mut self, input: crate::model::Characters) -> Self {
            self.characters = Some(input);
            self
        }
        /// <p> The number of characters in the input request documentation. </p>
        pub fn set_characters(
            mut self,
            input: std::option::Option<crate::model::Characters>,
        ) -> Self {
            self.characters = input;
            self
        }
        /// Consumes the builder and constructs a [`InferSnomedctOutput`](crate::output::InferSnomedctOutput)
        pub fn build(self) -> crate::output::InferSnomedctOutput {
            crate::output::InferSnomedctOutput {
                entities: self.entities,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
                snomedct_details: self.snomedct_details,
                characters: self.characters,
            }
        }
    }
}
impl InferSnomedctOutput {
    /// Creates a new builder-style object to manufacture [`InferSnomedctOutput`](crate::output::InferSnomedctOutput)
    pub fn builder() -> crate::output::infer_snomedct_output::Builder {
        crate::output::infer_snomedct_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferRxNormOutput {
    /// <p>The medication entities detected in the text linked to RxNorm concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::RxNormEntity>>,
    /// <p>If the result of the previous request to <code>InferRxNorm</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of medication entities.</p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>The version of the model used to analyze the documents, in the format <i>n</i>.<i>n</i>.<i>n</i> You can use this information to track the model used for a particular batch of documents.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl InferRxNormOutput {
    /// <p>The medication entities detected in the text linked to RxNorm concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::RxNormEntity]> {
        self.entities.as_deref()
    }
    /// <p>If the result of the previous request to <code>InferRxNorm</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of medication entities.</p>
    pub fn pagination_token(&self) -> std::option::Option<&str> {
        self.pagination_token.as_deref()
    }
    /// <p>The version of the model used to analyze the documents, in the format <i>n</i>.<i>n</i>.<i>n</i> You can use this information to track the model used for a particular batch of documents.</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
}
impl std::fmt::Debug for InferRxNormOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferRxNormOutput");
        formatter.field("entities", &self.entities);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`InferRxNormOutput`](crate::output::InferRxNormOutput)
pub mod infer_rx_norm_output {

    /// A builder for [`InferRxNormOutput`](crate::output::InferRxNormOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::RxNormEntity>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>The medication entities detected in the text linked to RxNorm concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.</p>
        pub fn entities(mut self, input: crate::model::RxNormEntity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>The medication entities detected in the text linked to RxNorm concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RxNormEntity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// <p>If the result of the previous request to <code>InferRxNorm</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of medication entities.</p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p>If the result of the previous request to <code>InferRxNorm</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of medication entities.</p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>The version of the model used to analyze the documents, in the format <i>n</i>.<i>n</i>.<i>n</i> You can use this information to track the model used for a particular batch of documents.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used to analyze the documents, in the format <i>n</i>.<i>n</i>.<i>n</i> You can use this information to track the model used for a particular batch of documents.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`InferRxNormOutput`](crate::output::InferRxNormOutput)
        pub fn build(self) -> crate::output::InferRxNormOutput {
            crate::output::InferRxNormOutput {
                entities: self.entities,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
            }
        }
    }
}
impl InferRxNormOutput {
    /// Creates a new builder-style object to manufacture [`InferRxNormOutput`](crate::output::InferRxNormOutput)
    pub fn builder() -> crate::output::infer_rx_norm_output::Builder {
        crate::output::infer_rx_norm_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InferIcd10CmOutput {
    /// <p>The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::Icd10CmEntity>>,
    /// <p>If the result of the previous request to <code>InferICD10CM</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of medical condition entities. </p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>The version of the model used to analyze the documents, in the format <i>n</i>.<i>n</i>.<i>n</i> You can use this information to track the model used for a particular batch of documents.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl InferIcd10CmOutput {
    /// <p>The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::Icd10CmEntity]> {
        self.entities.as_deref()
    }
    /// <p>If the result of the previous request to <code>InferICD10CM</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of medical condition entities. </p>
    pub fn pagination_token(&self) -> std::option::Option<&str> {
        self.pagination_token.as_deref()
    }
    /// <p>The version of the model used to analyze the documents, in the format <i>n</i>.<i>n</i>.<i>n</i> You can use this information to track the model used for a particular batch of documents.</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
}
impl std::fmt::Debug for InferIcd10CmOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InferIcd10CmOutput");
        formatter.field("entities", &self.entities);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`InferIcd10CmOutput`](crate::output::InferIcd10CmOutput)
pub mod infer_icd10_cm_output {

    /// A builder for [`InferIcd10CmOutput`](crate::output::InferIcd10CmOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Icd10CmEntity>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.</p>
        pub fn entities(mut self, input: crate::model::Icd10CmEntity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>The medical conditions detected in the text linked to ICD-10-CM concepts. If the action is successful, the service sends back an HTTP 200 response, as well as the entities detected.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Icd10CmEntity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// <p>If the result of the previous request to <code>InferICD10CM</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of medical condition entities. </p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p>If the result of the previous request to <code>InferICD10CM</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of medical condition entities. </p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>The version of the model used to analyze the documents, in the format <i>n</i>.<i>n</i>.<i>n</i> You can use this information to track the model used for a particular batch of documents.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used to analyze the documents, in the format <i>n</i>.<i>n</i>.<i>n</i> You can use this information to track the model used for a particular batch of documents.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`InferIcd10CmOutput`](crate::output::InferIcd10CmOutput)
        pub fn build(self) -> crate::output::InferIcd10CmOutput {
            crate::output::InferIcd10CmOutput {
                entities: self.entities,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
            }
        }
    }
}
impl InferIcd10CmOutput {
    /// Creates a new builder-style object to manufacture [`InferIcd10CmOutput`](crate::output::InferIcd10CmOutput)
    pub fn builder() -> crate::output::infer_icd10_cm_output::Builder {
        crate::output::infer_icd10_cm_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectPhiOutput {
    /// <p> The collection of PHI entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical; has in its detection. </p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    /// <p> If the result of the previous request to <code>DetectPHI</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of PHI entities. </p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl DetectPhiOutput {
    /// <p> The collection of PHI entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical; has in its detection. </p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::Entity]> {
        self.entities.as_deref()
    }
    /// <p> If the result of the previous request to <code>DetectPHI</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of PHI entities. </p>
    pub fn pagination_token(&self) -> std::option::Option<&str> {
        self.pagination_token.as_deref()
    }
    /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
}
impl std::fmt::Debug for DetectPhiOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectPhiOutput");
        formatter.field("entities", &self.entities);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`DetectPhiOutput`](crate::output::DetectPhiOutput)
pub mod detect_phi_output {

    /// A builder for [`DetectPhiOutput`](crate::output::DetectPhiOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p> The collection of PHI entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical; has in its detection. </p>
        pub fn entities(mut self, input: crate::model::Entity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p> The collection of PHI entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical; has in its detection. </p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// <p> If the result of the previous request to <code>DetectPHI</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of PHI entities. </p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p> If the result of the previous request to <code>DetectPHI</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of PHI entities. </p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectPhiOutput`](crate::output::DetectPhiOutput)
        pub fn build(self) -> crate::output::DetectPhiOutput {
            crate::output::DetectPhiOutput {
                entities: self.entities,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
            }
        }
    }
}
impl DetectPhiOutput {
    /// Creates a new builder-style object to manufacture [`DetectPhiOutput`](crate::output::DetectPhiOutput)
    pub fn builder() -> crate::output::detect_phi_output::Builder {
        crate::output::detect_phi_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectEntitiesV2Output {
    /// <p>The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence in the detection and analysis. Attributes and traits of the entity are also returned.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    /// <p>Attributes extracted from the input text that couldn't be related to an entity.</p>
    pub unmapped_attributes: std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
    /// <p>If the result to the <code>DetectEntitiesV2</code> operation was truncated, include the <code>PaginationToken</code> to fetch the next page of entities.</p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl DetectEntitiesV2Output {
    /// <p>The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence in the detection and analysis. Attributes and traits of the entity are also returned.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::Entity]> {
        self.entities.as_deref()
    }
    /// <p>Attributes extracted from the input text that couldn't be related to an entity.</p>
    pub fn unmapped_attributes(&self) -> std::option::Option<&[crate::model::UnmappedAttribute]> {
        self.unmapped_attributes.as_deref()
    }
    /// <p>If the result to the <code>DetectEntitiesV2</code> operation was truncated, include the <code>PaginationToken</code> to fetch the next page of entities.</p>
    pub fn pagination_token(&self) -> std::option::Option<&str> {
        self.pagination_token.as_deref()
    }
    /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
}
impl std::fmt::Debug for DetectEntitiesV2Output {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectEntitiesV2Output");
        formatter.field("entities", &self.entities);
        formatter.field("unmapped_attributes", &self.unmapped_attributes);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`DetectEntitiesV2Output`](crate::output::DetectEntitiesV2Output)
pub mod detect_entities_v2_output {

    /// A builder for [`DetectEntitiesV2Output`](crate::output::DetectEntitiesV2Output)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        pub(crate) unmapped_attributes:
            std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p>The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence in the detection and analysis. Attributes and traits of the entity are also returned.</p>
        pub fn entities(mut self, input: crate::model::Entity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p>The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence in the detection and analysis. Attributes and traits of the entity are also returned.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Appends an item to `unmapped_attributes`.
        ///
        /// To override the contents of this collection use [`set_unmapped_attributes`](Self::set_unmapped_attributes).
        ///
        /// <p>Attributes extracted from the input text that couldn't be related to an entity.</p>
        pub fn unmapped_attributes(mut self, input: crate::model::UnmappedAttribute) -> Self {
            let mut v = self.unmapped_attributes.unwrap_or_default();
            v.push(input);
            self.unmapped_attributes = Some(v);
            self
        }
        /// <p>Attributes extracted from the input text that couldn't be related to an entity.</p>
        pub fn set_unmapped_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
        ) -> Self {
            self.unmapped_attributes = input;
            self
        }
        /// <p>If the result to the <code>DetectEntitiesV2</code> operation was truncated, include the <code>PaginationToken</code> to fetch the next page of entities.</p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p>If the result to the <code>DetectEntitiesV2</code> operation was truncated, include the <code>PaginationToken</code> to fetch the next page of entities.</p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectEntitiesV2Output`](crate::output::DetectEntitiesV2Output)
        pub fn build(self) -> crate::output::DetectEntitiesV2Output {
            crate::output::DetectEntitiesV2Output {
                entities: self.entities,
                unmapped_attributes: self.unmapped_attributes,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
            }
        }
    }
}
impl DetectEntitiesV2Output {
    /// Creates a new builder-style object to manufacture [`DetectEntitiesV2Output`](crate::output::DetectEntitiesV2Output)
    pub fn builder() -> crate::output::detect_entities_v2_output::Builder {
        crate::output::detect_entities_v2_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DetectEntitiesOutput {
    /// <p> The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical; has in the detection and analysis. Attributes and traits of the entity are also returned.</p>
    pub entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
    /// <p> Attributes extracted from the input text that we were unable to relate to an entity.</p>
    pub unmapped_attributes: std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
    /// <p> If the result of the previous request to <code>DetectEntities</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of entities.</p>
    pub pagination_token: std::option::Option<std::string::String>,
    /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
    pub model_version: std::option::Option<std::string::String>,
}
impl DetectEntitiesOutput {
    /// <p> The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical; has in the detection and analysis. Attributes and traits of the entity are also returned.</p>
    pub fn entities(&self) -> std::option::Option<&[crate::model::Entity]> {
        self.entities.as_deref()
    }
    /// <p> Attributes extracted from the input text that we were unable to relate to an entity.</p>
    pub fn unmapped_attributes(&self) -> std::option::Option<&[crate::model::UnmappedAttribute]> {
        self.unmapped_attributes.as_deref()
    }
    /// <p> If the result of the previous request to <code>DetectEntities</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of entities.</p>
    pub fn pagination_token(&self) -> std::option::Option<&str> {
        self.pagination_token.as_deref()
    }
    /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
    pub fn model_version(&self) -> std::option::Option<&str> {
        self.model_version.as_deref()
    }
}
impl std::fmt::Debug for DetectEntitiesOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DetectEntitiesOutput");
        formatter.field("entities", &self.entities);
        formatter.field("unmapped_attributes", &self.unmapped_attributes);
        formatter.field("pagination_token", &self.pagination_token);
        formatter.field("model_version", &self.model_version);
        formatter.finish()
    }
}
/// See [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
pub mod detect_entities_output {

    /// A builder for [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) entities: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        pub(crate) unmapped_attributes:
            std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
        pub(crate) pagination_token: std::option::Option<std::string::String>,
        pub(crate) model_version: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Appends an item to `entities`.
        ///
        /// To override the contents of this collection use [`set_entities`](Self::set_entities).
        ///
        /// <p> The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical; has in the detection and analysis. Attributes and traits of the entity are also returned.</p>
        pub fn entities(mut self, input: crate::model::Entity) -> Self {
            let mut v = self.entities.unwrap_or_default();
            v.push(input);
            self.entities = Some(v);
            self
        }
        /// <p> The collection of medical entities extracted from the input text and their associated information. For each entity, the response provides the entity text, the entity category, where the entity text begins and ends, and the level of confidence that Comprehend Medical; has in the detection and analysis. Attributes and traits of the entity are also returned.</p>
        pub fn set_entities(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Entity>>,
        ) -> Self {
            self.entities = input;
            self
        }
        /// Appends an item to `unmapped_attributes`.
        ///
        /// To override the contents of this collection use [`set_unmapped_attributes`](Self::set_unmapped_attributes).
        ///
        /// <p> Attributes extracted from the input text that we were unable to relate to an entity.</p>
        pub fn unmapped_attributes(mut self, input: crate::model::UnmappedAttribute) -> Self {
            let mut v = self.unmapped_attributes.unwrap_or_default();
            v.push(input);
            self.unmapped_attributes = Some(v);
            self
        }
        /// <p> Attributes extracted from the input text that we were unable to relate to an entity.</p>
        pub fn set_unmapped_attributes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::UnmappedAttribute>>,
        ) -> Self {
            self.unmapped_attributes = input;
            self
        }
        /// <p> If the result of the previous request to <code>DetectEntities</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of entities.</p>
        pub fn pagination_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.pagination_token = Some(input.into());
            self
        }
        /// <p> If the result of the previous request to <code>DetectEntities</code> was truncated, include the <code>PaginationToken</code> to fetch the next page of entities.</p>
        pub fn set_pagination_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.pagination_token = input;
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
        pub fn model_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.model_version = Some(input.into());
            self
        }
        /// <p>The version of the model used to analyze the documents. The version number looks like X.X.X. You can use this information to track the model used for a particular batch of documents.</p>
        pub fn set_model_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.model_version = input;
            self
        }
        /// Consumes the builder and constructs a [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
        pub fn build(self) -> crate::output::DetectEntitiesOutput {
            crate::output::DetectEntitiesOutput {
                entities: self.entities,
                unmapped_attributes: self.unmapped_attributes,
                pagination_token: self.pagination_token,
                model_version: self.model_version,
            }
        }
    }
}
impl DetectEntitiesOutput {
    /// Creates a new builder-style object to manufacture [`DetectEntitiesOutput`](crate::output::DetectEntitiesOutput)
    pub fn builder() -> crate::output::detect_entities_output::Builder {
        crate::output::detect_entities_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSnomedctInferenceJobOutput {
    /// <p>Provides information about a detection job.</p>
    pub comprehend_medical_async_job_properties:
        std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
}
impl DescribeSnomedctInferenceJobOutput {
    /// <p>Provides information about a detection job.</p>
    pub fn comprehend_medical_async_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::ComprehendMedicalAsyncJobProperties> {
        self.comprehend_medical_async_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeSnomedctInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSnomedctInferenceJobOutput");
        formatter.field(
            "comprehend_medical_async_job_properties",
            &self.comprehend_medical_async_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeSnomedctInferenceJobOutput`](crate::output::DescribeSnomedctInferenceJobOutput)
pub mod describe_snomedct_inference_job_output {

    /// A builder for [`DescribeSnomedctInferenceJobOutput`](crate::output::DescribeSnomedctInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties:
            std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
    }
    impl Builder {
        /// <p>Provides information about a detection job.</p>
        pub fn comprehend_medical_async_job_properties(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            self.comprehend_medical_async_job_properties = Some(input);
            self
        }
        /// <p>Provides information about a detection job.</p>
        pub fn set_comprehend_medical_async_job_properties(
            mut self,
            input: std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            self.comprehend_medical_async_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSnomedctInferenceJobOutput`](crate::output::DescribeSnomedctInferenceJobOutput)
        pub fn build(self) -> crate::output::DescribeSnomedctInferenceJobOutput {
            crate::output::DescribeSnomedctInferenceJobOutput {
                comprehend_medical_async_job_properties: self
                    .comprehend_medical_async_job_properties,
            }
        }
    }
}
impl DescribeSnomedctInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeSnomedctInferenceJobOutput`](crate::output::DescribeSnomedctInferenceJobOutput)
    pub fn builder() -> crate::output::describe_snomedct_inference_job_output::Builder {
        crate::output::describe_snomedct_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeRxNormInferenceJobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub comprehend_medical_async_job_properties:
        std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
}
impl DescribeRxNormInferenceJobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub fn comprehend_medical_async_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::ComprehendMedicalAsyncJobProperties> {
        self.comprehend_medical_async_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeRxNormInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeRxNormInferenceJobOutput");
        formatter.field(
            "comprehend_medical_async_job_properties",
            &self.comprehend_medical_async_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeRxNormInferenceJobOutput`](crate::output::DescribeRxNormInferenceJobOutput)
pub mod describe_rx_norm_inference_job_output {

    /// A builder for [`DescribeRxNormInferenceJobOutput`](crate::output::DescribeRxNormInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties:
            std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn comprehend_medical_async_job_properties(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            self.comprehend_medical_async_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn set_comprehend_medical_async_job_properties(
            mut self,
            input: std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            self.comprehend_medical_async_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeRxNormInferenceJobOutput`](crate::output::DescribeRxNormInferenceJobOutput)
        pub fn build(self) -> crate::output::DescribeRxNormInferenceJobOutput {
            crate::output::DescribeRxNormInferenceJobOutput {
                comprehend_medical_async_job_properties: self
                    .comprehend_medical_async_job_properties,
            }
        }
    }
}
impl DescribeRxNormInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeRxNormInferenceJobOutput`](crate::output::DescribeRxNormInferenceJobOutput)
    pub fn builder() -> crate::output::describe_rx_norm_inference_job_output::Builder {
        crate::output::describe_rx_norm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribePhiDetectionJobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub comprehend_medical_async_job_properties:
        std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
}
impl DescribePhiDetectionJobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub fn comprehend_medical_async_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::ComprehendMedicalAsyncJobProperties> {
        self.comprehend_medical_async_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribePhiDetectionJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribePhiDetectionJobOutput");
        formatter.field(
            "comprehend_medical_async_job_properties",
            &self.comprehend_medical_async_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribePhiDetectionJobOutput`](crate::output::DescribePhiDetectionJobOutput)
pub mod describe_phi_detection_job_output {

    /// A builder for [`DescribePhiDetectionJobOutput`](crate::output::DescribePhiDetectionJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties:
            std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn comprehend_medical_async_job_properties(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            self.comprehend_medical_async_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn set_comprehend_medical_async_job_properties(
            mut self,
            input: std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            self.comprehend_medical_async_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribePhiDetectionJobOutput`](crate::output::DescribePhiDetectionJobOutput)
        pub fn build(self) -> crate::output::DescribePhiDetectionJobOutput {
            crate::output::DescribePhiDetectionJobOutput {
                comprehend_medical_async_job_properties: self
                    .comprehend_medical_async_job_properties,
            }
        }
    }
}
impl DescribePhiDetectionJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribePhiDetectionJobOutput`](crate::output::DescribePhiDetectionJobOutput)
    pub fn builder() -> crate::output::describe_phi_detection_job_output::Builder {
        crate::output::describe_phi_detection_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeIcd10CmInferenceJobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub comprehend_medical_async_job_properties:
        std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
}
impl DescribeIcd10CmInferenceJobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub fn comprehend_medical_async_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::ComprehendMedicalAsyncJobProperties> {
        self.comprehend_medical_async_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeIcd10CmInferenceJobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeIcd10CmInferenceJobOutput");
        formatter.field(
            "comprehend_medical_async_job_properties",
            &self.comprehend_medical_async_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeIcd10CmInferenceJobOutput`](crate::output::DescribeIcd10CmInferenceJobOutput)
pub mod describe_icd10_cm_inference_job_output {

    /// A builder for [`DescribeIcd10CmInferenceJobOutput`](crate::output::DescribeIcd10CmInferenceJobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties:
            std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn comprehend_medical_async_job_properties(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            self.comprehend_medical_async_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn set_comprehend_medical_async_job_properties(
            mut self,
            input: std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            self.comprehend_medical_async_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeIcd10CmInferenceJobOutput`](crate::output::DescribeIcd10CmInferenceJobOutput)
        pub fn build(self) -> crate::output::DescribeIcd10CmInferenceJobOutput {
            crate::output::DescribeIcd10CmInferenceJobOutput {
                comprehend_medical_async_job_properties: self
                    .comprehend_medical_async_job_properties,
            }
        }
    }
}
impl DescribeIcd10CmInferenceJobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeIcd10CmInferenceJobOutput`](crate::output::DescribeIcd10CmInferenceJobOutput)
    pub fn builder() -> crate::output::describe_icd10_cm_inference_job_output::Builder {
        crate::output::describe_icd10_cm_inference_job_output::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeEntitiesDetectionV2JobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub comprehend_medical_async_job_properties:
        std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
}
impl DescribeEntitiesDetectionV2JobOutput {
    /// <p>An object that contains the properties associated with a detection job.</p>
    pub fn comprehend_medical_async_job_properties(
        &self,
    ) -> std::option::Option<&crate::model::ComprehendMedicalAsyncJobProperties> {
        self.comprehend_medical_async_job_properties.as_ref()
    }
}
impl std::fmt::Debug for DescribeEntitiesDetectionV2JobOutput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeEntitiesDetectionV2JobOutput");
        formatter.field(
            "comprehend_medical_async_job_properties",
            &self.comprehend_medical_async_job_properties,
        );
        formatter.finish()
    }
}
/// See [`DescribeEntitiesDetectionV2JobOutput`](crate::output::DescribeEntitiesDetectionV2JobOutput)
pub mod describe_entities_detection_v2_job_output {

    /// A builder for [`DescribeEntitiesDetectionV2JobOutput`](crate::output::DescribeEntitiesDetectionV2JobOutput)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) comprehend_medical_async_job_properties:
            std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
    }
    impl Builder {
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn comprehend_medical_async_job_properties(
            mut self,
            input: crate::model::ComprehendMedicalAsyncJobProperties,
        ) -> Self {
            self.comprehend_medical_async_job_properties = Some(input);
            self
        }
        /// <p>An object that contains the properties associated with a detection job.</p>
        pub fn set_comprehend_medical_async_job_properties(
            mut self,
            input: std::option::Option<crate::model::ComprehendMedicalAsyncJobProperties>,
        ) -> Self {
            self.comprehend_medical_async_job_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`DescribeEntitiesDetectionV2JobOutput`](crate::output::DescribeEntitiesDetectionV2JobOutput)
        pub fn build(self) -> crate::output::DescribeEntitiesDetectionV2JobOutput {
            crate::output::DescribeEntitiesDetectionV2JobOutput {
                comprehend_medical_async_job_properties: self
                    .comprehend_medical_async_job_properties,
            }
        }
    }
}
impl DescribeEntitiesDetectionV2JobOutput {
    /// Creates a new builder-style object to manufacture [`DescribeEntitiesDetectionV2JobOutput`](crate::output::DescribeEntitiesDetectionV2JobOutput)
    pub fn builder() -> crate::output::describe_entities_detection_v2_job_output::Builder {
        crate::output::describe_entities_detection_v2_job_output::Builder::default()
    }
}
