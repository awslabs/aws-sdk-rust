// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateAwsAccountWithPartnerAccountError {
    pub kind: AssociateAwsAccountWithPartnerAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateAwsAccountWithPartnerAccountErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateAwsAccountWithPartnerAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateAwsAccountWithPartnerAccountErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::ConflictException(_inner) => {
                _inner.fmt(f)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateAwsAccountWithPartnerAccountError {
    fn code(&self) -> Option<&str> {
        AssociateAwsAccountWithPartnerAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateAwsAccountWithPartnerAccountError {
    pub fn new(
        kind: AssociateAwsAccountWithPartnerAccountErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateAwsAccountWithPartnerAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateAwsAccountWithPartnerAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateAwsAccountWithPartnerAccountErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateAwsAccountWithPartnerAccountErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateAwsAccountWithPartnerAccountErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateAwsAccountWithPartnerAccountErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateAwsAccountWithPartnerAccountErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateAwsAccountWithPartnerAccountErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for AssociateAwsAccountWithPartnerAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateAwsAccountWithPartnerAccountErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::ConflictException(_inner) => {
                Some(_inner)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            AssociateAwsAccountWithPartnerAccountErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateWirelessDeviceWithThingError {
    pub kind: AssociateWirelessDeviceWithThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateWirelessDeviceWithThingErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateWirelessDeviceWithThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateWirelessDeviceWithThingErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessDeviceWithThingErrorKind::ConflictException(_inner) => _inner.fmt(f),
            AssociateWirelessDeviceWithThingErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessDeviceWithThingErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessDeviceWithThingErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            AssociateWirelessDeviceWithThingErrorKind::ValidationException(_inner) => _inner.fmt(f),
            AssociateWirelessDeviceWithThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateWirelessDeviceWithThingError {
    fn code(&self) -> Option<&str> {
        AssociateWirelessDeviceWithThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateWirelessDeviceWithThingError {
    pub fn new(kind: AssociateWirelessDeviceWithThingErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateWirelessDeviceWithThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateWirelessDeviceWithThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessDeviceWithThingErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessDeviceWithThingErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessDeviceWithThingErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessDeviceWithThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessDeviceWithThingErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessDeviceWithThingErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for AssociateWirelessDeviceWithThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateWirelessDeviceWithThingErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessDeviceWithThingErrorKind::ConflictException(_inner) => Some(_inner),
            AssociateWirelessDeviceWithThingErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessDeviceWithThingErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessDeviceWithThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateWirelessDeviceWithThingErrorKind::ValidationException(_inner) => Some(_inner),
            AssociateWirelessDeviceWithThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateWirelessGatewayWithCertificateError {
    pub kind: AssociateWirelessGatewayWithCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateWirelessGatewayWithCertificateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateWirelessGatewayWithCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateWirelessGatewayWithCertificateErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::ConflictException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateWirelessGatewayWithCertificateError {
    fn code(&self) -> Option<&str> {
        AssociateWirelessGatewayWithCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateWirelessGatewayWithCertificateError {
    pub fn new(
        kind: AssociateWirelessGatewayWithCertificateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateWirelessGatewayWithCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateWirelessGatewayWithCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithCertificateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithCertificateErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithCertificateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithCertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithCertificateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for AssociateWirelessGatewayWithCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateWirelessGatewayWithCertificateErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::ConflictException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessGatewayWithCertificateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateWirelessGatewayWithThingError {
    pub kind: AssociateWirelessGatewayWithThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateWirelessGatewayWithThingErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateWirelessGatewayWithThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateWirelessGatewayWithThingErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithThingErrorKind::ConflictException(_inner) => _inner.fmt(f),
            AssociateWirelessGatewayWithThingErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithThingErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithThingErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithThingErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            AssociateWirelessGatewayWithThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateWirelessGatewayWithThingError {
    fn code(&self) -> Option<&str> {
        AssociateWirelessGatewayWithThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateWirelessGatewayWithThingError {
    pub fn new(
        kind: AssociateWirelessGatewayWithThingErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateWirelessGatewayWithThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateWirelessGatewayWithThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithThingErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithThingErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithThingErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithThingErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateWirelessGatewayWithThingErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for AssociateWirelessGatewayWithThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateWirelessGatewayWithThingErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessGatewayWithThingErrorKind::ConflictException(_inner) => Some(_inner),
            AssociateWirelessGatewayWithThingErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessGatewayWithThingErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AssociateWirelessGatewayWithThingErrorKind::ThrottlingException(_inner) => Some(_inner),
            AssociateWirelessGatewayWithThingErrorKind::ValidationException(_inner) => Some(_inner),
            AssociateWirelessGatewayWithThingErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDestinationError {
    pub kind: CreateDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDestinationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDestinationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDestinationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateDestinationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateDestinationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateDestinationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDestinationErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDestinationError {
    fn code(&self) -> Option<&str> {
        CreateDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDestinationError {
    pub fn new(kind: CreateDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDestinationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateDestinationErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDestinationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDestinationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDestinationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDestinationErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDestinationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDestinationErrorKind::ConflictException(_inner) => Some(_inner),
            CreateDestinationErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateDestinationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateDestinationErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDestinationErrorKind::ValidationException(_inner) => Some(_inner),
            CreateDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDeviceProfileError {
    pub kind: CreateDeviceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDeviceProfileErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDeviceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDeviceProfileErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateDeviceProfileErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateDeviceProfileErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateDeviceProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateDeviceProfileErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateDeviceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDeviceProfileError {
    fn code(&self) -> Option<&str> {
        CreateDeviceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDeviceProfileError {
    pub fn new(kind: CreateDeviceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDeviceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDeviceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeviceProfileErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeviceProfileErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeviceProfileErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeviceProfileErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDeviceProfileErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateDeviceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDeviceProfileErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateDeviceProfileErrorKind::ConflictException(_inner) => Some(_inner),
            CreateDeviceProfileErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateDeviceProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateDeviceProfileErrorKind::ValidationException(_inner) => Some(_inner),
            CreateDeviceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateServiceProfileError {
    pub kind: CreateServiceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateServiceProfileErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateServiceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateServiceProfileErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateServiceProfileErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateServiceProfileErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateServiceProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateServiceProfileErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateServiceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateServiceProfileError {
    fn code(&self) -> Option<&str> {
        CreateServiceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateServiceProfileError {
    pub fn new(kind: CreateServiceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateServiceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateServiceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceProfileErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceProfileErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceProfileErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceProfileErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceProfileErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateServiceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateServiceProfileErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateServiceProfileErrorKind::ConflictException(_inner) => Some(_inner),
            CreateServiceProfileErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateServiceProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateServiceProfileErrorKind::ValidationException(_inner) => Some(_inner),
            CreateServiceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWirelessDeviceError {
    pub kind: CreateWirelessDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWirelessDeviceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWirelessDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWirelessDeviceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateWirelessDeviceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateWirelessDeviceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateWirelessDeviceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateWirelessDeviceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateWirelessDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWirelessDeviceError {
    fn code(&self) -> Option<&str> {
        CreateWirelessDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWirelessDeviceError {
    pub fn new(kind: CreateWirelessDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWirelessDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWirelessDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessDeviceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessDeviceErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessDeviceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessDeviceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessDeviceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateWirelessDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWirelessDeviceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateWirelessDeviceErrorKind::ConflictException(_inner) => Some(_inner),
            CreateWirelessDeviceErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateWirelessDeviceErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateWirelessDeviceErrorKind::ValidationException(_inner) => Some(_inner),
            CreateWirelessDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWirelessGatewayError {
    pub kind: CreateWirelessGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWirelessGatewayErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWirelessGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWirelessGatewayErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWirelessGatewayError {
    fn code(&self) -> Option<&str> {
        CreateWirelessGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWirelessGatewayError {
    pub fn new(kind: CreateWirelessGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWirelessGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWirelessGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateWirelessGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWirelessGatewayErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateWirelessGatewayErrorKind::ConflictException(_inner) => Some(_inner),
            CreateWirelessGatewayErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateWirelessGatewayErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateWirelessGatewayErrorKind::ValidationException(_inner) => Some(_inner),
            CreateWirelessGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWirelessGatewayTaskError {
    pub kind: CreateWirelessGatewayTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWirelessGatewayTaskErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWirelessGatewayTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWirelessGatewayTaskErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayTaskErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayTaskErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayTaskErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateWirelessGatewayTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWirelessGatewayTaskError {
    fn code(&self) -> Option<&str> {
        CreateWirelessGatewayTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWirelessGatewayTaskError {
    pub fn new(kind: CreateWirelessGatewayTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWirelessGatewayTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWirelessGatewayTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateWirelessGatewayTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWirelessGatewayTaskErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateWirelessGatewayTaskErrorKind::ConflictException(_inner) => Some(_inner),
            CreateWirelessGatewayTaskErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateWirelessGatewayTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateWirelessGatewayTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateWirelessGatewayTaskErrorKind::ValidationException(_inner) => Some(_inner),
            CreateWirelessGatewayTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateWirelessGatewayTaskDefinitionError {
    pub kind: CreateWirelessGatewayTaskDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateWirelessGatewayTaskDefinitionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateWirelessGatewayTaskDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateWirelessGatewayTaskDefinitionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::ConflictException(_inner) => {
                _inner.fmt(f)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateWirelessGatewayTaskDefinitionError {
    fn code(&self) -> Option<&str> {
        CreateWirelessGatewayTaskDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateWirelessGatewayTaskDefinitionError {
    pub fn new(
        kind: CreateWirelessGatewayTaskDefinitionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateWirelessGatewayTaskDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateWirelessGatewayTaskDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskDefinitionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskDefinitionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskDefinitionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskDefinitionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskDefinitionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateWirelessGatewayTaskDefinitionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateWirelessGatewayTaskDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateWirelessGatewayTaskDefinitionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::ConflictException(_inner) => Some(_inner),
            CreateWirelessGatewayTaskDefinitionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            CreateWirelessGatewayTaskDefinitionErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDestinationError {
    pub kind: DeleteDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDestinationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDestinationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDestinationError {
    fn code(&self) -> Option<&str> {
        DeleteDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDestinationError {
    pub fn new(kind: DeleteDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteDestinationErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDestinationErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDestinationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDestinationErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteDestinationErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteDestinationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteDestinationErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDestinationErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDeviceProfileError {
    pub kind: DeleteDeviceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDeviceProfileErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDeviceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDeviceProfileErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteDeviceProfileErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteDeviceProfileErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteDeviceProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteDeviceProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteDeviceProfileErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteDeviceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDeviceProfileError {
    fn code(&self) -> Option<&str> {
        DeleteDeviceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDeviceProfileError {
    pub fn new(kind: DeleteDeviceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDeviceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDeviceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeviceProfileErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeviceProfileErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeviceProfileErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeviceProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeviceProfileErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDeviceProfileErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteDeviceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDeviceProfileErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteDeviceProfileErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteDeviceProfileErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteDeviceProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteDeviceProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteDeviceProfileErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteDeviceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServiceProfileError {
    pub kind: DeleteServiceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceProfileErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServiceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServiceProfileErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteServiceProfileErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteServiceProfileErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteServiceProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteServiceProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteServiceProfileErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteServiceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServiceProfileError {
    fn code(&self) -> Option<&str> {
        DeleteServiceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteServiceProfileError {
    pub fn new(kind: DeleteServiceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServiceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServiceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceProfileErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceProfileErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceProfileErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceProfileErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceProfileErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteServiceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServiceProfileErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteServiceProfileErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteServiceProfileErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteServiceProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteServiceProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteServiceProfileErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteServiceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteWirelessDeviceError {
    pub kind: DeleteWirelessDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteWirelessDeviceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteWirelessDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteWirelessDeviceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteWirelessDeviceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteWirelessDeviceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteWirelessDeviceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteWirelessDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteWirelessDeviceError {
    fn code(&self) -> Option<&str> {
        DeleteWirelessDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteWirelessDeviceError {
    pub fn new(kind: DeleteWirelessDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteWirelessDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteWirelessDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessDeviceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessDeviceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessDeviceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessDeviceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteWirelessDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteWirelessDeviceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteWirelessDeviceErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteWirelessDeviceErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteWirelessDeviceErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteWirelessDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteWirelessGatewayError {
    pub kind: DeleteWirelessGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteWirelessGatewayErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteWirelessGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteWirelessGatewayErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteWirelessGatewayErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteWirelessGatewayErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteWirelessGatewayErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteWirelessGatewayErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteWirelessGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteWirelessGatewayError {
    fn code(&self) -> Option<&str> {
        DeleteWirelessGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteWirelessGatewayError {
    pub fn new(kind: DeleteWirelessGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteWirelessGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteWirelessGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteWirelessGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteWirelessGatewayErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteWirelessGatewayErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteWirelessGatewayErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteWirelessGatewayErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteWirelessGatewayErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteWirelessGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteWirelessGatewayTaskError {
    pub kind: DeleteWirelessGatewayTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteWirelessGatewayTaskErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteWirelessGatewayTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteWirelessGatewayTaskErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteWirelessGatewayTaskErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteWirelessGatewayTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteWirelessGatewayTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteWirelessGatewayTaskErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteWirelessGatewayTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteWirelessGatewayTaskError {
    fn code(&self) -> Option<&str> {
        DeleteWirelessGatewayTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteWirelessGatewayTaskError {
    pub fn new(kind: DeleteWirelessGatewayTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteWirelessGatewayTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteWirelessGatewayTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayTaskErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayTaskErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayTaskErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayTaskErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteWirelessGatewayTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteWirelessGatewayTaskErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteWirelessGatewayTaskErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteWirelessGatewayTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteWirelessGatewayTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteWirelessGatewayTaskErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteWirelessGatewayTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteWirelessGatewayTaskDefinitionError {
    pub kind: DeleteWirelessGatewayTaskDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteWirelessGatewayTaskDefinitionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteWirelessGatewayTaskDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteWirelessGatewayTaskDefinitionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteWirelessGatewayTaskDefinitionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DeleteWirelessGatewayTaskDefinitionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteWirelessGatewayTaskDefinitionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DeleteWirelessGatewayTaskDefinitionErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteWirelessGatewayTaskDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteWirelessGatewayTaskDefinitionError {
    fn code(&self) -> Option<&str> {
        DeleteWirelessGatewayTaskDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteWirelessGatewayTaskDefinitionError {
    pub fn new(
        kind: DeleteWirelessGatewayTaskDefinitionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteWirelessGatewayTaskDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteWirelessGatewayTaskDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayTaskDefinitionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayTaskDefinitionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayTaskDefinitionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayTaskDefinitionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteWirelessGatewayTaskDefinitionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteWirelessGatewayTaskDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteWirelessGatewayTaskDefinitionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DeleteWirelessGatewayTaskDefinitionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            DeleteWirelessGatewayTaskDefinitionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteWirelessGatewayTaskDefinitionErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DeleteWirelessGatewayTaskDefinitionErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DeleteWirelessGatewayTaskDefinitionErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateAwsAccountFromPartnerAccountError {
    pub kind: DisassociateAwsAccountFromPartnerAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateAwsAccountFromPartnerAccountErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateAwsAccountFromPartnerAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateAwsAccountFromPartnerAccountErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateAwsAccountFromPartnerAccountErrorKind::ResourceNotFoundException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateAwsAccountFromPartnerAccountErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateAwsAccountFromPartnerAccountErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateAwsAccountFromPartnerAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateAwsAccountFromPartnerAccountError {
    fn code(&self) -> Option<&str> {
        DisassociateAwsAccountFromPartnerAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateAwsAccountFromPartnerAccountError {
    pub fn new(
        kind: DisassociateAwsAccountFromPartnerAccountErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateAwsAccountFromPartnerAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateAwsAccountFromPartnerAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateAwsAccountFromPartnerAccountErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateAwsAccountFromPartnerAccountErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateAwsAccountFromPartnerAccountErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateAwsAccountFromPartnerAccountErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DisassociateAwsAccountFromPartnerAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateAwsAccountFromPartnerAccountErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            DisassociateAwsAccountFromPartnerAccountErrorKind::ResourceNotFoundException(
                _inner,
            ) => Some(_inner),
            DisassociateAwsAccountFromPartnerAccountErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DisassociateAwsAccountFromPartnerAccountErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DisassociateAwsAccountFromPartnerAccountErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateWirelessDeviceFromThingError {
    pub kind: DisassociateWirelessDeviceFromThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateWirelessDeviceFromThingErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateWirelessDeviceFromThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateWirelessDeviceFromThingErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessDeviceFromThingErrorKind::ConflictException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessDeviceFromThingErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessDeviceFromThingErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessDeviceFromThingErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessDeviceFromThingErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessDeviceFromThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateWirelessDeviceFromThingError {
    fn code(&self) -> Option<&str> {
        DisassociateWirelessDeviceFromThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateWirelessDeviceFromThingError {
    pub fn new(
        kind: DisassociateWirelessDeviceFromThingErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateWirelessDeviceFromThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateWirelessDeviceFromThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessDeviceFromThingErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessDeviceFromThingErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessDeviceFromThingErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessDeviceFromThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessDeviceFromThingErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessDeviceFromThingErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DisassociateWirelessDeviceFromThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateWirelessDeviceFromThingErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessDeviceFromThingErrorKind::ConflictException(_inner) => Some(_inner),
            DisassociateWirelessDeviceFromThingErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessDeviceFromThingErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessDeviceFromThingErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessDeviceFromThingErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessDeviceFromThingErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateWirelessGatewayFromCertificateError {
    pub kind: DisassociateWirelessGatewayFromCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateWirelessGatewayFromCertificateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateWirelessGatewayFromCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateWirelessGatewayFromCertificateErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessGatewayFromCertificateErrorKind::InternalServerException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateWirelessGatewayFromCertificateErrorKind::ResourceNotFoundException(
                _inner,
            ) => _inner.fmt(f),
            DisassociateWirelessGatewayFromCertificateErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessGatewayFromCertificateErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessGatewayFromCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateWirelessGatewayFromCertificateError {
    fn code(&self) -> Option<&str> {
        DisassociateWirelessGatewayFromCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateWirelessGatewayFromCertificateError {
    pub fn new(
        kind: DisassociateWirelessGatewayFromCertificateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateWirelessGatewayFromCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateWirelessGatewayFromCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromCertificateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromCertificateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromCertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromCertificateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DisassociateWirelessGatewayFromCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateWirelessGatewayFromCertificateErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessGatewayFromCertificateErrorKind::InternalServerException(
                _inner,
            ) => Some(_inner),
            DisassociateWirelessGatewayFromCertificateErrorKind::ResourceNotFoundException(
                _inner,
            ) => Some(_inner),
            DisassociateWirelessGatewayFromCertificateErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessGatewayFromCertificateErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessGatewayFromCertificateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateWirelessGatewayFromThingError {
    pub kind: DisassociateWirelessGatewayFromThingErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateWirelessGatewayFromThingErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateWirelessGatewayFromThingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateWirelessGatewayFromThingErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessGatewayFromThingErrorKind::ConflictException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessGatewayFromThingErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessGatewayFromThingErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessGatewayFromThingErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessGatewayFromThingErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateWirelessGatewayFromThingErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateWirelessGatewayFromThingError {
    fn code(&self) -> Option<&str> {
        DisassociateWirelessGatewayFromThingError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateWirelessGatewayFromThingError {
    pub fn new(
        kind: DisassociateWirelessGatewayFromThingErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateWirelessGatewayFromThingErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateWirelessGatewayFromThingErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromThingErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromThingErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromThingErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromThingErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromThingErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateWirelessGatewayFromThingErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DisassociateWirelessGatewayFromThingError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateWirelessGatewayFromThingErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessGatewayFromThingErrorKind::ConflictException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessGatewayFromThingErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessGatewayFromThingErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessGatewayFromThingErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessGatewayFromThingErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DisassociateWirelessGatewayFromThingErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDestinationError {
    pub kind: GetDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDestinationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDestinationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDestinationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetDestinationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetDestinationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetDestinationErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDestinationError {
    fn code(&self) -> Option<&str> {
        GetDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDestinationError {
    pub fn new(kind: GetDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDestinationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDestinationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDestinationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetDestinationErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetDestinationErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDestinationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDestinationErrorKind::InternalServerException(_inner) => Some(_inner),
            GetDestinationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetDestinationErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetDestinationErrorKind::ValidationException(_inner) => Some(_inner),
            GetDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDeviceProfileError {
    pub kind: GetDeviceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDeviceProfileErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDeviceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDeviceProfileErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetDeviceProfileErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetDeviceProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetDeviceProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetDeviceProfileErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetDeviceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDeviceProfileError {
    fn code(&self) -> Option<&str> {
        GetDeviceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDeviceProfileError {
    pub fn new(kind: GetDeviceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDeviceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDeviceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeviceProfileErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeviceProfileErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeviceProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeviceProfileErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDeviceProfileErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetDeviceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDeviceProfileErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetDeviceProfileErrorKind::InternalServerException(_inner) => Some(_inner),
            GetDeviceProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetDeviceProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetDeviceProfileErrorKind::ValidationException(_inner) => Some(_inner),
            GetDeviceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetLogLevelsByResourceTypesError {
    pub kind: GetLogLevelsByResourceTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetLogLevelsByResourceTypesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetLogLevelsByResourceTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetLogLevelsByResourceTypesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetLogLevelsByResourceTypesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetLogLevelsByResourceTypesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetLogLevelsByResourceTypesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetLogLevelsByResourceTypesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetLogLevelsByResourceTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetLogLevelsByResourceTypesError {
    fn code(&self) -> Option<&str> {
        GetLogLevelsByResourceTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetLogLevelsByResourceTypesError {
    pub fn new(kind: GetLogLevelsByResourceTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetLogLevelsByResourceTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetLogLevelsByResourceTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogLevelsByResourceTypesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogLevelsByResourceTypesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogLevelsByResourceTypesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogLevelsByResourceTypesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetLogLevelsByResourceTypesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetLogLevelsByResourceTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetLogLevelsByResourceTypesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetLogLevelsByResourceTypesErrorKind::InternalServerException(_inner) => Some(_inner),
            GetLogLevelsByResourceTypesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetLogLevelsByResourceTypesErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetLogLevelsByResourceTypesErrorKind::ValidationException(_inner) => Some(_inner),
            GetLogLevelsByResourceTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPartnerAccountError {
    pub kind: GetPartnerAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPartnerAccountErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPartnerAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPartnerAccountErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetPartnerAccountErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPartnerAccountErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetPartnerAccountErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetPartnerAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPartnerAccountError {
    fn code(&self) -> Option<&str> {
        GetPartnerAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPartnerAccountError {
    pub fn new(kind: GetPartnerAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPartnerAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPartnerAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartnerAccountErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartnerAccountErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartnerAccountErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPartnerAccountErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetPartnerAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPartnerAccountErrorKind::InternalServerException(_inner) => Some(_inner),
            GetPartnerAccountErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetPartnerAccountErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetPartnerAccountErrorKind::ValidationException(_inner) => Some(_inner),
            GetPartnerAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResourceLogLevelError {
    pub kind: GetResourceLogLevelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourceLogLevelErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResourceLogLevelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResourceLogLevelErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetResourceLogLevelErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetResourceLogLevelErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetResourceLogLevelErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetResourceLogLevelErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetResourceLogLevelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResourceLogLevelError {
    fn code(&self) -> Option<&str> {
        GetResourceLogLevelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResourceLogLevelError {
    pub fn new(kind: GetResourceLogLevelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResourceLogLevelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResourceLogLevelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceLogLevelErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceLogLevelErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceLogLevelErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceLogLevelErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetResourceLogLevelErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetResourceLogLevelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResourceLogLevelErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetResourceLogLevelErrorKind::InternalServerException(_inner) => Some(_inner),
            GetResourceLogLevelErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetResourceLogLevelErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetResourceLogLevelErrorKind::ValidationException(_inner) => Some(_inner),
            GetResourceLogLevelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceEndpointError {
    pub kind: GetServiceEndpointErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceEndpointErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceEndpointErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetServiceEndpointErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetServiceEndpointErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetServiceEndpointErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetServiceEndpointErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceEndpointError {
    fn code(&self) -> Option<&str> {
        GetServiceEndpointError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceEndpointError {
    pub fn new(kind: GetServiceEndpointErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceEndpointErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceEndpointErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceEndpointErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceEndpointErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceEndpointErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceEndpointErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetServiceEndpointError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceEndpointErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetServiceEndpointErrorKind::InternalServerException(_inner) => Some(_inner),
            GetServiceEndpointErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetServiceEndpointErrorKind::ValidationException(_inner) => Some(_inner),
            GetServiceEndpointErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceProfileError {
    pub kind: GetServiceProfileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceProfileErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceProfileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceProfileErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetServiceProfileErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetServiceProfileErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetServiceProfileErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetServiceProfileErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetServiceProfileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceProfileError {
    fn code(&self) -> Option<&str> {
        GetServiceProfileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetServiceProfileError {
    pub fn new(kind: GetServiceProfileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceProfileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceProfileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceProfileErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceProfileErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceProfileErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceProfileErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceProfileErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetServiceProfileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceProfileErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetServiceProfileErrorKind::InternalServerException(_inner) => Some(_inner),
            GetServiceProfileErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetServiceProfileErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetServiceProfileErrorKind::ValidationException(_inner) => Some(_inner),
            GetServiceProfileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWirelessDeviceError {
    pub kind: GetWirelessDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWirelessDeviceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWirelessDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWirelessDeviceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetWirelessDeviceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetWirelessDeviceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetWirelessDeviceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetWirelessDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWirelessDeviceError {
    fn code(&self) -> Option<&str> {
        GetWirelessDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWirelessDeviceError {
    pub fn new(kind: GetWirelessDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWirelessDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWirelessDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessDeviceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessDeviceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessDeviceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessDeviceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetWirelessDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWirelessDeviceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetWirelessDeviceErrorKind::InternalServerException(_inner) => Some(_inner),
            GetWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetWirelessDeviceErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetWirelessDeviceErrorKind::ValidationException(_inner) => Some(_inner),
            GetWirelessDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWirelessDeviceStatisticsError {
    pub kind: GetWirelessDeviceStatisticsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWirelessDeviceStatisticsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWirelessDeviceStatisticsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWirelessDeviceStatisticsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetWirelessDeviceStatisticsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetWirelessDeviceStatisticsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessDeviceStatisticsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetWirelessDeviceStatisticsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetWirelessDeviceStatisticsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWirelessDeviceStatisticsError {
    fn code(&self) -> Option<&str> {
        GetWirelessDeviceStatisticsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWirelessDeviceStatisticsError {
    pub fn new(kind: GetWirelessDeviceStatisticsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWirelessDeviceStatisticsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWirelessDeviceStatisticsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessDeviceStatisticsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessDeviceStatisticsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessDeviceStatisticsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessDeviceStatisticsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessDeviceStatisticsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetWirelessDeviceStatisticsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWirelessDeviceStatisticsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetWirelessDeviceStatisticsErrorKind::InternalServerException(_inner) => Some(_inner),
            GetWirelessDeviceStatisticsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetWirelessDeviceStatisticsErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetWirelessDeviceStatisticsErrorKind::ValidationException(_inner) => Some(_inner),
            GetWirelessDeviceStatisticsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWirelessGatewayError {
    pub kind: GetWirelessGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWirelessGatewayErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWirelessGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWirelessGatewayErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetWirelessGatewayErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetWirelessGatewayErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetWirelessGatewayErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetWirelessGatewayErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetWirelessGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWirelessGatewayError {
    fn code(&self) -> Option<&str> {
        GetWirelessGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWirelessGatewayError {
    pub fn new(kind: GetWirelessGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWirelessGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWirelessGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetWirelessGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWirelessGatewayErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetWirelessGatewayErrorKind::InternalServerException(_inner) => Some(_inner),
            GetWirelessGatewayErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetWirelessGatewayErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetWirelessGatewayErrorKind::ValidationException(_inner) => Some(_inner),
            GetWirelessGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWirelessGatewayCertificateError {
    pub kind: GetWirelessGatewayCertificateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWirelessGatewayCertificateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWirelessGatewayCertificateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWirelessGatewayCertificateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetWirelessGatewayCertificateErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayCertificateErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayCertificateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetWirelessGatewayCertificateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetWirelessGatewayCertificateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWirelessGatewayCertificateError {
    fn code(&self) -> Option<&str> {
        GetWirelessGatewayCertificateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWirelessGatewayCertificateError {
    pub fn new(kind: GetWirelessGatewayCertificateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWirelessGatewayCertificateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWirelessGatewayCertificateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayCertificateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayCertificateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayCertificateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayCertificateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayCertificateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetWirelessGatewayCertificateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWirelessGatewayCertificateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetWirelessGatewayCertificateErrorKind::InternalServerException(_inner) => Some(_inner),
            GetWirelessGatewayCertificateErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetWirelessGatewayCertificateErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetWirelessGatewayCertificateErrorKind::ValidationException(_inner) => Some(_inner),
            GetWirelessGatewayCertificateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWirelessGatewayFirmwareInformationError {
    pub kind: GetWirelessGatewayFirmwareInformationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWirelessGatewayFirmwareInformationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWirelessGatewayFirmwareInformationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWirelessGatewayFirmwareInformationErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayFirmwareInformationErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayFirmwareInformationErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayFirmwareInformationErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayFirmwareInformationErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayFirmwareInformationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWirelessGatewayFirmwareInformationError {
    fn code(&self) -> Option<&str> {
        GetWirelessGatewayFirmwareInformationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWirelessGatewayFirmwareInformationError {
    pub fn new(
        kind: GetWirelessGatewayFirmwareInformationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWirelessGatewayFirmwareInformationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWirelessGatewayFirmwareInformationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayFirmwareInformationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayFirmwareInformationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayFirmwareInformationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayFirmwareInformationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayFirmwareInformationErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetWirelessGatewayFirmwareInformationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWirelessGatewayFirmwareInformationErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetWirelessGatewayFirmwareInformationErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            GetWirelessGatewayFirmwareInformationErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetWirelessGatewayFirmwareInformationErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            GetWirelessGatewayFirmwareInformationErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            GetWirelessGatewayFirmwareInformationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWirelessGatewayStatisticsError {
    pub kind: GetWirelessGatewayStatisticsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWirelessGatewayStatisticsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWirelessGatewayStatisticsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWirelessGatewayStatisticsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetWirelessGatewayStatisticsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetWirelessGatewayStatisticsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayStatisticsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetWirelessGatewayStatisticsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetWirelessGatewayStatisticsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWirelessGatewayStatisticsError {
    fn code(&self) -> Option<&str> {
        GetWirelessGatewayStatisticsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWirelessGatewayStatisticsError {
    pub fn new(kind: GetWirelessGatewayStatisticsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWirelessGatewayStatisticsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWirelessGatewayStatisticsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayStatisticsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayStatisticsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayStatisticsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayStatisticsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayStatisticsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetWirelessGatewayStatisticsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWirelessGatewayStatisticsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetWirelessGatewayStatisticsErrorKind::InternalServerException(_inner) => Some(_inner),
            GetWirelessGatewayStatisticsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetWirelessGatewayStatisticsErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetWirelessGatewayStatisticsErrorKind::ValidationException(_inner) => Some(_inner),
            GetWirelessGatewayStatisticsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWirelessGatewayTaskError {
    pub kind: GetWirelessGatewayTaskErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWirelessGatewayTaskErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWirelessGatewayTaskError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWirelessGatewayTaskErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetWirelessGatewayTaskErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetWirelessGatewayTaskErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetWirelessGatewayTaskErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetWirelessGatewayTaskErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetWirelessGatewayTaskErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWirelessGatewayTaskError {
    fn code(&self) -> Option<&str> {
        GetWirelessGatewayTaskError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWirelessGatewayTaskError {
    pub fn new(kind: GetWirelessGatewayTaskErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWirelessGatewayTaskErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWirelessGatewayTaskErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayTaskErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayTaskErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayTaskErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayTaskErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayTaskErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetWirelessGatewayTaskError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWirelessGatewayTaskErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetWirelessGatewayTaskErrorKind::InternalServerException(_inner) => Some(_inner),
            GetWirelessGatewayTaskErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetWirelessGatewayTaskErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetWirelessGatewayTaskErrorKind::ValidationException(_inner) => Some(_inner),
            GetWirelessGatewayTaskErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetWirelessGatewayTaskDefinitionError {
    pub kind: GetWirelessGatewayTaskDefinitionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetWirelessGatewayTaskDefinitionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetWirelessGatewayTaskDefinitionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetWirelessGatewayTaskDefinitionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayTaskDefinitionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayTaskDefinitionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetWirelessGatewayTaskDefinitionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetWirelessGatewayTaskDefinitionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetWirelessGatewayTaskDefinitionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetWirelessGatewayTaskDefinitionError {
    fn code(&self) -> Option<&str> {
        GetWirelessGatewayTaskDefinitionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetWirelessGatewayTaskDefinitionError {
    pub fn new(kind: GetWirelessGatewayTaskDefinitionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetWirelessGatewayTaskDefinitionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetWirelessGatewayTaskDefinitionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayTaskDefinitionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayTaskDefinitionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayTaskDefinitionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayTaskDefinitionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetWirelessGatewayTaskDefinitionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetWirelessGatewayTaskDefinitionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetWirelessGatewayTaskDefinitionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetWirelessGatewayTaskDefinitionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            GetWirelessGatewayTaskDefinitionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetWirelessGatewayTaskDefinitionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetWirelessGatewayTaskDefinitionErrorKind::ValidationException(_inner) => Some(_inner),
            GetWirelessGatewayTaskDefinitionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDestinationsError {
    pub kind: ListDestinationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDestinationsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDestinationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDestinationsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListDestinationsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListDestinationsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDestinationsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListDestinationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDestinationsError {
    fn code(&self) -> Option<&str> {
        ListDestinationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDestinationsError {
    pub fn new(kind: ListDestinationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDestinationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDestinationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDestinationsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDestinationsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDestinationsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDestinationsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListDestinationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDestinationsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListDestinationsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListDestinationsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDestinationsErrorKind::ValidationException(_inner) => Some(_inner),
            ListDestinationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListDeviceProfilesError {
    pub kind: ListDeviceProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListDeviceProfilesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListDeviceProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListDeviceProfilesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListDeviceProfilesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListDeviceProfilesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListDeviceProfilesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListDeviceProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListDeviceProfilesError {
    fn code(&self) -> Option<&str> {
        ListDeviceProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListDeviceProfilesError {
    pub fn new(kind: ListDeviceProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListDeviceProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListDeviceProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeviceProfilesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeviceProfilesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeviceProfilesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListDeviceProfilesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListDeviceProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListDeviceProfilesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListDeviceProfilesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListDeviceProfilesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListDeviceProfilesErrorKind::ValidationException(_inner) => Some(_inner),
            ListDeviceProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPartnerAccountsError {
    pub kind: ListPartnerAccountsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPartnerAccountsErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPartnerAccountsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPartnerAccountsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListPartnerAccountsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListPartnerAccountsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListPartnerAccountsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListPartnerAccountsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPartnerAccountsError {
    fn code(&self) -> Option<&str> {
        ListPartnerAccountsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPartnerAccountsError {
    pub fn new(kind: ListPartnerAccountsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPartnerAccountsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPartnerAccountsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPartnerAccountsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPartnerAccountsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPartnerAccountsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPartnerAccountsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListPartnerAccountsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPartnerAccountsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListPartnerAccountsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListPartnerAccountsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListPartnerAccountsErrorKind::ValidationException(_inner) => Some(_inner),
            ListPartnerAccountsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServiceProfilesError {
    pub kind: ListServiceProfilesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServiceProfilesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServiceProfilesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServiceProfilesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListServiceProfilesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListServiceProfilesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListServiceProfilesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListServiceProfilesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServiceProfilesError {
    fn code(&self) -> Option<&str> {
        ListServiceProfilesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListServiceProfilesError {
    pub fn new(kind: ListServiceProfilesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServiceProfilesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServiceProfilesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceProfilesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceProfilesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceProfilesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceProfilesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListServiceProfilesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServiceProfilesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListServiceProfilesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListServiceProfilesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListServiceProfilesErrorKind::ValidationException(_inner) => Some(_inner),
            ListServiceProfilesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::ConflictException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ValidationException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWirelessDevicesError {
    pub kind: ListWirelessDevicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWirelessDevicesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWirelessDevicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWirelessDevicesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListWirelessDevicesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListWirelessDevicesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListWirelessDevicesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListWirelessDevicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWirelessDevicesError {
    fn code(&self) -> Option<&str> {
        ListWirelessDevicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWirelessDevicesError {
    pub fn new(kind: ListWirelessDevicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWirelessDevicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWirelessDevicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessDevicesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessDevicesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessDevicesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessDevicesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListWirelessDevicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWirelessDevicesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListWirelessDevicesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListWirelessDevicesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListWirelessDevicesErrorKind::ValidationException(_inner) => Some(_inner),
            ListWirelessDevicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWirelessGatewaysError {
    pub kind: ListWirelessGatewaysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWirelessGatewaysErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWirelessGatewaysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWirelessGatewaysErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListWirelessGatewaysErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListWirelessGatewaysErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListWirelessGatewaysErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListWirelessGatewaysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWirelessGatewaysError {
    fn code(&self) -> Option<&str> {
        ListWirelessGatewaysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWirelessGatewaysError {
    pub fn new(kind: ListWirelessGatewaysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWirelessGatewaysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWirelessGatewaysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessGatewaysErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessGatewaysErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessGatewaysErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessGatewaysErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListWirelessGatewaysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWirelessGatewaysErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListWirelessGatewaysErrorKind::InternalServerException(_inner) => Some(_inner),
            ListWirelessGatewaysErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListWirelessGatewaysErrorKind::ValidationException(_inner) => Some(_inner),
            ListWirelessGatewaysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListWirelessGatewayTaskDefinitionsError {
    pub kind: ListWirelessGatewayTaskDefinitionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListWirelessGatewayTaskDefinitionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListWirelessGatewayTaskDefinitionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListWirelessGatewayTaskDefinitionsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListWirelessGatewayTaskDefinitionsErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            ListWirelessGatewayTaskDefinitionsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            ListWirelessGatewayTaskDefinitionsErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            ListWirelessGatewayTaskDefinitionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListWirelessGatewayTaskDefinitionsError {
    fn code(&self) -> Option<&str> {
        ListWirelessGatewayTaskDefinitionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListWirelessGatewayTaskDefinitionsError {
    pub fn new(
        kind: ListWirelessGatewayTaskDefinitionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListWirelessGatewayTaskDefinitionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListWirelessGatewayTaskDefinitionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessGatewayTaskDefinitionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessGatewayTaskDefinitionsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessGatewayTaskDefinitionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListWirelessGatewayTaskDefinitionsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListWirelessGatewayTaskDefinitionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListWirelessGatewayTaskDefinitionsErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListWirelessGatewayTaskDefinitionsErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            ListWirelessGatewayTaskDefinitionsErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            ListWirelessGatewayTaskDefinitionsErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            ListWirelessGatewayTaskDefinitionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutResourceLogLevelError {
    pub kind: PutResourceLogLevelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutResourceLogLevelErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutResourceLogLevelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutResourceLogLevelErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            PutResourceLogLevelErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            PutResourceLogLevelErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            PutResourceLogLevelErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            PutResourceLogLevelErrorKind::ValidationException(_inner) => _inner.fmt(f),
            PutResourceLogLevelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutResourceLogLevelError {
    fn code(&self) -> Option<&str> {
        PutResourceLogLevelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutResourceLogLevelError {
    pub fn new(kind: PutResourceLogLevelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutResourceLogLevelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutResourceLogLevelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourceLogLevelErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourceLogLevelErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourceLogLevelErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourceLogLevelErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutResourceLogLevelErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for PutResourceLogLevelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutResourceLogLevelErrorKind::AccessDeniedException(_inner) => Some(_inner),
            PutResourceLogLevelErrorKind::InternalServerException(_inner) => Some(_inner),
            PutResourceLogLevelErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            PutResourceLogLevelErrorKind::ThrottlingException(_inner) => Some(_inner),
            PutResourceLogLevelErrorKind::ValidationException(_inner) => Some(_inner),
            PutResourceLogLevelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetAllResourceLogLevelsError {
    pub kind: ResetAllResourceLogLevelsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetAllResourceLogLevelsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetAllResourceLogLevelsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetAllResourceLogLevelsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ResetAllResourceLogLevelsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ResetAllResourceLogLevelsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ResetAllResourceLogLevelsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ResetAllResourceLogLevelsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ResetAllResourceLogLevelsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetAllResourceLogLevelsError {
    fn code(&self) -> Option<&str> {
        ResetAllResourceLogLevelsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetAllResourceLogLevelsError {
    pub fn new(kind: ResetAllResourceLogLevelsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetAllResourceLogLevelsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetAllResourceLogLevelsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetAllResourceLogLevelsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetAllResourceLogLevelsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetAllResourceLogLevelsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetAllResourceLogLevelsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetAllResourceLogLevelsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ResetAllResourceLogLevelsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetAllResourceLogLevelsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ResetAllResourceLogLevelsErrorKind::InternalServerException(_inner) => Some(_inner),
            ResetAllResourceLogLevelsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ResetAllResourceLogLevelsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ResetAllResourceLogLevelsErrorKind::ValidationException(_inner) => Some(_inner),
            ResetAllResourceLogLevelsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ResetResourceLogLevelError {
    pub kind: ResetResourceLogLevelErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ResetResourceLogLevelErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ResetResourceLogLevelError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ResetResourceLogLevelErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ResetResourceLogLevelErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ResetResourceLogLevelErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ResetResourceLogLevelErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ResetResourceLogLevelErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ResetResourceLogLevelErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ResetResourceLogLevelError {
    fn code(&self) -> Option<&str> {
        ResetResourceLogLevelError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ResetResourceLogLevelError {
    pub fn new(kind: ResetResourceLogLevelErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ResetResourceLogLevelErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ResetResourceLogLevelErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetResourceLogLevelErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetResourceLogLevelErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetResourceLogLevelErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetResourceLogLevelErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ResetResourceLogLevelErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ResetResourceLogLevelError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ResetResourceLogLevelErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ResetResourceLogLevelErrorKind::InternalServerException(_inner) => Some(_inner),
            ResetResourceLogLevelErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ResetResourceLogLevelErrorKind::ThrottlingException(_inner) => Some(_inner),
            ResetResourceLogLevelErrorKind::ValidationException(_inner) => Some(_inner),
            ResetResourceLogLevelErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct SendDataToWirelessDeviceError {
    pub kind: SendDataToWirelessDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum SendDataToWirelessDeviceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for SendDataToWirelessDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            SendDataToWirelessDeviceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            SendDataToWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            SendDataToWirelessDeviceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            SendDataToWirelessDeviceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            SendDataToWirelessDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for SendDataToWirelessDeviceError {
    fn code(&self) -> Option<&str> {
        SendDataToWirelessDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl SendDataToWirelessDeviceError {
    pub fn new(kind: SendDataToWirelessDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: SendDataToWirelessDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: SendDataToWirelessDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendDataToWirelessDeviceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendDataToWirelessDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendDataToWirelessDeviceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            SendDataToWirelessDeviceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for SendDataToWirelessDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            SendDataToWirelessDeviceErrorKind::InternalServerException(_inner) => Some(_inner),
            SendDataToWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            SendDataToWirelessDeviceErrorKind::ThrottlingException(_inner) => Some(_inner),
            SendDataToWirelessDeviceErrorKind::ValidationException(_inner) => Some(_inner),
            SendDataToWirelessDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    TooManyTagsException(crate::error::TooManyTagsException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TooManyTagsException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::ConflictException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            TagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestWirelessDeviceError {
    pub kind: TestWirelessDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestWirelessDeviceErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestWirelessDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestWirelessDeviceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            TestWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TestWirelessDeviceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TestWirelessDeviceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            TestWirelessDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestWirelessDeviceError {
    fn code(&self) -> Option<&str> {
        TestWirelessDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestWirelessDeviceError {
    pub fn new(kind: TestWirelessDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestWirelessDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestWirelessDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestWirelessDeviceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestWirelessDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestWirelessDeviceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestWirelessDeviceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for TestWirelessDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestWirelessDeviceErrorKind::InternalServerException(_inner) => Some(_inner),
            TestWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TestWirelessDeviceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TestWirelessDeviceErrorKind::ValidationException(_inner) => Some(_inner),
            TestWirelessDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::ConflictException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDestinationError {
    pub kind: UpdateDestinationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDestinationErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDestinationErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateDestinationErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateDestinationErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateDestinationErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateDestinationErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateDestinationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDestinationError {
    fn code(&self) -> Option<&str> {
        UpdateDestinationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDestinationError {
    pub fn new(kind: UpdateDestinationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDestinationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDestinationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDestinationErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDestinationErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDestinationErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDestinationErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDestinationErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateDestinationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDestinationErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateDestinationErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateDestinationErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateDestinationErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateDestinationErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateDestinationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateLogLevelsByResourceTypesError {
    pub kind: UpdateLogLevelsByResourceTypesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateLogLevelsByResourceTypesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateLogLevelsByResourceTypesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateLogLevelsByResourceTypesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateLogLevelsByResourceTypesErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateLogLevelsByResourceTypesErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLogLevelsByResourceTypesErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateLogLevelsByResourceTypesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateLogLevelsByResourceTypesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateLogLevelsByResourceTypesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateLogLevelsByResourceTypesError {
    fn code(&self) -> Option<&str> {
        UpdateLogLevelsByResourceTypesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateLogLevelsByResourceTypesError {
    pub fn new(kind: UpdateLogLevelsByResourceTypesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateLogLevelsByResourceTypesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateLogLevelsByResourceTypesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLogLevelsByResourceTypesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLogLevelsByResourceTypesErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLogLevelsByResourceTypesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLogLevelsByResourceTypesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLogLevelsByResourceTypesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLogLevelsByResourceTypesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateLogLevelsByResourceTypesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateLogLevelsByResourceTypesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateLogLevelsByResourceTypesErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateLogLevelsByResourceTypesErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            UpdateLogLevelsByResourceTypesErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateLogLevelsByResourceTypesErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateLogLevelsByResourceTypesErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateLogLevelsByResourceTypesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePartnerAccountError {
    pub kind: UpdatePartnerAccountErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePartnerAccountErrorKind {
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePartnerAccountError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePartnerAccountErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdatePartnerAccountErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdatePartnerAccountErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdatePartnerAccountErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdatePartnerAccountErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePartnerAccountError {
    fn code(&self) -> Option<&str> {
        UpdatePartnerAccountError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePartnerAccountError {
    pub fn new(kind: UpdatePartnerAccountErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePartnerAccountErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePartnerAccountErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePartnerAccountErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePartnerAccountErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePartnerAccountErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePartnerAccountErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdatePartnerAccountError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePartnerAccountErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdatePartnerAccountErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdatePartnerAccountErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdatePartnerAccountErrorKind::ValidationException(_inner) => Some(_inner),
            UpdatePartnerAccountErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateWirelessDeviceError {
    pub kind: UpdateWirelessDeviceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateWirelessDeviceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateWirelessDeviceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateWirelessDeviceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateWirelessDeviceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateWirelessDeviceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateWirelessDeviceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateWirelessDeviceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateWirelessDeviceError {
    fn code(&self) -> Option<&str> {
        UpdateWirelessDeviceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateWirelessDeviceError {
    pub fn new(kind: UpdateWirelessDeviceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateWirelessDeviceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateWirelessDeviceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWirelessDeviceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWirelessDeviceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWirelessDeviceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWirelessDeviceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWirelessDeviceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateWirelessDeviceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateWirelessDeviceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateWirelessDeviceErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateWirelessDeviceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateWirelessDeviceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateWirelessDeviceErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateWirelessDeviceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateWirelessGatewayError {
    pub kind: UpdateWirelessGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateWirelessGatewayErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateWirelessGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateWirelessGatewayErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateWirelessGatewayErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateWirelessGatewayErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateWirelessGatewayErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateWirelessGatewayErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateWirelessGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateWirelessGatewayError {
    fn code(&self) -> Option<&str> {
        UpdateWirelessGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateWirelessGatewayError {
    pub fn new(kind: UpdateWirelessGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateWirelessGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateWirelessGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWirelessGatewayErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWirelessGatewayErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWirelessGatewayErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWirelessGatewayErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateWirelessGatewayErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateWirelessGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateWirelessGatewayErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateWirelessGatewayErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateWirelessGatewayErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateWirelessGatewayErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateWirelessGatewayErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateWirelessGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The input did not meet the specified constraints.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>The request was denied because it exceeded the allowed API request rate.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ThrottlingException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>Resource does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
    /// <p>Id of the not found resource.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>Type of the font found resource.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Id of the not found resource.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>Type of the font found resource.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>An unexpected error occurred while processing a request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServerException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException)
pub mod internal_server_exception {
    /// A builder for [`InternalServerException`](crate::error::InternalServerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException)
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message,
            }
        }
    }
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException)
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p>User does not have permission to perform this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p>Adding, updating, or deleting the resource can cause an inconsistent state.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
    /// <p>Id of the resource in the conflicting operation.</p>
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>Type of the resource in the conflicting operation.</p>
    pub resource_type: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &self.message);
        formatter.field("resource_id", &self.resource_id);
        formatter.field("resource_type", &self.resource_type);
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Id of the resource in the conflicting operation.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>Type of the resource in the conflicting operation.</p>
        pub fn resource_type(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_type = Some(input.into());
            self
        }
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
                resource_id: self.resource_id,
                resource_type: self.resource_type,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}

/// <p>The request was denied because the resource can't have any more tags.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyTagsException {
    pub message: std::option::Option<std::string::String>,
    /// <p>Name of the resource that exceeds maximum number of tags allowed.</p>
    pub resource_name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyTagsException");
        formatter.field("message", &self.message);
        formatter.field("resource_name", &self.resource_name);
        formatter.finish()
    }
}
impl TooManyTagsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsException {}
/// See [`TooManyTagsException`](crate::error::TooManyTagsException)
pub mod too_many_tags_exception {
    /// A builder for [`TooManyTagsException`](crate::error::TooManyTagsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) resource_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// <p>Name of the resource that exceeds maximum number of tags allowed.</p>
        pub fn resource_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_name = Some(input.into());
            self
        }
        pub fn set_resource_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_name = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTagsException`](crate::error::TooManyTagsException)
        pub fn build(self) -> crate::error::TooManyTagsException {
            crate::error::TooManyTagsException {
                message: self.message,
                resource_name: self.resource_name,
            }
        }
    }
}
impl TooManyTagsException {
    /// Creates a new builder-style object to manufacture [`TooManyTagsException`](crate::error::TooManyTagsException)
    pub fn builder() -> crate::error::too_many_tags_exception::Builder {
        crate::error::too_many_tags_exception::Builder::default()
    }
}
