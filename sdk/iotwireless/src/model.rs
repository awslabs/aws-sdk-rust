// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// When writing a match expression against `PositioningConfigStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let positioningconfigstatus = unimplemented!();
/// match positioningconfigstatus {
///     PositioningConfigStatus::Disabled => { /* ... */ },
///     PositioningConfigStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `positioningconfigstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PositioningConfigStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PositioningConfigStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PositioningConfigStatus::NewFeature` is defined.
/// Specifically, when `positioningconfigstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PositioningConfigStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PositioningConfigStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PositioningConfigStatus {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => PositioningConfigStatus::Disabled,
            "Enabled" => PositioningConfigStatus::Enabled,
            other => PositioningConfigStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PositioningConfigStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PositioningConfigStatus::from(s))
    }
}
impl PositioningConfigStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PositioningConfigStatus::Disabled => "Disabled",
            PositioningConfigStatus::Enabled => "Enabled",
            PositioningConfigStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for PositioningConfigStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>LoRaWAN object for update functions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanUpdateDevice {
    /// <p>The ID of the device profile for the wireless device.</p>
    #[doc(hidden)]
    pub device_profile_id: std::option::Option<std::string::String>,
    /// <p>The ID of the service profile.</p>
    #[doc(hidden)]
    pub service_profile_id: std::option::Option<std::string::String>,
    /// <p>ABP device object for update APIs for v1.1</p>
    #[doc(hidden)]
    pub abp_v1_1: std::option::Option<crate::model::UpdateAbpV11>,
    /// <p>ABP device object for update APIs for v1.0.x</p>
    #[doc(hidden)]
    pub abp_v1_0_x: std::option::Option<crate::model::UpdateAbpV10X>,
    /// <p>FPorts object for the positioning information of the device.</p>
    #[doc(hidden)]
    pub f_ports: std::option::Option<crate::model::UpdateFPorts>,
}
impl LoRaWanUpdateDevice {
    /// <p>The ID of the device profile for the wireless device.</p>
    pub fn device_profile_id(&self) -> std::option::Option<&str> {
        self.device_profile_id.as_deref()
    }
    /// <p>The ID of the service profile.</p>
    pub fn service_profile_id(&self) -> std::option::Option<&str> {
        self.service_profile_id.as_deref()
    }
    /// <p>ABP device object for update APIs for v1.1</p>
    pub fn abp_v1_1(&self) -> std::option::Option<&crate::model::UpdateAbpV11> {
        self.abp_v1_1.as_ref()
    }
    /// <p>ABP device object for update APIs for v1.0.x</p>
    pub fn abp_v1_0_x(&self) -> std::option::Option<&crate::model::UpdateAbpV10X> {
        self.abp_v1_0_x.as_ref()
    }
    /// <p>FPorts object for the positioning information of the device.</p>
    pub fn f_ports(&self) -> std::option::Option<&crate::model::UpdateFPorts> {
        self.f_ports.as_ref()
    }
}
impl LoRaWanUpdateDevice {
    /// Creates a new builder-style object to manufacture [`LoRaWanUpdateDevice`](crate::model::LoRaWanUpdateDevice).
    pub fn builder() -> crate::model::lo_ra_wan_update_device::Builder {
        crate::model::lo_ra_wan_update_device::Builder::default()
    }
}

/// See [`LoRaWanUpdateDevice`](crate::model::LoRaWanUpdateDevice).
pub mod lo_ra_wan_update_device {

    /// A builder for [`LoRaWanUpdateDevice`](crate::model::LoRaWanUpdateDevice).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_profile_id: std::option::Option<std::string::String>,
        pub(crate) service_profile_id: std::option::Option<std::string::String>,
        pub(crate) abp_v1_1: std::option::Option<crate::model::UpdateAbpV11>,
        pub(crate) abp_v1_0_x: std::option::Option<crate::model::UpdateAbpV10X>,
        pub(crate) f_ports: std::option::Option<crate::model::UpdateFPorts>,
    }
    impl Builder {
        /// <p>The ID of the device profile for the wireless device.</p>
        pub fn device_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_profile_id = Some(input.into());
            self
        }
        /// <p>The ID of the device profile for the wireless device.</p>
        pub fn set_device_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.device_profile_id = input;
            self
        }
        /// <p>The ID of the service profile.</p>
        pub fn service_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_profile_id = Some(input.into());
            self
        }
        /// <p>The ID of the service profile.</p>
        pub fn set_service_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_profile_id = input;
            self
        }
        /// <p>ABP device object for update APIs for v1.1</p>
        pub fn abp_v1_1(mut self, input: crate::model::UpdateAbpV11) -> Self {
            self.abp_v1_1 = Some(input);
            self
        }
        /// <p>ABP device object for update APIs for v1.1</p>
        pub fn set_abp_v1_1(
            mut self,
            input: std::option::Option<crate::model::UpdateAbpV11>,
        ) -> Self {
            self.abp_v1_1 = input;
            self
        }
        /// <p>ABP device object for update APIs for v1.0.x</p>
        pub fn abp_v1_0_x(mut self, input: crate::model::UpdateAbpV10X) -> Self {
            self.abp_v1_0_x = Some(input);
            self
        }
        /// <p>ABP device object for update APIs for v1.0.x</p>
        pub fn set_abp_v1_0_x(
            mut self,
            input: std::option::Option<crate::model::UpdateAbpV10X>,
        ) -> Self {
            self.abp_v1_0_x = input;
            self
        }
        /// <p>FPorts object for the positioning information of the device.</p>
        pub fn f_ports(mut self, input: crate::model::UpdateFPorts) -> Self {
            self.f_ports = Some(input);
            self
        }
        /// <p>FPorts object for the positioning information of the device.</p>
        pub fn set_f_ports(
            mut self,
            input: std::option::Option<crate::model::UpdateFPorts>,
        ) -> Self {
            self.f_ports = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanUpdateDevice`](crate::model::LoRaWanUpdateDevice).
        pub fn build(self) -> crate::model::LoRaWanUpdateDevice {
            crate::model::LoRaWanUpdateDevice {
                device_profile_id: self.device_profile_id,
                service_profile_id: self.service_profile_id,
                abp_v1_1: self.abp_v1_1,
                abp_v1_0_x: self.abp_v1_0_x,
                f_ports: self.f_ports,
            }
        }
    }
}

/// <p>Object for updating the FPorts information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateFPorts {
    /// <p>Positioning FPorts for the ClockSync, Stream, and GNSS functions.</p>
    #[doc(hidden)]
    pub positioning: std::option::Option<crate::model::Positioning>,
    /// <p>LoRaWAN application, which can be used for geolocation by activating positioning.</p>
    #[doc(hidden)]
    pub applications: std::option::Option<std::vec::Vec<crate::model::ApplicationConfig>>,
}
impl UpdateFPorts {
    /// <p>Positioning FPorts for the ClockSync, Stream, and GNSS functions.</p>
    pub fn positioning(&self) -> std::option::Option<&crate::model::Positioning> {
        self.positioning.as_ref()
    }
    /// <p>LoRaWAN application, which can be used for geolocation by activating positioning.</p>
    pub fn applications(&self) -> std::option::Option<&[crate::model::ApplicationConfig]> {
        self.applications.as_deref()
    }
}
impl UpdateFPorts {
    /// Creates a new builder-style object to manufacture [`UpdateFPorts`](crate::model::UpdateFPorts).
    pub fn builder() -> crate::model::update_f_ports::Builder {
        crate::model::update_f_ports::Builder::default()
    }
}

/// See [`UpdateFPorts`](crate::model::UpdateFPorts).
pub mod update_f_ports {

    /// A builder for [`UpdateFPorts`](crate::model::UpdateFPorts).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) positioning: std::option::Option<crate::model::Positioning>,
        pub(crate) applications:
            std::option::Option<std::vec::Vec<crate::model::ApplicationConfig>>,
    }
    impl Builder {
        /// <p>Positioning FPorts for the ClockSync, Stream, and GNSS functions.</p>
        pub fn positioning(mut self, input: crate::model::Positioning) -> Self {
            self.positioning = Some(input);
            self
        }
        /// <p>Positioning FPorts for the ClockSync, Stream, and GNSS functions.</p>
        pub fn set_positioning(
            mut self,
            input: std::option::Option<crate::model::Positioning>,
        ) -> Self {
            self.positioning = input;
            self
        }
        /// Appends an item to `applications`.
        ///
        /// To override the contents of this collection use [`set_applications`](Self::set_applications).
        ///
        /// <p>LoRaWAN application, which can be used for geolocation by activating positioning.</p>
        pub fn applications(mut self, input: crate::model::ApplicationConfig) -> Self {
            let mut v = self.applications.unwrap_or_default();
            v.push(input);
            self.applications = Some(v);
            self
        }
        /// <p>LoRaWAN application, which can be used for geolocation by activating positioning.</p>
        pub fn set_applications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ApplicationConfig>>,
        ) -> Self {
            self.applications = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateFPorts`](crate::model::UpdateFPorts).
        pub fn build(self) -> crate::model::UpdateFPorts {
            crate::model::UpdateFPorts {
                positioning: self.positioning,
                applications: self.applications,
            }
        }
    }
}

/// <p>LoRaWAN application configuration, which can be used to perform geolocation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApplicationConfig {
    /// <p>The Fport value.</p>
    #[doc(hidden)]
    pub f_port: std::option::Option<i32>,
    /// <p>Application type, which can be specified to obtain real-time position information of your LoRaWAN device.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::ApplicationConfigType>,
    /// <p>The name of the position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.</p>
    #[doc(hidden)]
    pub destination_name: std::option::Option<std::string::String>,
}
impl ApplicationConfig {
    /// <p>The Fport value.</p>
    pub fn f_port(&self) -> std::option::Option<i32> {
        self.f_port
    }
    /// <p>Application type, which can be specified to obtain real-time position information of your LoRaWAN device.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::ApplicationConfigType> {
        self.r#type.as_ref()
    }
    /// <p>The name of the position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.</p>
    pub fn destination_name(&self) -> std::option::Option<&str> {
        self.destination_name.as_deref()
    }
}
impl ApplicationConfig {
    /// Creates a new builder-style object to manufacture [`ApplicationConfig`](crate::model::ApplicationConfig).
    pub fn builder() -> crate::model::application_config::Builder {
        crate::model::application_config::Builder::default()
    }
}

/// See [`ApplicationConfig`](crate::model::ApplicationConfig).
pub mod application_config {

    /// A builder for [`ApplicationConfig`](crate::model::ApplicationConfig).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) f_port: std::option::Option<i32>,
        pub(crate) r#type: std::option::Option<crate::model::ApplicationConfigType>,
        pub(crate) destination_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Fport value.</p>
        pub fn f_port(mut self, input: i32) -> Self {
            self.f_port = Some(input);
            self
        }
        /// <p>The Fport value.</p>
        pub fn set_f_port(mut self, input: std::option::Option<i32>) -> Self {
            self.f_port = input;
            self
        }
        /// <p>Application type, which can be specified to obtain real-time position information of your LoRaWAN device.</p>
        pub fn r#type(mut self, input: crate::model::ApplicationConfigType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Application type, which can be specified to obtain real-time position information of your LoRaWAN device.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::ApplicationConfigType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The name of the position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        /// <p>The name of the position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.</p>
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name = input;
            self
        }
        /// Consumes the builder and constructs a [`ApplicationConfig`](crate::model::ApplicationConfig).
        pub fn build(self) -> crate::model::ApplicationConfig {
            crate::model::ApplicationConfig {
                f_port: self.f_port,
                r#type: self.r#type,
                destination_name: self.destination_name,
            }
        }
    }
}

/// When writing a match expression against `ApplicationConfigType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let applicationconfigtype = unimplemented!();
/// match applicationconfigtype {
///     ApplicationConfigType::SemtechGeoLocation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `applicationconfigtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ApplicationConfigType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ApplicationConfigType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ApplicationConfigType::NewFeature` is defined.
/// Specifically, when `applicationconfigtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ApplicationConfigType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ApplicationConfigType {
    #[allow(missing_docs)] // documentation missing in model
    SemtechGeoLocation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ApplicationConfigType {
    fn from(s: &str) -> Self {
        match s {
            "SemtechGeolocation" => ApplicationConfigType::SemtechGeoLocation,
            other => {
                ApplicationConfigType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ApplicationConfigType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ApplicationConfigType::from(s))
    }
}
impl ApplicationConfigType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ApplicationConfigType::SemtechGeoLocation => "SemtechGeolocation",
            ApplicationConfigType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SemtechGeolocation"]
    }
}
impl AsRef<str> for ApplicationConfigType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The FPorts for the position information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Positioning {
    /// <p>The Fport value.</p>
    #[doc(hidden)]
    pub clock_sync: std::option::Option<i32>,
    /// <p>The Fport value.</p>
    #[doc(hidden)]
    pub stream: std::option::Option<i32>,
    /// <p>The Fport value.</p>
    #[doc(hidden)]
    pub gnss: std::option::Option<i32>,
}
impl Positioning {
    /// <p>The Fport value.</p>
    pub fn clock_sync(&self) -> std::option::Option<i32> {
        self.clock_sync
    }
    /// <p>The Fport value.</p>
    pub fn stream(&self) -> std::option::Option<i32> {
        self.stream
    }
    /// <p>The Fport value.</p>
    pub fn gnss(&self) -> std::option::Option<i32> {
        self.gnss
    }
}
impl Positioning {
    /// Creates a new builder-style object to manufacture [`Positioning`](crate::model::Positioning).
    pub fn builder() -> crate::model::positioning::Builder {
        crate::model::positioning::Builder::default()
    }
}

/// See [`Positioning`](crate::model::Positioning).
pub mod positioning {

    /// A builder for [`Positioning`](crate::model::Positioning).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) clock_sync: std::option::Option<i32>,
        pub(crate) stream: std::option::Option<i32>,
        pub(crate) gnss: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Fport value.</p>
        pub fn clock_sync(mut self, input: i32) -> Self {
            self.clock_sync = Some(input);
            self
        }
        /// <p>The Fport value.</p>
        pub fn set_clock_sync(mut self, input: std::option::Option<i32>) -> Self {
            self.clock_sync = input;
            self
        }
        /// <p>The Fport value.</p>
        pub fn stream(mut self, input: i32) -> Self {
            self.stream = Some(input);
            self
        }
        /// <p>The Fport value.</p>
        pub fn set_stream(mut self, input: std::option::Option<i32>) -> Self {
            self.stream = input;
            self
        }
        /// <p>The Fport value.</p>
        pub fn gnss(mut self, input: i32) -> Self {
            self.gnss = Some(input);
            self
        }
        /// <p>The Fport value.</p>
        pub fn set_gnss(mut self, input: std::option::Option<i32>) -> Self {
            self.gnss = input;
            self
        }
        /// Consumes the builder and constructs a [`Positioning`](crate::model::Positioning).
        pub fn build(self) -> crate::model::Positioning {
            crate::model::Positioning {
                clock_sync: self.clock_sync,
                stream: self.stream,
                gnss: self.gnss,
            }
        }
    }
}

/// <p>ABP device object for LoRaWAN specification v1.0.x</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAbpV10X {
    /// <p>The FCnt init value.</p>
    #[doc(hidden)]
    pub f_cnt_start: std::option::Option<i32>,
}
impl UpdateAbpV10X {
    /// <p>The FCnt init value.</p>
    pub fn f_cnt_start(&self) -> std::option::Option<i32> {
        self.f_cnt_start
    }
}
impl UpdateAbpV10X {
    /// Creates a new builder-style object to manufacture [`UpdateAbpV10X`](crate::model::UpdateAbpV10X).
    pub fn builder() -> crate::model::update_abp_v10_x::Builder {
        crate::model::update_abp_v10_x::Builder::default()
    }
}

/// See [`UpdateAbpV10X`](crate::model::UpdateAbpV10X).
pub mod update_abp_v10_x {

    /// A builder for [`UpdateAbpV10X`](crate::model::UpdateAbpV10X).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) f_cnt_start: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The FCnt init value.</p>
        pub fn f_cnt_start(mut self, input: i32) -> Self {
            self.f_cnt_start = Some(input);
            self
        }
        /// <p>The FCnt init value.</p>
        pub fn set_f_cnt_start(mut self, input: std::option::Option<i32>) -> Self {
            self.f_cnt_start = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAbpV10X`](crate::model::UpdateAbpV10X).
        pub fn build(self) -> crate::model::UpdateAbpV10X {
            crate::model::UpdateAbpV10X {
                f_cnt_start: self.f_cnt_start,
            }
        }
    }
}

/// <p>ABP device object for LoRaWAN specification v1.1</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateAbpV11 {
    /// <p>The FCnt init value.</p>
    #[doc(hidden)]
    pub f_cnt_start: std::option::Option<i32>,
}
impl UpdateAbpV11 {
    /// <p>The FCnt init value.</p>
    pub fn f_cnt_start(&self) -> std::option::Option<i32> {
        self.f_cnt_start
    }
}
impl UpdateAbpV11 {
    /// Creates a new builder-style object to manufacture [`UpdateAbpV11`](crate::model::UpdateAbpV11).
    pub fn builder() -> crate::model::update_abp_v11::Builder {
        crate::model::update_abp_v11::Builder::default()
    }
}

/// See [`UpdateAbpV11`](crate::model::UpdateAbpV11).
pub mod update_abp_v11 {

    /// A builder for [`UpdateAbpV11`](crate::model::UpdateAbpV11).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) f_cnt_start: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The FCnt init value.</p>
        pub fn f_cnt_start(mut self, input: i32) -> Self {
            self.f_cnt_start = Some(input);
            self
        }
        /// <p>The FCnt init value.</p>
        pub fn set_f_cnt_start(mut self, input: std::option::Option<i32>) -> Self {
            self.f_cnt_start = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateAbpV11`](crate::model::UpdateAbpV11).
        pub fn build(self) -> crate::model::UpdateAbpV11 {
            crate::model::UpdateAbpV11 {
                f_cnt_start: self.f_cnt_start,
            }
        }
    }
}

/// When writing a match expression against `PositionResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let positionresourcetype = unimplemented!();
/// match positionresourcetype {
///     PositionResourceType::WirelessDevice => { /* ... */ },
///     PositionResourceType::WirelessGateway => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `positionresourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PositionResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PositionResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PositionResourceType::NewFeature` is defined.
/// Specifically, when `positionresourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PositionResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PositionResourceType {
    #[allow(missing_docs)] // documentation missing in model
    WirelessDevice,
    #[allow(missing_docs)] // documentation missing in model
    WirelessGateway,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PositionResourceType {
    fn from(s: &str) -> Self {
        match s {
            "WirelessDevice" => PositionResourceType::WirelessDevice,
            "WirelessGateway" => PositionResourceType::WirelessGateway,
            other => {
                PositionResourceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PositionResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PositionResourceType::from(s))
    }
}
impl PositionResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PositionResourceType::WirelessDevice => "WirelessDevice",
            PositionResourceType::WirelessGateway => "WirelessGateway",
            PositionResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["WirelessDevice", "WirelessGateway"]
    }
}
impl AsRef<str> for PositionResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Message delivery status event configuration object for enabling and disabling relevant topics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MessageDeliveryStatusEventConfiguration {
    /// <p> <code>SidewalkEventNotificationConfigurations</code> object, which is the event configuration object for Sidewalk-related event topics.</p>
    #[doc(hidden)]
    pub sidewalk: std::option::Option<crate::model::SidewalkEventNotificationConfigurations>,
    /// <p>Denotes whether the wireless device ID message delivery status event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub wireless_device_id_event_topic:
        std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl MessageDeliveryStatusEventConfiguration {
    /// <p> <code>SidewalkEventNotificationConfigurations</code> object, which is the event configuration object for Sidewalk-related event topics.</p>
    pub fn sidewalk(
        &self,
    ) -> std::option::Option<&crate::model::SidewalkEventNotificationConfigurations> {
        self.sidewalk.as_ref()
    }
    /// <p>Denotes whether the wireless device ID message delivery status event topic is enabled or disabled.</p>
    pub fn wireless_device_id_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.wireless_device_id_event_topic.as_ref()
    }
}
impl MessageDeliveryStatusEventConfiguration {
    /// Creates a new builder-style object to manufacture [`MessageDeliveryStatusEventConfiguration`](crate::model::MessageDeliveryStatusEventConfiguration).
    pub fn builder() -> crate::model::message_delivery_status_event_configuration::Builder {
        crate::model::message_delivery_status_event_configuration::Builder::default()
    }
}

/// See [`MessageDeliveryStatusEventConfiguration`](crate::model::MessageDeliveryStatusEventConfiguration).
pub mod message_delivery_status_event_configuration {

    /// A builder for [`MessageDeliveryStatusEventConfiguration`](crate::model::MessageDeliveryStatusEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sidewalk:
            std::option::Option<crate::model::SidewalkEventNotificationConfigurations>,
        pub(crate) wireless_device_id_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p> <code>SidewalkEventNotificationConfigurations</code> object, which is the event configuration object for Sidewalk-related event topics.</p>
        pub fn sidewalk(
            mut self,
            input: crate::model::SidewalkEventNotificationConfigurations,
        ) -> Self {
            self.sidewalk = Some(input);
            self
        }
        /// <p> <code>SidewalkEventNotificationConfigurations</code> object, which is the event configuration object for Sidewalk-related event topics.</p>
        pub fn set_sidewalk(
            mut self,
            input: std::option::Option<crate::model::SidewalkEventNotificationConfigurations>,
        ) -> Self {
            self.sidewalk = input;
            self
        }
        /// <p>Denotes whether the wireless device ID message delivery status event topic is enabled or disabled.</p>
        pub fn wireless_device_id_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.wireless_device_id_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the wireless device ID message delivery status event topic is enabled or disabled.</p>
        pub fn set_wireless_device_id_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.wireless_device_id_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageDeliveryStatusEventConfiguration`](crate::model::MessageDeliveryStatusEventConfiguration).
        pub fn build(self) -> crate::model::MessageDeliveryStatusEventConfiguration {
            crate::model::MessageDeliveryStatusEventConfiguration {
                sidewalk: self.sidewalk,
                wireless_device_id_event_topic: self.wireless_device_id_event_topic,
            }
        }
    }
}

/// When writing a match expression against `EventNotificationTopicStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let eventnotificationtopicstatus = unimplemented!();
/// match eventnotificationtopicstatus {
///     EventNotificationTopicStatus::Disabled => { /* ... */ },
///     EventNotificationTopicStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `eventnotificationtopicstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EventNotificationTopicStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EventNotificationTopicStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EventNotificationTopicStatus::NewFeature` is defined.
/// Specifically, when `eventnotificationtopicstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EventNotificationTopicStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventNotificationTopicStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EventNotificationTopicStatus {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => EventNotificationTopicStatus::Disabled,
            "Enabled" => EventNotificationTopicStatus::Enabled,
            other => EventNotificationTopicStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for EventNotificationTopicStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventNotificationTopicStatus::from(s))
    }
}
impl EventNotificationTopicStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EventNotificationTopicStatus::Disabled => "Disabled",
            EventNotificationTopicStatus::Enabled => "Enabled",
            EventNotificationTopicStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for EventNotificationTopicStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p> <code>SidewalkEventNotificationConfigurations</code> object, which is the event configuration object for Sidewalk-related event topics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SidewalkEventNotificationConfigurations {
    /// <p>Denotes whether the Amazon ID event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub amazon_id_event_topic: std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl SidewalkEventNotificationConfigurations {
    /// <p>Denotes whether the Amazon ID event topic is enabled or disabled.</p>
    pub fn amazon_id_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.amazon_id_event_topic.as_ref()
    }
}
impl SidewalkEventNotificationConfigurations {
    /// Creates a new builder-style object to manufacture [`SidewalkEventNotificationConfigurations`](crate::model::SidewalkEventNotificationConfigurations).
    pub fn builder() -> crate::model::sidewalk_event_notification_configurations::Builder {
        crate::model::sidewalk_event_notification_configurations::Builder::default()
    }
}

/// See [`SidewalkEventNotificationConfigurations`](crate::model::SidewalkEventNotificationConfigurations).
pub mod sidewalk_event_notification_configurations {

    /// A builder for [`SidewalkEventNotificationConfigurations`](crate::model::SidewalkEventNotificationConfigurations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amazon_id_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p>Denotes whether the Amazon ID event topic is enabled or disabled.</p>
        pub fn amazon_id_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.amazon_id_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the Amazon ID event topic is enabled or disabled.</p>
        pub fn set_amazon_id_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.amazon_id_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`SidewalkEventNotificationConfigurations`](crate::model::SidewalkEventNotificationConfigurations).
        pub fn build(self) -> crate::model::SidewalkEventNotificationConfigurations {
            crate::model::SidewalkEventNotificationConfigurations {
                amazon_id_event_topic: self.amazon_id_event_topic,
            }
        }
    }
}

/// <p>Connection status event configuration object for enabling or disabling topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionStatusEventConfiguration {
    /// <p>Connection status event configuration object for enabling or disabling LoRaWAN related event topics.</p>
    #[doc(hidden)]
    pub lo_ra_wan:
        std::option::Option<crate::model::LoRaWanConnectionStatusEventNotificationConfigurations>,
    /// <p>Denotes whether the wireless gateway ID connection status event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub wireless_gateway_id_event_topic:
        std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl ConnectionStatusEventConfiguration {
    /// <p>Connection status event configuration object for enabling or disabling LoRaWAN related event topics.</p>
    pub fn lo_ra_wan(
        &self,
    ) -> std::option::Option<&crate::model::LoRaWanConnectionStatusEventNotificationConfigurations>
    {
        self.lo_ra_wan.as_ref()
    }
    /// <p>Denotes whether the wireless gateway ID connection status event topic is enabled or disabled.</p>
    pub fn wireless_gateway_id_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.wireless_gateway_id_event_topic.as_ref()
    }
}
impl ConnectionStatusEventConfiguration {
    /// Creates a new builder-style object to manufacture [`ConnectionStatusEventConfiguration`](crate::model::ConnectionStatusEventConfiguration).
    pub fn builder() -> crate::model::connection_status_event_configuration::Builder {
        crate::model::connection_status_event_configuration::Builder::default()
    }
}

/// See [`ConnectionStatusEventConfiguration`](crate::model::ConnectionStatusEventConfiguration).
pub mod connection_status_event_configuration {

    /// A builder for [`ConnectionStatusEventConfiguration`](crate::model::ConnectionStatusEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lo_ra_wan: std::option::Option<
            crate::model::LoRaWanConnectionStatusEventNotificationConfigurations,
        >,
        pub(crate) wireless_gateway_id_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p>Connection status event configuration object for enabling or disabling LoRaWAN related event topics.</p>
        pub fn lo_ra_wan(
            mut self,
            input: crate::model::LoRaWanConnectionStatusEventNotificationConfigurations,
        ) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>Connection status event configuration object for enabling or disabling LoRaWAN related event topics.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<
                crate::model::LoRaWanConnectionStatusEventNotificationConfigurations,
            >,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// <p>Denotes whether the wireless gateway ID connection status event topic is enabled or disabled.</p>
        pub fn wireless_gateway_id_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.wireless_gateway_id_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the wireless gateway ID connection status event topic is enabled or disabled.</p>
        pub fn set_wireless_gateway_id_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.wireless_gateway_id_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionStatusEventConfiguration`](crate::model::ConnectionStatusEventConfiguration).
        pub fn build(self) -> crate::model::ConnectionStatusEventConfiguration {
            crate::model::ConnectionStatusEventConfiguration {
                lo_ra_wan: self.lo_ra_wan,
                wireless_gateway_id_event_topic: self.wireless_gateway_id_event_topic,
            }
        }
    }
}

/// <p>Object for LoRaWAN connection status resource type event configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanConnectionStatusEventNotificationConfigurations {
    /// <p>Denotes whether the gateway EUI connection status event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub gateway_eui_event_topic: std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl LoRaWanConnectionStatusEventNotificationConfigurations {
    /// <p>Denotes whether the gateway EUI connection status event topic is enabled or disabled.</p>
    pub fn gateway_eui_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.gateway_eui_event_topic.as_ref()
    }
}
impl LoRaWanConnectionStatusEventNotificationConfigurations {
    /// Creates a new builder-style object to manufacture [`LoRaWanConnectionStatusEventNotificationConfigurations`](crate::model::LoRaWanConnectionStatusEventNotificationConfigurations).
    pub fn builder(
    ) -> crate::model::lo_ra_wan_connection_status_event_notification_configurations::Builder {
        crate::model::lo_ra_wan_connection_status_event_notification_configurations::Builder::default()
    }
}

/// See [`LoRaWanConnectionStatusEventNotificationConfigurations`](crate::model::LoRaWanConnectionStatusEventNotificationConfigurations).
pub mod lo_ra_wan_connection_status_event_notification_configurations {

    /// A builder for [`LoRaWanConnectionStatusEventNotificationConfigurations`](crate::model::LoRaWanConnectionStatusEventNotificationConfigurations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_eui_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p>Denotes whether the gateway EUI connection status event topic is enabled or disabled.</p>
        pub fn gateway_eui_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.gateway_eui_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the gateway EUI connection status event topic is enabled or disabled.</p>
        pub fn set_gateway_eui_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.gateway_eui_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanConnectionStatusEventNotificationConfigurations`](crate::model::LoRaWanConnectionStatusEventNotificationConfigurations).
        pub fn build(self) -> crate::model::LoRaWanConnectionStatusEventNotificationConfigurations {
            crate::model::LoRaWanConnectionStatusEventNotificationConfigurations {
                gateway_eui_event_topic: self.gateway_eui_event_topic,
            }
        }
    }
}

/// <p>Join event configuration object for enabling or disabling topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JoinEventConfiguration {
    /// <p>Join event configuration object for enabling or disabling LoRaWAN related event topics.</p>
    #[doc(hidden)]
    pub lo_ra_wan: std::option::Option<crate::model::LoRaWanJoinEventNotificationConfigurations>,
    /// <p>Denotes whether the wireless device ID join event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub wireless_device_id_event_topic:
        std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl JoinEventConfiguration {
    /// <p>Join event configuration object for enabling or disabling LoRaWAN related event topics.</p>
    pub fn lo_ra_wan(
        &self,
    ) -> std::option::Option<&crate::model::LoRaWanJoinEventNotificationConfigurations> {
        self.lo_ra_wan.as_ref()
    }
    /// <p>Denotes whether the wireless device ID join event topic is enabled or disabled.</p>
    pub fn wireless_device_id_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.wireless_device_id_event_topic.as_ref()
    }
}
impl JoinEventConfiguration {
    /// Creates a new builder-style object to manufacture [`JoinEventConfiguration`](crate::model::JoinEventConfiguration).
    pub fn builder() -> crate::model::join_event_configuration::Builder {
        crate::model::join_event_configuration::Builder::default()
    }
}

/// See [`JoinEventConfiguration`](crate::model::JoinEventConfiguration).
pub mod join_event_configuration {

    /// A builder for [`JoinEventConfiguration`](crate::model::JoinEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lo_ra_wan:
            std::option::Option<crate::model::LoRaWanJoinEventNotificationConfigurations>,
        pub(crate) wireless_device_id_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p>Join event configuration object for enabling or disabling LoRaWAN related event topics.</p>
        pub fn lo_ra_wan(
            mut self,
            input: crate::model::LoRaWanJoinEventNotificationConfigurations,
        ) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>Join event configuration object for enabling or disabling LoRaWAN related event topics.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<crate::model::LoRaWanJoinEventNotificationConfigurations>,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// <p>Denotes whether the wireless device ID join event topic is enabled or disabled.</p>
        pub fn wireless_device_id_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.wireless_device_id_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the wireless device ID join event topic is enabled or disabled.</p>
        pub fn set_wireless_device_id_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.wireless_device_id_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`JoinEventConfiguration`](crate::model::JoinEventConfiguration).
        pub fn build(self) -> crate::model::JoinEventConfiguration {
            crate::model::JoinEventConfiguration {
                lo_ra_wan: self.lo_ra_wan,
                wireless_device_id_event_topic: self.wireless_device_id_event_topic,
            }
        }
    }
}

/// <p>Object for LoRaWAN join resource type event configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanJoinEventNotificationConfigurations {
    /// <p>Denotes whether the Dev EUI join event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub dev_eui_event_topic: std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl LoRaWanJoinEventNotificationConfigurations {
    /// <p>Denotes whether the Dev EUI join event topic is enabled or disabled.</p>
    pub fn dev_eui_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.dev_eui_event_topic.as_ref()
    }
}
impl LoRaWanJoinEventNotificationConfigurations {
    /// Creates a new builder-style object to manufacture [`LoRaWanJoinEventNotificationConfigurations`](crate::model::LoRaWanJoinEventNotificationConfigurations).
    pub fn builder() -> crate::model::lo_ra_wan_join_event_notification_configurations::Builder {
        crate::model::lo_ra_wan_join_event_notification_configurations::Builder::default()
    }
}

/// See [`LoRaWanJoinEventNotificationConfigurations`](crate::model::LoRaWanJoinEventNotificationConfigurations).
pub mod lo_ra_wan_join_event_notification_configurations {

    /// A builder for [`LoRaWanJoinEventNotificationConfigurations`](crate::model::LoRaWanJoinEventNotificationConfigurations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dev_eui_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p>Denotes whether the Dev EUI join event topic is enabled or disabled.</p>
        pub fn dev_eui_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.dev_eui_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the Dev EUI join event topic is enabled or disabled.</p>
        pub fn set_dev_eui_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.dev_eui_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanJoinEventNotificationConfigurations`](crate::model::LoRaWanJoinEventNotificationConfigurations).
        pub fn build(self) -> crate::model::LoRaWanJoinEventNotificationConfigurations {
            crate::model::LoRaWanJoinEventNotificationConfigurations {
                dev_eui_event_topic: self.dev_eui_event_topic,
            }
        }
    }
}

/// <p>Proximity event configuration object for enabling and disabling relevant topics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProximityEventConfiguration {
    /// <p>Proximity event configuration object for enabling or disabling Sidewalk related event topics.</p>
    #[doc(hidden)]
    pub sidewalk: std::option::Option<crate::model::SidewalkEventNotificationConfigurations>,
    /// <p>Denotes whether the wireless device ID proximity event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub wireless_device_id_event_topic:
        std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl ProximityEventConfiguration {
    /// <p>Proximity event configuration object for enabling or disabling Sidewalk related event topics.</p>
    pub fn sidewalk(
        &self,
    ) -> std::option::Option<&crate::model::SidewalkEventNotificationConfigurations> {
        self.sidewalk.as_ref()
    }
    /// <p>Denotes whether the wireless device ID proximity event topic is enabled or disabled.</p>
    pub fn wireless_device_id_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.wireless_device_id_event_topic.as_ref()
    }
}
impl ProximityEventConfiguration {
    /// Creates a new builder-style object to manufacture [`ProximityEventConfiguration`](crate::model::ProximityEventConfiguration).
    pub fn builder() -> crate::model::proximity_event_configuration::Builder {
        crate::model::proximity_event_configuration::Builder::default()
    }
}

/// See [`ProximityEventConfiguration`](crate::model::ProximityEventConfiguration).
pub mod proximity_event_configuration {

    /// A builder for [`ProximityEventConfiguration`](crate::model::ProximityEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sidewalk:
            std::option::Option<crate::model::SidewalkEventNotificationConfigurations>,
        pub(crate) wireless_device_id_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p>Proximity event configuration object for enabling or disabling Sidewalk related event topics.</p>
        pub fn sidewalk(
            mut self,
            input: crate::model::SidewalkEventNotificationConfigurations,
        ) -> Self {
            self.sidewalk = Some(input);
            self
        }
        /// <p>Proximity event configuration object for enabling or disabling Sidewalk related event topics.</p>
        pub fn set_sidewalk(
            mut self,
            input: std::option::Option<crate::model::SidewalkEventNotificationConfigurations>,
        ) -> Self {
            self.sidewalk = input;
            self
        }
        /// <p>Denotes whether the wireless device ID proximity event topic is enabled or disabled.</p>
        pub fn wireless_device_id_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.wireless_device_id_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the wireless device ID proximity event topic is enabled or disabled.</p>
        pub fn set_wireless_device_id_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.wireless_device_id_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`ProximityEventConfiguration`](crate::model::ProximityEventConfiguration).
        pub fn build(self) -> crate::model::ProximityEventConfiguration {
            crate::model::ProximityEventConfiguration {
                sidewalk: self.sidewalk,
                wireless_device_id_event_topic: self.wireless_device_id_event_topic,
            }
        }
    }
}

/// <p>Device registration state event configuration object for enabling and disabling relevant topics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeviceRegistrationStateEventConfiguration {
    /// <p>Device registration state event configuration object for enabling or disabling Sidewalk related event topics.</p>
    #[doc(hidden)]
    pub sidewalk: std::option::Option<crate::model::SidewalkEventNotificationConfigurations>,
    /// <p>Denotes whether the wireless device ID device registration state event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub wireless_device_id_event_topic:
        std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl DeviceRegistrationStateEventConfiguration {
    /// <p>Device registration state event configuration object for enabling or disabling Sidewalk related event topics.</p>
    pub fn sidewalk(
        &self,
    ) -> std::option::Option<&crate::model::SidewalkEventNotificationConfigurations> {
        self.sidewalk.as_ref()
    }
    /// <p>Denotes whether the wireless device ID device registration state event topic is enabled or disabled.</p>
    pub fn wireless_device_id_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.wireless_device_id_event_topic.as_ref()
    }
}
impl DeviceRegistrationStateEventConfiguration {
    /// Creates a new builder-style object to manufacture [`DeviceRegistrationStateEventConfiguration`](crate::model::DeviceRegistrationStateEventConfiguration).
    pub fn builder() -> crate::model::device_registration_state_event_configuration::Builder {
        crate::model::device_registration_state_event_configuration::Builder::default()
    }
}

/// See [`DeviceRegistrationStateEventConfiguration`](crate::model::DeviceRegistrationStateEventConfiguration).
pub mod device_registration_state_event_configuration {

    /// A builder for [`DeviceRegistrationStateEventConfiguration`](crate::model::DeviceRegistrationStateEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sidewalk:
            std::option::Option<crate::model::SidewalkEventNotificationConfigurations>,
        pub(crate) wireless_device_id_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p>Device registration state event configuration object for enabling or disabling Sidewalk related event topics.</p>
        pub fn sidewalk(
            mut self,
            input: crate::model::SidewalkEventNotificationConfigurations,
        ) -> Self {
            self.sidewalk = Some(input);
            self
        }
        /// <p>Device registration state event configuration object for enabling or disabling Sidewalk related event topics.</p>
        pub fn set_sidewalk(
            mut self,
            input: std::option::Option<crate::model::SidewalkEventNotificationConfigurations>,
        ) -> Self {
            self.sidewalk = input;
            self
        }
        /// <p>Denotes whether the wireless device ID device registration state event topic is enabled or disabled.</p>
        pub fn wireless_device_id_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.wireless_device_id_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the wireless device ID device registration state event topic is enabled or disabled.</p>
        pub fn set_wireless_device_id_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.wireless_device_id_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceRegistrationStateEventConfiguration`](crate::model::DeviceRegistrationStateEventConfiguration).
        pub fn build(self) -> crate::model::DeviceRegistrationStateEventConfiguration {
            crate::model::DeviceRegistrationStateEventConfiguration {
                sidewalk: self.sidewalk,
                wireless_device_id_event_topic: self.wireless_device_id_event_topic,
            }
        }
    }
}

/// When writing a match expression against `EventNotificationPartnerType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let eventnotificationpartnertype = unimplemented!();
/// match eventnotificationpartnertype {
///     EventNotificationPartnerType::Sidewalk => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `eventnotificationpartnertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EventNotificationPartnerType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EventNotificationPartnerType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EventNotificationPartnerType::NewFeature` is defined.
/// Specifically, when `eventnotificationpartnertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EventNotificationPartnerType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventNotificationPartnerType {
    #[allow(missing_docs)] // documentation missing in model
    Sidewalk,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EventNotificationPartnerType {
    fn from(s: &str) -> Self {
        match s {
            "Sidewalk" => EventNotificationPartnerType::Sidewalk,
            other => EventNotificationPartnerType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for EventNotificationPartnerType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventNotificationPartnerType::from(s))
    }
}
impl EventNotificationPartnerType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EventNotificationPartnerType::Sidewalk => "Sidewalk",
            EventNotificationPartnerType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Sidewalk"]
    }
}
impl AsRef<str> for EventNotificationPartnerType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `IdentifierType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let identifiertype = unimplemented!();
/// match identifiertype {
///     IdentifierType::DevEui => { /* ... */ },
///     IdentifierType::GatewayEui => { /* ... */ },
///     IdentifierType::PartnerAccountId => { /* ... */ },
///     IdentifierType::WirelessDeviceId => { /* ... */ },
///     IdentifierType::WirelessGatewayId => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `identifiertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `IdentifierType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `IdentifierType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `IdentifierType::NewFeature` is defined.
/// Specifically, when `identifiertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `IdentifierType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum IdentifierType {
    #[allow(missing_docs)] // documentation missing in model
    DevEui,
    #[allow(missing_docs)] // documentation missing in model
    GatewayEui,
    #[allow(missing_docs)] // documentation missing in model
    PartnerAccountId,
    #[allow(missing_docs)] // documentation missing in model
    WirelessDeviceId,
    #[allow(missing_docs)] // documentation missing in model
    WirelessGatewayId,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for IdentifierType {
    fn from(s: &str) -> Self {
        match s {
            "DevEui" => IdentifierType::DevEui,
            "GatewayEui" => IdentifierType::GatewayEui,
            "PartnerAccountId" => IdentifierType::PartnerAccountId,
            "WirelessDeviceId" => IdentifierType::WirelessDeviceId,
            "WirelessGatewayId" => IdentifierType::WirelessGatewayId,
            other => IdentifierType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for IdentifierType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(IdentifierType::from(s))
    }
}
impl IdentifierType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            IdentifierType::DevEui => "DevEui",
            IdentifierType::GatewayEui => "GatewayEui",
            IdentifierType::PartnerAccountId => "PartnerAccountId",
            IdentifierType::WirelessDeviceId => "WirelessDeviceId",
            IdentifierType::WirelessGatewayId => "WirelessGatewayId",
            IdentifierType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DevEui",
            "GatewayEui",
            "PartnerAccountId",
            "WirelessDeviceId",
            "WirelessGatewayId",
        ]
    }
}
impl AsRef<str> for IdentifierType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PartnerType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let partnertype = unimplemented!();
/// match partnertype {
///     PartnerType::Sidewalk => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `partnertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PartnerType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PartnerType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PartnerType::NewFeature` is defined.
/// Specifically, when `partnertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PartnerType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PartnerType {
    #[allow(missing_docs)] // documentation missing in model
    Sidewalk,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PartnerType {
    fn from(s: &str) -> Self {
        match s {
            "Sidewalk" => PartnerType::Sidewalk,
            other => PartnerType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for PartnerType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PartnerType::from(s))
    }
}
impl PartnerType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PartnerType::Sidewalk => "Sidewalk",
            PartnerType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Sidewalk"]
    }
}
impl AsRef<str> for PartnerType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Sidewalk update.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SidewalkUpdateAccount {
    /// <p>The new Sidewalk application server private key.</p>
    #[doc(hidden)]
    pub app_server_private_key: std::option::Option<std::string::String>,
}
impl SidewalkUpdateAccount {
    /// <p>The new Sidewalk application server private key.</p>
    pub fn app_server_private_key(&self) -> std::option::Option<&str> {
        self.app_server_private_key.as_deref()
    }
}
impl std::fmt::Debug for SidewalkUpdateAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SidewalkUpdateAccount");
        formatter.field("app_server_private_key", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl SidewalkUpdateAccount {
    /// Creates a new builder-style object to manufacture [`SidewalkUpdateAccount`](crate::model::SidewalkUpdateAccount).
    pub fn builder() -> crate::model::sidewalk_update_account::Builder {
        crate::model::sidewalk_update_account::Builder::default()
    }
}

/// See [`SidewalkUpdateAccount`](crate::model::SidewalkUpdateAccount).
pub mod sidewalk_update_account {

    /// A builder for [`SidewalkUpdateAccount`](crate::model::SidewalkUpdateAccount).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) app_server_private_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The new Sidewalk application server private key.</p>
        pub fn app_server_private_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_server_private_key = Some(input.into());
            self
        }
        /// <p>The new Sidewalk application server private key.</p>
        pub fn set_app_server_private_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_server_private_key = input;
            self
        }
        /// Consumes the builder and constructs a [`SidewalkUpdateAccount`](crate::model::SidewalkUpdateAccount).
        pub fn build(self) -> crate::model::SidewalkUpdateAccount {
            crate::model::SidewalkUpdateAccount {
                app_server_private_key: self.app_server_private_key,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("app_server_private_key", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}

/// <p>Trace content for your wireless gateway and wireless device resources.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TraceContent {
    /// <p> <code>FrameInfo</code> of your wireless device resources for the trace content. Use FrameInfo to debug the communication between your LoRaWAN end devices and the network server.</p>
    #[doc(hidden)]
    pub wireless_device_frame_info: std::option::Option<crate::model::WirelessDeviceFrameInfo>,
    /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
    #[doc(hidden)]
    pub log_level: std::option::Option<crate::model::LogLevel>,
}
impl TraceContent {
    /// <p> <code>FrameInfo</code> of your wireless device resources for the trace content. Use FrameInfo to debug the communication between your LoRaWAN end devices and the network server.</p>
    pub fn wireless_device_frame_info(
        &self,
    ) -> std::option::Option<&crate::model::WirelessDeviceFrameInfo> {
        self.wireless_device_frame_info.as_ref()
    }
    /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
}
impl TraceContent {
    /// Creates a new builder-style object to manufacture [`TraceContent`](crate::model::TraceContent).
    pub fn builder() -> crate::model::trace_content::Builder {
        crate::model::trace_content::Builder::default()
    }
}

/// See [`TraceContent`](crate::model::TraceContent).
pub mod trace_content {

    /// A builder for [`TraceContent`](crate::model::TraceContent).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) wireless_device_frame_info:
            std::option::Option<crate::model::WirelessDeviceFrameInfo>,
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
    }
    impl Builder {
        /// <p> <code>FrameInfo</code> of your wireless device resources for the trace content. Use FrameInfo to debug the communication between your LoRaWAN end devices and the network server.</p>
        pub fn wireless_device_frame_info(
            mut self,
            input: crate::model::WirelessDeviceFrameInfo,
        ) -> Self {
            self.wireless_device_frame_info = Some(input);
            self
        }
        /// <p> <code>FrameInfo</code> of your wireless device resources for the trace content. Use FrameInfo to debug the communication between your LoRaWAN end devices and the network server.</p>
        pub fn set_wireless_device_frame_info(
            mut self,
            input: std::option::Option<crate::model::WirelessDeviceFrameInfo>,
        ) -> Self {
            self.wireless_device_frame_info = input;
            self
        }
        /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// Consumes the builder and constructs a [`TraceContent`](crate::model::TraceContent).
        pub fn build(self) -> crate::model::TraceContent {
            crate::model::TraceContent {
                wireless_device_frame_info: self.wireless_device_frame_info,
                log_level: self.log_level,
            }
        }
    }
}

/// When writing a match expression against `LogLevel`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let loglevel = unimplemented!();
/// match loglevel {
///     LogLevel::Disabled => { /* ... */ },
///     LogLevel::Error => { /* ... */ },
///     LogLevel::Info => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `loglevel` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LogLevel::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LogLevel::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LogLevel::NewFeature` is defined.
/// Specifically, when `loglevel` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LogLevel::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display
/// less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogLevel {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Info,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LogLevel {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => LogLevel::Disabled,
            "ERROR" => LogLevel::Error,
            "INFO" => LogLevel::Info,
            other => LogLevel::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LogLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogLevel::from(s))
    }
}
impl LogLevel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogLevel::Disabled => "DISABLED",
            LogLevel::Error => "ERROR",
            LogLevel::Info => "INFO",
            LogLevel::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ERROR", "INFO"]
    }
}
impl AsRef<str> for LogLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WirelessDeviceFrameInfo`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wirelessdeviceframeinfo = unimplemented!();
/// match wirelessdeviceframeinfo {
///     WirelessDeviceFrameInfo::Disabled => { /* ... */ },
///     WirelessDeviceFrameInfo::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wirelessdeviceframeinfo` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WirelessDeviceFrameInfo::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WirelessDeviceFrameInfo::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WirelessDeviceFrameInfo::NewFeature` is defined.
/// Specifically, when `wirelessdeviceframeinfo` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WirelessDeviceFrameInfo::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>
/// <code>FrameInfo</code> of your wireless device resources for the trace content. Use FrameInfo to debug
/// the communication between your LoRaWAN end devices and the network server.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WirelessDeviceFrameInfo {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WirelessDeviceFrameInfo {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => WirelessDeviceFrameInfo::Disabled,
            "ENABLED" => WirelessDeviceFrameInfo::Enabled,
            other => WirelessDeviceFrameInfo::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for WirelessDeviceFrameInfo {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WirelessDeviceFrameInfo::from(s))
    }
}
impl WirelessDeviceFrameInfo {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WirelessDeviceFrameInfo::Disabled => "DISABLED",
            WirelessDeviceFrameInfo::Enabled => "ENABLED",
            WirelessDeviceFrameInfo::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for WirelessDeviceFrameInfo {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The LoRaWAN information that is to be used with the multicast group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanMulticast {
    /// <p>Supported RfRegions</p>
    #[doc(hidden)]
    pub rf_region: std::option::Option<crate::model::SupportedRfRegion>,
    /// <p>DlClass for LoRaWAM, valid values are ClassB and ClassC.</p>
    #[doc(hidden)]
    pub dl_class: std::option::Option<crate::model::DlClass>,
}
impl LoRaWanMulticast {
    /// <p>Supported RfRegions</p>
    pub fn rf_region(&self) -> std::option::Option<&crate::model::SupportedRfRegion> {
        self.rf_region.as_ref()
    }
    /// <p>DlClass for LoRaWAM, valid values are ClassB and ClassC.</p>
    pub fn dl_class(&self) -> std::option::Option<&crate::model::DlClass> {
        self.dl_class.as_ref()
    }
}
impl LoRaWanMulticast {
    /// Creates a new builder-style object to manufacture [`LoRaWanMulticast`](crate::model::LoRaWanMulticast).
    pub fn builder() -> crate::model::lo_ra_wan_multicast::Builder {
        crate::model::lo_ra_wan_multicast::Builder::default()
    }
}

/// See [`LoRaWanMulticast`](crate::model::LoRaWanMulticast).
pub mod lo_ra_wan_multicast {

    /// A builder for [`LoRaWanMulticast`](crate::model::LoRaWanMulticast).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rf_region: std::option::Option<crate::model::SupportedRfRegion>,
        pub(crate) dl_class: std::option::Option<crate::model::DlClass>,
    }
    impl Builder {
        /// <p>Supported RfRegions</p>
        pub fn rf_region(mut self, input: crate::model::SupportedRfRegion) -> Self {
            self.rf_region = Some(input);
            self
        }
        /// <p>Supported RfRegions</p>
        pub fn set_rf_region(
            mut self,
            input: std::option::Option<crate::model::SupportedRfRegion>,
        ) -> Self {
            self.rf_region = input;
            self
        }
        /// <p>DlClass for LoRaWAM, valid values are ClassB and ClassC.</p>
        pub fn dl_class(mut self, input: crate::model::DlClass) -> Self {
            self.dl_class = Some(input);
            self
        }
        /// <p>DlClass for LoRaWAM, valid values are ClassB and ClassC.</p>
        pub fn set_dl_class(mut self, input: std::option::Option<crate::model::DlClass>) -> Self {
            self.dl_class = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanMulticast`](crate::model::LoRaWanMulticast).
        pub fn build(self) -> crate::model::LoRaWanMulticast {
            crate::model::LoRaWanMulticast {
                rf_region: self.rf_region,
                dl_class: self.dl_class,
            }
        }
    }
}

/// When writing a match expression against `DlClass`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dlclass = unimplemented!();
/// match dlclass {
///     DlClass::ClassB => { /* ... */ },
///     DlClass::ClassC => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dlclass` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DlClass::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DlClass::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DlClass::NewFeature` is defined.
/// Specifically, when `dlclass` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DlClass::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>DlClass for LoRaWAM, valid values are ClassB and ClassC.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DlClass {
    #[allow(missing_docs)] // documentation missing in model
    ClassB,
    #[allow(missing_docs)] // documentation missing in model
    ClassC,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DlClass {
    fn from(s: &str) -> Self {
        match s {
            "ClassB" => DlClass::ClassB,
            "ClassC" => DlClass::ClassC,
            other => DlClass::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DlClass {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DlClass::from(s))
    }
}
impl DlClass {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DlClass::ClassB => "ClassB",
            DlClass::ClassC => "ClassC",
            DlClass::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ClassB", "ClassC"]
    }
}
impl AsRef<str> for DlClass {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `SupportedRfRegion`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let supportedrfregion = unimplemented!();
/// match supportedrfregion {
///     SupportedRfRegion::As9231 => { /* ... */ },
///     SupportedRfRegion::Au915 => { /* ... */ },
///     SupportedRfRegion::Eu868 => { /* ... */ },
///     SupportedRfRegion::Us915 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `supportedrfregion` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SupportedRfRegion::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SupportedRfRegion::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SupportedRfRegion::NewFeature` is defined.
/// Specifically, when `supportedrfregion` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SupportedRfRegion::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Supported RfRegions</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SupportedRfRegion {
    #[allow(missing_docs)] // documentation missing in model
    As9231,
    #[allow(missing_docs)] // documentation missing in model
    Au915,
    #[allow(missing_docs)] // documentation missing in model
    Eu868,
    #[allow(missing_docs)] // documentation missing in model
    Us915,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SupportedRfRegion {
    fn from(s: &str) -> Self {
        match s {
            "AS923-1" => SupportedRfRegion::As9231,
            "AU915" => SupportedRfRegion::Au915,
            "EU868" => SupportedRfRegion::Eu868,
            "US915" => SupportedRfRegion::Us915,
            other => {
                SupportedRfRegion::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for SupportedRfRegion {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SupportedRfRegion::from(s))
    }
}
impl SupportedRfRegion {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SupportedRfRegion::As9231 => "AS923-1",
            SupportedRfRegion::Au915 => "AU915",
            SupportedRfRegion::Eu868 => "EU868",
            SupportedRfRegion::Us915 => "US915",
            SupportedRfRegion::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AS923-1", "AU915", "EU868", "US915"]
    }
}
impl AsRef<str> for SupportedRfRegion {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The log options for wireless gateways and can be used to set log levels for a specific type of wireless gateway.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WirelessGatewayLogOption {
    /// <p>The wireless gateway type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::WirelessGatewayType>,
    /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
    #[doc(hidden)]
    pub log_level: std::option::Option<crate::model::LogLevel>,
    /// <p>The list of wireless gateway event log options.</p>
    #[doc(hidden)]
    pub events: std::option::Option<std::vec::Vec<crate::model::WirelessGatewayEventLogOption>>,
}
impl WirelessGatewayLogOption {
    /// <p>The wireless gateway type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::WirelessGatewayType> {
        self.r#type.as_ref()
    }
    /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
    /// <p>The list of wireless gateway event log options.</p>
    pub fn events(&self) -> std::option::Option<&[crate::model::WirelessGatewayEventLogOption]> {
        self.events.as_deref()
    }
}
impl WirelessGatewayLogOption {
    /// Creates a new builder-style object to manufacture [`WirelessGatewayLogOption`](crate::model::WirelessGatewayLogOption).
    pub fn builder() -> crate::model::wireless_gateway_log_option::Builder {
        crate::model::wireless_gateway_log_option::Builder::default()
    }
}

/// See [`WirelessGatewayLogOption`](crate::model::WirelessGatewayLogOption).
pub mod wireless_gateway_log_option {

    /// A builder for [`WirelessGatewayLogOption`](crate::model::WirelessGatewayLogOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::WirelessGatewayType>,
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
        pub(crate) events:
            std::option::Option<std::vec::Vec<crate::model::WirelessGatewayEventLogOption>>,
    }
    impl Builder {
        /// <p>The wireless gateway type.</p>
        pub fn r#type(mut self, input: crate::model::WirelessGatewayType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The wireless gateway type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::WirelessGatewayType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// Appends an item to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>The list of wireless gateway event log options.</p>
        pub fn events(mut self, input: crate::model::WirelessGatewayEventLogOption) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input);
            self.events = Some(v);
            self
        }
        /// <p>The list of wireless gateway event log options.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WirelessGatewayEventLogOption>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// Consumes the builder and constructs a [`WirelessGatewayLogOption`](crate::model::WirelessGatewayLogOption).
        pub fn build(self) -> crate::model::WirelessGatewayLogOption {
            crate::model::WirelessGatewayLogOption {
                r#type: self.r#type,
                log_level: self.log_level,
                events: self.events,
            }
        }
    }
}

/// <p>The log options for a wireless gateway event and can be used to set log levels for a specific wireless gateway event.</p>
/// <p>For a LoRaWAN gateway, possible events for a log message are <code>CUPS_Request</code> and <code>Certificate</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WirelessGatewayEventLogOption {
    /// <p>The event for a log message, if the log message is tied to a wireless gateway.</p>
    #[doc(hidden)]
    pub event: std::option::Option<crate::model::WirelessGatewayEvent>,
    /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
    #[doc(hidden)]
    pub log_level: std::option::Option<crate::model::LogLevel>,
}
impl WirelessGatewayEventLogOption {
    /// <p>The event for a log message, if the log message is tied to a wireless gateway.</p>
    pub fn event(&self) -> std::option::Option<&crate::model::WirelessGatewayEvent> {
        self.event.as_ref()
    }
    /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
}
impl WirelessGatewayEventLogOption {
    /// Creates a new builder-style object to manufacture [`WirelessGatewayEventLogOption`](crate::model::WirelessGatewayEventLogOption).
    pub fn builder() -> crate::model::wireless_gateway_event_log_option::Builder {
        crate::model::wireless_gateway_event_log_option::Builder::default()
    }
}

/// See [`WirelessGatewayEventLogOption`](crate::model::WirelessGatewayEventLogOption).
pub mod wireless_gateway_event_log_option {

    /// A builder for [`WirelessGatewayEventLogOption`](crate::model::WirelessGatewayEventLogOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event: std::option::Option<crate::model::WirelessGatewayEvent>,
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
    }
    impl Builder {
        /// <p>The event for a log message, if the log message is tied to a wireless gateway.</p>
        pub fn event(mut self, input: crate::model::WirelessGatewayEvent) -> Self {
            self.event = Some(input);
            self
        }
        /// <p>The event for a log message, if the log message is tied to a wireless gateway.</p>
        pub fn set_event(
            mut self,
            input: std::option::Option<crate::model::WirelessGatewayEvent>,
        ) -> Self {
            self.event = input;
            self
        }
        /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// Consumes the builder and constructs a [`WirelessGatewayEventLogOption`](crate::model::WirelessGatewayEventLogOption).
        pub fn build(self) -> crate::model::WirelessGatewayEventLogOption {
            crate::model::WirelessGatewayEventLogOption {
                event: self.event,
                log_level: self.log_level,
            }
        }
    }
}

/// When writing a match expression against `WirelessGatewayEvent`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wirelessgatewayevent = unimplemented!();
/// match wirelessgatewayevent {
///     WirelessGatewayEvent::CupsRequest => { /* ... */ },
///     WirelessGatewayEvent::Certificate => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wirelessgatewayevent` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WirelessGatewayEvent::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WirelessGatewayEvent::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WirelessGatewayEvent::NewFeature` is defined.
/// Specifically, when `wirelessgatewayevent` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WirelessGatewayEvent::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The event for a log message, if the log message is tied to a wireless gateway.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WirelessGatewayEvent {
    #[allow(missing_docs)] // documentation missing in model
    CupsRequest,
    #[allow(missing_docs)] // documentation missing in model
    Certificate,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WirelessGatewayEvent {
    fn from(s: &str) -> Self {
        match s {
            "CUPS_Request" => WirelessGatewayEvent::CupsRequest,
            "Certificate" => WirelessGatewayEvent::Certificate,
            other => {
                WirelessGatewayEvent::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WirelessGatewayEvent {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WirelessGatewayEvent::from(s))
    }
}
impl WirelessGatewayEvent {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WirelessGatewayEvent::CupsRequest => "CUPS_Request",
            WirelessGatewayEvent::Certificate => "Certificate",
            WirelessGatewayEvent::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CUPS_Request", "Certificate"]
    }
}
impl AsRef<str> for WirelessGatewayEvent {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WirelessGatewayType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wirelessgatewaytype = unimplemented!();
/// match wirelessgatewaytype {
///     WirelessGatewayType::LoRaWan => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wirelessgatewaytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WirelessGatewayType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WirelessGatewayType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WirelessGatewayType::NewFeature` is defined.
/// Specifically, when `wirelessgatewaytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WirelessGatewayType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The wireless gateway type.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WirelessGatewayType {
    #[allow(missing_docs)] // documentation missing in model
    LoRaWan,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WirelessGatewayType {
    fn from(s: &str) -> Self {
        match s {
            "LoRaWAN" => WirelessGatewayType::LoRaWan,
            other => {
                WirelessGatewayType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WirelessGatewayType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WirelessGatewayType::from(s))
    }
}
impl WirelessGatewayType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WirelessGatewayType::LoRaWan => "LoRaWAN",
            WirelessGatewayType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LoRaWAN"]
    }
}
impl AsRef<str> for WirelessGatewayType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The log options for wireless devices and can be used to set log levels for a specific type of wireless device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WirelessDeviceLogOption {
    /// <p>The wireless device type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::WirelessDeviceType>,
    /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
    #[doc(hidden)]
    pub log_level: std::option::Option<crate::model::LogLevel>,
    /// <p>The list of wireless device event log options.</p>
    #[doc(hidden)]
    pub events: std::option::Option<std::vec::Vec<crate::model::WirelessDeviceEventLogOption>>,
}
impl WirelessDeviceLogOption {
    /// <p>The wireless device type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::WirelessDeviceType> {
        self.r#type.as_ref()
    }
    /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
    /// <p>The list of wireless device event log options.</p>
    pub fn events(&self) -> std::option::Option<&[crate::model::WirelessDeviceEventLogOption]> {
        self.events.as_deref()
    }
}
impl WirelessDeviceLogOption {
    /// Creates a new builder-style object to manufacture [`WirelessDeviceLogOption`](crate::model::WirelessDeviceLogOption).
    pub fn builder() -> crate::model::wireless_device_log_option::Builder {
        crate::model::wireless_device_log_option::Builder::default()
    }
}

/// See [`WirelessDeviceLogOption`](crate::model::WirelessDeviceLogOption).
pub mod wireless_device_log_option {

    /// A builder for [`WirelessDeviceLogOption`](crate::model::WirelessDeviceLogOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::WirelessDeviceType>,
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
        pub(crate) events:
            std::option::Option<std::vec::Vec<crate::model::WirelessDeviceEventLogOption>>,
    }
    impl Builder {
        /// <p>The wireless device type.</p>
        pub fn r#type(mut self, input: crate::model::WirelessDeviceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The wireless device type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::WirelessDeviceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// Appends an item to `events`.
        ///
        /// To override the contents of this collection use [`set_events`](Self::set_events).
        ///
        /// <p>The list of wireless device event log options.</p>
        pub fn events(mut self, input: crate::model::WirelessDeviceEventLogOption) -> Self {
            let mut v = self.events.unwrap_or_default();
            v.push(input);
            self.events = Some(v);
            self
        }
        /// <p>The list of wireless device event log options.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WirelessDeviceEventLogOption>>,
        ) -> Self {
            self.events = input;
            self
        }
        /// Consumes the builder and constructs a [`WirelessDeviceLogOption`](crate::model::WirelessDeviceLogOption).
        pub fn build(self) -> crate::model::WirelessDeviceLogOption {
            crate::model::WirelessDeviceLogOption {
                r#type: self.r#type,
                log_level: self.log_level,
                events: self.events,
            }
        }
    }
}

/// <p>The log options for a wireless device event and can be used to set log levels for a specific wireless device event.</p>
/// <p>For a LoRaWAN device, possible events for a log messsage are: <code>Join</code>, <code>Rejoin</code>, <code>Downlink_Data</code>, and <code>Uplink_Data</code>. For a Sidewalk device, possible events for a log message are <code>Registration</code>, <code>Downlink_Data</code>, and <code>Uplink_Data</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WirelessDeviceEventLogOption {
    /// <p>The event for a log message, if the log message is tied to a wireless device.</p>
    #[doc(hidden)]
    pub event: std::option::Option<crate::model::WirelessDeviceEvent>,
    /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
    #[doc(hidden)]
    pub log_level: std::option::Option<crate::model::LogLevel>,
}
impl WirelessDeviceEventLogOption {
    /// <p>The event for a log message, if the log message is tied to a wireless device.</p>
    pub fn event(&self) -> std::option::Option<&crate::model::WirelessDeviceEvent> {
        self.event.as_ref()
    }
    /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
    pub fn log_level(&self) -> std::option::Option<&crate::model::LogLevel> {
        self.log_level.as_ref()
    }
}
impl WirelessDeviceEventLogOption {
    /// Creates a new builder-style object to manufacture [`WirelessDeviceEventLogOption`](crate::model::WirelessDeviceEventLogOption).
    pub fn builder() -> crate::model::wireless_device_event_log_option::Builder {
        crate::model::wireless_device_event_log_option::Builder::default()
    }
}

/// See [`WirelessDeviceEventLogOption`](crate::model::WirelessDeviceEventLogOption).
pub mod wireless_device_event_log_option {

    /// A builder for [`WirelessDeviceEventLogOption`](crate::model::WirelessDeviceEventLogOption).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) event: std::option::Option<crate::model::WirelessDeviceEvent>,
        pub(crate) log_level: std::option::Option<crate::model::LogLevel>,
    }
    impl Builder {
        /// <p>The event for a log message, if the log message is tied to a wireless device.</p>
        pub fn event(mut self, input: crate::model::WirelessDeviceEvent) -> Self {
            self.event = Some(input);
            self
        }
        /// <p>The event for a log message, if the log message is tied to a wireless device.</p>
        pub fn set_event(
            mut self,
            input: std::option::Option<crate::model::WirelessDeviceEvent>,
        ) -> Self {
            self.event = input;
            self
        }
        /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
        pub fn log_level(mut self, input: crate::model::LogLevel) -> Self {
            self.log_level = Some(input);
            self
        }
        /// <p>The log level for a log message. The log levels can be disabled, or set to <code>ERROR</code> to display less verbose logs containing only error information, or to <code>INFO</code> for more detailed logs.</p>
        pub fn set_log_level(mut self, input: std::option::Option<crate::model::LogLevel>) -> Self {
            self.log_level = input;
            self
        }
        /// Consumes the builder and constructs a [`WirelessDeviceEventLogOption`](crate::model::WirelessDeviceEventLogOption).
        pub fn build(self) -> crate::model::WirelessDeviceEventLogOption {
            crate::model::WirelessDeviceEventLogOption {
                event: self.event,
                log_level: self.log_level,
            }
        }
    }
}

/// When writing a match expression against `WirelessDeviceEvent`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wirelessdeviceevent = unimplemented!();
/// match wirelessdeviceevent {
///     WirelessDeviceEvent::DownlinkData => { /* ... */ },
///     WirelessDeviceEvent::Join => { /* ... */ },
///     WirelessDeviceEvent::Registration => { /* ... */ },
///     WirelessDeviceEvent::Rejoin => { /* ... */ },
///     WirelessDeviceEvent::UplinkData => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wirelessdeviceevent` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WirelessDeviceEvent::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WirelessDeviceEvent::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WirelessDeviceEvent::NewFeature` is defined.
/// Specifically, when `wirelessdeviceevent` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WirelessDeviceEvent::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The event for a log message, if the log message is tied to a wireless device.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WirelessDeviceEvent {
    #[allow(missing_docs)] // documentation missing in model
    DownlinkData,
    #[allow(missing_docs)] // documentation missing in model
    Join,
    #[allow(missing_docs)] // documentation missing in model
    Registration,
    #[allow(missing_docs)] // documentation missing in model
    Rejoin,
    #[allow(missing_docs)] // documentation missing in model
    UplinkData,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WirelessDeviceEvent {
    fn from(s: &str) -> Self {
        match s {
            "Downlink_Data" => WirelessDeviceEvent::DownlinkData,
            "Join" => WirelessDeviceEvent::Join,
            "Registration" => WirelessDeviceEvent::Registration,
            "Rejoin" => WirelessDeviceEvent::Rejoin,
            "Uplink_Data" => WirelessDeviceEvent::UplinkData,
            other => {
                WirelessDeviceEvent::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WirelessDeviceEvent {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WirelessDeviceEvent::from(s))
    }
}
impl WirelessDeviceEvent {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WirelessDeviceEvent::DownlinkData => "Downlink_Data",
            WirelessDeviceEvent::Join => "Join",
            WirelessDeviceEvent::Registration => "Registration",
            WirelessDeviceEvent::Rejoin => "Rejoin",
            WirelessDeviceEvent::UplinkData => "Uplink_Data",
            WirelessDeviceEvent::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Downlink_Data",
            "Join",
            "Registration",
            "Rejoin",
            "Uplink_Data",
        ]
    }
}
impl AsRef<str> for WirelessDeviceEvent {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WirelessDeviceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wirelessdevicetype = unimplemented!();
/// match wirelessdevicetype {
///     WirelessDeviceType::LoRaWan => { /* ... */ },
///     WirelessDeviceType::Sidewalk => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wirelessdevicetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WirelessDeviceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WirelessDeviceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WirelessDeviceType::NewFeature` is defined.
/// Specifically, when `wirelessdevicetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WirelessDeviceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WirelessDeviceType {
    #[allow(missing_docs)] // documentation missing in model
    LoRaWan,
    #[allow(missing_docs)] // documentation missing in model
    Sidewalk,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WirelessDeviceType {
    fn from(s: &str) -> Self {
        match s {
            "LoRaWAN" => WirelessDeviceType::LoRaWan,
            "Sidewalk" => WirelessDeviceType::Sidewalk,
            other => {
                WirelessDeviceType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WirelessDeviceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WirelessDeviceType::from(s))
    }
}
impl WirelessDeviceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WirelessDeviceType::LoRaWan => "LoRaWAN",
            WirelessDeviceType::Sidewalk => "Sidewalk",
            WirelessDeviceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LoRaWAN", "Sidewalk"]
    }
}
impl AsRef<str> for WirelessDeviceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The LoRaWAN information used with a FUOTA task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanFuotaTask {
    /// <p>Supported RfRegions</p>
    #[doc(hidden)]
    pub rf_region: std::option::Option<crate::model::SupportedRfRegion>,
}
impl LoRaWanFuotaTask {
    /// <p>Supported RfRegions</p>
    pub fn rf_region(&self) -> std::option::Option<&crate::model::SupportedRfRegion> {
        self.rf_region.as_ref()
    }
}
impl LoRaWanFuotaTask {
    /// Creates a new builder-style object to manufacture [`LoRaWanFuotaTask`](crate::model::LoRaWanFuotaTask).
    pub fn builder() -> crate::model::lo_ra_wan_fuota_task::Builder {
        crate::model::lo_ra_wan_fuota_task::Builder::default()
    }
}

/// See [`LoRaWanFuotaTask`](crate::model::LoRaWanFuotaTask).
pub mod lo_ra_wan_fuota_task {

    /// A builder for [`LoRaWanFuotaTask`](crate::model::LoRaWanFuotaTask).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rf_region: std::option::Option<crate::model::SupportedRfRegion>,
    }
    impl Builder {
        /// <p>Supported RfRegions</p>
        pub fn rf_region(mut self, input: crate::model::SupportedRfRegion) -> Self {
            self.rf_region = Some(input);
            self
        }
        /// <p>Supported RfRegions</p>
        pub fn set_rf_region(
            mut self,
            input: std::option::Option<crate::model::SupportedRfRegion>,
        ) -> Self {
            self.rf_region = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanFuotaTask`](crate::model::LoRaWanFuotaTask).
        pub fn build(self) -> crate::model::LoRaWanFuotaTask {
            crate::model::LoRaWanFuotaTask {
                rf_region: self.rf_region,
            }
        }
    }
}

/// <p>Message delivery status resource type event configuration object for enabling or disabling relevant topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MessageDeliveryStatusResourceTypeEventConfiguration {
    /// <p>Sidewalk resource type event configuration object for enabling or disabling topic.</p>
    #[doc(hidden)]
    pub sidewalk: std::option::Option<crate::model::SidewalkResourceTypeEventConfiguration>,
}
impl MessageDeliveryStatusResourceTypeEventConfiguration {
    /// <p>Sidewalk resource type event configuration object for enabling or disabling topic.</p>
    pub fn sidewalk(
        &self,
    ) -> std::option::Option<&crate::model::SidewalkResourceTypeEventConfiguration> {
        self.sidewalk.as_ref()
    }
}
impl MessageDeliveryStatusResourceTypeEventConfiguration {
    /// Creates a new builder-style object to manufacture [`MessageDeliveryStatusResourceTypeEventConfiguration`](crate::model::MessageDeliveryStatusResourceTypeEventConfiguration).
    pub fn builder(
    ) -> crate::model::message_delivery_status_resource_type_event_configuration::Builder {
        crate::model::message_delivery_status_resource_type_event_configuration::Builder::default()
    }
}

/// See [`MessageDeliveryStatusResourceTypeEventConfiguration`](crate::model::MessageDeliveryStatusResourceTypeEventConfiguration).
pub mod message_delivery_status_resource_type_event_configuration {

    /// A builder for [`MessageDeliveryStatusResourceTypeEventConfiguration`](crate::model::MessageDeliveryStatusResourceTypeEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sidewalk:
            std::option::Option<crate::model::SidewalkResourceTypeEventConfiguration>,
    }
    impl Builder {
        /// <p>Sidewalk resource type event configuration object for enabling or disabling topic.</p>
        pub fn sidewalk(
            mut self,
            input: crate::model::SidewalkResourceTypeEventConfiguration,
        ) -> Self {
            self.sidewalk = Some(input);
            self
        }
        /// <p>Sidewalk resource type event configuration object for enabling or disabling topic.</p>
        pub fn set_sidewalk(
            mut self,
            input: std::option::Option<crate::model::SidewalkResourceTypeEventConfiguration>,
        ) -> Self {
            self.sidewalk = input;
            self
        }
        /// Consumes the builder and constructs a [`MessageDeliveryStatusResourceTypeEventConfiguration`](crate::model::MessageDeliveryStatusResourceTypeEventConfiguration).
        pub fn build(self) -> crate::model::MessageDeliveryStatusResourceTypeEventConfiguration {
            crate::model::MessageDeliveryStatusResourceTypeEventConfiguration {
                sidewalk: self.sidewalk,
            }
        }
    }
}

/// <p>Sidewalk resource type event configuration object for enabling or disabling topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SidewalkResourceTypeEventConfiguration {
    /// <p>Denotes whether the wireless device join event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub wireless_device_event_topic:
        std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl SidewalkResourceTypeEventConfiguration {
    /// <p>Denotes whether the wireless device join event topic is enabled or disabled.</p>
    pub fn wireless_device_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.wireless_device_event_topic.as_ref()
    }
}
impl SidewalkResourceTypeEventConfiguration {
    /// Creates a new builder-style object to manufacture [`SidewalkResourceTypeEventConfiguration`](crate::model::SidewalkResourceTypeEventConfiguration).
    pub fn builder() -> crate::model::sidewalk_resource_type_event_configuration::Builder {
        crate::model::sidewalk_resource_type_event_configuration::Builder::default()
    }
}

/// See [`SidewalkResourceTypeEventConfiguration`](crate::model::SidewalkResourceTypeEventConfiguration).
pub mod sidewalk_resource_type_event_configuration {

    /// A builder for [`SidewalkResourceTypeEventConfiguration`](crate::model::SidewalkResourceTypeEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) wireless_device_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p>Denotes whether the wireless device join event topic is enabled or disabled.</p>
        pub fn wireless_device_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.wireless_device_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the wireless device join event topic is enabled or disabled.</p>
        pub fn set_wireless_device_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.wireless_device_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`SidewalkResourceTypeEventConfiguration`](crate::model::SidewalkResourceTypeEventConfiguration).
        pub fn build(self) -> crate::model::SidewalkResourceTypeEventConfiguration {
            crate::model::SidewalkResourceTypeEventConfiguration {
                wireless_device_event_topic: self.wireless_device_event_topic,
            }
        }
    }
}

/// <p>Connection status resource type event configuration object for enabling or disabling topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionStatusResourceTypeEventConfiguration {
    /// <p>Connection status resource type event configuration object for enabling or disabling LoRaWAN related event topics.</p>
    #[doc(hidden)]
    pub lo_ra_wan:
        std::option::Option<crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration>,
}
impl ConnectionStatusResourceTypeEventConfiguration {
    /// <p>Connection status resource type event configuration object for enabling or disabling LoRaWAN related event topics.</p>
    pub fn lo_ra_wan(
        &self,
    ) -> std::option::Option<&crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration>
    {
        self.lo_ra_wan.as_ref()
    }
}
impl ConnectionStatusResourceTypeEventConfiguration {
    /// Creates a new builder-style object to manufacture [`ConnectionStatusResourceTypeEventConfiguration`](crate::model::ConnectionStatusResourceTypeEventConfiguration).
    pub fn builder() -> crate::model::connection_status_resource_type_event_configuration::Builder {
        crate::model::connection_status_resource_type_event_configuration::Builder::default()
    }
}

/// See [`ConnectionStatusResourceTypeEventConfiguration`](crate::model::ConnectionStatusResourceTypeEventConfiguration).
pub mod connection_status_resource_type_event_configuration {

    /// A builder for [`ConnectionStatusResourceTypeEventConfiguration`](crate::model::ConnectionStatusResourceTypeEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lo_ra_wan: std::option::Option<
            crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration,
        >,
    }
    impl Builder {
        /// <p>Connection status resource type event configuration object for enabling or disabling LoRaWAN related event topics.</p>
        pub fn lo_ra_wan(
            mut self,
            input: crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration,
        ) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>Connection status resource type event configuration object for enabling or disabling LoRaWAN related event topics.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<
                crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration,
            >,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionStatusResourceTypeEventConfiguration`](crate::model::ConnectionStatusResourceTypeEventConfiguration).
        pub fn build(self) -> crate::model::ConnectionStatusResourceTypeEventConfiguration {
            crate::model::ConnectionStatusResourceTypeEventConfiguration {
                lo_ra_wan: self.lo_ra_wan,
            }
        }
    }
}

/// <p>Object for LoRaWAN connection status resource type event configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanConnectionStatusResourceTypeEventConfiguration {
    /// <p>Denotes whether the wireless gateway connection status event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub wireless_gateway_event_topic:
        std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl LoRaWanConnectionStatusResourceTypeEventConfiguration {
    /// <p>Denotes whether the wireless gateway connection status event topic is enabled or disabled.</p>
    pub fn wireless_gateway_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.wireless_gateway_event_topic.as_ref()
    }
}
impl LoRaWanConnectionStatusResourceTypeEventConfiguration {
    /// Creates a new builder-style object to manufacture [`LoRaWanConnectionStatusResourceTypeEventConfiguration`](crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration).
    pub fn builder(
    ) -> crate::model::lo_ra_wan_connection_status_resource_type_event_configuration::Builder {
        crate::model::lo_ra_wan_connection_status_resource_type_event_configuration::Builder::default()
    }
}

/// See [`LoRaWanConnectionStatusResourceTypeEventConfiguration`](crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration).
pub mod lo_ra_wan_connection_status_resource_type_event_configuration {

    /// A builder for [`LoRaWanConnectionStatusResourceTypeEventConfiguration`](crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) wireless_gateway_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p>Denotes whether the wireless gateway connection status event topic is enabled or disabled.</p>
        pub fn wireless_gateway_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.wireless_gateway_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the wireless gateway connection status event topic is enabled or disabled.</p>
        pub fn set_wireless_gateway_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.wireless_gateway_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanConnectionStatusResourceTypeEventConfiguration`](crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration).
        pub fn build(self) -> crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration {
            crate::model::LoRaWanConnectionStatusResourceTypeEventConfiguration {
                wireless_gateway_event_topic: self.wireless_gateway_event_topic,
            }
        }
    }
}

/// <p>Join resource type event configuration object for enabling or disabling topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct JoinResourceTypeEventConfiguration {
    /// <p>Join resource type event configuration object for enabling or disabling LoRaWAN related event topics.</p>
    #[doc(hidden)]
    pub lo_ra_wan: std::option::Option<crate::model::LoRaWanJoinResourceTypeEventConfiguration>,
}
impl JoinResourceTypeEventConfiguration {
    /// <p>Join resource type event configuration object for enabling or disabling LoRaWAN related event topics.</p>
    pub fn lo_ra_wan(
        &self,
    ) -> std::option::Option<&crate::model::LoRaWanJoinResourceTypeEventConfiguration> {
        self.lo_ra_wan.as_ref()
    }
}
impl JoinResourceTypeEventConfiguration {
    /// Creates a new builder-style object to manufacture [`JoinResourceTypeEventConfiguration`](crate::model::JoinResourceTypeEventConfiguration).
    pub fn builder() -> crate::model::join_resource_type_event_configuration::Builder {
        crate::model::join_resource_type_event_configuration::Builder::default()
    }
}

/// See [`JoinResourceTypeEventConfiguration`](crate::model::JoinResourceTypeEventConfiguration).
pub mod join_resource_type_event_configuration {

    /// A builder for [`JoinResourceTypeEventConfiguration`](crate::model::JoinResourceTypeEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lo_ra_wan:
            std::option::Option<crate::model::LoRaWanJoinResourceTypeEventConfiguration>,
    }
    impl Builder {
        /// <p>Join resource type event configuration object for enabling or disabling LoRaWAN related event topics.</p>
        pub fn lo_ra_wan(
            mut self,
            input: crate::model::LoRaWanJoinResourceTypeEventConfiguration,
        ) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>Join resource type event configuration object for enabling or disabling LoRaWAN related event topics.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<crate::model::LoRaWanJoinResourceTypeEventConfiguration>,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// Consumes the builder and constructs a [`JoinResourceTypeEventConfiguration`](crate::model::JoinResourceTypeEventConfiguration).
        pub fn build(self) -> crate::model::JoinResourceTypeEventConfiguration {
            crate::model::JoinResourceTypeEventConfiguration {
                lo_ra_wan: self.lo_ra_wan,
            }
        }
    }
}

/// <p>Object for LoRaWAN join resource type event configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanJoinResourceTypeEventConfiguration {
    /// <p>Denotes whether the wireless device join event topic is enabled or disabled.</p>
    #[doc(hidden)]
    pub wireless_device_event_topic:
        std::option::Option<crate::model::EventNotificationTopicStatus>,
}
impl LoRaWanJoinResourceTypeEventConfiguration {
    /// <p>Denotes whether the wireless device join event topic is enabled or disabled.</p>
    pub fn wireless_device_event_topic(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationTopicStatus> {
        self.wireless_device_event_topic.as_ref()
    }
}
impl LoRaWanJoinResourceTypeEventConfiguration {
    /// Creates a new builder-style object to manufacture [`LoRaWanJoinResourceTypeEventConfiguration`](crate::model::LoRaWanJoinResourceTypeEventConfiguration).
    pub fn builder() -> crate::model::lo_ra_wan_join_resource_type_event_configuration::Builder {
        crate::model::lo_ra_wan_join_resource_type_event_configuration::Builder::default()
    }
}

/// See [`LoRaWanJoinResourceTypeEventConfiguration`](crate::model::LoRaWanJoinResourceTypeEventConfiguration).
pub mod lo_ra_wan_join_resource_type_event_configuration {

    /// A builder for [`LoRaWanJoinResourceTypeEventConfiguration`](crate::model::LoRaWanJoinResourceTypeEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) wireless_device_event_topic:
            std::option::Option<crate::model::EventNotificationTopicStatus>,
    }
    impl Builder {
        /// <p>Denotes whether the wireless device join event topic is enabled or disabled.</p>
        pub fn wireless_device_event_topic(
            mut self,
            input: crate::model::EventNotificationTopicStatus,
        ) -> Self {
            self.wireless_device_event_topic = Some(input);
            self
        }
        /// <p>Denotes whether the wireless device join event topic is enabled or disabled.</p>
        pub fn set_wireless_device_event_topic(
            mut self,
            input: std::option::Option<crate::model::EventNotificationTopicStatus>,
        ) -> Self {
            self.wireless_device_event_topic = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanJoinResourceTypeEventConfiguration`](crate::model::LoRaWanJoinResourceTypeEventConfiguration).
        pub fn build(self) -> crate::model::LoRaWanJoinResourceTypeEventConfiguration {
            crate::model::LoRaWanJoinResourceTypeEventConfiguration {
                wireless_device_event_topic: self.wireless_device_event_topic,
            }
        }
    }
}

/// <p>Proximity resource type event configuration object for enabling or disabling topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ProximityResourceTypeEventConfiguration {
    /// <p>Proximity resource type event configuration object for enabling and disabling wireless device topic.</p>
    #[doc(hidden)]
    pub sidewalk: std::option::Option<crate::model::SidewalkResourceTypeEventConfiguration>,
}
impl ProximityResourceTypeEventConfiguration {
    /// <p>Proximity resource type event configuration object for enabling and disabling wireless device topic.</p>
    pub fn sidewalk(
        &self,
    ) -> std::option::Option<&crate::model::SidewalkResourceTypeEventConfiguration> {
        self.sidewalk.as_ref()
    }
}
impl ProximityResourceTypeEventConfiguration {
    /// Creates a new builder-style object to manufacture [`ProximityResourceTypeEventConfiguration`](crate::model::ProximityResourceTypeEventConfiguration).
    pub fn builder() -> crate::model::proximity_resource_type_event_configuration::Builder {
        crate::model::proximity_resource_type_event_configuration::Builder::default()
    }
}

/// See [`ProximityResourceTypeEventConfiguration`](crate::model::ProximityResourceTypeEventConfiguration).
pub mod proximity_resource_type_event_configuration {

    /// A builder for [`ProximityResourceTypeEventConfiguration`](crate::model::ProximityResourceTypeEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sidewalk:
            std::option::Option<crate::model::SidewalkResourceTypeEventConfiguration>,
    }
    impl Builder {
        /// <p>Proximity resource type event configuration object for enabling and disabling wireless device topic.</p>
        pub fn sidewalk(
            mut self,
            input: crate::model::SidewalkResourceTypeEventConfiguration,
        ) -> Self {
            self.sidewalk = Some(input);
            self
        }
        /// <p>Proximity resource type event configuration object for enabling and disabling wireless device topic.</p>
        pub fn set_sidewalk(
            mut self,
            input: std::option::Option<crate::model::SidewalkResourceTypeEventConfiguration>,
        ) -> Self {
            self.sidewalk = input;
            self
        }
        /// Consumes the builder and constructs a [`ProximityResourceTypeEventConfiguration`](crate::model::ProximityResourceTypeEventConfiguration).
        pub fn build(self) -> crate::model::ProximityResourceTypeEventConfiguration {
            crate::model::ProximityResourceTypeEventConfiguration {
                sidewalk: self.sidewalk,
            }
        }
    }
}

/// <p>Device registration state resource type event configuration object for enabling or disabling topic.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeviceRegistrationStateResourceTypeEventConfiguration {
    /// <p>Device registration resource type state event configuration object for enabling or disabling Sidewalk related event topics.</p>
    #[doc(hidden)]
    pub sidewalk: std::option::Option<crate::model::SidewalkResourceTypeEventConfiguration>,
}
impl DeviceRegistrationStateResourceTypeEventConfiguration {
    /// <p>Device registration resource type state event configuration object for enabling or disabling Sidewalk related event topics.</p>
    pub fn sidewalk(
        &self,
    ) -> std::option::Option<&crate::model::SidewalkResourceTypeEventConfiguration> {
        self.sidewalk.as_ref()
    }
}
impl DeviceRegistrationStateResourceTypeEventConfiguration {
    /// Creates a new builder-style object to manufacture [`DeviceRegistrationStateResourceTypeEventConfiguration`](crate::model::DeviceRegistrationStateResourceTypeEventConfiguration).
    pub fn builder(
    ) -> crate::model::device_registration_state_resource_type_event_configuration::Builder {
        crate::model::device_registration_state_resource_type_event_configuration::Builder::default(
        )
    }
}

/// See [`DeviceRegistrationStateResourceTypeEventConfiguration`](crate::model::DeviceRegistrationStateResourceTypeEventConfiguration).
pub mod device_registration_state_resource_type_event_configuration {

    /// A builder for [`DeviceRegistrationStateResourceTypeEventConfiguration`](crate::model::DeviceRegistrationStateResourceTypeEventConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) sidewalk:
            std::option::Option<crate::model::SidewalkResourceTypeEventConfiguration>,
    }
    impl Builder {
        /// <p>Device registration resource type state event configuration object for enabling or disabling Sidewalk related event topics.</p>
        pub fn sidewalk(
            mut self,
            input: crate::model::SidewalkResourceTypeEventConfiguration,
        ) -> Self {
            self.sidewalk = Some(input);
            self
        }
        /// <p>Device registration resource type state event configuration object for enabling or disabling Sidewalk related event topics.</p>
        pub fn set_sidewalk(
            mut self,
            input: std::option::Option<crate::model::SidewalkResourceTypeEventConfiguration>,
        ) -> Self {
            self.sidewalk = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceRegistrationStateResourceTypeEventConfiguration`](crate::model::DeviceRegistrationStateResourceTypeEventConfiguration).
        pub fn build(self) -> crate::model::DeviceRegistrationStateResourceTypeEventConfiguration {
            crate::model::DeviceRegistrationStateResourceTypeEventConfiguration {
                sidewalk: self.sidewalk,
            }
        }
    }
}

/// When writing a match expression against `ExpressionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let expressiontype = unimplemented!();
/// match expressiontype {
///     ExpressionType::MqttTopic => { /* ... */ },
///     ExpressionType::RuleName => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `expressiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ExpressionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ExpressionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ExpressionType::NewFeature` is defined.
/// Specifically, when `expressiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ExpressionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ExpressionType {
    #[allow(missing_docs)] // documentation missing in model
    MqttTopic,
    #[allow(missing_docs)] // documentation missing in model
    RuleName,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ExpressionType {
    fn from(s: &str) -> Self {
        match s {
            "MqttTopic" => ExpressionType::MqttTopic,
            "RuleName" => ExpressionType::RuleName,
            other => ExpressionType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ExpressionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ExpressionType::from(s))
    }
}
impl ExpressionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ExpressionType::MqttTopic => "MqttTopic",
            ExpressionType::RuleName => "RuleName",
            ExpressionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["MqttTopic", "RuleName"]
    }
}
impl AsRef<str> for ExpressionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>A simple label consisting of a customer-defined key-value pair</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The tag's key value.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The tag's value.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The tag's key value.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The tag's value.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The tag's key value.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The tag's key value.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The tag's value.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The tag's value.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}

/// <p>The LoRaWAN information used with the multicast session.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanMulticastSession {
    /// <p>Downlink data rate.</p>
    #[doc(hidden)]
    pub dl_dr: std::option::Option<i32>,
    /// <p>Downlink frequency.</p>
    #[doc(hidden)]
    pub dl_freq: std::option::Option<i32>,
    /// <p>Timestamp of when the multicast group session is to start.</p>
    #[doc(hidden)]
    pub session_start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>How long before a multicast group session is to timeout.</p>
    #[doc(hidden)]
    pub session_timeout: std::option::Option<i32>,
}
impl LoRaWanMulticastSession {
    /// <p>Downlink data rate.</p>
    pub fn dl_dr(&self) -> std::option::Option<i32> {
        self.dl_dr
    }
    /// <p>Downlink frequency.</p>
    pub fn dl_freq(&self) -> std::option::Option<i32> {
        self.dl_freq
    }
    /// <p>Timestamp of when the multicast group session is to start.</p>
    pub fn session_start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.session_start_time.as_ref()
    }
    /// <p>How long before a multicast group session is to timeout.</p>
    pub fn session_timeout(&self) -> std::option::Option<i32> {
        self.session_timeout
    }
}
impl LoRaWanMulticastSession {
    /// Creates a new builder-style object to manufacture [`LoRaWanMulticastSession`](crate::model::LoRaWanMulticastSession).
    pub fn builder() -> crate::model::lo_ra_wan_multicast_session::Builder {
        crate::model::lo_ra_wan_multicast_session::Builder::default()
    }
}

/// See [`LoRaWanMulticastSession`](crate::model::LoRaWanMulticastSession).
pub mod lo_ra_wan_multicast_session {

    /// A builder for [`LoRaWanMulticastSession`](crate::model::LoRaWanMulticastSession).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dl_dr: std::option::Option<i32>,
        pub(crate) dl_freq: std::option::Option<i32>,
        pub(crate) session_start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) session_timeout: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Downlink data rate.</p>
        pub fn dl_dr(mut self, input: i32) -> Self {
            self.dl_dr = Some(input);
            self
        }
        /// <p>Downlink data rate.</p>
        pub fn set_dl_dr(mut self, input: std::option::Option<i32>) -> Self {
            self.dl_dr = input;
            self
        }
        /// <p>Downlink frequency.</p>
        pub fn dl_freq(mut self, input: i32) -> Self {
            self.dl_freq = Some(input);
            self
        }
        /// <p>Downlink frequency.</p>
        pub fn set_dl_freq(mut self, input: std::option::Option<i32>) -> Self {
            self.dl_freq = input;
            self
        }
        /// <p>Timestamp of when the multicast group session is to start.</p>
        pub fn session_start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.session_start_time = Some(input);
            self
        }
        /// <p>Timestamp of when the multicast group session is to start.</p>
        pub fn set_session_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.session_start_time = input;
            self
        }
        /// <p>How long before a multicast group session is to timeout.</p>
        pub fn session_timeout(mut self, input: i32) -> Self {
            self.session_timeout = Some(input);
            self
        }
        /// <p>How long before a multicast group session is to timeout.</p>
        pub fn set_session_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.session_timeout = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanMulticastSession`](crate::model::LoRaWanMulticastSession).
        pub fn build(self) -> crate::model::LoRaWanMulticastSession {
            crate::model::LoRaWanMulticastSession {
                dl_dr: self.dl_dr,
                dl_freq: self.dl_freq,
                session_start_time: self.session_start_time,
                session_timeout: self.session_timeout,
            }
        }
    }
}

/// <p>The LoRaWAN information used to start a FUOTA task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanStartFuotaTask {
    /// <p>Start time of a FUOTA task.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl LoRaWanStartFuotaTask {
    /// <p>Start time of a FUOTA task.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
}
impl LoRaWanStartFuotaTask {
    /// Creates a new builder-style object to manufacture [`LoRaWanStartFuotaTask`](crate::model::LoRaWanStartFuotaTask).
    pub fn builder() -> crate::model::lo_ra_wan_start_fuota_task::Builder {
        crate::model::lo_ra_wan_start_fuota_task::Builder::default()
    }
}

/// See [`LoRaWanStartFuotaTask`](crate::model::LoRaWanStartFuotaTask).
pub mod lo_ra_wan_start_fuota_task {

    /// A builder for [`LoRaWanStartFuotaTask`](crate::model::LoRaWanStartFuotaTask).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>Start time of a FUOTA task.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>Start time of a FUOTA task.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanStartFuotaTask`](crate::model::LoRaWanStartFuotaTask).
        pub fn build(self) -> crate::model::LoRaWanStartFuotaTask {
            crate::model::LoRaWanStartFuotaTask {
                start_time: self.start_time,
            }
        }
    }
}

/// <p>WirelessMetadata object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WirelessMetadata {
    /// <p>LoRaWAN device info.</p>
    #[doc(hidden)]
    pub lo_ra_wan: std::option::Option<crate::model::LoRaWanSendDataToDevice>,
    /// <p>The Sidewalk account credentials.</p>
    #[doc(hidden)]
    pub sidewalk: std::option::Option<crate::model::SidewalkSendDataToDevice>,
}
impl WirelessMetadata {
    /// <p>LoRaWAN device info.</p>
    pub fn lo_ra_wan(&self) -> std::option::Option<&crate::model::LoRaWanSendDataToDevice> {
        self.lo_ra_wan.as_ref()
    }
    /// <p>The Sidewalk account credentials.</p>
    pub fn sidewalk(&self) -> std::option::Option<&crate::model::SidewalkSendDataToDevice> {
        self.sidewalk.as_ref()
    }
}
impl WirelessMetadata {
    /// Creates a new builder-style object to manufacture [`WirelessMetadata`](crate::model::WirelessMetadata).
    pub fn builder() -> crate::model::wireless_metadata::Builder {
        crate::model::wireless_metadata::Builder::default()
    }
}

/// See [`WirelessMetadata`](crate::model::WirelessMetadata).
pub mod wireless_metadata {

    /// A builder for [`WirelessMetadata`](crate::model::WirelessMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lo_ra_wan: std::option::Option<crate::model::LoRaWanSendDataToDevice>,
        pub(crate) sidewalk: std::option::Option<crate::model::SidewalkSendDataToDevice>,
    }
    impl Builder {
        /// <p>LoRaWAN device info.</p>
        pub fn lo_ra_wan(mut self, input: crate::model::LoRaWanSendDataToDevice) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>LoRaWAN device info.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<crate::model::LoRaWanSendDataToDevice>,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// <p>The Sidewalk account credentials.</p>
        pub fn sidewalk(mut self, input: crate::model::SidewalkSendDataToDevice) -> Self {
            self.sidewalk = Some(input);
            self
        }
        /// <p>The Sidewalk account credentials.</p>
        pub fn set_sidewalk(
            mut self,
            input: std::option::Option<crate::model::SidewalkSendDataToDevice>,
        ) -> Self {
            self.sidewalk = input;
            self
        }
        /// Consumes the builder and constructs a [`WirelessMetadata`](crate::model::WirelessMetadata).
        pub fn build(self) -> crate::model::WirelessMetadata {
            crate::model::WirelessMetadata {
                lo_ra_wan: self.lo_ra_wan,
                sidewalk: self.sidewalk,
            }
        }
    }
}

/// <p>Information about a Sidewalk router.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SidewalkSendDataToDevice {
    /// <p>The sequence number.</p>
    #[doc(hidden)]
    pub seq: std::option::Option<i32>,
    /// <p>Sidewalk device message type. Default value is <code>CUSTOM_COMMAND_ID_NOTIFY</code>.</p>
    #[doc(hidden)]
    pub message_type: std::option::Option<crate::model::MessageType>,
    /// <p>The duration of time in seconds to retry sending the ACK.</p>
    #[doc(hidden)]
    pub ack_mode_retry_duration_secs: std::option::Option<i32>,
}
impl SidewalkSendDataToDevice {
    /// <p>The sequence number.</p>
    pub fn seq(&self) -> std::option::Option<i32> {
        self.seq
    }
    /// <p>Sidewalk device message type. Default value is <code>CUSTOM_COMMAND_ID_NOTIFY</code>.</p>
    pub fn message_type(&self) -> std::option::Option<&crate::model::MessageType> {
        self.message_type.as_ref()
    }
    /// <p>The duration of time in seconds to retry sending the ACK.</p>
    pub fn ack_mode_retry_duration_secs(&self) -> std::option::Option<i32> {
        self.ack_mode_retry_duration_secs
    }
}
impl SidewalkSendDataToDevice {
    /// Creates a new builder-style object to manufacture [`SidewalkSendDataToDevice`](crate::model::SidewalkSendDataToDevice).
    pub fn builder() -> crate::model::sidewalk_send_data_to_device::Builder {
        crate::model::sidewalk_send_data_to_device::Builder::default()
    }
}

/// See [`SidewalkSendDataToDevice`](crate::model::SidewalkSendDataToDevice).
pub mod sidewalk_send_data_to_device {

    /// A builder for [`SidewalkSendDataToDevice`](crate::model::SidewalkSendDataToDevice).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) seq: std::option::Option<i32>,
        pub(crate) message_type: std::option::Option<crate::model::MessageType>,
        pub(crate) ack_mode_retry_duration_secs: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The sequence number.</p>
        pub fn seq(mut self, input: i32) -> Self {
            self.seq = Some(input);
            self
        }
        /// <p>The sequence number.</p>
        pub fn set_seq(mut self, input: std::option::Option<i32>) -> Self {
            self.seq = input;
            self
        }
        /// <p>Sidewalk device message type. Default value is <code>CUSTOM_COMMAND_ID_NOTIFY</code>.</p>
        pub fn message_type(mut self, input: crate::model::MessageType) -> Self {
            self.message_type = Some(input);
            self
        }
        /// <p>Sidewalk device message type. Default value is <code>CUSTOM_COMMAND_ID_NOTIFY</code>.</p>
        pub fn set_message_type(
            mut self,
            input: std::option::Option<crate::model::MessageType>,
        ) -> Self {
            self.message_type = input;
            self
        }
        /// <p>The duration of time in seconds to retry sending the ACK.</p>
        pub fn ack_mode_retry_duration_secs(mut self, input: i32) -> Self {
            self.ack_mode_retry_duration_secs = Some(input);
            self
        }
        /// <p>The duration of time in seconds to retry sending the ACK.</p>
        pub fn set_ack_mode_retry_duration_secs(mut self, input: std::option::Option<i32>) -> Self {
            self.ack_mode_retry_duration_secs = input;
            self
        }
        /// Consumes the builder and constructs a [`SidewalkSendDataToDevice`](crate::model::SidewalkSendDataToDevice).
        pub fn build(self) -> crate::model::SidewalkSendDataToDevice {
            crate::model::SidewalkSendDataToDevice {
                seq: self.seq,
                message_type: self.message_type,
                ack_mode_retry_duration_secs: self.ack_mode_retry_duration_secs,
            }
        }
    }
}

/// When writing a match expression against `MessageType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let messagetype = unimplemented!();
/// match messagetype {
///     MessageType::CustomCommandIdGet => { /* ... */ },
///     MessageType::CustomCommandIdNotify => { /* ... */ },
///     MessageType::CustomCommandIdResp => { /* ... */ },
///     MessageType::CustomCommandIdSet => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `messagetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `MessageType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `MessageType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `MessageType::NewFeature` is defined.
/// Specifically, when `messagetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `MessageType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Sidewalk device message type. Default value is <code>CUSTOM_COMMAND_ID_NOTIFY</code>.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum MessageType {
    #[allow(missing_docs)] // documentation missing in model
    CustomCommandIdGet,
    #[allow(missing_docs)] // documentation missing in model
    CustomCommandIdNotify,
    #[allow(missing_docs)] // documentation missing in model
    CustomCommandIdResp,
    #[allow(missing_docs)] // documentation missing in model
    CustomCommandIdSet,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for MessageType {
    fn from(s: &str) -> Self {
        match s {
            "CUSTOM_COMMAND_ID_GET" => MessageType::CustomCommandIdGet,
            "CUSTOM_COMMAND_ID_NOTIFY" => MessageType::CustomCommandIdNotify,
            "CUSTOM_COMMAND_ID_RESP" => MessageType::CustomCommandIdResp,
            "CUSTOM_COMMAND_ID_SET" => MessageType::CustomCommandIdSet,
            other => MessageType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for MessageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(MessageType::from(s))
    }
}
impl MessageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            MessageType::CustomCommandIdGet => "CUSTOM_COMMAND_ID_GET",
            MessageType::CustomCommandIdNotify => "CUSTOM_COMMAND_ID_NOTIFY",
            MessageType::CustomCommandIdResp => "CUSTOM_COMMAND_ID_RESP",
            MessageType::CustomCommandIdSet => "CUSTOM_COMMAND_ID_SET",
            MessageType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "CUSTOM_COMMAND_ID_GET",
            "CUSTOM_COMMAND_ID_NOTIFY",
            "CUSTOM_COMMAND_ID_RESP",
            "CUSTOM_COMMAND_ID_SET",
        ]
    }
}
impl AsRef<str> for MessageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>LoRaWAN router info.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanSendDataToDevice {
    /// <p>The Fport value.</p>
    #[doc(hidden)]
    pub f_port: std::option::Option<i32>,
    /// <p>Choose the gateways that you want to use for the downlink data traffic when the wireless device is running in class B or class C mode.</p>
    #[doc(hidden)]
    pub participating_gateways: std::option::Option<crate::model::ParticipatingGateways>,
}
impl LoRaWanSendDataToDevice {
    /// <p>The Fport value.</p>
    pub fn f_port(&self) -> std::option::Option<i32> {
        self.f_port
    }
    /// <p>Choose the gateways that you want to use for the downlink data traffic when the wireless device is running in class B or class C mode.</p>
    pub fn participating_gateways(
        &self,
    ) -> std::option::Option<&crate::model::ParticipatingGateways> {
        self.participating_gateways.as_ref()
    }
}
impl LoRaWanSendDataToDevice {
    /// Creates a new builder-style object to manufacture [`LoRaWanSendDataToDevice`](crate::model::LoRaWanSendDataToDevice).
    pub fn builder() -> crate::model::lo_ra_wan_send_data_to_device::Builder {
        crate::model::lo_ra_wan_send_data_to_device::Builder::default()
    }
}

/// See [`LoRaWanSendDataToDevice`](crate::model::LoRaWanSendDataToDevice).
pub mod lo_ra_wan_send_data_to_device {

    /// A builder for [`LoRaWanSendDataToDevice`](crate::model::LoRaWanSendDataToDevice).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) f_port: std::option::Option<i32>,
        pub(crate) participating_gateways: std::option::Option<crate::model::ParticipatingGateways>,
    }
    impl Builder {
        /// <p>The Fport value.</p>
        pub fn f_port(mut self, input: i32) -> Self {
            self.f_port = Some(input);
            self
        }
        /// <p>The Fport value.</p>
        pub fn set_f_port(mut self, input: std::option::Option<i32>) -> Self {
            self.f_port = input;
            self
        }
        /// <p>Choose the gateways that you want to use for the downlink data traffic when the wireless device is running in class B or class C mode.</p>
        pub fn participating_gateways(
            mut self,
            input: crate::model::ParticipatingGateways,
        ) -> Self {
            self.participating_gateways = Some(input);
            self
        }
        /// <p>Choose the gateways that you want to use for the downlink data traffic when the wireless device is running in class B or class C mode.</p>
        pub fn set_participating_gateways(
            mut self,
            input: std::option::Option<crate::model::ParticipatingGateways>,
        ) -> Self {
            self.participating_gateways = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanSendDataToDevice`](crate::model::LoRaWanSendDataToDevice).
        pub fn build(self) -> crate::model::LoRaWanSendDataToDevice {
            crate::model::LoRaWanSendDataToDevice {
                f_port: self.f_port,
                participating_gateways: self.participating_gateways,
            }
        }
    }
}

/// <p>Specify the list of gateways to which you want to send downlink data traffic when the wireless device is running in class B or class C mode.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParticipatingGateways {
    /// <p>Indicates whether to send the downlink message in sequential mode or concurrent mode, or to use only the chosen gateways from the previous uplink message transmission.</p>
    #[doc(hidden)]
    pub downlink_mode: std::option::Option<crate::model::DownlinkMode>,
    /// <p>The list of gateways that you want to use for sending the downlink data traffic.</p>
    #[doc(hidden)]
    pub gateway_list: std::option::Option<std::vec::Vec<crate::model::GatewayListItem>>,
    /// <p>The duration of time for which AWS IoT Core for LoRaWAN will wait before transmitting the payload to the next gateway.</p>
    #[doc(hidden)]
    pub transmission_interval: std::option::Option<i32>,
}
impl ParticipatingGateways {
    /// <p>Indicates whether to send the downlink message in sequential mode or concurrent mode, or to use only the chosen gateways from the previous uplink message transmission.</p>
    pub fn downlink_mode(&self) -> std::option::Option<&crate::model::DownlinkMode> {
        self.downlink_mode.as_ref()
    }
    /// <p>The list of gateways that you want to use for sending the downlink data traffic.</p>
    pub fn gateway_list(&self) -> std::option::Option<&[crate::model::GatewayListItem]> {
        self.gateway_list.as_deref()
    }
    /// <p>The duration of time for which AWS IoT Core for LoRaWAN will wait before transmitting the payload to the next gateway.</p>
    pub fn transmission_interval(&self) -> std::option::Option<i32> {
        self.transmission_interval
    }
}
impl ParticipatingGateways {
    /// Creates a new builder-style object to manufacture [`ParticipatingGateways`](crate::model::ParticipatingGateways).
    pub fn builder() -> crate::model::participating_gateways::Builder {
        crate::model::participating_gateways::Builder::default()
    }
}

/// See [`ParticipatingGateways`](crate::model::ParticipatingGateways).
pub mod participating_gateways {

    /// A builder for [`ParticipatingGateways`](crate::model::ParticipatingGateways).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) downlink_mode: std::option::Option<crate::model::DownlinkMode>,
        pub(crate) gateway_list: std::option::Option<std::vec::Vec<crate::model::GatewayListItem>>,
        pub(crate) transmission_interval: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Indicates whether to send the downlink message in sequential mode or concurrent mode, or to use only the chosen gateways from the previous uplink message transmission.</p>
        pub fn downlink_mode(mut self, input: crate::model::DownlinkMode) -> Self {
            self.downlink_mode = Some(input);
            self
        }
        /// <p>Indicates whether to send the downlink message in sequential mode or concurrent mode, or to use only the chosen gateways from the previous uplink message transmission.</p>
        pub fn set_downlink_mode(
            mut self,
            input: std::option::Option<crate::model::DownlinkMode>,
        ) -> Self {
            self.downlink_mode = input;
            self
        }
        /// Appends an item to `gateway_list`.
        ///
        /// To override the contents of this collection use [`set_gateway_list`](Self::set_gateway_list).
        ///
        /// <p>The list of gateways that you want to use for sending the downlink data traffic.</p>
        pub fn gateway_list(mut self, input: crate::model::GatewayListItem) -> Self {
            let mut v = self.gateway_list.unwrap_or_default();
            v.push(input);
            self.gateway_list = Some(v);
            self
        }
        /// <p>The list of gateways that you want to use for sending the downlink data traffic.</p>
        pub fn set_gateway_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GatewayListItem>>,
        ) -> Self {
            self.gateway_list = input;
            self
        }
        /// <p>The duration of time for which AWS IoT Core for LoRaWAN will wait before transmitting the payload to the next gateway.</p>
        pub fn transmission_interval(mut self, input: i32) -> Self {
            self.transmission_interval = Some(input);
            self
        }
        /// <p>The duration of time for which AWS IoT Core for LoRaWAN will wait before transmitting the payload to the next gateway.</p>
        pub fn set_transmission_interval(mut self, input: std::option::Option<i32>) -> Self {
            self.transmission_interval = input;
            self
        }
        /// Consumes the builder and constructs a [`ParticipatingGateways`](crate::model::ParticipatingGateways).
        pub fn build(self) -> crate::model::ParticipatingGateways {
            crate::model::ParticipatingGateways {
                downlink_mode: self.downlink_mode,
                gateway_list: self.gateway_list,
                transmission_interval: self.transmission_interval,
            }
        }
    }
}

/// <p>Gateway list item object that specifies the frequency and list of gateways for which the downlink message should be sent.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GatewayListItem {
    /// <p>The ID of the wireless gateways that you want to add to the list of gateways when sending downlink messages.</p>
    #[doc(hidden)]
    pub gateway_id: std::option::Option<std::string::String>,
    /// <p>The frequency to use for the gateways when sending a downlink message to the wireless device.</p>
    #[doc(hidden)]
    pub downlink_frequency: std::option::Option<i32>,
}
impl GatewayListItem {
    /// <p>The ID of the wireless gateways that you want to add to the list of gateways when sending downlink messages.</p>
    pub fn gateway_id(&self) -> std::option::Option<&str> {
        self.gateway_id.as_deref()
    }
    /// <p>The frequency to use for the gateways when sending a downlink message to the wireless device.</p>
    pub fn downlink_frequency(&self) -> std::option::Option<i32> {
        self.downlink_frequency
    }
}
impl GatewayListItem {
    /// Creates a new builder-style object to manufacture [`GatewayListItem`](crate::model::GatewayListItem).
    pub fn builder() -> crate::model::gateway_list_item::Builder {
        crate::model::gateway_list_item::Builder::default()
    }
}

/// See [`GatewayListItem`](crate::model::GatewayListItem).
pub mod gateway_list_item {

    /// A builder for [`GatewayListItem`](crate::model::GatewayListItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_id: std::option::Option<std::string::String>,
        pub(crate) downlink_frequency: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ID of the wireless gateways that you want to add to the list of gateways when sending downlink messages.</p>
        pub fn gateway_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_id = Some(input.into());
            self
        }
        /// <p>The ID of the wireless gateways that you want to add to the list of gateways when sending downlink messages.</p>
        pub fn set_gateway_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_id = input;
            self
        }
        /// <p>The frequency to use for the gateways when sending a downlink message to the wireless device.</p>
        pub fn downlink_frequency(mut self, input: i32) -> Self {
            self.downlink_frequency = Some(input);
            self
        }
        /// <p>The frequency to use for the gateways when sending a downlink message to the wireless device.</p>
        pub fn set_downlink_frequency(mut self, input: std::option::Option<i32>) -> Self {
            self.downlink_frequency = input;
            self
        }
        /// Consumes the builder and constructs a [`GatewayListItem`](crate::model::GatewayListItem).
        pub fn build(self) -> crate::model::GatewayListItem {
            crate::model::GatewayListItem {
                gateway_id: self.gateway_id,
                downlink_frequency: self.downlink_frequency,
            }
        }
    }
}

/// When writing a match expression against `DownlinkMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let downlinkmode = unimplemented!();
/// match downlinkmode {
///     DownlinkMode::Concurrent => { /* ... */ },
///     DownlinkMode::Sequential => { /* ... */ },
///     DownlinkMode::UsingUplinkGateway => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `downlinkmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DownlinkMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DownlinkMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DownlinkMode::NewFeature` is defined.
/// Specifically, when `downlinkmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DownlinkMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DownlinkMode {
    #[allow(missing_docs)] // documentation missing in model
    Concurrent,
    #[allow(missing_docs)] // documentation missing in model
    Sequential,
    #[allow(missing_docs)] // documentation missing in model
    UsingUplinkGateway,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DownlinkMode {
    fn from(s: &str) -> Self {
        match s {
            "CONCURRENT" => DownlinkMode::Concurrent,
            "SEQUENTIAL" => DownlinkMode::Sequential,
            "USING_UPLINK_GATEWAY" => DownlinkMode::UsingUplinkGateway,
            other => DownlinkMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DownlinkMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DownlinkMode::from(s))
    }
}
impl DownlinkMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DownlinkMode::Concurrent => "CONCURRENT",
            DownlinkMode::Sequential => "SEQUENTIAL",
            DownlinkMode::UsingUplinkGateway => "USING_UPLINK_GATEWAY",
            DownlinkMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONCURRENT", "SEQUENTIAL", "USING_UPLINK_GATEWAY"]
    }
}
impl AsRef<str> for DownlinkMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Wireless metadata that is to be sent to multicast group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MulticastWirelessMetadata {
    /// <p>The metadata information of the LoRaWAN multicast group.</p>
    #[doc(hidden)]
    pub lo_ra_wan: std::option::Option<crate::model::LoRaWanMulticastMetadata>,
}
impl MulticastWirelessMetadata {
    /// <p>The metadata information of the LoRaWAN multicast group.</p>
    pub fn lo_ra_wan(&self) -> std::option::Option<&crate::model::LoRaWanMulticastMetadata> {
        self.lo_ra_wan.as_ref()
    }
}
impl MulticastWirelessMetadata {
    /// Creates a new builder-style object to manufacture [`MulticastWirelessMetadata`](crate::model::MulticastWirelessMetadata).
    pub fn builder() -> crate::model::multicast_wireless_metadata::Builder {
        crate::model::multicast_wireless_metadata::Builder::default()
    }
}

/// See [`MulticastWirelessMetadata`](crate::model::MulticastWirelessMetadata).
pub mod multicast_wireless_metadata {

    /// A builder for [`MulticastWirelessMetadata`](crate::model::MulticastWirelessMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lo_ra_wan: std::option::Option<crate::model::LoRaWanMulticastMetadata>,
    }
    impl Builder {
        /// <p>The metadata information of the LoRaWAN multicast group.</p>
        pub fn lo_ra_wan(mut self, input: crate::model::LoRaWanMulticastMetadata) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>The metadata information of the LoRaWAN multicast group.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<crate::model::LoRaWanMulticastMetadata>,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// Consumes the builder and constructs a [`MulticastWirelessMetadata`](crate::model::MulticastWirelessMetadata).
        pub fn build(self) -> crate::model::MulticastWirelessMetadata {
            crate::model::MulticastWirelessMetadata {
                lo_ra_wan: self.lo_ra_wan,
            }
        }
    }
}

/// <p>The metadata information of the LoRaWAN multicast group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanMulticastMetadata {
    /// <p>The Fport value.</p>
    #[doc(hidden)]
    pub f_port: std::option::Option<i32>,
}
impl LoRaWanMulticastMetadata {
    /// <p>The Fport value.</p>
    pub fn f_port(&self) -> std::option::Option<i32> {
        self.f_port
    }
}
impl LoRaWanMulticastMetadata {
    /// Creates a new builder-style object to manufacture [`LoRaWanMulticastMetadata`](crate::model::LoRaWanMulticastMetadata).
    pub fn builder() -> crate::model::lo_ra_wan_multicast_metadata::Builder {
        crate::model::lo_ra_wan_multicast_metadata::Builder::default()
    }
}

/// See [`LoRaWanMulticastMetadata`](crate::model::LoRaWanMulticastMetadata).
pub mod lo_ra_wan_multicast_metadata {

    /// A builder for [`LoRaWanMulticastMetadata`](crate::model::LoRaWanMulticastMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) f_port: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Fport value.</p>
        pub fn f_port(mut self, input: i32) -> Self {
            self.f_port = Some(input);
            self
        }
        /// <p>The Fport value.</p>
        pub fn set_f_port(mut self, input: std::option::Option<i32>) -> Self {
            self.f_port = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanMulticastMetadata`](crate::model::LoRaWanMulticastMetadata).
        pub fn build(self) -> crate::model::LoRaWanMulticastMetadata {
            crate::model::LoRaWanMulticastMetadata {
                f_port: self.f_port,
            }
        }
    }
}

/// <p>The wrapper for position solver configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PositionSolverConfigurations {
    /// <p>The Semtech GNSS solver configuration object.</p>
    #[doc(hidden)]
    pub semtech_gnss: std::option::Option<crate::model::SemtechGnssConfiguration>,
}
impl PositionSolverConfigurations {
    /// <p>The Semtech GNSS solver configuration object.</p>
    pub fn semtech_gnss(&self) -> std::option::Option<&crate::model::SemtechGnssConfiguration> {
        self.semtech_gnss.as_ref()
    }
}
impl PositionSolverConfigurations {
    /// Creates a new builder-style object to manufacture [`PositionSolverConfigurations`](crate::model::PositionSolverConfigurations).
    pub fn builder() -> crate::model::position_solver_configurations::Builder {
        crate::model::position_solver_configurations::Builder::default()
    }
}

/// See [`PositionSolverConfigurations`](crate::model::PositionSolverConfigurations).
pub mod position_solver_configurations {

    /// A builder for [`PositionSolverConfigurations`](crate::model::PositionSolverConfigurations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) semtech_gnss: std::option::Option<crate::model::SemtechGnssConfiguration>,
    }
    impl Builder {
        /// <p>The Semtech GNSS solver configuration object.</p>
        pub fn semtech_gnss(mut self, input: crate::model::SemtechGnssConfiguration) -> Self {
            self.semtech_gnss = Some(input);
            self
        }
        /// <p>The Semtech GNSS solver configuration object.</p>
        pub fn set_semtech_gnss(
            mut self,
            input: std::option::Option<crate::model::SemtechGnssConfiguration>,
        ) -> Self {
            self.semtech_gnss = input;
            self
        }
        /// Consumes the builder and constructs a [`PositionSolverConfigurations`](crate::model::PositionSolverConfigurations).
        pub fn build(self) -> crate::model::PositionSolverConfigurations {
            crate::model::PositionSolverConfigurations {
                semtech_gnss: self.semtech_gnss,
            }
        }
    }
}

/// <p>Information about the Semtech GNSS solver configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SemtechGnssConfiguration {
    /// <p>The status indicating whether the solver is enabled.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::PositionConfigurationStatus>,
    /// <p>Whether forward error correction is enabled.</p>
    #[doc(hidden)]
    pub fec: std::option::Option<crate::model::PositionConfigurationFec>,
}
impl SemtechGnssConfiguration {
    /// <p>The status indicating whether the solver is enabled.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::PositionConfigurationStatus> {
        self.status.as_ref()
    }
    /// <p>Whether forward error correction is enabled.</p>
    pub fn fec(&self) -> std::option::Option<&crate::model::PositionConfigurationFec> {
        self.fec.as_ref()
    }
}
impl SemtechGnssConfiguration {
    /// Creates a new builder-style object to manufacture [`SemtechGnssConfiguration`](crate::model::SemtechGnssConfiguration).
    pub fn builder() -> crate::model::semtech_gnss_configuration::Builder {
        crate::model::semtech_gnss_configuration::Builder::default()
    }
}

/// See [`SemtechGnssConfiguration`](crate::model::SemtechGnssConfiguration).
pub mod semtech_gnss_configuration {

    /// A builder for [`SemtechGnssConfiguration`](crate::model::SemtechGnssConfiguration).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::PositionConfigurationStatus>,
        pub(crate) fec: std::option::Option<crate::model::PositionConfigurationFec>,
    }
    impl Builder {
        /// <p>The status indicating whether the solver is enabled.</p>
        pub fn status(mut self, input: crate::model::PositionConfigurationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status indicating whether the solver is enabled.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PositionConfigurationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Whether forward error correction is enabled.</p>
        pub fn fec(mut self, input: crate::model::PositionConfigurationFec) -> Self {
            self.fec = Some(input);
            self
        }
        /// <p>Whether forward error correction is enabled.</p>
        pub fn set_fec(
            mut self,
            input: std::option::Option<crate::model::PositionConfigurationFec>,
        ) -> Self {
            self.fec = input;
            self
        }
        /// Consumes the builder and constructs a [`SemtechGnssConfiguration`](crate::model::SemtechGnssConfiguration).
        pub fn build(self) -> crate::model::SemtechGnssConfiguration {
            crate::model::SemtechGnssConfiguration {
                status: self.status,
                fec: self.fec,
            }
        }
    }
}

/// When writing a match expression against `PositionConfigurationFec`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let positionconfigurationfec = unimplemented!();
/// match positionconfigurationfec {
///     PositionConfigurationFec::None => { /* ... */ },
///     PositionConfigurationFec::Rose => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `positionconfigurationfec` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PositionConfigurationFec::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PositionConfigurationFec::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PositionConfigurationFec::NewFeature` is defined.
/// Specifically, when `positionconfigurationfec` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PositionConfigurationFec::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PositionConfigurationFec {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Rose,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PositionConfigurationFec {
    fn from(s: &str) -> Self {
        match s {
            "NONE" => PositionConfigurationFec::None,
            "ROSE" => PositionConfigurationFec::Rose,
            other => PositionConfigurationFec::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PositionConfigurationFec {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PositionConfigurationFec::from(s))
    }
}
impl PositionConfigurationFec {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PositionConfigurationFec::None => "NONE",
            PositionConfigurationFec::Rose => "ROSE",
            PositionConfigurationFec::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["NONE", "ROSE"]
    }
}
impl AsRef<str> for PositionConfigurationFec {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PositionConfigurationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let positionconfigurationstatus = unimplemented!();
/// match positionconfigurationstatus {
///     PositionConfigurationStatus::Disabled => { /* ... */ },
///     PositionConfigurationStatus::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `positionconfigurationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PositionConfigurationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PositionConfigurationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PositionConfigurationStatus::NewFeature` is defined.
/// Specifically, when `positionconfigurationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PositionConfigurationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PositionConfigurationStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PositionConfigurationStatus {
    fn from(s: &str) -> Self {
        match s {
            "Disabled" => PositionConfigurationStatus::Disabled,
            "Enabled" => PositionConfigurationStatus::Enabled,
            other => PositionConfigurationStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for PositionConfigurationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PositionConfigurationStatus::from(s))
    }
}
impl PositionConfigurationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PositionConfigurationStatus::Disabled => "Disabled",
            PositionConfigurationStatus::Enabled => "Enabled",
            PositionConfigurationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Disabled", "Enabled"]
    }
}
impl AsRef<str> for PositionConfigurationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>UpdateWirelessGatewayTaskEntry object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateWirelessGatewayTaskEntry {
    /// <p>The ID of the new wireless gateway task entry.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The properties that relate to the LoRaWAN wireless gateway.</p>
    #[doc(hidden)]
    pub lo_ra_wan: std::option::Option<crate::model::LoRaWanUpdateGatewayTaskEntry>,
    /// <p>The Amazon Resource Name of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl UpdateWirelessGatewayTaskEntry {
    /// <p>The ID of the new wireless gateway task entry.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The properties that relate to the LoRaWAN wireless gateway.</p>
    pub fn lo_ra_wan(&self) -> std::option::Option<&crate::model::LoRaWanUpdateGatewayTaskEntry> {
        self.lo_ra_wan.as_ref()
    }
    /// <p>The Amazon Resource Name of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl UpdateWirelessGatewayTaskEntry {
    /// Creates a new builder-style object to manufacture [`UpdateWirelessGatewayTaskEntry`](crate::model::UpdateWirelessGatewayTaskEntry).
    pub fn builder() -> crate::model::update_wireless_gateway_task_entry::Builder {
        crate::model::update_wireless_gateway_task_entry::Builder::default()
    }
}

/// See [`UpdateWirelessGatewayTaskEntry`](crate::model::UpdateWirelessGatewayTaskEntry).
pub mod update_wireless_gateway_task_entry {

    /// A builder for [`UpdateWirelessGatewayTaskEntry`](crate::model::UpdateWirelessGatewayTaskEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) lo_ra_wan: std::option::Option<crate::model::LoRaWanUpdateGatewayTaskEntry>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the new wireless gateway task entry.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the new wireless gateway task entry.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The properties that relate to the LoRaWAN wireless gateway.</p>
        pub fn lo_ra_wan(mut self, input: crate::model::LoRaWanUpdateGatewayTaskEntry) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>The properties that relate to the LoRaWAN wireless gateway.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<crate::model::LoRaWanUpdateGatewayTaskEntry>,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateWirelessGatewayTaskEntry`](crate::model::UpdateWirelessGatewayTaskEntry).
        pub fn build(self) -> crate::model::UpdateWirelessGatewayTaskEntry {
            crate::model::UpdateWirelessGatewayTaskEntry {
                id: self.id,
                lo_ra_wan: self.lo_ra_wan,
                arn: self.arn,
            }
        }
    }
}

/// <p>LoRaWANUpdateGatewayTaskEntry object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanUpdateGatewayTaskEntry {
    /// <p>The version of the gateways that should receive the update.</p>
    #[doc(hidden)]
    pub current_version: std::option::Option<crate::model::LoRaWanGatewayVersion>,
    /// <p>The firmware version to update the gateway to.</p>
    #[doc(hidden)]
    pub update_version: std::option::Option<crate::model::LoRaWanGatewayVersion>,
}
impl LoRaWanUpdateGatewayTaskEntry {
    /// <p>The version of the gateways that should receive the update.</p>
    pub fn current_version(&self) -> std::option::Option<&crate::model::LoRaWanGatewayVersion> {
        self.current_version.as_ref()
    }
    /// <p>The firmware version to update the gateway to.</p>
    pub fn update_version(&self) -> std::option::Option<&crate::model::LoRaWanGatewayVersion> {
        self.update_version.as_ref()
    }
}
impl LoRaWanUpdateGatewayTaskEntry {
    /// Creates a new builder-style object to manufacture [`LoRaWanUpdateGatewayTaskEntry`](crate::model::LoRaWanUpdateGatewayTaskEntry).
    pub fn builder() -> crate::model::lo_ra_wan_update_gateway_task_entry::Builder {
        crate::model::lo_ra_wan_update_gateway_task_entry::Builder::default()
    }
}

/// See [`LoRaWanUpdateGatewayTaskEntry`](crate::model::LoRaWanUpdateGatewayTaskEntry).
pub mod lo_ra_wan_update_gateway_task_entry {

    /// A builder for [`LoRaWanUpdateGatewayTaskEntry`](crate::model::LoRaWanUpdateGatewayTaskEntry).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) current_version: std::option::Option<crate::model::LoRaWanGatewayVersion>,
        pub(crate) update_version: std::option::Option<crate::model::LoRaWanGatewayVersion>,
    }
    impl Builder {
        /// <p>The version of the gateways that should receive the update.</p>
        pub fn current_version(mut self, input: crate::model::LoRaWanGatewayVersion) -> Self {
            self.current_version = Some(input);
            self
        }
        /// <p>The version of the gateways that should receive the update.</p>
        pub fn set_current_version(
            mut self,
            input: std::option::Option<crate::model::LoRaWanGatewayVersion>,
        ) -> Self {
            self.current_version = input;
            self
        }
        /// <p>The firmware version to update the gateway to.</p>
        pub fn update_version(mut self, input: crate::model::LoRaWanGatewayVersion) -> Self {
            self.update_version = Some(input);
            self
        }
        /// <p>The firmware version to update the gateway to.</p>
        pub fn set_update_version(
            mut self,
            input: std::option::Option<crate::model::LoRaWanGatewayVersion>,
        ) -> Self {
            self.update_version = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanUpdateGatewayTaskEntry`](crate::model::LoRaWanUpdateGatewayTaskEntry).
        pub fn build(self) -> crate::model::LoRaWanUpdateGatewayTaskEntry {
            crate::model::LoRaWanUpdateGatewayTaskEntry {
                current_version: self.current_version,
                update_version: self.update_version,
            }
        }
    }
}

/// <p>LoRaWANGatewayVersion object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanGatewayVersion {
    /// <p>The version of the wireless gateway firmware.</p>
    #[doc(hidden)]
    pub package_version: std::option::Option<std::string::String>,
    /// <p>The model number of the wireless gateway.</p>
    #[doc(hidden)]
    pub model: std::option::Option<std::string::String>,
    /// <p>The basic station version of the wireless gateway.</p>
    #[doc(hidden)]
    pub station: std::option::Option<std::string::String>,
}
impl LoRaWanGatewayVersion {
    /// <p>The version of the wireless gateway firmware.</p>
    pub fn package_version(&self) -> std::option::Option<&str> {
        self.package_version.as_deref()
    }
    /// <p>The model number of the wireless gateway.</p>
    pub fn model(&self) -> std::option::Option<&str> {
        self.model.as_deref()
    }
    /// <p>The basic station version of the wireless gateway.</p>
    pub fn station(&self) -> std::option::Option<&str> {
        self.station.as_deref()
    }
}
impl LoRaWanGatewayVersion {
    /// Creates a new builder-style object to manufacture [`LoRaWanGatewayVersion`](crate::model::LoRaWanGatewayVersion).
    pub fn builder() -> crate::model::lo_ra_wan_gateway_version::Builder {
        crate::model::lo_ra_wan_gateway_version::Builder::default()
    }
}

/// See [`LoRaWanGatewayVersion`](crate::model::LoRaWanGatewayVersion).
pub mod lo_ra_wan_gateway_version {

    /// A builder for [`LoRaWanGatewayVersion`](crate::model::LoRaWanGatewayVersion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) package_version: std::option::Option<std::string::String>,
        pub(crate) model: std::option::Option<std::string::String>,
        pub(crate) station: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The version of the wireless gateway firmware.</p>
        pub fn package_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.package_version = Some(input.into());
            self
        }
        /// <p>The version of the wireless gateway firmware.</p>
        pub fn set_package_version(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.package_version = input;
            self
        }
        /// <p>The model number of the wireless gateway.</p>
        pub fn model(mut self, input: impl Into<std::string::String>) -> Self {
            self.model = Some(input.into());
            self
        }
        /// <p>The model number of the wireless gateway.</p>
        pub fn set_model(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.model = input;
            self
        }
        /// <p>The basic station version of the wireless gateway.</p>
        pub fn station(mut self, input: impl Into<std::string::String>) -> Self {
            self.station = Some(input.into());
            self
        }
        /// <p>The basic station version of the wireless gateway.</p>
        pub fn set_station(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.station = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanGatewayVersion`](crate::model::LoRaWanGatewayVersion).
        pub fn build(self) -> crate::model::LoRaWanGatewayVersion {
            crate::model::LoRaWanGatewayVersion {
                package_version: self.package_version,
                model: self.model,
                station: self.station,
            }
        }
    }
}

/// When writing a match expression against `WirelessGatewayTaskDefinitionType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wirelessgatewaytaskdefinitiontype = unimplemented!();
/// match wirelessgatewaytaskdefinitiontype {
///     WirelessGatewayTaskDefinitionType::Update => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wirelessgatewaytaskdefinitiontype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WirelessGatewayTaskDefinitionType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WirelessGatewayTaskDefinitionType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WirelessGatewayTaskDefinitionType::NewFeature` is defined.
/// Specifically, when `wirelessgatewaytaskdefinitiontype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WirelessGatewayTaskDefinitionType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WirelessGatewayTaskDefinitionType {
    #[allow(missing_docs)] // documentation missing in model
    Update,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WirelessGatewayTaskDefinitionType {
    fn from(s: &str) -> Self {
        match s {
            "UPDATE" => WirelessGatewayTaskDefinitionType::Update,
            other => WirelessGatewayTaskDefinitionType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for WirelessGatewayTaskDefinitionType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WirelessGatewayTaskDefinitionType::from(s))
    }
}
impl WirelessGatewayTaskDefinitionType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WirelessGatewayTaskDefinitionType::Update => "UPDATE",
            WirelessGatewayTaskDefinitionType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["UPDATE"]
    }
}
impl AsRef<str> for WirelessGatewayTaskDefinitionType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a wireless gateway's operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WirelessGatewayStatistics {
    /// <p>The Amazon Resource Name of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the wireless gateway reporting the data.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The name of the resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the resource.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>LoRaWAN gateway info.</p>
    #[doc(hidden)]
    pub lo_ra_wan: std::option::Option<crate::model::LoRaWanGateway>,
    /// <p>The date and time when the most recent uplink was received.</p>
    #[doc(hidden)]
    pub last_uplink_received_at: std::option::Option<std::string::String>,
}
impl WirelessGatewayStatistics {
    /// <p>The Amazon Resource Name of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the wireless gateway reporting the data.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The name of the resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the resource.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>LoRaWAN gateway info.</p>
    pub fn lo_ra_wan(&self) -> std::option::Option<&crate::model::LoRaWanGateway> {
        self.lo_ra_wan.as_ref()
    }
    /// <p>The date and time when the most recent uplink was received.</p>
    pub fn last_uplink_received_at(&self) -> std::option::Option<&str> {
        self.last_uplink_received_at.as_deref()
    }
}
impl WirelessGatewayStatistics {
    /// Creates a new builder-style object to manufacture [`WirelessGatewayStatistics`](crate::model::WirelessGatewayStatistics).
    pub fn builder() -> crate::model::wireless_gateway_statistics::Builder {
        crate::model::wireless_gateway_statistics::Builder::default()
    }
}

/// See [`WirelessGatewayStatistics`](crate::model::WirelessGatewayStatistics).
pub mod wireless_gateway_statistics {

    /// A builder for [`WirelessGatewayStatistics`](crate::model::WirelessGatewayStatistics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) lo_ra_wan: std::option::Option<crate::model::LoRaWanGateway>,
        pub(crate) last_uplink_received_at: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the wireless gateway reporting the data.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the wireless gateway reporting the data.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The name of the resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the resource.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>LoRaWAN gateway info.</p>
        pub fn lo_ra_wan(mut self, input: crate::model::LoRaWanGateway) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>LoRaWAN gateway info.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<crate::model::LoRaWanGateway>,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// <p>The date and time when the most recent uplink was received.</p>
        pub fn last_uplink_received_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_uplink_received_at = Some(input.into());
            self
        }
        /// <p>The date and time when the most recent uplink was received.</p>
        pub fn set_last_uplink_received_at(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_uplink_received_at = input;
            self
        }
        /// Consumes the builder and constructs a [`WirelessGatewayStatistics`](crate::model::WirelessGatewayStatistics).
        pub fn build(self) -> crate::model::WirelessGatewayStatistics {
            crate::model::WirelessGatewayStatistics {
                arn: self.arn,
                id: self.id,
                name: self.name,
                description: self.description,
                lo_ra_wan: self.lo_ra_wan,
                last_uplink_received_at: self.last_uplink_received_at,
            }
        }
    }
}

/// <p>LoRaWANGateway object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanGateway {
    /// <p>The gateway's EUI value.</p>
    #[doc(hidden)]
    pub gateway_eui: std::option::Option<std::string::String>,
    /// <p>The frequency band (RFRegion) value.</p>
    #[doc(hidden)]
    pub rf_region: std::option::Option<std::string::String>,
    /// <p>A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.</p>
    #[doc(hidden)]
    pub join_eui_filters: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
    /// <p>A list of NetId values that are used by LoRa gateways to filter the uplink frames.</p>
    #[doc(hidden)]
    pub net_id_filters: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>A list of integer indicating which sub bands are supported by LoRa gateway.</p>
    #[doc(hidden)]
    pub sub_bands: std::option::Option<std::vec::Vec<i32>>,
    /// <p>Beaconing object information, which consists of the data rate and frequency parameters.</p>
    #[doc(hidden)]
    pub beaconing: std::option::Option<crate::model::Beaconing>,
}
impl LoRaWanGateway {
    /// <p>The gateway's EUI value.</p>
    pub fn gateway_eui(&self) -> std::option::Option<&str> {
        self.gateway_eui.as_deref()
    }
    /// <p>The frequency band (RFRegion) value.</p>
    pub fn rf_region(&self) -> std::option::Option<&str> {
        self.rf_region.as_deref()
    }
    /// <p>A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.</p>
    pub fn join_eui_filters(&self) -> std::option::Option<&[std::vec::Vec<std::string::String>]> {
        self.join_eui_filters.as_deref()
    }
    /// <p>A list of NetId values that are used by LoRa gateways to filter the uplink frames.</p>
    pub fn net_id_filters(&self) -> std::option::Option<&[std::string::String]> {
        self.net_id_filters.as_deref()
    }
    /// <p>A list of integer indicating which sub bands are supported by LoRa gateway.</p>
    pub fn sub_bands(&self) -> std::option::Option<&[i32]> {
        self.sub_bands.as_deref()
    }
    /// <p>Beaconing object information, which consists of the data rate and frequency parameters.</p>
    pub fn beaconing(&self) -> std::option::Option<&crate::model::Beaconing> {
        self.beaconing.as_ref()
    }
}
impl LoRaWanGateway {
    /// Creates a new builder-style object to manufacture [`LoRaWanGateway`](crate::model::LoRaWanGateway).
    pub fn builder() -> crate::model::lo_ra_wan_gateway::Builder {
        crate::model::lo_ra_wan_gateway::Builder::default()
    }
}

/// See [`LoRaWanGateway`](crate::model::LoRaWanGateway).
pub mod lo_ra_wan_gateway {

    /// A builder for [`LoRaWanGateway`](crate::model::LoRaWanGateway).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_eui: std::option::Option<std::string::String>,
        pub(crate) rf_region: std::option::Option<std::string::String>,
        pub(crate) join_eui_filters:
            std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        pub(crate) net_id_filters: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) sub_bands: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) beaconing: std::option::Option<crate::model::Beaconing>,
    }
    impl Builder {
        /// <p>The gateway's EUI value.</p>
        pub fn gateway_eui(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_eui = Some(input.into());
            self
        }
        /// <p>The gateway's EUI value.</p>
        pub fn set_gateway_eui(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_eui = input;
            self
        }
        /// <p>The frequency band (RFRegion) value.</p>
        pub fn rf_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.rf_region = Some(input.into());
            self
        }
        /// <p>The frequency band (RFRegion) value.</p>
        pub fn set_rf_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rf_region = input;
            self
        }
        /// Appends an item to `join_eui_filters`.
        ///
        /// To override the contents of this collection use [`set_join_eui_filters`](Self::set_join_eui_filters).
        ///
        /// <p>A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.</p>
        pub fn join_eui_filters(mut self, input: std::vec::Vec<std::string::String>) -> Self {
            let mut v = self.join_eui_filters.unwrap_or_default();
            v.push(input);
            self.join_eui_filters = Some(v);
            self
        }
        /// <p>A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.</p>
        pub fn set_join_eui_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<std::vec::Vec<std::string::String>>>,
        ) -> Self {
            self.join_eui_filters = input;
            self
        }
        /// Appends an item to `net_id_filters`.
        ///
        /// To override the contents of this collection use [`set_net_id_filters`](Self::set_net_id_filters).
        ///
        /// <p>A list of NetId values that are used by LoRa gateways to filter the uplink frames.</p>
        pub fn net_id_filters(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.net_id_filters.unwrap_or_default();
            v.push(input.into());
            self.net_id_filters = Some(v);
            self
        }
        /// <p>A list of NetId values that are used by LoRa gateways to filter the uplink frames.</p>
        pub fn set_net_id_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.net_id_filters = input;
            self
        }
        /// Appends an item to `sub_bands`.
        ///
        /// To override the contents of this collection use [`set_sub_bands`](Self::set_sub_bands).
        ///
        /// <p>A list of integer indicating which sub bands are supported by LoRa gateway.</p>
        pub fn sub_bands(mut self, input: i32) -> Self {
            let mut v = self.sub_bands.unwrap_or_default();
            v.push(input);
            self.sub_bands = Some(v);
            self
        }
        /// <p>A list of integer indicating which sub bands are supported by LoRa gateway.</p>
        pub fn set_sub_bands(mut self, input: std::option::Option<std::vec::Vec<i32>>) -> Self {
            self.sub_bands = input;
            self
        }
        /// <p>Beaconing object information, which consists of the data rate and frequency parameters.</p>
        pub fn beaconing(mut self, input: crate::model::Beaconing) -> Self {
            self.beaconing = Some(input);
            self
        }
        /// <p>Beaconing object information, which consists of the data rate and frequency parameters.</p>
        pub fn set_beaconing(
            mut self,
            input: std::option::Option<crate::model::Beaconing>,
        ) -> Self {
            self.beaconing = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanGateway`](crate::model::LoRaWanGateway).
        pub fn build(self) -> crate::model::LoRaWanGateway {
            crate::model::LoRaWanGateway {
                gateway_eui: self.gateway_eui,
                rf_region: self.rf_region,
                join_eui_filters: self.join_eui_filters,
                net_id_filters: self.net_id_filters,
                sub_bands: self.sub_bands,
                beaconing: self.beaconing,
            }
        }
    }
}

/// <p>Beaconing parameters for configuring the wireless gateways.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Beaconing {
    /// <p>The data rate for gateways that are sending the beacons.</p>
    #[doc(hidden)]
    pub data_rate: std::option::Option<i32>,
    /// <p>The frequency list for the gateways to send the beacons.</p>
    #[doc(hidden)]
    pub frequencies: std::option::Option<std::vec::Vec<i32>>,
}
impl Beaconing {
    /// <p>The data rate for gateways that are sending the beacons.</p>
    pub fn data_rate(&self) -> std::option::Option<i32> {
        self.data_rate
    }
    /// <p>The frequency list for the gateways to send the beacons.</p>
    pub fn frequencies(&self) -> std::option::Option<&[i32]> {
        self.frequencies.as_deref()
    }
}
impl Beaconing {
    /// Creates a new builder-style object to manufacture [`Beaconing`](crate::model::Beaconing).
    pub fn builder() -> crate::model::beaconing::Builder {
        crate::model::beaconing::Builder::default()
    }
}

/// See [`Beaconing`](crate::model::Beaconing).
pub mod beaconing {

    /// A builder for [`Beaconing`](crate::model::Beaconing).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) data_rate: std::option::Option<i32>,
        pub(crate) frequencies: std::option::Option<std::vec::Vec<i32>>,
    }
    impl Builder {
        /// <p>The data rate for gateways that are sending the beacons.</p>
        pub fn data_rate(mut self, input: i32) -> Self {
            self.data_rate = Some(input);
            self
        }
        /// <p>The data rate for gateways that are sending the beacons.</p>
        pub fn set_data_rate(mut self, input: std::option::Option<i32>) -> Self {
            self.data_rate = input;
            self
        }
        /// Appends an item to `frequencies`.
        ///
        /// To override the contents of this collection use [`set_frequencies`](Self::set_frequencies).
        ///
        /// <p>The frequency list for the gateways to send the beacons.</p>
        pub fn frequencies(mut self, input: i32) -> Self {
            let mut v = self.frequencies.unwrap_or_default();
            v.push(input);
            self.frequencies = Some(v);
            self
        }
        /// <p>The frequency list for the gateways to send the beacons.</p>
        pub fn set_frequencies(mut self, input: std::option::Option<std::vec::Vec<i32>>) -> Self {
            self.frequencies = input;
            self
        }
        /// Consumes the builder and constructs a [`Beaconing`](crate::model::Beaconing).
        pub fn build(self) -> crate::model::Beaconing {
            crate::model::Beaconing {
                data_rate: self.data_rate,
                frequencies: self.frequencies,
            }
        }
    }
}

/// <p>Information about a wireless device's operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WirelessDeviceStatistics {
    /// <p>The Amazon Resource Name of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The ID of the wireless device reporting the data.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The wireless device type.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::WirelessDeviceType>,
    /// <p>The name of the resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The name of the destination to which the device is assigned.</p>
    #[doc(hidden)]
    pub destination_name: std::option::Option<std::string::String>,
    /// <p>The date and time when the most recent uplink was received.</p>
    #[doc(hidden)]
    pub last_uplink_received_at: std::option::Option<std::string::String>,
    /// <p>LoRaWAN device info.</p>
    #[doc(hidden)]
    pub lo_ra_wan: std::option::Option<crate::model::LoRaWanListDevice>,
    /// <p>The Sidewalk account credentials.</p>
    #[doc(hidden)]
    pub sidewalk: std::option::Option<crate::model::SidewalkListDevice>,
    /// <p>The status of a wireless device in a FUOTA task.</p>
    #[doc(hidden)]
    pub fuota_device_status: std::option::Option<crate::model::FuotaDeviceStatus>,
    /// <p>The status of the wireless device in the multicast group.</p>
    #[doc(hidden)]
    pub multicast_device_status: std::option::Option<std::string::String>,
    /// <p>Id of the multicast group.</p>
    #[doc(hidden)]
    pub mc_group_id: std::option::Option<i32>,
}
impl WirelessDeviceStatistics {
    /// <p>The Amazon Resource Name of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The ID of the wireless device reporting the data.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The wireless device type.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::WirelessDeviceType> {
        self.r#type.as_ref()
    }
    /// <p>The name of the resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The name of the destination to which the device is assigned.</p>
    pub fn destination_name(&self) -> std::option::Option<&str> {
        self.destination_name.as_deref()
    }
    /// <p>The date and time when the most recent uplink was received.</p>
    pub fn last_uplink_received_at(&self) -> std::option::Option<&str> {
        self.last_uplink_received_at.as_deref()
    }
    /// <p>LoRaWAN device info.</p>
    pub fn lo_ra_wan(&self) -> std::option::Option<&crate::model::LoRaWanListDevice> {
        self.lo_ra_wan.as_ref()
    }
    /// <p>The Sidewalk account credentials.</p>
    pub fn sidewalk(&self) -> std::option::Option<&crate::model::SidewalkListDevice> {
        self.sidewalk.as_ref()
    }
    /// <p>The status of a wireless device in a FUOTA task.</p>
    pub fn fuota_device_status(&self) -> std::option::Option<&crate::model::FuotaDeviceStatus> {
        self.fuota_device_status.as_ref()
    }
    /// <p>The status of the wireless device in the multicast group.</p>
    pub fn multicast_device_status(&self) -> std::option::Option<&str> {
        self.multicast_device_status.as_deref()
    }
    /// <p>Id of the multicast group.</p>
    pub fn mc_group_id(&self) -> std::option::Option<i32> {
        self.mc_group_id
    }
}
impl WirelessDeviceStatistics {
    /// Creates a new builder-style object to manufacture [`WirelessDeviceStatistics`](crate::model::WirelessDeviceStatistics).
    pub fn builder() -> crate::model::wireless_device_statistics::Builder {
        crate::model::wireless_device_statistics::Builder::default()
    }
}

/// See [`WirelessDeviceStatistics`](crate::model::WirelessDeviceStatistics).
pub mod wireless_device_statistics {

    /// A builder for [`WirelessDeviceStatistics`](crate::model::WirelessDeviceStatistics).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) r#type: std::option::Option<crate::model::WirelessDeviceType>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) destination_name: std::option::Option<std::string::String>,
        pub(crate) last_uplink_received_at: std::option::Option<std::string::String>,
        pub(crate) lo_ra_wan: std::option::Option<crate::model::LoRaWanListDevice>,
        pub(crate) sidewalk: std::option::Option<crate::model::SidewalkListDevice>,
        pub(crate) fuota_device_status: std::option::Option<crate::model::FuotaDeviceStatus>,
        pub(crate) multicast_device_status: std::option::Option<std::string::String>,
        pub(crate) mc_group_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The ID of the wireless device reporting the data.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the wireless device reporting the data.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The wireless device type.</p>
        pub fn r#type(mut self, input: crate::model::WirelessDeviceType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The wireless device type.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::WirelessDeviceType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The name of the resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The name of the destination to which the device is assigned.</p>
        pub fn destination_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination_name = Some(input.into());
            self
        }
        /// <p>The name of the destination to which the device is assigned.</p>
        pub fn set_destination_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.destination_name = input;
            self
        }
        /// <p>The date and time when the most recent uplink was received.</p>
        pub fn last_uplink_received_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.last_uplink_received_at = Some(input.into());
            self
        }
        /// <p>The date and time when the most recent uplink was received.</p>
        pub fn set_last_uplink_received_at(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.last_uplink_received_at = input;
            self
        }
        /// <p>LoRaWAN device info.</p>
        pub fn lo_ra_wan(mut self, input: crate::model::LoRaWanListDevice) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>LoRaWAN device info.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<crate::model::LoRaWanListDevice>,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// <p>The Sidewalk account credentials.</p>
        pub fn sidewalk(mut self, input: crate::model::SidewalkListDevice) -> Self {
            self.sidewalk = Some(input);
            self
        }
        /// <p>The Sidewalk account credentials.</p>
        pub fn set_sidewalk(
            mut self,
            input: std::option::Option<crate::model::SidewalkListDevice>,
        ) -> Self {
            self.sidewalk = input;
            self
        }
        /// <p>The status of a wireless device in a FUOTA task.</p>
        pub fn fuota_device_status(mut self, input: crate::model::FuotaDeviceStatus) -> Self {
            self.fuota_device_status = Some(input);
            self
        }
        /// <p>The status of a wireless device in a FUOTA task.</p>
        pub fn set_fuota_device_status(
            mut self,
            input: std::option::Option<crate::model::FuotaDeviceStatus>,
        ) -> Self {
            self.fuota_device_status = input;
            self
        }
        /// <p>The status of the wireless device in the multicast group.</p>
        pub fn multicast_device_status(mut self, input: impl Into<std::string::String>) -> Self {
            self.multicast_device_status = Some(input.into());
            self
        }
        /// <p>The status of the wireless device in the multicast group.</p>
        pub fn set_multicast_device_status(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.multicast_device_status = input;
            self
        }
        /// <p>Id of the multicast group.</p>
        pub fn mc_group_id(mut self, input: i32) -> Self {
            self.mc_group_id = Some(input);
            self
        }
        /// <p>Id of the multicast group.</p>
        pub fn set_mc_group_id(mut self, input: std::option::Option<i32>) -> Self {
            self.mc_group_id = input;
            self
        }
        /// Consumes the builder and constructs a [`WirelessDeviceStatistics`](crate::model::WirelessDeviceStatistics).
        pub fn build(self) -> crate::model::WirelessDeviceStatistics {
            crate::model::WirelessDeviceStatistics {
                arn: self.arn,
                id: self.id,
                r#type: self.r#type,
                name: self.name,
                destination_name: self.destination_name,
                last_uplink_received_at: self.last_uplink_received_at,
                lo_ra_wan: self.lo_ra_wan,
                sidewalk: self.sidewalk,
                fuota_device_status: self.fuota_device_status,
                multicast_device_status: self.multicast_device_status,
                mc_group_id: self.mc_group_id,
            }
        }
    }
}

/// When writing a match expression against `FuotaDeviceStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fuotadevicestatus = unimplemented!();
/// match fuotadevicestatus {
///     FuotaDeviceStatus::FragAlgoUnsupported => { /* ... */ },
///     FuotaDeviceStatus::FragIndexUnsupported => { /* ... */ },
///     FuotaDeviceStatus::Initial => { /* ... */ },
///     FuotaDeviceStatus::MicError => { /* ... */ },
///     FuotaDeviceStatus::MemoryError => { /* ... */ },
///     FuotaDeviceStatus::MissingFrag => { /* ... */ },
///     FuotaDeviceStatus::NotEnoughMemory => { /* ... */ },
///     FuotaDeviceStatus::PackageNotSupported => { /* ... */ },
///     FuotaDeviceStatus::SessionCntReplay => { /* ... */ },
///     FuotaDeviceStatus::Successful => { /* ... */ },
///     FuotaDeviceStatus::WrongDescriptor => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fuotadevicestatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FuotaDeviceStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FuotaDeviceStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FuotaDeviceStatus::NewFeature` is defined.
/// Specifically, when `fuotadevicestatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FuotaDeviceStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The status of a wireless device in a FUOTA task.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FuotaDeviceStatus {
    #[allow(missing_docs)] // documentation missing in model
    FragAlgoUnsupported,
    #[allow(missing_docs)] // documentation missing in model
    FragIndexUnsupported,
    #[allow(missing_docs)] // documentation missing in model
    Initial,
    #[allow(missing_docs)] // documentation missing in model
    MicError,
    #[allow(missing_docs)] // documentation missing in model
    MemoryError,
    #[allow(missing_docs)] // documentation missing in model
    MissingFrag,
    #[allow(missing_docs)] // documentation missing in model
    NotEnoughMemory,
    #[allow(missing_docs)] // documentation missing in model
    PackageNotSupported,
    #[allow(missing_docs)] // documentation missing in model
    SessionCntReplay,
    #[allow(missing_docs)] // documentation missing in model
    Successful,
    #[allow(missing_docs)] // documentation missing in model
    WrongDescriptor,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FuotaDeviceStatus {
    fn from(s: &str) -> Self {
        match s {
            "FragAlgo_unsupported" => FuotaDeviceStatus::FragAlgoUnsupported,
            "FragIndex_unsupported" => FuotaDeviceStatus::FragIndexUnsupported,
            "Initial" => FuotaDeviceStatus::Initial,
            "MICError" => FuotaDeviceStatus::MicError,
            "MemoryError" => FuotaDeviceStatus::MemoryError,
            "MissingFrag" => FuotaDeviceStatus::MissingFrag,
            "Not_enough_memory" => FuotaDeviceStatus::NotEnoughMemory,
            "Package_Not_Supported" => FuotaDeviceStatus::PackageNotSupported,
            "SessionCnt_replay" => FuotaDeviceStatus::SessionCntReplay,
            "Successful" => FuotaDeviceStatus::Successful,
            "Wrong_descriptor" => FuotaDeviceStatus::WrongDescriptor,
            other => {
                FuotaDeviceStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for FuotaDeviceStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FuotaDeviceStatus::from(s))
    }
}
impl FuotaDeviceStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FuotaDeviceStatus::FragAlgoUnsupported => "FragAlgo_unsupported",
            FuotaDeviceStatus::FragIndexUnsupported => "FragIndex_unsupported",
            FuotaDeviceStatus::Initial => "Initial",
            FuotaDeviceStatus::MicError => "MICError",
            FuotaDeviceStatus::MemoryError => "MemoryError",
            FuotaDeviceStatus::MissingFrag => "MissingFrag",
            FuotaDeviceStatus::NotEnoughMemory => "Not_enough_memory",
            FuotaDeviceStatus::PackageNotSupported => "Package_Not_Supported",
            FuotaDeviceStatus::SessionCntReplay => "SessionCnt_replay",
            FuotaDeviceStatus::Successful => "Successful",
            FuotaDeviceStatus::WrongDescriptor => "Wrong_descriptor",
            FuotaDeviceStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "FragAlgo_unsupported",
            "FragIndex_unsupported",
            "Initial",
            "MICError",
            "MemoryError",
            "MissingFrag",
            "Not_enough_memory",
            "Package_Not_Supported",
            "SessionCnt_replay",
            "Successful",
            "Wrong_descriptor",
        ]
    }
}
impl AsRef<str> for FuotaDeviceStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Sidewalk object used by list functions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SidewalkListDevice {
    /// <p>The Sidewalk Amazon ID.</p>
    #[doc(hidden)]
    pub amazon_id: std::option::Option<std::string::String>,
    /// <p>The sidewalk device identification.</p>
    #[doc(hidden)]
    pub sidewalk_id: std::option::Option<std::string::String>,
    /// <p>The Sidewalk manufacturing series number.</p>
    #[doc(hidden)]
    pub sidewalk_manufacturing_sn: std::option::Option<std::string::String>,
    /// <p>The sidewalk device certificates for Ed25519 and P256r1.</p>
    #[doc(hidden)]
    pub device_certificates: std::option::Option<std::vec::Vec<crate::model::CertificateList>>,
}
impl SidewalkListDevice {
    /// <p>The Sidewalk Amazon ID.</p>
    pub fn amazon_id(&self) -> std::option::Option<&str> {
        self.amazon_id.as_deref()
    }
    /// <p>The sidewalk device identification.</p>
    pub fn sidewalk_id(&self) -> std::option::Option<&str> {
        self.sidewalk_id.as_deref()
    }
    /// <p>The Sidewalk manufacturing series number.</p>
    pub fn sidewalk_manufacturing_sn(&self) -> std::option::Option<&str> {
        self.sidewalk_manufacturing_sn.as_deref()
    }
    /// <p>The sidewalk device certificates for Ed25519 and P256r1.</p>
    pub fn device_certificates(&self) -> std::option::Option<&[crate::model::CertificateList]> {
        self.device_certificates.as_deref()
    }
}
impl SidewalkListDevice {
    /// Creates a new builder-style object to manufacture [`SidewalkListDevice`](crate::model::SidewalkListDevice).
    pub fn builder() -> crate::model::sidewalk_list_device::Builder {
        crate::model::sidewalk_list_device::Builder::default()
    }
}

/// See [`SidewalkListDevice`](crate::model::SidewalkListDevice).
pub mod sidewalk_list_device {

    /// A builder for [`SidewalkListDevice`](crate::model::SidewalkListDevice).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amazon_id: std::option::Option<std::string::String>,
        pub(crate) sidewalk_id: std::option::Option<std::string::String>,
        pub(crate) sidewalk_manufacturing_sn: std::option::Option<std::string::String>,
        pub(crate) device_certificates:
            std::option::Option<std::vec::Vec<crate::model::CertificateList>>,
    }
    impl Builder {
        /// <p>The Sidewalk Amazon ID.</p>
        pub fn amazon_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.amazon_id = Some(input.into());
            self
        }
        /// <p>The Sidewalk Amazon ID.</p>
        pub fn set_amazon_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amazon_id = input;
            self
        }
        /// <p>The sidewalk device identification.</p>
        pub fn sidewalk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sidewalk_id = Some(input.into());
            self
        }
        /// <p>The sidewalk device identification.</p>
        pub fn set_sidewalk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sidewalk_id = input;
            self
        }
        /// <p>The Sidewalk manufacturing series number.</p>
        pub fn sidewalk_manufacturing_sn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sidewalk_manufacturing_sn = Some(input.into());
            self
        }
        /// <p>The Sidewalk manufacturing series number.</p>
        pub fn set_sidewalk_manufacturing_sn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sidewalk_manufacturing_sn = input;
            self
        }
        /// Appends an item to `device_certificates`.
        ///
        /// To override the contents of this collection use [`set_device_certificates`](Self::set_device_certificates).
        ///
        /// <p>The sidewalk device certificates for Ed25519 and P256r1.</p>
        pub fn device_certificates(mut self, input: crate::model::CertificateList) -> Self {
            let mut v = self.device_certificates.unwrap_or_default();
            v.push(input);
            self.device_certificates = Some(v);
            self
        }
        /// <p>The sidewalk device certificates for Ed25519 and P256r1.</p>
        pub fn set_device_certificates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CertificateList>>,
        ) -> Self {
            self.device_certificates = input;
            self
        }
        /// Consumes the builder and constructs a [`SidewalkListDevice`](crate::model::SidewalkListDevice).
        pub fn build(self) -> crate::model::SidewalkListDevice {
            crate::model::SidewalkListDevice {
                amazon_id: self.amazon_id,
                sidewalk_id: self.sidewalk_id,
                sidewalk_manufacturing_sn: self.sidewalk_manufacturing_sn,
                device_certificates: self.device_certificates,
            }
        }
    }
}

/// <p>List of sidewalk certificates.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CertificateList {
    /// <p>The certificate chain algorithm provided by sidewalk.</p>
    #[doc(hidden)]
    pub signing_alg: std::option::Option<crate::model::SigningAlg>,
    /// <p>The value of the chosen sidewalk certificate.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl CertificateList {
    /// <p>The certificate chain algorithm provided by sidewalk.</p>
    pub fn signing_alg(&self) -> std::option::Option<&crate::model::SigningAlg> {
        self.signing_alg.as_ref()
    }
    /// <p>The value of the chosen sidewalk certificate.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
impl CertificateList {
    /// Creates a new builder-style object to manufacture [`CertificateList`](crate::model::CertificateList).
    pub fn builder() -> crate::model::certificate_list::Builder {
        crate::model::certificate_list::Builder::default()
    }
}

/// See [`CertificateList`](crate::model::CertificateList).
pub mod certificate_list {

    /// A builder for [`CertificateList`](crate::model::CertificateList).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) signing_alg: std::option::Option<crate::model::SigningAlg>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The certificate chain algorithm provided by sidewalk.</p>
        pub fn signing_alg(mut self, input: crate::model::SigningAlg) -> Self {
            self.signing_alg = Some(input);
            self
        }
        /// <p>The certificate chain algorithm provided by sidewalk.</p>
        pub fn set_signing_alg(
            mut self,
            input: std::option::Option<crate::model::SigningAlg>,
        ) -> Self {
            self.signing_alg = input;
            self
        }
        /// <p>The value of the chosen sidewalk certificate.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the chosen sidewalk certificate.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateList`](crate::model::CertificateList).
        pub fn build(self) -> crate::model::CertificateList {
            crate::model::CertificateList {
                signing_alg: self.signing_alg,
                value: self.value,
            }
        }
    }
}

/// When writing a match expression against `SigningAlg`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let signingalg = unimplemented!();
/// match signingalg {
///     SigningAlg::Ed25519 => { /* ... */ },
///     SigningAlg::P256r1 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `signingalg` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SigningAlg::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SigningAlg::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SigningAlg::NewFeature` is defined.
/// Specifically, when `signingalg` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SigningAlg::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The certificate chain algorithm provided by sidewalk.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SigningAlg {
    #[allow(missing_docs)] // documentation missing in model
    Ed25519,
    #[allow(missing_docs)] // documentation missing in model
    P256r1,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SigningAlg {
    fn from(s: &str) -> Self {
        match s {
            "Ed25519" => SigningAlg::Ed25519,
            "P256r1" => SigningAlg::P256r1,
            other => SigningAlg::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SigningAlg {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SigningAlg::from(s))
    }
}
impl SigningAlg {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SigningAlg::Ed25519 => "Ed25519",
            SigningAlg::P256r1 => "P256r1",
            SigningAlg::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Ed25519", "P256r1"]
    }
}
impl AsRef<str> for SigningAlg {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>LoRaWAN object for list functions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanListDevice {
    /// <p>The DevEUI value.</p>
    #[doc(hidden)]
    pub dev_eui: std::option::Option<std::string::String>,
}
impl LoRaWanListDevice {
    /// <p>The DevEUI value.</p>
    pub fn dev_eui(&self) -> std::option::Option<&str> {
        self.dev_eui.as_deref()
    }
}
impl LoRaWanListDevice {
    /// Creates a new builder-style object to manufacture [`LoRaWanListDevice`](crate::model::LoRaWanListDevice).
    pub fn builder() -> crate::model::lo_ra_wan_list_device::Builder {
        crate::model::lo_ra_wan_list_device::Builder::default()
    }
}

/// See [`LoRaWanListDevice`](crate::model::LoRaWanListDevice).
pub mod lo_ra_wan_list_device {

    /// A builder for [`LoRaWanListDevice`](crate::model::LoRaWanListDevice).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dev_eui: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The DevEUI value.</p>
        pub fn dev_eui(mut self, input: impl Into<std::string::String>) -> Self {
            self.dev_eui = Some(input.into());
            self
        }
        /// <p>The DevEUI value.</p>
        pub fn set_dev_eui(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dev_eui = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanListDevice`](crate::model::LoRaWanListDevice).
        pub fn build(self) -> crate::model::LoRaWanListDevice {
            crate::model::LoRaWanListDevice {
                dev_eui: self.dev_eui,
            }
        }
    }
}

/// <p>Information about a service profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ServiceProfile {
    /// <p>The Amazon Resource Name of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the service profile.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl ServiceProfile {
    /// <p>The Amazon Resource Name of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the service profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
impl ServiceProfile {
    /// Creates a new builder-style object to manufacture [`ServiceProfile`](crate::model::ServiceProfile).
    pub fn builder() -> crate::model::service_profile::Builder {
        crate::model::service_profile::Builder::default()
    }
}

/// See [`ServiceProfile`](crate::model::ServiceProfile).
pub mod service_profile {

    /// A builder for [`ServiceProfile`](crate::model::ServiceProfile).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the service profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the service profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceProfile`](crate::model::ServiceProfile).
        pub fn build(self) -> crate::model::ServiceProfile {
            crate::model::ServiceProfile {
                arn: self.arn,
                name: self.name,
                id: self.id,
            }
        }
    }
}

/// <p>The message in the downlink queue.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DownlinkQueueMessage {
    /// <p> The message ID assigned by IoT Wireless to each downlink message, which helps identify the message.</p>
    #[doc(hidden)]
    pub message_id: std::option::Option<std::string::String>,
    /// <p>The transmit mode to use for sending data to the wireless device. This can be <code>0</code> for UM (unacknowledge mode) or <code>1</code> for AM (acknowledge mode).</p>
    #[doc(hidden)]
    pub transmit_mode: std::option::Option<i32>,
    /// <p>The time at which Iot Wireless received the downlink message.</p>
    #[doc(hidden)]
    pub received_at: std::option::Option<std::string::String>,
    /// <p>LoRaWAN router info.</p>
    #[doc(hidden)]
    pub lo_ra_wan: std::option::Option<crate::model::LoRaWanSendDataToDevice>,
}
impl DownlinkQueueMessage {
    /// <p> The message ID assigned by IoT Wireless to each downlink message, which helps identify the message.</p>
    pub fn message_id(&self) -> std::option::Option<&str> {
        self.message_id.as_deref()
    }
    /// <p>The transmit mode to use for sending data to the wireless device. This can be <code>0</code> for UM (unacknowledge mode) or <code>1</code> for AM (acknowledge mode).</p>
    pub fn transmit_mode(&self) -> std::option::Option<i32> {
        self.transmit_mode
    }
    /// <p>The time at which Iot Wireless received the downlink message.</p>
    pub fn received_at(&self) -> std::option::Option<&str> {
        self.received_at.as_deref()
    }
    /// <p>LoRaWAN router info.</p>
    pub fn lo_ra_wan(&self) -> std::option::Option<&crate::model::LoRaWanSendDataToDevice> {
        self.lo_ra_wan.as_ref()
    }
}
impl DownlinkQueueMessage {
    /// Creates a new builder-style object to manufacture [`DownlinkQueueMessage`](crate::model::DownlinkQueueMessage).
    pub fn builder() -> crate::model::downlink_queue_message::Builder {
        crate::model::downlink_queue_message::Builder::default()
    }
}

/// See [`DownlinkQueueMessage`](crate::model::DownlinkQueueMessage).
pub mod downlink_queue_message {

    /// A builder for [`DownlinkQueueMessage`](crate::model::DownlinkQueueMessage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message_id: std::option::Option<std::string::String>,
        pub(crate) transmit_mode: std::option::Option<i32>,
        pub(crate) received_at: std::option::Option<std::string::String>,
        pub(crate) lo_ra_wan: std::option::Option<crate::model::LoRaWanSendDataToDevice>,
    }
    impl Builder {
        /// <p> The message ID assigned by IoT Wireless to each downlink message, which helps identify the message.</p>
        pub fn message_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.message_id = Some(input.into());
            self
        }
        /// <p> The message ID assigned by IoT Wireless to each downlink message, which helps identify the message.</p>
        pub fn set_message_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message_id = input;
            self
        }
        /// <p>The transmit mode to use for sending data to the wireless device. This can be <code>0</code> for UM (unacknowledge mode) or <code>1</code> for AM (acknowledge mode).</p>
        pub fn transmit_mode(mut self, input: i32) -> Self {
            self.transmit_mode = Some(input);
            self
        }
        /// <p>The transmit mode to use for sending data to the wireless device. This can be <code>0</code> for UM (unacknowledge mode) or <code>1</code> for AM (acknowledge mode).</p>
        pub fn set_transmit_mode(mut self, input: std::option::Option<i32>) -> Self {
            self.transmit_mode = input;
            self
        }
        /// <p>The time at which Iot Wireless received the downlink message.</p>
        pub fn received_at(mut self, input: impl Into<std::string::String>) -> Self {
            self.received_at = Some(input.into());
            self
        }
        /// <p>The time at which Iot Wireless received the downlink message.</p>
        pub fn set_received_at(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.received_at = input;
            self
        }
        /// <p>LoRaWAN router info.</p>
        pub fn lo_ra_wan(mut self, input: crate::model::LoRaWanSendDataToDevice) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>LoRaWAN router info.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<crate::model::LoRaWanSendDataToDevice>,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// Consumes the builder and constructs a [`DownlinkQueueMessage`](crate::model::DownlinkQueueMessage).
        pub fn build(self) -> crate::model::DownlinkQueueMessage {
            crate::model::DownlinkQueueMessage {
                message_id: self.message_id,
                transmit_mode: self.transmit_mode,
                received_at: self.received_at,
                lo_ra_wan: self.lo_ra_wan,
            }
        }
    }
}

/// <p>The wrapper for a position configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PositionConfigurationItem {
    /// <p>Resource identifier for the position configuration.</p>
    #[doc(hidden)]
    pub resource_identifier: std::option::Option<std::string::String>,
    /// <p>Resource type of the resource for the position configuration.</p>
    #[doc(hidden)]
    pub resource_type: std::option::Option<crate::model::PositionResourceType>,
    /// <p>The details of the positioning solver object used to compute the location.</p>
    #[doc(hidden)]
    pub solvers: std::option::Option<crate::model::PositionSolverDetails>,
    /// <p>The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.</p>
    #[doc(hidden)]
    pub destination: std::option::Option<std::string::String>,
}
impl PositionConfigurationItem {
    /// <p>Resource identifier for the position configuration.</p>
    pub fn resource_identifier(&self) -> std::option::Option<&str> {
        self.resource_identifier.as_deref()
    }
    /// <p>Resource type of the resource for the position configuration.</p>
    pub fn resource_type(&self) -> std::option::Option<&crate::model::PositionResourceType> {
        self.resource_type.as_ref()
    }
    /// <p>The details of the positioning solver object used to compute the location.</p>
    pub fn solvers(&self) -> std::option::Option<&crate::model::PositionSolverDetails> {
        self.solvers.as_ref()
    }
    /// <p>The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.</p>
    pub fn destination(&self) -> std::option::Option<&str> {
        self.destination.as_deref()
    }
}
impl PositionConfigurationItem {
    /// Creates a new builder-style object to manufacture [`PositionConfigurationItem`](crate::model::PositionConfigurationItem).
    pub fn builder() -> crate::model::position_configuration_item::Builder {
        crate::model::position_configuration_item::Builder::default()
    }
}

/// See [`PositionConfigurationItem`](crate::model::PositionConfigurationItem).
pub mod position_configuration_item {

    /// A builder for [`PositionConfigurationItem`](crate::model::PositionConfigurationItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_identifier: std::option::Option<std::string::String>,
        pub(crate) resource_type: std::option::Option<crate::model::PositionResourceType>,
        pub(crate) solvers: std::option::Option<crate::model::PositionSolverDetails>,
        pub(crate) destination: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Resource identifier for the position configuration.</p>
        pub fn resource_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_identifier = Some(input.into());
            self
        }
        /// <p>Resource identifier for the position configuration.</p>
        pub fn set_resource_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_identifier = input;
            self
        }
        /// <p>Resource type of the resource for the position configuration.</p>
        pub fn resource_type(mut self, input: crate::model::PositionResourceType) -> Self {
            self.resource_type = Some(input);
            self
        }
        /// <p>Resource type of the resource for the position configuration.</p>
        pub fn set_resource_type(
            mut self,
            input: std::option::Option<crate::model::PositionResourceType>,
        ) -> Self {
            self.resource_type = input;
            self
        }
        /// <p>The details of the positioning solver object used to compute the location.</p>
        pub fn solvers(mut self, input: crate::model::PositionSolverDetails) -> Self {
            self.solvers = Some(input);
            self
        }
        /// <p>The details of the positioning solver object used to compute the location.</p>
        pub fn set_solvers(
            mut self,
            input: std::option::Option<crate::model::PositionSolverDetails>,
        ) -> Self {
            self.solvers = input;
            self
        }
        /// <p>The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.</p>
        pub fn destination(mut self, input: impl Into<std::string::String>) -> Self {
            self.destination = Some(input.into());
            self
        }
        /// <p>The position data destination that describes the AWS IoT rule that processes the device's position data for use by AWS IoT Core for LoRaWAN.</p>
        pub fn set_destination(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.destination = input;
            self
        }
        /// Consumes the builder and constructs a [`PositionConfigurationItem`](crate::model::PositionConfigurationItem).
        pub fn build(self) -> crate::model::PositionConfigurationItem {
            crate::model::PositionConfigurationItem {
                resource_identifier: self.resource_identifier,
                resource_type: self.resource_type,
                solvers: self.solvers,
                destination: self.destination,
            }
        }
    }
}

/// <p>The wrapper for position solver details.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PositionSolverDetails {
    /// <p>The Semtech GNSS solver object details.</p>
    #[doc(hidden)]
    pub semtech_gnss: std::option::Option<crate::model::SemtechGnssDetail>,
}
impl PositionSolverDetails {
    /// <p>The Semtech GNSS solver object details.</p>
    pub fn semtech_gnss(&self) -> std::option::Option<&crate::model::SemtechGnssDetail> {
        self.semtech_gnss.as_ref()
    }
}
impl PositionSolverDetails {
    /// Creates a new builder-style object to manufacture [`PositionSolverDetails`](crate::model::PositionSolverDetails).
    pub fn builder() -> crate::model::position_solver_details::Builder {
        crate::model::position_solver_details::Builder::default()
    }
}

/// See [`PositionSolverDetails`](crate::model::PositionSolverDetails).
pub mod position_solver_details {

    /// A builder for [`PositionSolverDetails`](crate::model::PositionSolverDetails).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) semtech_gnss: std::option::Option<crate::model::SemtechGnssDetail>,
    }
    impl Builder {
        /// <p>The Semtech GNSS solver object details.</p>
        pub fn semtech_gnss(mut self, input: crate::model::SemtechGnssDetail) -> Self {
            self.semtech_gnss = Some(input);
            self
        }
        /// <p>The Semtech GNSS solver object details.</p>
        pub fn set_semtech_gnss(
            mut self,
            input: std::option::Option<crate::model::SemtechGnssDetail>,
        ) -> Self {
            self.semtech_gnss = input;
            self
        }
        /// Consumes the builder and constructs a [`PositionSolverDetails`](crate::model::PositionSolverDetails).
        pub fn build(self) -> crate::model::PositionSolverDetails {
            crate::model::PositionSolverDetails {
                semtech_gnss: self.semtech_gnss,
            }
        }
    }
}

/// <p>Details of the Semtech GNSS solver object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SemtechGnssDetail {
    /// <p>The vendor of the solver object.</p>
    #[doc(hidden)]
    pub provider: std::option::Option<crate::model::PositionSolverProvider>,
    /// <p>The type of positioning solver used.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::PositionSolverType>,
    /// <p>The status indicating whether the solver is enabled.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::PositionConfigurationStatus>,
    /// <p>Whether forward error correction is enabled.</p>
    #[doc(hidden)]
    pub fec: std::option::Option<crate::model::PositionConfigurationFec>,
}
impl SemtechGnssDetail {
    /// <p>The vendor of the solver object.</p>
    pub fn provider(&self) -> std::option::Option<&crate::model::PositionSolverProvider> {
        self.provider.as_ref()
    }
    /// <p>The type of positioning solver used.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::PositionSolverType> {
        self.r#type.as_ref()
    }
    /// <p>The status indicating whether the solver is enabled.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::PositionConfigurationStatus> {
        self.status.as_ref()
    }
    /// <p>Whether forward error correction is enabled.</p>
    pub fn fec(&self) -> std::option::Option<&crate::model::PositionConfigurationFec> {
        self.fec.as_ref()
    }
}
impl SemtechGnssDetail {
    /// Creates a new builder-style object to manufacture [`SemtechGnssDetail`](crate::model::SemtechGnssDetail).
    pub fn builder() -> crate::model::semtech_gnss_detail::Builder {
        crate::model::semtech_gnss_detail::Builder::default()
    }
}

/// See [`SemtechGnssDetail`](crate::model::SemtechGnssDetail).
pub mod semtech_gnss_detail {

    /// A builder for [`SemtechGnssDetail`](crate::model::SemtechGnssDetail).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) provider: std::option::Option<crate::model::PositionSolverProvider>,
        pub(crate) r#type: std::option::Option<crate::model::PositionSolverType>,
        pub(crate) status: std::option::Option<crate::model::PositionConfigurationStatus>,
        pub(crate) fec: std::option::Option<crate::model::PositionConfigurationFec>,
    }
    impl Builder {
        /// <p>The vendor of the solver object.</p>
        pub fn provider(mut self, input: crate::model::PositionSolverProvider) -> Self {
            self.provider = Some(input);
            self
        }
        /// <p>The vendor of the solver object.</p>
        pub fn set_provider(
            mut self,
            input: std::option::Option<crate::model::PositionSolverProvider>,
        ) -> Self {
            self.provider = input;
            self
        }
        /// <p>The type of positioning solver used.</p>
        pub fn r#type(mut self, input: crate::model::PositionSolverType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The type of positioning solver used.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::PositionSolverType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// <p>The status indicating whether the solver is enabled.</p>
        pub fn status(mut self, input: crate::model::PositionConfigurationStatus) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status indicating whether the solver is enabled.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::PositionConfigurationStatus>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>Whether forward error correction is enabled.</p>
        pub fn fec(mut self, input: crate::model::PositionConfigurationFec) -> Self {
            self.fec = Some(input);
            self
        }
        /// <p>Whether forward error correction is enabled.</p>
        pub fn set_fec(
            mut self,
            input: std::option::Option<crate::model::PositionConfigurationFec>,
        ) -> Self {
            self.fec = input;
            self
        }
        /// Consumes the builder and constructs a [`SemtechGnssDetail`](crate::model::SemtechGnssDetail).
        pub fn build(self) -> crate::model::SemtechGnssDetail {
            crate::model::SemtechGnssDetail {
                provider: self.provider,
                r#type: self.r#type,
                status: self.status,
                fec: self.fec,
            }
        }
    }
}

/// When writing a match expression against `PositionSolverType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let positionsolvertype = unimplemented!();
/// match positionsolvertype {
///     PositionSolverType::Gnss => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `positionsolvertype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PositionSolverType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PositionSolverType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PositionSolverType::NewFeature` is defined.
/// Specifically, when `positionsolvertype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PositionSolverType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PositionSolverType {
    #[allow(missing_docs)] // documentation missing in model
    Gnss,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PositionSolverType {
    fn from(s: &str) -> Self {
        match s {
            "GNSS" => PositionSolverType::Gnss,
            other => {
                PositionSolverType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PositionSolverType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PositionSolverType::from(s))
    }
}
impl PositionSolverType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PositionSolverType::Gnss => "GNSS",
            PositionSolverType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GNSS"]
    }
}
impl AsRef<str> for PositionSolverType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `PositionSolverProvider`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let positionsolverprovider = unimplemented!();
/// match positionsolverprovider {
///     PositionSolverProvider::Semtech => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `positionsolverprovider` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `PositionSolverProvider::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `PositionSolverProvider::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `PositionSolverProvider::NewFeature` is defined.
/// Specifically, when `positionsolverprovider` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `PositionSolverProvider::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum PositionSolverProvider {
    #[allow(missing_docs)] // documentation missing in model
    Semtech,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for PositionSolverProvider {
    fn from(s: &str) -> Self {
        match s {
            "Semtech" => PositionSolverProvider::Semtech,
            other => {
                PositionSolverProvider::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for PositionSolverProvider {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(PositionSolverProvider::from(s))
    }
}
impl PositionSolverProvider {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            PositionSolverProvider::Semtech => "Semtech",
            PositionSolverProvider::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Semtech"]
    }
}
impl AsRef<str> for PositionSolverProvider {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Information about a Sidewalk account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SidewalkAccountInfoWithFingerprint {
    /// <p>The Sidewalk Amazon ID.</p>
    #[doc(hidden)]
    pub amazon_id: std::option::Option<std::string::String>,
    /// <p>The fingerprint of the Sidewalk application server private key.</p>
    #[doc(hidden)]
    pub fingerprint: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
}
impl SidewalkAccountInfoWithFingerprint {
    /// <p>The Sidewalk Amazon ID.</p>
    pub fn amazon_id(&self) -> std::option::Option<&str> {
        self.amazon_id.as_deref()
    }
    /// <p>The fingerprint of the Sidewalk application server private key.</p>
    pub fn fingerprint(&self) -> std::option::Option<&str> {
        self.fingerprint.as_deref()
    }
    /// <p>The Amazon Resource Name of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
}
impl std::fmt::Debug for SidewalkAccountInfoWithFingerprint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SidewalkAccountInfoWithFingerprint");
        formatter.field("amazon_id", &self.amazon_id);
        formatter.field("fingerprint", &"*** Sensitive Data Redacted ***");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}
impl SidewalkAccountInfoWithFingerprint {
    /// Creates a new builder-style object to manufacture [`SidewalkAccountInfoWithFingerprint`](crate::model::SidewalkAccountInfoWithFingerprint).
    pub fn builder() -> crate::model::sidewalk_account_info_with_fingerprint::Builder {
        crate::model::sidewalk_account_info_with_fingerprint::Builder::default()
    }
}

/// See [`SidewalkAccountInfoWithFingerprint`](crate::model::SidewalkAccountInfoWithFingerprint).
pub mod sidewalk_account_info_with_fingerprint {

    /// A builder for [`SidewalkAccountInfoWithFingerprint`](crate::model::SidewalkAccountInfoWithFingerprint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) amazon_id: std::option::Option<std::string::String>,
        pub(crate) fingerprint: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Sidewalk Amazon ID.</p>
        pub fn amazon_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.amazon_id = Some(input.into());
            self
        }
        /// <p>The Sidewalk Amazon ID.</p>
        pub fn set_amazon_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amazon_id = input;
            self
        }
        /// <p>The fingerprint of the Sidewalk application server private key.</p>
        pub fn fingerprint(mut self, input: impl Into<std::string::String>) -> Self {
            self.fingerprint = Some(input.into());
            self
        }
        /// <p>The fingerprint of the Sidewalk application server private key.</p>
        pub fn set_fingerprint(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.fingerprint = input;
            self
        }
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// Consumes the builder and constructs a [`SidewalkAccountInfoWithFingerprint`](crate::model::SidewalkAccountInfoWithFingerprint).
        pub fn build(self) -> crate::model::SidewalkAccountInfoWithFingerprint {
            crate::model::SidewalkAccountInfoWithFingerprint {
                amazon_id: self.amazon_id,
                fingerprint: self.fingerprint,
                arn: self.arn,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("amazon_id", &self.amazon_id);
            formatter.field("fingerprint", &"*** Sensitive Data Redacted ***");
            formatter.field("arn", &self.arn);
            formatter.finish()
        }
    }
}

/// <p>Network analyzer configurations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NetworkAnalyzerConfigurations {
    /// <p>The Amazon Resource Name of the new resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Name of the network analyzer configuration.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl NetworkAnalyzerConfigurations {
    /// <p>The Amazon Resource Name of the new resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>Name of the network analyzer configuration.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl NetworkAnalyzerConfigurations {
    /// Creates a new builder-style object to manufacture [`NetworkAnalyzerConfigurations`](crate::model::NetworkAnalyzerConfigurations).
    pub fn builder() -> crate::model::network_analyzer_configurations::Builder {
        crate::model::network_analyzer_configurations::Builder::default()
    }
}

/// See [`NetworkAnalyzerConfigurations`](crate::model::NetworkAnalyzerConfigurations).
pub mod network_analyzer_configurations {

    /// A builder for [`NetworkAnalyzerConfigurations`](crate::model::NetworkAnalyzerConfigurations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name of the new resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name of the new resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>Name of the network analyzer configuration.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>Name of the network analyzer configuration.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`NetworkAnalyzerConfigurations`](crate::model::NetworkAnalyzerConfigurations).
        pub fn build(self) -> crate::model::NetworkAnalyzerConfigurations {
            crate::model::NetworkAnalyzerConfigurations {
                arn: self.arn,
                name: self.name,
            }
        }
    }
}

/// <p>A multicast group that is associated with a FUOTA task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MulticastGroupByFuotaTask {
    /// <p>The ID of the multicast group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl MulticastGroupByFuotaTask {
    /// <p>The ID of the multicast group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
impl MulticastGroupByFuotaTask {
    /// Creates a new builder-style object to manufacture [`MulticastGroupByFuotaTask`](crate::model::MulticastGroupByFuotaTask).
    pub fn builder() -> crate::model::multicast_group_by_fuota_task::Builder {
        crate::model::multicast_group_by_fuota_task::Builder::default()
    }
}

/// See [`MulticastGroupByFuotaTask`](crate::model::MulticastGroupByFuotaTask).
pub mod multicast_group_by_fuota_task {

    /// A builder for [`MulticastGroupByFuotaTask`](crate::model::MulticastGroupByFuotaTask).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the multicast group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the multicast group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`MulticastGroupByFuotaTask`](crate::model::MulticastGroupByFuotaTask).
        pub fn build(self) -> crate::model::MulticastGroupByFuotaTask {
            crate::model::MulticastGroupByFuotaTask { id: self.id }
        }
    }
}

/// <p>A multicast group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MulticastGroup {
    /// <p>The ID of the multicast group.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The arn of the multicast group.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the multicast group.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl MulticastGroup {
    /// <p>The ID of the multicast group.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The arn of the multicast group.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the multicast group.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl MulticastGroup {
    /// Creates a new builder-style object to manufacture [`MulticastGroup`](crate::model::MulticastGroup).
    pub fn builder() -> crate::model::multicast_group::Builder {
        crate::model::multicast_group::Builder::default()
    }
}

/// See [`MulticastGroup`](crate::model::MulticastGroup).
pub mod multicast_group {

    /// A builder for [`MulticastGroup`](crate::model::MulticastGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of the multicast group.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the multicast group.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The arn of the multicast group.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The arn of the multicast group.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the multicast group.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the multicast group.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`MulticastGroup`](crate::model::MulticastGroup).
        pub fn build(self) -> crate::model::MulticastGroup {
            crate::model::MulticastGroup {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}

/// <p>A FUOTA task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FuotaTask {
    /// <p>The ID of a FUOTA task.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
    /// <p>The arn of a FUOTA task.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of a FUOTA task.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
}
impl FuotaTask {
    /// <p>The ID of a FUOTA task.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
    /// <p>The arn of a FUOTA task.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of a FUOTA task.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
}
impl FuotaTask {
    /// Creates a new builder-style object to manufacture [`FuotaTask`](crate::model::FuotaTask).
    pub fn builder() -> crate::model::fuota_task::Builder {
        crate::model::fuota_task::Builder::default()
    }
}

/// See [`FuotaTask`](crate::model::FuotaTask).
pub mod fuota_task {

    /// A builder for [`FuotaTask`](crate::model::FuotaTask).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) id: std::option::Option<std::string::String>,
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The ID of a FUOTA task.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of a FUOTA task.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// <p>The arn of a FUOTA task.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The arn of a FUOTA task.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of a FUOTA task.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of a FUOTA task.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`FuotaTask`](crate::model::FuotaTask).
        pub fn build(self) -> crate::model::FuotaTask {
            crate::model::FuotaTask {
                id: self.id,
                arn: self.arn,
                name: self.name,
            }
        }
    }
}

/// <p>Event configuration object for a single resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventConfigurationItem {
    /// <p>Resource identifier opted in for event messaging.</p>
    #[doc(hidden)]
    pub identifier: std::option::Option<std::string::String>,
    /// <p>Identifier type of the particular resource identifier for event configuration.</p>
    #[doc(hidden)]
    pub identifier_type: std::option::Option<crate::model::IdentifierType>,
    /// <p>Partner type of the resource if the identifier type is PartnerAccountId.</p>
    #[doc(hidden)]
    pub partner_type: std::option::Option<crate::model::EventNotificationPartnerType>,
    /// <p>Object of all event configurations and the status of the event topics.</p>
    #[doc(hidden)]
    pub events: std::option::Option<crate::model::EventNotificationItemConfigurations>,
}
impl EventConfigurationItem {
    /// <p>Resource identifier opted in for event messaging.</p>
    pub fn identifier(&self) -> std::option::Option<&str> {
        self.identifier.as_deref()
    }
    /// <p>Identifier type of the particular resource identifier for event configuration.</p>
    pub fn identifier_type(&self) -> std::option::Option<&crate::model::IdentifierType> {
        self.identifier_type.as_ref()
    }
    /// <p>Partner type of the resource if the identifier type is PartnerAccountId.</p>
    pub fn partner_type(&self) -> std::option::Option<&crate::model::EventNotificationPartnerType> {
        self.partner_type.as_ref()
    }
    /// <p>Object of all event configurations and the status of the event topics.</p>
    pub fn events(
        &self,
    ) -> std::option::Option<&crate::model::EventNotificationItemConfigurations> {
        self.events.as_ref()
    }
}
impl EventConfigurationItem {
    /// Creates a new builder-style object to manufacture [`EventConfigurationItem`](crate::model::EventConfigurationItem).
    pub fn builder() -> crate::model::event_configuration_item::Builder {
        crate::model::event_configuration_item::Builder::default()
    }
}

/// See [`EventConfigurationItem`](crate::model::EventConfigurationItem).
pub mod event_configuration_item {

    /// A builder for [`EventConfigurationItem`](crate::model::EventConfigurationItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) identifier: std::option::Option<std::string::String>,
        pub(crate) identifier_type: std::option::Option<crate::model::IdentifierType>,
        pub(crate) partner_type: std::option::Option<crate::model::EventNotificationPartnerType>,
        pub(crate) events: std::option::Option<crate::model::EventNotificationItemConfigurations>,
    }
    impl Builder {
        /// <p>Resource identifier opted in for event messaging.</p>
        pub fn identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.identifier = Some(input.into());
            self
        }
        /// <p>Resource identifier opted in for event messaging.</p>
        pub fn set_identifier(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.identifier = input;
            self
        }
        /// <p>Identifier type of the particular resource identifier for event configuration.</p>
        pub fn identifier_type(mut self, input: crate::model::IdentifierType) -> Self {
            self.identifier_type = Some(input);
            self
        }
        /// <p>Identifier type of the particular resource identifier for event configuration.</p>
        pub fn set_identifier_type(
            mut self,
            input: std::option::Option<crate::model::IdentifierType>,
        ) -> Self {
            self.identifier_type = input;
            self
        }
        /// <p>Partner type of the resource if the identifier type is PartnerAccountId.</p>
        pub fn partner_type(mut self, input: crate::model::EventNotificationPartnerType) -> Self {
            self.partner_type = Some(input);
            self
        }
        /// <p>Partner type of the resource if the identifier type is PartnerAccountId.</p>
        pub fn set_partner_type(
            mut self,
            input: std::option::Option<crate::model::EventNotificationPartnerType>,
        ) -> Self {
            self.partner_type = input;
            self
        }
        /// <p>Object of all event configurations and the status of the event topics.</p>
        pub fn events(mut self, input: crate::model::EventNotificationItemConfigurations) -> Self {
            self.events = Some(input);
            self
        }
        /// <p>Object of all event configurations and the status of the event topics.</p>
        pub fn set_events(
            mut self,
            input: std::option::Option<crate::model::EventNotificationItemConfigurations>,
        ) -> Self {
            self.events = input;
            self
        }
        /// Consumes the builder and constructs a [`EventConfigurationItem`](crate::model::EventConfigurationItem).
        pub fn build(self) -> crate::model::EventConfigurationItem {
            crate::model::EventConfigurationItem {
                identifier: self.identifier,
                identifier_type: self.identifier_type,
                partner_type: self.partner_type,
                events: self.events,
            }
        }
    }
}

/// <p>Object of all event configurations and the status of the event topics.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EventNotificationItemConfigurations {
    /// <p>Device registration state event configuration for an event configuration item.</p>
    #[doc(hidden)]
    pub device_registration_state:
        std::option::Option<crate::model::DeviceRegistrationStateEventConfiguration>,
    /// <p>Proximity event configuration for an event configuration item.</p>
    #[doc(hidden)]
    pub proximity: std::option::Option<crate::model::ProximityEventConfiguration>,
    /// <p>Join event configuration for an event configuration item.</p>
    #[doc(hidden)]
    pub join: std::option::Option<crate::model::JoinEventConfiguration>,
    /// <p>Connection status event configuration for an event configuration item.</p>
    #[doc(hidden)]
    pub connection_status: std::option::Option<crate::model::ConnectionStatusEventConfiguration>,
    /// <p>Message delivery status event configuration for an event configuration item.</p>
    #[doc(hidden)]
    pub message_delivery_status:
        std::option::Option<crate::model::MessageDeliveryStatusEventConfiguration>,
}
impl EventNotificationItemConfigurations {
    /// <p>Device registration state event configuration for an event configuration item.</p>
    pub fn device_registration_state(
        &self,
    ) -> std::option::Option<&crate::model::DeviceRegistrationStateEventConfiguration> {
        self.device_registration_state.as_ref()
    }
    /// <p>Proximity event configuration for an event configuration item.</p>
    pub fn proximity(&self) -> std::option::Option<&crate::model::ProximityEventConfiguration> {
        self.proximity.as_ref()
    }
    /// <p>Join event configuration for an event configuration item.</p>
    pub fn join(&self) -> std::option::Option<&crate::model::JoinEventConfiguration> {
        self.join.as_ref()
    }
    /// <p>Connection status event configuration for an event configuration item.</p>
    pub fn connection_status(
        &self,
    ) -> std::option::Option<&crate::model::ConnectionStatusEventConfiguration> {
        self.connection_status.as_ref()
    }
    /// <p>Message delivery status event configuration for an event configuration item.</p>
    pub fn message_delivery_status(
        &self,
    ) -> std::option::Option<&crate::model::MessageDeliveryStatusEventConfiguration> {
        self.message_delivery_status.as_ref()
    }
}
impl EventNotificationItemConfigurations {
    /// Creates a new builder-style object to manufacture [`EventNotificationItemConfigurations`](crate::model::EventNotificationItemConfigurations).
    pub fn builder() -> crate::model::event_notification_item_configurations::Builder {
        crate::model::event_notification_item_configurations::Builder::default()
    }
}

/// See [`EventNotificationItemConfigurations`](crate::model::EventNotificationItemConfigurations).
pub mod event_notification_item_configurations {

    /// A builder for [`EventNotificationItemConfigurations`](crate::model::EventNotificationItemConfigurations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_registration_state:
            std::option::Option<crate::model::DeviceRegistrationStateEventConfiguration>,
        pub(crate) proximity: std::option::Option<crate::model::ProximityEventConfiguration>,
        pub(crate) join: std::option::Option<crate::model::JoinEventConfiguration>,
        pub(crate) connection_status:
            std::option::Option<crate::model::ConnectionStatusEventConfiguration>,
        pub(crate) message_delivery_status:
            std::option::Option<crate::model::MessageDeliveryStatusEventConfiguration>,
    }
    impl Builder {
        /// <p>Device registration state event configuration for an event configuration item.</p>
        pub fn device_registration_state(
            mut self,
            input: crate::model::DeviceRegistrationStateEventConfiguration,
        ) -> Self {
            self.device_registration_state = Some(input);
            self
        }
        /// <p>Device registration state event configuration for an event configuration item.</p>
        pub fn set_device_registration_state(
            mut self,
            input: std::option::Option<crate::model::DeviceRegistrationStateEventConfiguration>,
        ) -> Self {
            self.device_registration_state = input;
            self
        }
        /// <p>Proximity event configuration for an event configuration item.</p>
        pub fn proximity(mut self, input: crate::model::ProximityEventConfiguration) -> Self {
            self.proximity = Some(input);
            self
        }
        /// <p>Proximity event configuration for an event configuration item.</p>
        pub fn set_proximity(
            mut self,
            input: std::option::Option<crate::model::ProximityEventConfiguration>,
        ) -> Self {
            self.proximity = input;
            self
        }
        /// <p>Join event configuration for an event configuration item.</p>
        pub fn join(mut self, input: crate::model::JoinEventConfiguration) -> Self {
            self.join = Some(input);
            self
        }
        /// <p>Join event configuration for an event configuration item.</p>
        pub fn set_join(
            mut self,
            input: std::option::Option<crate::model::JoinEventConfiguration>,
        ) -> Self {
            self.join = input;
            self
        }
        /// <p>Connection status event configuration for an event configuration item.</p>
        pub fn connection_status(
            mut self,
            input: crate::model::ConnectionStatusEventConfiguration,
        ) -> Self {
            self.connection_status = Some(input);
            self
        }
        /// <p>Connection status event configuration for an event configuration item.</p>
        pub fn set_connection_status(
            mut self,
            input: std::option::Option<crate::model::ConnectionStatusEventConfiguration>,
        ) -> Self {
            self.connection_status = input;
            self
        }
        /// <p>Message delivery status event configuration for an event configuration item.</p>
        pub fn message_delivery_status(
            mut self,
            input: crate::model::MessageDeliveryStatusEventConfiguration,
        ) -> Self {
            self.message_delivery_status = Some(input);
            self
        }
        /// <p>Message delivery status event configuration for an event configuration item.</p>
        pub fn set_message_delivery_status(
            mut self,
            input: std::option::Option<crate::model::MessageDeliveryStatusEventConfiguration>,
        ) -> Self {
            self.message_delivery_status = input;
            self
        }
        /// Consumes the builder and constructs a [`EventNotificationItemConfigurations`](crate::model::EventNotificationItemConfigurations).
        pub fn build(self) -> crate::model::EventNotificationItemConfigurations {
            crate::model::EventNotificationItemConfigurations {
                device_registration_state: self.device_registration_state,
                proximity: self.proximity,
                join: self.join,
                connection_status: self.connection_status,
                message_delivery_status: self.message_delivery_status,
            }
        }
    }
}

/// When writing a match expression against `EventNotificationResourceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let eventnotificationresourcetype = unimplemented!();
/// match eventnotificationresourcetype {
///     EventNotificationResourceType::SidewalkAccount => { /* ... */ },
///     EventNotificationResourceType::WirelessDevice => { /* ... */ },
///     EventNotificationResourceType::WirelessGateway => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `eventnotificationresourcetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `EventNotificationResourceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `EventNotificationResourceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `EventNotificationResourceType::NewFeature` is defined.
/// Specifically, when `eventnotificationresourcetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `EventNotificationResourceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum EventNotificationResourceType {
    #[allow(missing_docs)] // documentation missing in model
    SidewalkAccount,
    #[allow(missing_docs)] // documentation missing in model
    WirelessDevice,
    #[allow(missing_docs)] // documentation missing in model
    WirelessGateway,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for EventNotificationResourceType {
    fn from(s: &str) -> Self {
        match s {
            "SidewalkAccount" => EventNotificationResourceType::SidewalkAccount,
            "WirelessDevice" => EventNotificationResourceType::WirelessDevice,
            "WirelessGateway" => EventNotificationResourceType::WirelessGateway,
            other => EventNotificationResourceType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for EventNotificationResourceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(EventNotificationResourceType::from(s))
    }
}
impl EventNotificationResourceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            EventNotificationResourceType::SidewalkAccount => "SidewalkAccount",
            EventNotificationResourceType::WirelessDevice => "WirelessDevice",
            EventNotificationResourceType::WirelessGateway => "WirelessGateway",
            EventNotificationResourceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["SidewalkAccount", "WirelessDevice", "WirelessGateway"]
    }
}
impl AsRef<str> for EventNotificationResourceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a device profile.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DeviceProfile {
    /// <p>The Amazon Resource Name of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the device profile.</p>
    #[doc(hidden)]
    pub id: std::option::Option<std::string::String>,
}
impl DeviceProfile {
    /// <p>The Amazon Resource Name of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The ID of the device profile.</p>
    pub fn id(&self) -> std::option::Option<&str> {
        self.id.as_deref()
    }
}
impl DeviceProfile {
    /// Creates a new builder-style object to manufacture [`DeviceProfile`](crate::model::DeviceProfile).
    pub fn builder() -> crate::model::device_profile::Builder {
        crate::model::device_profile::Builder::default()
    }
}

/// See [`DeviceProfile`](crate::model::DeviceProfile).
pub mod device_profile {

    /// A builder for [`DeviceProfile`](crate::model::DeviceProfile).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The ID of the device profile.</p>
        pub fn id(mut self, input: impl Into<std::string::String>) -> Self {
            self.id = Some(input.into());
            self
        }
        /// <p>The ID of the device profile.</p>
        pub fn set_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.id = input;
            self
        }
        /// Consumes the builder and constructs a [`DeviceProfile`](crate::model::DeviceProfile).
        pub fn build(self) -> crate::model::DeviceProfile {
            crate::model::DeviceProfile {
                arn: self.arn,
                name: self.name,
                id: self.id,
            }
        }
    }
}

/// <p>Describes a destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Destinations {
    /// <p>The Amazon Resource Name of the resource.</p>
    #[doc(hidden)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The name of the resource.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The type of value in <code>Expression</code>.</p>
    #[doc(hidden)]
    pub expression_type: std::option::Option<crate::model::ExpressionType>,
    /// <p>The rule name or topic rule to send messages to.</p>
    #[doc(hidden)]
    pub expression: std::option::Option<std::string::String>,
    /// <p>The description of the resource.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ARN of the IAM Role that authorizes the destination.</p>
    #[doc(hidden)]
    pub role_arn: std::option::Option<std::string::String>,
}
impl Destinations {
    /// <p>The Amazon Resource Name of the resource.</p>
    pub fn arn(&self) -> std::option::Option<&str> {
        self.arn.as_deref()
    }
    /// <p>The name of the resource.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The type of value in <code>Expression</code>.</p>
    pub fn expression_type(&self) -> std::option::Option<&crate::model::ExpressionType> {
        self.expression_type.as_ref()
    }
    /// <p>The rule name or topic rule to send messages to.</p>
    pub fn expression(&self) -> std::option::Option<&str> {
        self.expression.as_deref()
    }
    /// <p>The description of the resource.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The ARN of the IAM Role that authorizes the destination.</p>
    pub fn role_arn(&self) -> std::option::Option<&str> {
        self.role_arn.as_deref()
    }
}
impl Destinations {
    /// Creates a new builder-style object to manufacture [`Destinations`](crate::model::Destinations).
    pub fn builder() -> crate::model::destinations::Builder {
        crate::model::destinations::Builder::default()
    }
}

/// See [`Destinations`](crate::model::Destinations).
pub mod destinations {

    /// A builder for [`Destinations`](crate::model::Destinations).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) arn: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) expression_type: std::option::Option<crate::model::ExpressionType>,
        pub(crate) expression: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) role_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name of the resource.</p>
        pub fn set_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.arn = input;
            self
        }
        /// <p>The name of the resource.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the resource.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The type of value in <code>Expression</code>.</p>
        pub fn expression_type(mut self, input: crate::model::ExpressionType) -> Self {
            self.expression_type = Some(input);
            self
        }
        /// <p>The type of value in <code>Expression</code>.</p>
        pub fn set_expression_type(
            mut self,
            input: std::option::Option<crate::model::ExpressionType>,
        ) -> Self {
            self.expression_type = input;
            self
        }
        /// <p>The rule name or topic rule to send messages to.</p>
        pub fn expression(mut self, input: impl Into<std::string::String>) -> Self {
            self.expression = Some(input.into());
            self
        }
        /// <p>The rule name or topic rule to send messages to.</p>
        pub fn set_expression(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.expression = input;
            self
        }
        /// <p>The description of the resource.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the resource.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The ARN of the IAM Role that authorizes the destination.</p>
        pub fn role_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.role_arn = Some(input.into());
            self
        }
        /// <p>The ARN of the IAM Role that authorizes the destination.</p>
        pub fn set_role_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.role_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`Destinations`](crate::model::Destinations).
        pub fn build(self) -> crate::model::Destinations {
            crate::model::Destinations {
                arn: self.arn,
                name: self.name,
                expression_type: self.expression_type,
                expression: self.expression,
                description: self.description,
                role_arn: self.role_arn,
            }
        }
    }
}

/// <p>UpdateWirelessGatewayTaskCreate object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateWirelessGatewayTaskCreate {
    /// <p>The link to the S3 bucket.</p>
    #[doc(hidden)]
    pub update_data_source: std::option::Option<std::string::String>,
    /// <p>The IAM role used to read data from the S3 bucket.</p>
    #[doc(hidden)]
    pub update_data_role: std::option::Option<std::string::String>,
    /// <p>The properties that relate to the LoRaWAN wireless gateway.</p>
    #[doc(hidden)]
    pub lo_ra_wan: std::option::Option<crate::model::LoRaWanUpdateGatewayTaskCreate>,
}
impl UpdateWirelessGatewayTaskCreate {
    /// <p>The link to the S3 bucket.</p>
    pub fn update_data_source(&self) -> std::option::Option<&str> {
        self.update_data_source.as_deref()
    }
    /// <p>The IAM role used to read data from the S3 bucket.</p>
    pub fn update_data_role(&self) -> std::option::Option<&str> {
        self.update_data_role.as_deref()
    }
    /// <p>The properties that relate to the LoRaWAN wireless gateway.</p>
    pub fn lo_ra_wan(&self) -> std::option::Option<&crate::model::LoRaWanUpdateGatewayTaskCreate> {
        self.lo_ra_wan.as_ref()
    }
}
impl UpdateWirelessGatewayTaskCreate {
    /// Creates a new builder-style object to manufacture [`UpdateWirelessGatewayTaskCreate`](crate::model::UpdateWirelessGatewayTaskCreate).
    pub fn builder() -> crate::model::update_wireless_gateway_task_create::Builder {
        crate::model::update_wireless_gateway_task_create::Builder::default()
    }
}

/// See [`UpdateWirelessGatewayTaskCreate`](crate::model::UpdateWirelessGatewayTaskCreate).
pub mod update_wireless_gateway_task_create {

    /// A builder for [`UpdateWirelessGatewayTaskCreate`](crate::model::UpdateWirelessGatewayTaskCreate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_data_source: std::option::Option<std::string::String>,
        pub(crate) update_data_role: std::option::Option<std::string::String>,
        pub(crate) lo_ra_wan: std::option::Option<crate::model::LoRaWanUpdateGatewayTaskCreate>,
    }
    impl Builder {
        /// <p>The link to the S3 bucket.</p>
        pub fn update_data_source(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_data_source = Some(input.into());
            self
        }
        /// <p>The link to the S3 bucket.</p>
        pub fn set_update_data_source(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.update_data_source = input;
            self
        }
        /// <p>The IAM role used to read data from the S3 bucket.</p>
        pub fn update_data_role(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_data_role = Some(input.into());
            self
        }
        /// <p>The IAM role used to read data from the S3 bucket.</p>
        pub fn set_update_data_role(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.update_data_role = input;
            self
        }
        /// <p>The properties that relate to the LoRaWAN wireless gateway.</p>
        pub fn lo_ra_wan(mut self, input: crate::model::LoRaWanUpdateGatewayTaskCreate) -> Self {
            self.lo_ra_wan = Some(input);
            self
        }
        /// <p>The properties that relate to the LoRaWAN wireless gateway.</p>
        pub fn set_lo_ra_wan(
            mut self,
            input: std::option::Option<crate::model::LoRaWanUpdateGatewayTaskCreate>,
        ) -> Self {
            self.lo_ra_wan = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateWirelessGatewayTaskCreate`](crate::model::UpdateWirelessGatewayTaskCreate).
        pub fn build(self) -> crate::model::UpdateWirelessGatewayTaskCreate {
            crate::model::UpdateWirelessGatewayTaskCreate {
                update_data_source: self.update_data_source,
                update_data_role: self.update_data_role,
                lo_ra_wan: self.lo_ra_wan,
            }
        }
    }
}

/// <p>LoRaWANUpdateGatewayTaskCreate object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanUpdateGatewayTaskCreate {
    /// <p>The signature used to verify the update firmware.</p>
    #[doc(hidden)]
    pub update_signature: std::option::Option<std::string::String>,
    /// <p>The CRC of the signature private key to check.</p>
    #[doc(hidden)]
    pub sig_key_crc: std::option::Option<i64>,
    /// <p>The version of the gateways that should receive the update.</p>
    #[doc(hidden)]
    pub current_version: std::option::Option<crate::model::LoRaWanGatewayVersion>,
    /// <p>The firmware version to update the gateway to.</p>
    #[doc(hidden)]
    pub update_version: std::option::Option<crate::model::LoRaWanGatewayVersion>,
}
impl LoRaWanUpdateGatewayTaskCreate {
    /// <p>The signature used to verify the update firmware.</p>
    pub fn update_signature(&self) -> std::option::Option<&str> {
        self.update_signature.as_deref()
    }
    /// <p>The CRC of the signature private key to check.</p>
    pub fn sig_key_crc(&self) -> std::option::Option<i64> {
        self.sig_key_crc
    }
    /// <p>The version of the gateways that should receive the update.</p>
    pub fn current_version(&self) -> std::option::Option<&crate::model::LoRaWanGatewayVersion> {
        self.current_version.as_ref()
    }
    /// <p>The firmware version to update the gateway to.</p>
    pub fn update_version(&self) -> std::option::Option<&crate::model::LoRaWanGatewayVersion> {
        self.update_version.as_ref()
    }
}
impl LoRaWanUpdateGatewayTaskCreate {
    /// Creates a new builder-style object to manufacture [`LoRaWanUpdateGatewayTaskCreate`](crate::model::LoRaWanUpdateGatewayTaskCreate).
    pub fn builder() -> crate::model::lo_ra_wan_update_gateway_task_create::Builder {
        crate::model::lo_ra_wan_update_gateway_task_create::Builder::default()
    }
}

/// See [`LoRaWanUpdateGatewayTaskCreate`](crate::model::LoRaWanUpdateGatewayTaskCreate).
pub mod lo_ra_wan_update_gateway_task_create {

    /// A builder for [`LoRaWanUpdateGatewayTaskCreate`](crate::model::LoRaWanUpdateGatewayTaskCreate).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_signature: std::option::Option<std::string::String>,
        pub(crate) sig_key_crc: std::option::Option<i64>,
        pub(crate) current_version: std::option::Option<crate::model::LoRaWanGatewayVersion>,
        pub(crate) update_version: std::option::Option<crate::model::LoRaWanGatewayVersion>,
    }
    impl Builder {
        /// <p>The signature used to verify the update firmware.</p>
        pub fn update_signature(mut self, input: impl Into<std::string::String>) -> Self {
            self.update_signature = Some(input.into());
            self
        }
        /// <p>The signature used to verify the update firmware.</p>
        pub fn set_update_signature(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.update_signature = input;
            self
        }
        /// <p>The CRC of the signature private key to check.</p>
        pub fn sig_key_crc(mut self, input: i64) -> Self {
            self.sig_key_crc = Some(input);
            self
        }
        /// <p>The CRC of the signature private key to check.</p>
        pub fn set_sig_key_crc(mut self, input: std::option::Option<i64>) -> Self {
            self.sig_key_crc = input;
            self
        }
        /// <p>The version of the gateways that should receive the update.</p>
        pub fn current_version(mut self, input: crate::model::LoRaWanGatewayVersion) -> Self {
            self.current_version = Some(input);
            self
        }
        /// <p>The version of the gateways that should receive the update.</p>
        pub fn set_current_version(
            mut self,
            input: std::option::Option<crate::model::LoRaWanGatewayVersion>,
        ) -> Self {
            self.current_version = input;
            self
        }
        /// <p>The firmware version to update the gateway to.</p>
        pub fn update_version(mut self, input: crate::model::LoRaWanGatewayVersion) -> Self {
            self.update_version = Some(input);
            self
        }
        /// <p>The firmware version to update the gateway to.</p>
        pub fn set_update_version(
            mut self,
            input: std::option::Option<crate::model::LoRaWanGatewayVersion>,
        ) -> Self {
            self.update_version = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanUpdateGatewayTaskCreate`](crate::model::LoRaWanUpdateGatewayTaskCreate).
        pub fn build(self) -> crate::model::LoRaWanUpdateGatewayTaskCreate {
            crate::model::LoRaWanUpdateGatewayTaskCreate {
                update_signature: self.update_signature,
                sig_key_crc: self.sig_key_crc,
                current_version: self.current_version,
                update_version: self.update_version,
            }
        }
    }
}

/// When writing a match expression against `WirelessGatewayTaskStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wirelessgatewaytaskstatus = unimplemented!();
/// match wirelessgatewaytaskstatus {
///     WirelessGatewayTaskStatus::Completed => { /* ... */ },
///     WirelessGatewayTaskStatus::Failed => { /* ... */ },
///     WirelessGatewayTaskStatus::FirstRetry => { /* ... */ },
///     WirelessGatewayTaskStatus::InProgress => { /* ... */ },
///     WirelessGatewayTaskStatus::Pending => { /* ... */ },
///     WirelessGatewayTaskStatus::SecondRetry => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wirelessgatewaytaskstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WirelessGatewayTaskStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WirelessGatewayTaskStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WirelessGatewayTaskStatus::NewFeature` is defined.
/// Specifically, when `wirelessgatewaytaskstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WirelessGatewayTaskStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WirelessGatewayTaskStatus {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    FirstRetry,
    #[allow(missing_docs)] // documentation missing in model
    InProgress,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    SecondRetry,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WirelessGatewayTaskStatus {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => WirelessGatewayTaskStatus::Completed,
            "FAILED" => WirelessGatewayTaskStatus::Failed,
            "FIRST_RETRY" => WirelessGatewayTaskStatus::FirstRetry,
            "IN_PROGRESS" => WirelessGatewayTaskStatus::InProgress,
            "PENDING" => WirelessGatewayTaskStatus::Pending,
            "SECOND_RETRY" => WirelessGatewayTaskStatus::SecondRetry,
            other => WirelessGatewayTaskStatus::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for WirelessGatewayTaskStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WirelessGatewayTaskStatus::from(s))
    }
}
impl WirelessGatewayTaskStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WirelessGatewayTaskStatus::Completed => "COMPLETED",
            WirelessGatewayTaskStatus::Failed => "FAILED",
            WirelessGatewayTaskStatus::FirstRetry => "FIRST_RETRY",
            WirelessGatewayTaskStatus::InProgress => "IN_PROGRESS",
            WirelessGatewayTaskStatus::Pending => "PENDING",
            WirelessGatewayTaskStatus::SecondRetry => "SECOND_RETRY",
            WirelessGatewayTaskStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "COMPLETED",
            "FAILED",
            "FIRST_RETRY",
            "IN_PROGRESS",
            "PENDING",
            "SECOND_RETRY",
        ]
    }
}
impl AsRef<str> for WirelessGatewayTaskStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ConnectionStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let connectionstatus = unimplemented!();
/// match connectionstatus {
///     ConnectionStatus::Connected => { /* ... */ },
///     ConnectionStatus::Disconnected => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectionstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectionStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectionStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectionStatus::NewFeature` is defined.
/// Specifically, when `connectionstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectionStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectionStatus {
    #[allow(missing_docs)] // documentation missing in model
    Connected,
    #[allow(missing_docs)] // documentation missing in model
    Disconnected,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConnectionStatus {
    fn from(s: &str) -> Self {
        match s {
            "Connected" => ConnectionStatus::Connected,
            "Disconnected" => ConnectionStatus::Disconnected,
            other => ConnectionStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ConnectionStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConnectionStatus::from(s))
    }
}
impl ConnectionStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionStatus::Connected => "Connected",
            ConnectionStatus::Disconnected => "Disconnected",
            ConnectionStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Connected", "Disconnected"]
    }
}
impl AsRef<str> for ConnectionStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>LoRaWANGatewayCurrentVersion object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanGatewayCurrentVersion {
    /// <p>The version of the gateways that should receive the update.</p>
    #[doc(hidden)]
    pub current_version: std::option::Option<crate::model::LoRaWanGatewayVersion>,
}
impl LoRaWanGatewayCurrentVersion {
    /// <p>The version of the gateways that should receive the update.</p>
    pub fn current_version(&self) -> std::option::Option<&crate::model::LoRaWanGatewayVersion> {
        self.current_version.as_ref()
    }
}
impl LoRaWanGatewayCurrentVersion {
    /// Creates a new builder-style object to manufacture [`LoRaWanGatewayCurrentVersion`](crate::model::LoRaWanGatewayCurrentVersion).
    pub fn builder() -> crate::model::lo_ra_wan_gateway_current_version::Builder {
        crate::model::lo_ra_wan_gateway_current_version::Builder::default()
    }
}

/// See [`LoRaWanGatewayCurrentVersion`](crate::model::LoRaWanGatewayCurrentVersion).
pub mod lo_ra_wan_gateway_current_version {

    /// A builder for [`LoRaWanGatewayCurrentVersion`](crate::model::LoRaWanGatewayCurrentVersion).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) current_version: std::option::Option<crate::model::LoRaWanGatewayVersion>,
    }
    impl Builder {
        /// <p>The version of the gateways that should receive the update.</p>
        pub fn current_version(mut self, input: crate::model::LoRaWanGatewayVersion) -> Self {
            self.current_version = Some(input);
            self
        }
        /// <p>The version of the gateways that should receive the update.</p>
        pub fn set_current_version(
            mut self,
            input: std::option::Option<crate::model::LoRaWanGatewayVersion>,
        ) -> Self {
            self.current_version = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanGatewayCurrentVersion`](crate::model::LoRaWanGatewayCurrentVersion).
        pub fn build(self) -> crate::model::LoRaWanGatewayCurrentVersion {
            crate::model::LoRaWanGatewayCurrentVersion {
                current_version: self.current_version,
            }
        }
    }
}

/// When writing a match expression against `WirelessGatewayIdType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wirelessgatewayidtype = unimplemented!();
/// match wirelessgatewayidtype {
///     WirelessGatewayIdType::GatewayEui => { /* ... */ },
///     WirelessGatewayIdType::ThingName => { /* ... */ },
///     WirelessGatewayIdType::WirelessGatewayId => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wirelessgatewayidtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WirelessGatewayIdType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WirelessGatewayIdType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WirelessGatewayIdType::NewFeature` is defined.
/// Specifically, when `wirelessgatewayidtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WirelessGatewayIdType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WirelessGatewayIdType {
    #[allow(missing_docs)] // documentation missing in model
    GatewayEui,
    #[allow(missing_docs)] // documentation missing in model
    ThingName,
    #[allow(missing_docs)] // documentation missing in model
    WirelessGatewayId,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WirelessGatewayIdType {
    fn from(s: &str) -> Self {
        match s {
            "GatewayEui" => WirelessGatewayIdType::GatewayEui,
            "ThingName" => WirelessGatewayIdType::ThingName,
            "WirelessGatewayId" => WirelessGatewayIdType::WirelessGatewayId,
            other => {
                WirelessGatewayIdType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WirelessGatewayIdType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WirelessGatewayIdType::from(s))
    }
}
impl WirelessGatewayIdType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WirelessGatewayIdType::GatewayEui => "GatewayEui",
            WirelessGatewayIdType::ThingName => "ThingName",
            WirelessGatewayIdType::WirelessGatewayId => "WirelessGatewayId",
            WirelessGatewayIdType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["GatewayEui", "ThingName", "WirelessGatewayId"]
    }
}
impl AsRef<str> for WirelessGatewayIdType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>MetaData for Sidewalk device.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SidewalkDeviceMetadata {
    /// <p>The RSSI value.</p>
    #[doc(hidden)]
    pub rssi: std::option::Option<i32>,
    /// <p>Sidewalk device battery level.</p>
    #[doc(hidden)]
    pub battery_level: std::option::Option<crate::model::BatteryLevel>,
    /// <p>Sidewalk device status notification.</p>
    #[doc(hidden)]
    pub event: std::option::Option<crate::model::Event>,
    /// <p>Device state defines the device status of sidewalk device.</p>
    #[doc(hidden)]
    pub device_state: std::option::Option<crate::model::DeviceState>,
}
impl SidewalkDeviceMetadata {
    /// <p>The RSSI value.</p>
    pub fn rssi(&self) -> std::option::Option<i32> {
        self.rssi
    }
    /// <p>Sidewalk device battery level.</p>
    pub fn battery_level(&self) -> std::option::Option<&crate::model::BatteryLevel> {
        self.battery_level.as_ref()
    }
    /// <p>Sidewalk device status notification.</p>
    pub fn event(&self) -> std::option::Option<&crate::model::Event> {
        self.event.as_ref()
    }
    /// <p>Device state defines the device status of sidewalk device.</p>
    pub fn device_state(&self) -> std::option::Option<&crate::model::DeviceState> {
        self.device_state.as_ref()
    }
}
impl SidewalkDeviceMetadata {
    /// Creates a new builder-style object to manufacture [`SidewalkDeviceMetadata`](crate::model::SidewalkDeviceMetadata).
    pub fn builder() -> crate::model::sidewalk_device_metadata::Builder {
        crate::model::sidewalk_device_metadata::Builder::default()
    }
}

/// See [`SidewalkDeviceMetadata`](crate::model::SidewalkDeviceMetadata).
pub mod sidewalk_device_metadata {

    /// A builder for [`SidewalkDeviceMetadata`](crate::model::SidewalkDeviceMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rssi: std::option::Option<i32>,
        pub(crate) battery_level: std::option::Option<crate::model::BatteryLevel>,
        pub(crate) event: std::option::Option<crate::model::Event>,
        pub(crate) device_state: std::option::Option<crate::model::DeviceState>,
    }
    impl Builder {
        /// <p>The RSSI value.</p>
        pub fn rssi(mut self, input: i32) -> Self {
            self.rssi = Some(input);
            self
        }
        /// <p>The RSSI value.</p>
        pub fn set_rssi(mut self, input: std::option::Option<i32>) -> Self {
            self.rssi = input;
            self
        }
        /// <p>Sidewalk device battery level.</p>
        pub fn battery_level(mut self, input: crate::model::BatteryLevel) -> Self {
            self.battery_level = Some(input);
            self
        }
        /// <p>Sidewalk device battery level.</p>
        pub fn set_battery_level(
            mut self,
            input: std::option::Option<crate::model::BatteryLevel>,
        ) -> Self {
            self.battery_level = input;
            self
        }
        /// <p>Sidewalk device status notification.</p>
        pub fn event(mut self, input: crate::model::Event) -> Self {
            self.event = Some(input);
            self
        }
        /// <p>Sidewalk device status notification.</p>
        pub fn set_event(mut self, input: std::option::Option<crate::model::Event>) -> Self {
            self.event = input;
            self
        }
        /// <p>Device state defines the device status of sidewalk device.</p>
        pub fn device_state(mut self, input: crate::model::DeviceState) -> Self {
            self.device_state = Some(input);
            self
        }
        /// <p>Device state defines the device status of sidewalk device.</p>
        pub fn set_device_state(
            mut self,
            input: std::option::Option<crate::model::DeviceState>,
        ) -> Self {
            self.device_state = input;
            self
        }
        /// Consumes the builder and constructs a [`SidewalkDeviceMetadata`](crate::model::SidewalkDeviceMetadata).
        pub fn build(self) -> crate::model::SidewalkDeviceMetadata {
            crate::model::SidewalkDeviceMetadata {
                rssi: self.rssi,
                battery_level: self.battery_level,
                event: self.event,
                device_state: self.device_state,
            }
        }
    }
}

/// When writing a match expression against `DeviceState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let devicestate = unimplemented!();
/// match devicestate {
///     DeviceState::Provisioned => { /* ... */ },
///     DeviceState::Registerednotseen => { /* ... */ },
///     DeviceState::Registeredreachable => { /* ... */ },
///     DeviceState::Registeredunreachable => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `devicestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeviceState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeviceState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeviceState::NewFeature` is defined.
/// Specifically, when `devicestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeviceState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Device state defines the device status of sidewalk device.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeviceState {
    #[allow(missing_docs)] // documentation missing in model
    Provisioned,
    #[allow(missing_docs)] // documentation missing in model
    Registerednotseen,
    #[allow(missing_docs)] // documentation missing in model
    Registeredreachable,
    #[allow(missing_docs)] // documentation missing in model
    Registeredunreachable,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeviceState {
    fn from(s: &str) -> Self {
        match s {
            "Provisioned" => DeviceState::Provisioned,
            "RegisteredNotSeen" => DeviceState::Registerednotseen,
            "RegisteredReachable" => DeviceState::Registeredreachable,
            "RegisteredUnreachable" => DeviceState::Registeredunreachable,
            other => DeviceState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for DeviceState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeviceState::from(s))
    }
}
impl DeviceState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeviceState::Provisioned => "Provisioned",
            DeviceState::Registerednotseen => "RegisteredNotSeen",
            DeviceState::Registeredreachable => "RegisteredReachable",
            DeviceState::Registeredunreachable => "RegisteredUnreachable",
            DeviceState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Provisioned",
            "RegisteredNotSeen",
            "RegisteredReachable",
            "RegisteredUnreachable",
        ]
    }
}
impl AsRef<str> for DeviceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Event`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let event = unimplemented!();
/// match event {
///     Event::Ack => { /* ... */ },
///     Event::Discovered => { /* ... */ },
///     Event::Lost => { /* ... */ },
///     Event::Nack => { /* ... */ },
///     Event::Passthrough => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `event` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Event::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Event::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Event::NewFeature` is defined.
/// Specifically, when `event` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Event::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Sidewalk device status notification.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Event {
    #[allow(missing_docs)] // documentation missing in model
    Ack,
    #[allow(missing_docs)] // documentation missing in model
    Discovered,
    #[allow(missing_docs)] // documentation missing in model
    Lost,
    #[allow(missing_docs)] // documentation missing in model
    Nack,
    #[allow(missing_docs)] // documentation missing in model
    Passthrough,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Event {
    fn from(s: &str) -> Self {
        match s {
            "ack" => Event::Ack,
            "discovered" => Event::Discovered,
            "lost" => Event::Lost,
            "nack" => Event::Nack,
            "passthrough" => Event::Passthrough,
            other => Event::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Event {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Event::from(s))
    }
}
impl Event {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Event::Ack => "ack",
            Event::Discovered => "discovered",
            Event::Lost => "lost",
            Event::Nack => "nack",
            Event::Passthrough => "passthrough",
            Event::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ack", "discovered", "lost", "nack", "passthrough"]
    }
}
impl AsRef<str> for Event {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `BatteryLevel`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let batterylevel = unimplemented!();
/// match batterylevel {
///     BatteryLevel::Critical => { /* ... */ },
///     BatteryLevel::Low => { /* ... */ },
///     BatteryLevel::Normal => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `batterylevel` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BatteryLevel::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BatteryLevel::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BatteryLevel::NewFeature` is defined.
/// Specifically, when `batterylevel` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BatteryLevel::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>Sidewalk device battery level.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BatteryLevel {
    #[allow(missing_docs)] // documentation missing in model
    Critical,
    #[allow(missing_docs)] // documentation missing in model
    Low,
    #[allow(missing_docs)] // documentation missing in model
    Normal,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BatteryLevel {
    fn from(s: &str) -> Self {
        match s {
            "critical" => BatteryLevel::Critical,
            "low" => BatteryLevel::Low,
            "normal" => BatteryLevel::Normal,
            other => BatteryLevel::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BatteryLevel {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BatteryLevel::from(s))
    }
}
impl BatteryLevel {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BatteryLevel::Critical => "critical",
            BatteryLevel::Low => "low",
            BatteryLevel::Normal => "normal",
            BatteryLevel::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["critical", "low", "normal"]
    }
}
impl AsRef<str> for BatteryLevel {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>LoRaWAN device metatdata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanDeviceMetadata {
    /// <p>The DevEUI value.</p>
    #[doc(hidden)]
    pub dev_eui: std::option::Option<std::string::String>,
    /// <p>The FPort value.</p>
    #[doc(hidden)]
    pub f_port: std::option::Option<i32>,
    /// <p>The DataRate value.</p>
    #[doc(hidden)]
    pub data_rate: std::option::Option<i32>,
    /// <p>The device's channel frequency in Hz.</p>
    #[doc(hidden)]
    pub frequency: std::option::Option<i32>,
    /// <p>The date and time of the metadata.</p>
    #[doc(hidden)]
    pub timestamp: std::option::Option<std::string::String>,
    /// <p>Information about the gateways accessed by the device.</p>
    #[doc(hidden)]
    pub gateways: std::option::Option<std::vec::Vec<crate::model::LoRaWanGatewayMetadata>>,
}
impl LoRaWanDeviceMetadata {
    /// <p>The DevEUI value.</p>
    pub fn dev_eui(&self) -> std::option::Option<&str> {
        self.dev_eui.as_deref()
    }
    /// <p>The FPort value.</p>
    pub fn f_port(&self) -> std::option::Option<i32> {
        self.f_port
    }
    /// <p>The DataRate value.</p>
    pub fn data_rate(&self) -> std::option::Option<i32> {
        self.data_rate
    }
    /// <p>The device's channel frequency in Hz.</p>
    pub fn frequency(&self) -> std::option::Option<i32> {
        self.frequency
    }
    /// <p>The date and time of the metadata.</p>
    pub fn timestamp(&self) -> std::option::Option<&str> {
        self.timestamp.as_deref()
    }
    /// <p>Information about the gateways accessed by the device.</p>
    pub fn gateways(&self) -> std::option::Option<&[crate::model::LoRaWanGatewayMetadata]> {
        self.gateways.as_deref()
    }
}
impl LoRaWanDeviceMetadata {
    /// Creates a new builder-style object to manufacture [`LoRaWanDeviceMetadata`](crate::model::LoRaWanDeviceMetadata).
    pub fn builder() -> crate::model::lo_ra_wan_device_metadata::Builder {
        crate::model::lo_ra_wan_device_metadata::Builder::default()
    }
}

/// See [`LoRaWanDeviceMetadata`](crate::model::LoRaWanDeviceMetadata).
pub mod lo_ra_wan_device_metadata {

    /// A builder for [`LoRaWanDeviceMetadata`](crate::model::LoRaWanDeviceMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dev_eui: std::option::Option<std::string::String>,
        pub(crate) f_port: std::option::Option<i32>,
        pub(crate) data_rate: std::option::Option<i32>,
        pub(crate) frequency: std::option::Option<i32>,
        pub(crate) timestamp: std::option::Option<std::string::String>,
        pub(crate) gateways:
            std::option::Option<std::vec::Vec<crate::model::LoRaWanGatewayMetadata>>,
    }
    impl Builder {
        /// <p>The DevEUI value.</p>
        pub fn dev_eui(mut self, input: impl Into<std::string::String>) -> Self {
            self.dev_eui = Some(input.into());
            self
        }
        /// <p>The DevEUI value.</p>
        pub fn set_dev_eui(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dev_eui = input;
            self
        }
        /// <p>The FPort value.</p>
        pub fn f_port(mut self, input: i32) -> Self {
            self.f_port = Some(input);
            self
        }
        /// <p>The FPort value.</p>
        pub fn set_f_port(mut self, input: std::option::Option<i32>) -> Self {
            self.f_port = input;
            self
        }
        /// <p>The DataRate value.</p>
        pub fn data_rate(mut self, input: i32) -> Self {
            self.data_rate = Some(input);
            self
        }
        /// <p>The DataRate value.</p>
        pub fn set_data_rate(mut self, input: std::option::Option<i32>) -> Self {
            self.data_rate = input;
            self
        }
        /// <p>The device's channel frequency in Hz.</p>
        pub fn frequency(mut self, input: i32) -> Self {
            self.frequency = Some(input);
            self
        }
        /// <p>The device's channel frequency in Hz.</p>
        pub fn set_frequency(mut self, input: std::option::Option<i32>) -> Self {
            self.frequency = input;
            self
        }
        /// <p>The date and time of the metadata.</p>
        pub fn timestamp(mut self, input: impl Into<std::string::String>) -> Self {
            self.timestamp = Some(input.into());
            self
        }
        /// <p>The date and time of the metadata.</p>
        pub fn set_timestamp(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.timestamp = input;
            self
        }
        /// Appends an item to `gateways`.
        ///
        /// To override the contents of this collection use [`set_gateways`](Self::set_gateways).
        ///
        /// <p>Information about the gateways accessed by the device.</p>
        pub fn gateways(mut self, input: crate::model::LoRaWanGatewayMetadata) -> Self {
            let mut v = self.gateways.unwrap_or_default();
            v.push(input);
            self.gateways = Some(v);
            self
        }
        /// <p>Information about the gateways accessed by the device.</p>
        pub fn set_gateways(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LoRaWanGatewayMetadata>>,
        ) -> Self {
            self.gateways = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanDeviceMetadata`](crate::model::LoRaWanDeviceMetadata).
        pub fn build(self) -> crate::model::LoRaWanDeviceMetadata {
            crate::model::LoRaWanDeviceMetadata {
                dev_eui: self.dev_eui,
                f_port: self.f_port,
                data_rate: self.data_rate,
                frequency: self.frequency,
                timestamp: self.timestamp,
                gateways: self.gateways,
            }
        }
    }
}

/// <p>LoRaWAN gateway metatdata.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanGatewayMetadata {
    /// <p>The gateway's EUI value.</p>
    #[doc(hidden)]
    pub gateway_eui: std::option::Option<std::string::String>,
    /// <p>The SNR value.</p>
    #[doc(hidden)]
    pub snr: std::option::Option<f64>,
    /// <p>The RSSI value.</p>
    #[doc(hidden)]
    pub rssi: std::option::Option<f64>,
}
impl LoRaWanGatewayMetadata {
    /// <p>The gateway's EUI value.</p>
    pub fn gateway_eui(&self) -> std::option::Option<&str> {
        self.gateway_eui.as_deref()
    }
    /// <p>The SNR value.</p>
    pub fn snr(&self) -> std::option::Option<f64> {
        self.snr
    }
    /// <p>The RSSI value.</p>
    pub fn rssi(&self) -> std::option::Option<f64> {
        self.rssi
    }
}
impl LoRaWanGatewayMetadata {
    /// Creates a new builder-style object to manufacture [`LoRaWanGatewayMetadata`](crate::model::LoRaWanGatewayMetadata).
    pub fn builder() -> crate::model::lo_ra_wan_gateway_metadata::Builder {
        crate::model::lo_ra_wan_gateway_metadata::Builder::default()
    }
}

/// See [`LoRaWanGatewayMetadata`](crate::model::LoRaWanGatewayMetadata).
pub mod lo_ra_wan_gateway_metadata {

    /// A builder for [`LoRaWanGatewayMetadata`](crate::model::LoRaWanGatewayMetadata).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gateway_eui: std::option::Option<std::string::String>,
        pub(crate) snr: std::option::Option<f64>,
        pub(crate) rssi: std::option::Option<f64>,
    }
    impl Builder {
        /// <p>The gateway's EUI value.</p>
        pub fn gateway_eui(mut self, input: impl Into<std::string::String>) -> Self {
            self.gateway_eui = Some(input.into());
            self
        }
        /// <p>The gateway's EUI value.</p>
        pub fn set_gateway_eui(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gateway_eui = input;
            self
        }
        /// <p>The SNR value.</p>
        pub fn snr(mut self, input: f64) -> Self {
            self.snr = Some(input);
            self
        }
        /// <p>The SNR value.</p>
        pub fn set_snr(mut self, input: std::option::Option<f64>) -> Self {
            self.snr = input;
            self
        }
        /// <p>The RSSI value.</p>
        pub fn rssi(mut self, input: f64) -> Self {
            self.rssi = Some(input);
            self
        }
        /// <p>The RSSI value.</p>
        pub fn set_rssi(mut self, input: std::option::Option<f64>) -> Self {
            self.rssi = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanGatewayMetadata`](crate::model::LoRaWanGatewayMetadata).
        pub fn build(self) -> crate::model::LoRaWanGatewayMetadata {
            crate::model::LoRaWanGatewayMetadata {
                gateway_eui: self.gateway_eui,
                snr: self.snr,
                rssi: self.rssi,
            }
        }
    }
}

/// <p>Sidewalk device object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SidewalkDevice {
    /// <p>The Sidewalk Amazon ID.</p>
    #[doc(hidden)]
    pub amazon_id: std::option::Option<std::string::String>,
    /// <p>The sidewalk device identification.</p>
    #[doc(hidden)]
    pub sidewalk_id: std::option::Option<std::string::String>,
    /// <p>The Sidewalk manufacturing series number.</p>
    #[doc(hidden)]
    pub sidewalk_manufacturing_sn: std::option::Option<std::string::String>,
    /// <p>The sidewalk device certificates for Ed25519 and P256r1.</p>
    #[doc(hidden)]
    pub device_certificates: std::option::Option<std::vec::Vec<crate::model::CertificateList>>,
}
impl SidewalkDevice {
    /// <p>The Sidewalk Amazon ID.</p>
    pub fn amazon_id(&self) -> std::option::Option<&str> {
        self.amazon_id.as_deref()
    }
    /// <p>The sidewalk device identification.</p>
    pub fn sidewalk_id(&self) -> std::option::Option<&str> {
        self.sidewalk_id.as_deref()
    }
    /// <p>The Sidewalk manufacturing series number.</p>
    pub fn sidewalk_manufacturing_sn(&self) -> std::option::Option<&str> {
        self.sidewalk_manufacturing_sn.as_deref()
    }
    /// <p>The sidewalk device certificates for Ed25519 and P256r1.</p>
    pub fn device_certificates(&self) -> std::option::Option<&[crate::model::CertificateList]> {
        self.device_certificates.as_deref()
    }
}
impl SidewalkDevice {
    /// Creates a new builder-style object to manufacture [`SidewalkDevice`](crate::model::SidewalkDevice).
    pub fn builder() -> crate::model::sidewalk_device::Builder {
        crate::model::sidewalk_device::Builder::default()
    }
}

/// See [`SidewalkDevice`](crate::model::SidewalkDevice).
pub mod sidewalk_device {

    /// A builder for [`SidewalkDevice`](crate::model::SidewalkDevice).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) amazon_id: std::option::Option<std::string::String>,
        pub(crate) sidewalk_id: std::option::Option<std::string::String>,
        pub(crate) sidewalk_manufacturing_sn: std::option::Option<std::string::String>,
        pub(crate) device_certificates:
            std::option::Option<std::vec::Vec<crate::model::CertificateList>>,
    }
    impl Builder {
        /// <p>The Sidewalk Amazon ID.</p>
        pub fn amazon_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.amazon_id = Some(input.into());
            self
        }
        /// <p>The Sidewalk Amazon ID.</p>
        pub fn set_amazon_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amazon_id = input;
            self
        }
        /// <p>The sidewalk device identification.</p>
        pub fn sidewalk_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.sidewalk_id = Some(input.into());
            self
        }
        /// <p>The sidewalk device identification.</p>
        pub fn set_sidewalk_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.sidewalk_id = input;
            self
        }
        /// <p>The Sidewalk manufacturing series number.</p>
        pub fn sidewalk_manufacturing_sn(mut self, input: impl Into<std::string::String>) -> Self {
            self.sidewalk_manufacturing_sn = Some(input.into());
            self
        }
        /// <p>The Sidewalk manufacturing series number.</p>
        pub fn set_sidewalk_manufacturing_sn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.sidewalk_manufacturing_sn = input;
            self
        }
        /// Appends an item to `device_certificates`.
        ///
        /// To override the contents of this collection use [`set_device_certificates`](Self::set_device_certificates).
        ///
        /// <p>The sidewalk device certificates for Ed25519 and P256r1.</p>
        pub fn device_certificates(mut self, input: crate::model::CertificateList) -> Self {
            let mut v = self.device_certificates.unwrap_or_default();
            v.push(input);
            self.device_certificates = Some(v);
            self
        }
        /// <p>The sidewalk device certificates for Ed25519 and P256r1.</p>
        pub fn set_device_certificates(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CertificateList>>,
        ) -> Self {
            self.device_certificates = input;
            self
        }
        /// Consumes the builder and constructs a [`SidewalkDevice`](crate::model::SidewalkDevice).
        pub fn build(self) -> crate::model::SidewalkDevice {
            crate::model::SidewalkDevice {
                amazon_id: self.amazon_id,
                sidewalk_id: self.sidewalk_id,
                sidewalk_manufacturing_sn: self.sidewalk_manufacturing_sn,
                device_certificates: self.device_certificates,
            }
        }
    }
}

/// <p>LoRaWAN object for create functions.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanDevice {
    /// <p>The DevEUI value.</p>
    #[doc(hidden)]
    pub dev_eui: std::option::Option<std::string::String>,
    /// <p>The ID of the device profile for the new wireless device.</p>
    #[doc(hidden)]
    pub device_profile_id: std::option::Option<std::string::String>,
    /// <p>The ID of the service profile.</p>
    #[doc(hidden)]
    pub service_profile_id: std::option::Option<std::string::String>,
    /// <p>OTAA device object for v1.1 for create APIs</p>
    #[doc(hidden)]
    pub otaa_v1_1: std::option::Option<crate::model::OtaaV11>,
    /// <p>OTAA device object for create APIs for v1.0.x</p>
    #[doc(hidden)]
    pub otaa_v1_0_x: std::option::Option<crate::model::OtaaV10X>,
    /// <p>ABP device object for create APIs for v1.1</p>
    #[doc(hidden)]
    pub abp_v1_1: std::option::Option<crate::model::AbpV11>,
    /// <p>LoRaWAN object for create APIs</p>
    #[doc(hidden)]
    pub abp_v1_0_x: std::option::Option<crate::model::AbpV10X>,
    /// <p>List of FPort assigned for different LoRaWAN application packages to use</p>
    #[doc(hidden)]
    pub f_ports: std::option::Option<crate::model::FPorts>,
}
impl LoRaWanDevice {
    /// <p>The DevEUI value.</p>
    pub fn dev_eui(&self) -> std::option::Option<&str> {
        self.dev_eui.as_deref()
    }
    /// <p>The ID of the device profile for the new wireless device.</p>
    pub fn device_profile_id(&self) -> std::option::Option<&str> {
        self.device_profile_id.as_deref()
    }
    /// <p>The ID of the service profile.</p>
    pub fn service_profile_id(&self) -> std::option::Option<&str> {
        self.service_profile_id.as_deref()
    }
    /// <p>OTAA device object for v1.1 for create APIs</p>
    pub fn otaa_v1_1(&self) -> std::option::Option<&crate::model::OtaaV11> {
        self.otaa_v1_1.as_ref()
    }
    /// <p>OTAA device object for create APIs for v1.0.x</p>
    pub fn otaa_v1_0_x(&self) -> std::option::Option<&crate::model::OtaaV10X> {
        self.otaa_v1_0_x.as_ref()
    }
    /// <p>ABP device object for create APIs for v1.1</p>
    pub fn abp_v1_1(&self) -> std::option::Option<&crate::model::AbpV11> {
        self.abp_v1_1.as_ref()
    }
    /// <p>LoRaWAN object for create APIs</p>
    pub fn abp_v1_0_x(&self) -> std::option::Option<&crate::model::AbpV10X> {
        self.abp_v1_0_x.as_ref()
    }
    /// <p>List of FPort assigned for different LoRaWAN application packages to use</p>
    pub fn f_ports(&self) -> std::option::Option<&crate::model::FPorts> {
        self.f_ports.as_ref()
    }
}
impl LoRaWanDevice {
    /// Creates a new builder-style object to manufacture [`LoRaWanDevice`](crate::model::LoRaWanDevice).
    pub fn builder() -> crate::model::lo_ra_wan_device::Builder {
        crate::model::lo_ra_wan_device::Builder::default()
    }
}

/// See [`LoRaWanDevice`](crate::model::LoRaWanDevice).
pub mod lo_ra_wan_device {

    /// A builder for [`LoRaWanDevice`](crate::model::LoRaWanDevice).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dev_eui: std::option::Option<std::string::String>,
        pub(crate) device_profile_id: std::option::Option<std::string::String>,
        pub(crate) service_profile_id: std::option::Option<std::string::String>,
        pub(crate) otaa_v1_1: std::option::Option<crate::model::OtaaV11>,
        pub(crate) otaa_v1_0_x: std::option::Option<crate::model::OtaaV10X>,
        pub(crate) abp_v1_1: std::option::Option<crate::model::AbpV11>,
        pub(crate) abp_v1_0_x: std::option::Option<crate::model::AbpV10X>,
        pub(crate) f_ports: std::option::Option<crate::model::FPorts>,
    }
    impl Builder {
        /// <p>The DevEUI value.</p>
        pub fn dev_eui(mut self, input: impl Into<std::string::String>) -> Self {
            self.dev_eui = Some(input.into());
            self
        }
        /// <p>The DevEUI value.</p>
        pub fn set_dev_eui(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dev_eui = input;
            self
        }
        /// <p>The ID of the device profile for the new wireless device.</p>
        pub fn device_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.device_profile_id = Some(input.into());
            self
        }
        /// <p>The ID of the device profile for the new wireless device.</p>
        pub fn set_device_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.device_profile_id = input;
            self
        }
        /// <p>The ID of the service profile.</p>
        pub fn service_profile_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.service_profile_id = Some(input.into());
            self
        }
        /// <p>The ID of the service profile.</p>
        pub fn set_service_profile_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.service_profile_id = input;
            self
        }
        /// <p>OTAA device object for v1.1 for create APIs</p>
        pub fn otaa_v1_1(mut self, input: crate::model::OtaaV11) -> Self {
            self.otaa_v1_1 = Some(input);
            self
        }
        /// <p>OTAA device object for v1.1 for create APIs</p>
        pub fn set_otaa_v1_1(mut self, input: std::option::Option<crate::model::OtaaV11>) -> Self {
            self.otaa_v1_1 = input;
            self
        }
        /// <p>OTAA device object for create APIs for v1.0.x</p>
        pub fn otaa_v1_0_x(mut self, input: crate::model::OtaaV10X) -> Self {
            self.otaa_v1_0_x = Some(input);
            self
        }
        /// <p>OTAA device object for create APIs for v1.0.x</p>
        pub fn set_otaa_v1_0_x(
            mut self,
            input: std::option::Option<crate::model::OtaaV10X>,
        ) -> Self {
            self.otaa_v1_0_x = input;
            self
        }
        /// <p>ABP device object for create APIs for v1.1</p>
        pub fn abp_v1_1(mut self, input: crate::model::AbpV11) -> Self {
            self.abp_v1_1 = Some(input);
            self
        }
        /// <p>ABP device object for create APIs for v1.1</p>
        pub fn set_abp_v1_1(mut self, input: std::option::Option<crate::model::AbpV11>) -> Self {
            self.abp_v1_1 = input;
            self
        }
        /// <p>LoRaWAN object for create APIs</p>
        pub fn abp_v1_0_x(mut self, input: crate::model::AbpV10X) -> Self {
            self.abp_v1_0_x = Some(input);
            self
        }
        /// <p>LoRaWAN object for create APIs</p>
        pub fn set_abp_v1_0_x(mut self, input: std::option::Option<crate::model::AbpV10X>) -> Self {
            self.abp_v1_0_x = input;
            self
        }
        /// <p>List of FPort assigned for different LoRaWAN application packages to use</p>
        pub fn f_ports(mut self, input: crate::model::FPorts) -> Self {
            self.f_ports = Some(input);
            self
        }
        /// <p>List of FPort assigned for different LoRaWAN application packages to use</p>
        pub fn set_f_ports(mut self, input: std::option::Option<crate::model::FPorts>) -> Self {
            self.f_ports = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanDevice`](crate::model::LoRaWanDevice).
        pub fn build(self) -> crate::model::LoRaWanDevice {
            crate::model::LoRaWanDevice {
                dev_eui: self.dev_eui,
                device_profile_id: self.device_profile_id,
                service_profile_id: self.service_profile_id,
                otaa_v1_1: self.otaa_v1_1,
                otaa_v1_0_x: self.otaa_v1_0_x,
                abp_v1_1: self.abp_v1_1,
                abp_v1_0_x: self.abp_v1_0_x,
                f_ports: self.f_ports,
            }
        }
    }
}

/// <p>List of FPort assigned for different LoRaWAN application packages to use</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FPorts {
    /// <p>The Fport value.</p>
    #[doc(hidden)]
    pub fuota: std::option::Option<i32>,
    /// <p>The Fport value.</p>
    #[doc(hidden)]
    pub multicast: std::option::Option<i32>,
    /// <p>The Fport value.</p>
    #[doc(hidden)]
    pub clock_sync: std::option::Option<i32>,
    /// <p>FPort values for the GNSS, stream, and ClockSync functions of the positioning information.</p>
    #[doc(hidden)]
    pub positioning: std::option::Option<crate::model::Positioning>,
    /// <p>Optional LoRaWAN application information, which can be used for geolocation.</p>
    #[doc(hidden)]
    pub applications: std::option::Option<std::vec::Vec<crate::model::ApplicationConfig>>,
}
impl FPorts {
    /// <p>The Fport value.</p>
    pub fn fuota(&self) -> std::option::Option<i32> {
        self.fuota
    }
    /// <p>The Fport value.</p>
    pub fn multicast(&self) -> std::option::Option<i32> {
        self.multicast
    }
    /// <p>The Fport value.</p>
    pub fn clock_sync(&self) -> std::option::Option<i32> {
        self.clock_sync
    }
    /// <p>FPort values for the GNSS, stream, and ClockSync functions of the positioning information.</p>
    pub fn positioning(&self) -> std::option::Option<&crate::model::Positioning> {
        self.positioning.as_ref()
    }
    /// <p>Optional LoRaWAN application information, which can be used for geolocation.</p>
    pub fn applications(&self) -> std::option::Option<&[crate::model::ApplicationConfig]> {
        self.applications.as_deref()
    }
}
impl FPorts {
    /// Creates a new builder-style object to manufacture [`FPorts`](crate::model::FPorts).
    pub fn builder() -> crate::model::f_ports::Builder {
        crate::model::f_ports::Builder::default()
    }
}

/// See [`FPorts`](crate::model::FPorts).
pub mod f_ports {

    /// A builder for [`FPorts`](crate::model::FPorts).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) fuota: std::option::Option<i32>,
        pub(crate) multicast: std::option::Option<i32>,
        pub(crate) clock_sync: std::option::Option<i32>,
        pub(crate) positioning: std::option::Option<crate::model::Positioning>,
        pub(crate) applications:
            std::option::Option<std::vec::Vec<crate::model::ApplicationConfig>>,
    }
    impl Builder {
        /// <p>The Fport value.</p>
        pub fn fuota(mut self, input: i32) -> Self {
            self.fuota = Some(input);
            self
        }
        /// <p>The Fport value.</p>
        pub fn set_fuota(mut self, input: std::option::Option<i32>) -> Self {
            self.fuota = input;
            self
        }
        /// <p>The Fport value.</p>
        pub fn multicast(mut self, input: i32) -> Self {
            self.multicast = Some(input);
            self
        }
        /// <p>The Fport value.</p>
        pub fn set_multicast(mut self, input: std::option::Option<i32>) -> Self {
            self.multicast = input;
            self
        }
        /// <p>The Fport value.</p>
        pub fn clock_sync(mut self, input: i32) -> Self {
            self.clock_sync = Some(input);
            self
        }
        /// <p>The Fport value.</p>
        pub fn set_clock_sync(mut self, input: std::option::Option<i32>) -> Self {
            self.clock_sync = input;
            self
        }
        /// <p>FPort values for the GNSS, stream, and ClockSync functions of the positioning information.</p>
        pub fn positioning(mut self, input: crate::model::Positioning) -> Self {
            self.positioning = Some(input);
            self
        }
        /// <p>FPort values for the GNSS, stream, and ClockSync functions of the positioning information.</p>
        pub fn set_positioning(
            mut self,
            input: std::option::Option<crate::model::Positioning>,
        ) -> Self {
            self.positioning = input;
            self
        }
        /// Appends an item to `applications`.
        ///
        /// To override the contents of this collection use [`set_applications`](Self::set_applications).
        ///
        /// <p>Optional LoRaWAN application information, which can be used for geolocation.</p>
        pub fn applications(mut self, input: crate::model::ApplicationConfig) -> Self {
            let mut v = self.applications.unwrap_or_default();
            v.push(input);
            self.applications = Some(v);
            self
        }
        /// <p>Optional LoRaWAN application information, which can be used for geolocation.</p>
        pub fn set_applications(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ApplicationConfig>>,
        ) -> Self {
            self.applications = input;
            self
        }
        /// Consumes the builder and constructs a [`FPorts`](crate::model::FPorts).
        pub fn build(self) -> crate::model::FPorts {
            crate::model::FPorts {
                fuota: self.fuota,
                multicast: self.multicast,
                clock_sync: self.clock_sync,
                positioning: self.positioning,
                applications: self.applications,
            }
        }
    }
}

/// <p>ABP device object for LoRaWAN specification v1.0.x</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AbpV10X {
    /// <p>The DevAddr value.</p>
    #[doc(hidden)]
    pub dev_addr: std::option::Option<std::string::String>,
    /// <p>Session keys for ABP v1.0.x</p>
    #[doc(hidden)]
    pub session_keys: std::option::Option<crate::model::SessionKeysAbpV10X>,
    /// <p>The FCnt init value.</p>
    #[doc(hidden)]
    pub f_cnt_start: std::option::Option<i32>,
}
impl AbpV10X {
    /// <p>The DevAddr value.</p>
    pub fn dev_addr(&self) -> std::option::Option<&str> {
        self.dev_addr.as_deref()
    }
    /// <p>Session keys for ABP v1.0.x</p>
    pub fn session_keys(&self) -> std::option::Option<&crate::model::SessionKeysAbpV10X> {
        self.session_keys.as_ref()
    }
    /// <p>The FCnt init value.</p>
    pub fn f_cnt_start(&self) -> std::option::Option<i32> {
        self.f_cnt_start
    }
}
impl AbpV10X {
    /// Creates a new builder-style object to manufacture [`AbpV10X`](crate::model::AbpV10X).
    pub fn builder() -> crate::model::abp_v10_x::Builder {
        crate::model::abp_v10_x::Builder::default()
    }
}

/// See [`AbpV10X`](crate::model::AbpV10X).
pub mod abp_v10_x {

    /// A builder for [`AbpV10X`](crate::model::AbpV10X).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dev_addr: std::option::Option<std::string::String>,
        pub(crate) session_keys: std::option::Option<crate::model::SessionKeysAbpV10X>,
        pub(crate) f_cnt_start: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The DevAddr value.</p>
        pub fn dev_addr(mut self, input: impl Into<std::string::String>) -> Self {
            self.dev_addr = Some(input.into());
            self
        }
        /// <p>The DevAddr value.</p>
        pub fn set_dev_addr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dev_addr = input;
            self
        }
        /// <p>Session keys for ABP v1.0.x</p>
        pub fn session_keys(mut self, input: crate::model::SessionKeysAbpV10X) -> Self {
            self.session_keys = Some(input);
            self
        }
        /// <p>Session keys for ABP v1.0.x</p>
        pub fn set_session_keys(
            mut self,
            input: std::option::Option<crate::model::SessionKeysAbpV10X>,
        ) -> Self {
            self.session_keys = input;
            self
        }
        /// <p>The FCnt init value.</p>
        pub fn f_cnt_start(mut self, input: i32) -> Self {
            self.f_cnt_start = Some(input);
            self
        }
        /// <p>The FCnt init value.</p>
        pub fn set_f_cnt_start(mut self, input: std::option::Option<i32>) -> Self {
            self.f_cnt_start = input;
            self
        }
        /// Consumes the builder and constructs a [`AbpV10X`](crate::model::AbpV10X).
        pub fn build(self) -> crate::model::AbpV10X {
            crate::model::AbpV10X {
                dev_addr: self.dev_addr,
                session_keys: self.session_keys,
                f_cnt_start: self.f_cnt_start,
            }
        }
    }
}

/// <p>Session keys for ABP v1.1</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SessionKeysAbpV10X {
    /// <p>The NwkSKey value.</p>
    #[doc(hidden)]
    pub nwk_s_key: std::option::Option<std::string::String>,
    /// <p>The AppSKey value.</p>
    #[doc(hidden)]
    pub app_s_key: std::option::Option<std::string::String>,
}
impl SessionKeysAbpV10X {
    /// <p>The NwkSKey value.</p>
    pub fn nwk_s_key(&self) -> std::option::Option<&str> {
        self.nwk_s_key.as_deref()
    }
    /// <p>The AppSKey value.</p>
    pub fn app_s_key(&self) -> std::option::Option<&str> {
        self.app_s_key.as_deref()
    }
}
impl SessionKeysAbpV10X {
    /// Creates a new builder-style object to manufacture [`SessionKeysAbpV10X`](crate::model::SessionKeysAbpV10X).
    pub fn builder() -> crate::model::session_keys_abp_v10_x::Builder {
        crate::model::session_keys_abp_v10_x::Builder::default()
    }
}

/// See [`SessionKeysAbpV10X`](crate::model::SessionKeysAbpV10X).
pub mod session_keys_abp_v10_x {

    /// A builder for [`SessionKeysAbpV10X`](crate::model::SessionKeysAbpV10X).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) nwk_s_key: std::option::Option<std::string::String>,
        pub(crate) app_s_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The NwkSKey value.</p>
        pub fn nwk_s_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.nwk_s_key = Some(input.into());
            self
        }
        /// <p>The NwkSKey value.</p>
        pub fn set_nwk_s_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.nwk_s_key = input;
            self
        }
        /// <p>The AppSKey value.</p>
        pub fn app_s_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_s_key = Some(input.into());
            self
        }
        /// <p>The AppSKey value.</p>
        pub fn set_app_s_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_s_key = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionKeysAbpV10X`](crate::model::SessionKeysAbpV10X).
        pub fn build(self) -> crate::model::SessionKeysAbpV10X {
            crate::model::SessionKeysAbpV10X {
                nwk_s_key: self.nwk_s_key,
                app_s_key: self.app_s_key,
            }
        }
    }
}

/// <p>ABP device object for LoRaWAN specification v1.1</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AbpV11 {
    /// <p>The DevAddr value.</p>
    #[doc(hidden)]
    pub dev_addr: std::option::Option<std::string::String>,
    /// <p>Session keys for ABP v1.1</p>
    #[doc(hidden)]
    pub session_keys: std::option::Option<crate::model::SessionKeysAbpV11>,
    /// <p>The FCnt init value.</p>
    #[doc(hidden)]
    pub f_cnt_start: std::option::Option<i32>,
}
impl AbpV11 {
    /// <p>The DevAddr value.</p>
    pub fn dev_addr(&self) -> std::option::Option<&str> {
        self.dev_addr.as_deref()
    }
    /// <p>Session keys for ABP v1.1</p>
    pub fn session_keys(&self) -> std::option::Option<&crate::model::SessionKeysAbpV11> {
        self.session_keys.as_ref()
    }
    /// <p>The FCnt init value.</p>
    pub fn f_cnt_start(&self) -> std::option::Option<i32> {
        self.f_cnt_start
    }
}
impl AbpV11 {
    /// Creates a new builder-style object to manufacture [`AbpV11`](crate::model::AbpV11).
    pub fn builder() -> crate::model::abp_v11::Builder {
        crate::model::abp_v11::Builder::default()
    }
}

/// See [`AbpV11`](crate::model::AbpV11).
pub mod abp_v11 {

    /// A builder for [`AbpV11`](crate::model::AbpV11).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) dev_addr: std::option::Option<std::string::String>,
        pub(crate) session_keys: std::option::Option<crate::model::SessionKeysAbpV11>,
        pub(crate) f_cnt_start: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The DevAddr value.</p>
        pub fn dev_addr(mut self, input: impl Into<std::string::String>) -> Self {
            self.dev_addr = Some(input.into());
            self
        }
        /// <p>The DevAddr value.</p>
        pub fn set_dev_addr(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.dev_addr = input;
            self
        }
        /// <p>Session keys for ABP v1.1</p>
        pub fn session_keys(mut self, input: crate::model::SessionKeysAbpV11) -> Self {
            self.session_keys = Some(input);
            self
        }
        /// <p>Session keys for ABP v1.1</p>
        pub fn set_session_keys(
            mut self,
            input: std::option::Option<crate::model::SessionKeysAbpV11>,
        ) -> Self {
            self.session_keys = input;
            self
        }
        /// <p>The FCnt init value.</p>
        pub fn f_cnt_start(mut self, input: i32) -> Self {
            self.f_cnt_start = Some(input);
            self
        }
        /// <p>The FCnt init value.</p>
        pub fn set_f_cnt_start(mut self, input: std::option::Option<i32>) -> Self {
            self.f_cnt_start = input;
            self
        }
        /// Consumes the builder and constructs a [`AbpV11`](crate::model::AbpV11).
        pub fn build(self) -> crate::model::AbpV11 {
            crate::model::AbpV11 {
                dev_addr: self.dev_addr,
                session_keys: self.session_keys,
                f_cnt_start: self.f_cnt_start,
            }
        }
    }
}

/// <p>Session keys for ABP v1.1</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SessionKeysAbpV11 {
    /// <p>The FNwkSIntKey value.</p>
    #[doc(hidden)]
    pub f_nwk_s_int_key: std::option::Option<std::string::String>,
    /// <p>The SNwkSIntKey value.</p>
    #[doc(hidden)]
    pub s_nwk_s_int_key: std::option::Option<std::string::String>,
    /// <p>The NwkSEncKey value.</p>
    #[doc(hidden)]
    pub nwk_s_enc_key: std::option::Option<std::string::String>,
    /// <p>The AppSKey value.</p>
    #[doc(hidden)]
    pub app_s_key: std::option::Option<std::string::String>,
}
impl SessionKeysAbpV11 {
    /// <p>The FNwkSIntKey value.</p>
    pub fn f_nwk_s_int_key(&self) -> std::option::Option<&str> {
        self.f_nwk_s_int_key.as_deref()
    }
    /// <p>The SNwkSIntKey value.</p>
    pub fn s_nwk_s_int_key(&self) -> std::option::Option<&str> {
        self.s_nwk_s_int_key.as_deref()
    }
    /// <p>The NwkSEncKey value.</p>
    pub fn nwk_s_enc_key(&self) -> std::option::Option<&str> {
        self.nwk_s_enc_key.as_deref()
    }
    /// <p>The AppSKey value.</p>
    pub fn app_s_key(&self) -> std::option::Option<&str> {
        self.app_s_key.as_deref()
    }
}
impl SessionKeysAbpV11 {
    /// Creates a new builder-style object to manufacture [`SessionKeysAbpV11`](crate::model::SessionKeysAbpV11).
    pub fn builder() -> crate::model::session_keys_abp_v11::Builder {
        crate::model::session_keys_abp_v11::Builder::default()
    }
}

/// See [`SessionKeysAbpV11`](crate::model::SessionKeysAbpV11).
pub mod session_keys_abp_v11 {

    /// A builder for [`SessionKeysAbpV11`](crate::model::SessionKeysAbpV11).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) f_nwk_s_int_key: std::option::Option<std::string::String>,
        pub(crate) s_nwk_s_int_key: std::option::Option<std::string::String>,
        pub(crate) nwk_s_enc_key: std::option::Option<std::string::String>,
        pub(crate) app_s_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The FNwkSIntKey value.</p>
        pub fn f_nwk_s_int_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.f_nwk_s_int_key = Some(input.into());
            self
        }
        /// <p>The FNwkSIntKey value.</p>
        pub fn set_f_nwk_s_int_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.f_nwk_s_int_key = input;
            self
        }
        /// <p>The SNwkSIntKey value.</p>
        pub fn s_nwk_s_int_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.s_nwk_s_int_key = Some(input.into());
            self
        }
        /// <p>The SNwkSIntKey value.</p>
        pub fn set_s_nwk_s_int_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.s_nwk_s_int_key = input;
            self
        }
        /// <p>The NwkSEncKey value.</p>
        pub fn nwk_s_enc_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.nwk_s_enc_key = Some(input.into());
            self
        }
        /// <p>The NwkSEncKey value.</p>
        pub fn set_nwk_s_enc_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.nwk_s_enc_key = input;
            self
        }
        /// <p>The AppSKey value.</p>
        pub fn app_s_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_s_key = Some(input.into());
            self
        }
        /// <p>The AppSKey value.</p>
        pub fn set_app_s_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_s_key = input;
            self
        }
        /// Consumes the builder and constructs a [`SessionKeysAbpV11`](crate::model::SessionKeysAbpV11).
        pub fn build(self) -> crate::model::SessionKeysAbpV11 {
            crate::model::SessionKeysAbpV11 {
                f_nwk_s_int_key: self.f_nwk_s_int_key,
                s_nwk_s_int_key: self.s_nwk_s_int_key,
                nwk_s_enc_key: self.nwk_s_enc_key,
                app_s_key: self.app_s_key,
            }
        }
    }
}

/// <p>OTAA device object for v1.0.x</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OtaaV10X {
    /// <p>The AppKey value.</p>
    #[doc(hidden)]
    pub app_key: std::option::Option<std::string::String>,
    /// <p>The AppEUI value.</p>
    #[doc(hidden)]
    pub app_eui: std::option::Option<std::string::String>,
    /// <p>The GenAppKey value.</p>
    #[doc(hidden)]
    pub gen_app_key: std::option::Option<std::string::String>,
}
impl OtaaV10X {
    /// <p>The AppKey value.</p>
    pub fn app_key(&self) -> std::option::Option<&str> {
        self.app_key.as_deref()
    }
    /// <p>The AppEUI value.</p>
    pub fn app_eui(&self) -> std::option::Option<&str> {
        self.app_eui.as_deref()
    }
    /// <p>The GenAppKey value.</p>
    pub fn gen_app_key(&self) -> std::option::Option<&str> {
        self.gen_app_key.as_deref()
    }
}
impl OtaaV10X {
    /// Creates a new builder-style object to manufacture [`OtaaV10X`](crate::model::OtaaV10X).
    pub fn builder() -> crate::model::otaa_v10_x::Builder {
        crate::model::otaa_v10_x::Builder::default()
    }
}

/// See [`OtaaV10X`](crate::model::OtaaV10X).
pub mod otaa_v10_x {

    /// A builder for [`OtaaV10X`](crate::model::OtaaV10X).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_key: std::option::Option<std::string::String>,
        pub(crate) app_eui: std::option::Option<std::string::String>,
        pub(crate) gen_app_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The AppKey value.</p>
        pub fn app_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_key = Some(input.into());
            self
        }
        /// <p>The AppKey value.</p>
        pub fn set_app_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_key = input;
            self
        }
        /// <p>The AppEUI value.</p>
        pub fn app_eui(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_eui = Some(input.into());
            self
        }
        /// <p>The AppEUI value.</p>
        pub fn set_app_eui(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_eui = input;
            self
        }
        /// <p>The GenAppKey value.</p>
        pub fn gen_app_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.gen_app_key = Some(input.into());
            self
        }
        /// <p>The GenAppKey value.</p>
        pub fn set_gen_app_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.gen_app_key = input;
            self
        }
        /// Consumes the builder and constructs a [`OtaaV10X`](crate::model::OtaaV10X).
        pub fn build(self) -> crate::model::OtaaV10X {
            crate::model::OtaaV10X {
                app_key: self.app_key,
                app_eui: self.app_eui,
                gen_app_key: self.gen_app_key,
            }
        }
    }
}

/// <p>OTAA device object for v1.1</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OtaaV11 {
    /// <p>The AppKey value.</p>
    #[doc(hidden)]
    pub app_key: std::option::Option<std::string::String>,
    /// <p>The NwkKey value.</p>
    #[doc(hidden)]
    pub nwk_key: std::option::Option<std::string::String>,
    /// <p>The JoinEUI value.</p>
    #[doc(hidden)]
    pub join_eui: std::option::Option<std::string::String>,
}
impl OtaaV11 {
    /// <p>The AppKey value.</p>
    pub fn app_key(&self) -> std::option::Option<&str> {
        self.app_key.as_deref()
    }
    /// <p>The NwkKey value.</p>
    pub fn nwk_key(&self) -> std::option::Option<&str> {
        self.nwk_key.as_deref()
    }
    /// <p>The JoinEUI value.</p>
    pub fn join_eui(&self) -> std::option::Option<&str> {
        self.join_eui.as_deref()
    }
}
impl OtaaV11 {
    /// Creates a new builder-style object to manufacture [`OtaaV11`](crate::model::OtaaV11).
    pub fn builder() -> crate::model::otaa_v11::Builder {
        crate::model::otaa_v11::Builder::default()
    }
}

/// See [`OtaaV11`](crate::model::OtaaV11).
pub mod otaa_v11 {

    /// A builder for [`OtaaV11`](crate::model::OtaaV11).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) app_key: std::option::Option<std::string::String>,
        pub(crate) nwk_key: std::option::Option<std::string::String>,
        pub(crate) join_eui: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The AppKey value.</p>
        pub fn app_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_key = Some(input.into());
            self
        }
        /// <p>The AppKey value.</p>
        pub fn set_app_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.app_key = input;
            self
        }
        /// <p>The NwkKey value.</p>
        pub fn nwk_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.nwk_key = Some(input.into());
            self
        }
        /// <p>The NwkKey value.</p>
        pub fn set_nwk_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.nwk_key = input;
            self
        }
        /// <p>The JoinEUI value.</p>
        pub fn join_eui(mut self, input: impl Into<std::string::String>) -> Self {
            self.join_eui = Some(input.into());
            self
        }
        /// <p>The JoinEUI value.</p>
        pub fn set_join_eui(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.join_eui = input;
            self
        }
        /// Consumes the builder and constructs a [`OtaaV11`](crate::model::OtaaV11).
        pub fn build(self) -> crate::model::OtaaV11 {
            crate::model::OtaaV11 {
                app_key: self.app_key,
                nwk_key: self.nwk_key,
                join_eui: self.join_eui,
            }
        }
    }
}

/// When writing a match expression against `WirelessDeviceIdType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wirelessdeviceidtype = unimplemented!();
/// match wirelessdeviceidtype {
///     WirelessDeviceIdType::DevEui => { /* ... */ },
///     WirelessDeviceIdType::SidewalkManufacturingSn => { /* ... */ },
///     WirelessDeviceIdType::ThingName => { /* ... */ },
///     WirelessDeviceIdType::WirelessDeviceId => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wirelessdeviceidtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WirelessDeviceIdType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WirelessDeviceIdType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WirelessDeviceIdType::NewFeature` is defined.
/// Specifically, when `wirelessdeviceidtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WirelessDeviceIdType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WirelessDeviceIdType {
    #[allow(missing_docs)] // documentation missing in model
    DevEui,
    #[allow(missing_docs)] // documentation missing in model
    SidewalkManufacturingSn,
    #[allow(missing_docs)] // documentation missing in model
    ThingName,
    #[allow(missing_docs)] // documentation missing in model
    WirelessDeviceId,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WirelessDeviceIdType {
    fn from(s: &str) -> Self {
        match s {
            "DevEui" => WirelessDeviceIdType::DevEui,
            "SidewalkManufacturingSn" => WirelessDeviceIdType::SidewalkManufacturingSn,
            "ThingName" => WirelessDeviceIdType::ThingName,
            "WirelessDeviceId" => WirelessDeviceIdType::WirelessDeviceId,
            other => {
                WirelessDeviceIdType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WirelessDeviceIdType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WirelessDeviceIdType::from(s))
    }
}
impl WirelessDeviceIdType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WirelessDeviceIdType::DevEui => "DevEui",
            WirelessDeviceIdType::SidewalkManufacturingSn => "SidewalkManufacturingSn",
            WirelessDeviceIdType::ThingName => "ThingName",
            WirelessDeviceIdType::WirelessDeviceId => "WirelessDeviceId",
            WirelessDeviceIdType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DevEui",
            "SidewalkManufacturingSn",
            "ThingName",
            "WirelessDeviceId",
        ]
    }
}
impl AsRef<str> for WirelessDeviceIdType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>LoRaWANGetServiceProfileInfo object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanGetServiceProfileInfo {
    /// <p>The ULRate value.</p>
    #[doc(hidden)]
    pub ul_rate: std::option::Option<i32>,
    /// <p>The ULBucketSize value.</p>
    #[doc(hidden)]
    pub ul_bucket_size: std::option::Option<i32>,
    /// <p>The ULRatePolicy value.</p>
    #[doc(hidden)]
    pub ul_rate_policy: std::option::Option<std::string::String>,
    /// <p>The DLRate value.</p>
    #[doc(hidden)]
    pub dl_rate: std::option::Option<i32>,
    /// <p>The DLBucketSize value.</p>
    #[doc(hidden)]
    pub dl_bucket_size: std::option::Option<i32>,
    /// <p>The DLRatePolicy value.</p>
    #[doc(hidden)]
    pub dl_rate_policy: std::option::Option<std::string::String>,
    /// <p>The AddGWMetaData value.</p>
    #[doc(hidden)]
    pub add_gw_metadata: bool,
    /// <p>The DevStatusReqFreq value.</p>
    #[doc(hidden)]
    pub dev_status_req_freq: std::option::Option<i32>,
    /// <p>The ReportDevStatusBattery value.</p>
    #[doc(hidden)]
    pub report_dev_status_battery: bool,
    /// <p>The ReportDevStatusMargin value.</p>
    #[doc(hidden)]
    pub report_dev_status_margin: bool,
    /// <p>The DRMin value.</p>
    #[doc(hidden)]
    pub dr_min: i32,
    /// <p>The DRMax value.</p>
    #[doc(hidden)]
    pub dr_max: i32,
    /// <p>The ChannelMask value.</p>
    #[doc(hidden)]
    pub channel_mask: std::option::Option<std::string::String>,
    /// <p>The PRAllowed value that describes whether passive roaming is allowed.</p>
    #[doc(hidden)]
    pub pr_allowed: bool,
    /// <p>The HRAllowed value that describes whether handover roaming is allowed.</p>
    #[doc(hidden)]
    pub hr_allowed: bool,
    /// <p>The RAAllowed value that describes whether roaming activation is allowed.</p>
    #[doc(hidden)]
    pub ra_allowed: bool,
    /// <p>The NwkGeoLoc value.</p>
    #[doc(hidden)]
    pub nwk_geo_loc: bool,
    /// <p>The TargetPER value.</p>
    #[doc(hidden)]
    pub target_per: i32,
    /// <p>The MinGwDiversity value.</p>
    #[doc(hidden)]
    pub min_gw_diversity: std::option::Option<i32>,
}
impl LoRaWanGetServiceProfileInfo {
    /// <p>The ULRate value.</p>
    pub fn ul_rate(&self) -> std::option::Option<i32> {
        self.ul_rate
    }
    /// <p>The ULBucketSize value.</p>
    pub fn ul_bucket_size(&self) -> std::option::Option<i32> {
        self.ul_bucket_size
    }
    /// <p>The ULRatePolicy value.</p>
    pub fn ul_rate_policy(&self) -> std::option::Option<&str> {
        self.ul_rate_policy.as_deref()
    }
    /// <p>The DLRate value.</p>
    pub fn dl_rate(&self) -> std::option::Option<i32> {
        self.dl_rate
    }
    /// <p>The DLBucketSize value.</p>
    pub fn dl_bucket_size(&self) -> std::option::Option<i32> {
        self.dl_bucket_size
    }
    /// <p>The DLRatePolicy value.</p>
    pub fn dl_rate_policy(&self) -> std::option::Option<&str> {
        self.dl_rate_policy.as_deref()
    }
    /// <p>The AddGWMetaData value.</p>
    pub fn add_gw_metadata(&self) -> bool {
        self.add_gw_metadata
    }
    /// <p>The DevStatusReqFreq value.</p>
    pub fn dev_status_req_freq(&self) -> std::option::Option<i32> {
        self.dev_status_req_freq
    }
    /// <p>The ReportDevStatusBattery value.</p>
    pub fn report_dev_status_battery(&self) -> bool {
        self.report_dev_status_battery
    }
    /// <p>The ReportDevStatusMargin value.</p>
    pub fn report_dev_status_margin(&self) -> bool {
        self.report_dev_status_margin
    }
    /// <p>The DRMin value.</p>
    pub fn dr_min(&self) -> i32 {
        self.dr_min
    }
    /// <p>The DRMax value.</p>
    pub fn dr_max(&self) -> i32 {
        self.dr_max
    }
    /// <p>The ChannelMask value.</p>
    pub fn channel_mask(&self) -> std::option::Option<&str> {
        self.channel_mask.as_deref()
    }
    /// <p>The PRAllowed value that describes whether passive roaming is allowed.</p>
    pub fn pr_allowed(&self) -> bool {
        self.pr_allowed
    }
    /// <p>The HRAllowed value that describes whether handover roaming is allowed.</p>
    pub fn hr_allowed(&self) -> bool {
        self.hr_allowed
    }
    /// <p>The RAAllowed value that describes whether roaming activation is allowed.</p>
    pub fn ra_allowed(&self) -> bool {
        self.ra_allowed
    }
    /// <p>The NwkGeoLoc value.</p>
    pub fn nwk_geo_loc(&self) -> bool {
        self.nwk_geo_loc
    }
    /// <p>The TargetPER value.</p>
    pub fn target_per(&self) -> i32 {
        self.target_per
    }
    /// <p>The MinGwDiversity value.</p>
    pub fn min_gw_diversity(&self) -> std::option::Option<i32> {
        self.min_gw_diversity
    }
}
impl LoRaWanGetServiceProfileInfo {
    /// Creates a new builder-style object to manufacture [`LoRaWanGetServiceProfileInfo`](crate::model::LoRaWanGetServiceProfileInfo).
    pub fn builder() -> crate::model::lo_ra_wan_get_service_profile_info::Builder {
        crate::model::lo_ra_wan_get_service_profile_info::Builder::default()
    }
}

/// See [`LoRaWanGetServiceProfileInfo`](crate::model::LoRaWanGetServiceProfileInfo).
pub mod lo_ra_wan_get_service_profile_info {

    /// A builder for [`LoRaWanGetServiceProfileInfo`](crate::model::LoRaWanGetServiceProfileInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ul_rate: std::option::Option<i32>,
        pub(crate) ul_bucket_size: std::option::Option<i32>,
        pub(crate) ul_rate_policy: std::option::Option<std::string::String>,
        pub(crate) dl_rate: std::option::Option<i32>,
        pub(crate) dl_bucket_size: std::option::Option<i32>,
        pub(crate) dl_rate_policy: std::option::Option<std::string::String>,
        pub(crate) add_gw_metadata: std::option::Option<bool>,
        pub(crate) dev_status_req_freq: std::option::Option<i32>,
        pub(crate) report_dev_status_battery: std::option::Option<bool>,
        pub(crate) report_dev_status_margin: std::option::Option<bool>,
        pub(crate) dr_min: std::option::Option<i32>,
        pub(crate) dr_max: std::option::Option<i32>,
        pub(crate) channel_mask: std::option::Option<std::string::String>,
        pub(crate) pr_allowed: std::option::Option<bool>,
        pub(crate) hr_allowed: std::option::Option<bool>,
        pub(crate) ra_allowed: std::option::Option<bool>,
        pub(crate) nwk_geo_loc: std::option::Option<bool>,
        pub(crate) target_per: std::option::Option<i32>,
        pub(crate) min_gw_diversity: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The ULRate value.</p>
        pub fn ul_rate(mut self, input: i32) -> Self {
            self.ul_rate = Some(input);
            self
        }
        /// <p>The ULRate value.</p>
        pub fn set_ul_rate(mut self, input: std::option::Option<i32>) -> Self {
            self.ul_rate = input;
            self
        }
        /// <p>The ULBucketSize value.</p>
        pub fn ul_bucket_size(mut self, input: i32) -> Self {
            self.ul_bucket_size = Some(input);
            self
        }
        /// <p>The ULBucketSize value.</p>
        pub fn set_ul_bucket_size(mut self, input: std::option::Option<i32>) -> Self {
            self.ul_bucket_size = input;
            self
        }
        /// <p>The ULRatePolicy value.</p>
        pub fn ul_rate_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.ul_rate_policy = Some(input.into());
            self
        }
        /// <p>The ULRatePolicy value.</p>
        pub fn set_ul_rate_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.ul_rate_policy = input;
            self
        }
        /// <p>The DLRate value.</p>
        pub fn dl_rate(mut self, input: i32) -> Self {
            self.dl_rate = Some(input);
            self
        }
        /// <p>The DLRate value.</p>
        pub fn set_dl_rate(mut self, input: std::option::Option<i32>) -> Self {
            self.dl_rate = input;
            self
        }
        /// <p>The DLBucketSize value.</p>
        pub fn dl_bucket_size(mut self, input: i32) -> Self {
            self.dl_bucket_size = Some(input);
            self
        }
        /// <p>The DLBucketSize value.</p>
        pub fn set_dl_bucket_size(mut self, input: std::option::Option<i32>) -> Self {
            self.dl_bucket_size = input;
            self
        }
        /// <p>The DLRatePolicy value.</p>
        pub fn dl_rate_policy(mut self, input: impl Into<std::string::String>) -> Self {
            self.dl_rate_policy = Some(input.into());
            self
        }
        /// <p>The DLRatePolicy value.</p>
        pub fn set_dl_rate_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dl_rate_policy = input;
            self
        }
        /// <p>The AddGWMetaData value.</p>
        pub fn add_gw_metadata(mut self, input: bool) -> Self {
            self.add_gw_metadata = Some(input);
            self
        }
        /// <p>The AddGWMetaData value.</p>
        pub fn set_add_gw_metadata(mut self, input: std::option::Option<bool>) -> Self {
            self.add_gw_metadata = input;
            self
        }
        /// <p>The DevStatusReqFreq value.</p>
        pub fn dev_status_req_freq(mut self, input: i32) -> Self {
            self.dev_status_req_freq = Some(input);
            self
        }
        /// <p>The DevStatusReqFreq value.</p>
        pub fn set_dev_status_req_freq(mut self, input: std::option::Option<i32>) -> Self {
            self.dev_status_req_freq = input;
            self
        }
        /// <p>The ReportDevStatusBattery value.</p>
        pub fn report_dev_status_battery(mut self, input: bool) -> Self {
            self.report_dev_status_battery = Some(input);
            self
        }
        /// <p>The ReportDevStatusBattery value.</p>
        pub fn set_report_dev_status_battery(mut self, input: std::option::Option<bool>) -> Self {
            self.report_dev_status_battery = input;
            self
        }
        /// <p>The ReportDevStatusMargin value.</p>
        pub fn report_dev_status_margin(mut self, input: bool) -> Self {
            self.report_dev_status_margin = Some(input);
            self
        }
        /// <p>The ReportDevStatusMargin value.</p>
        pub fn set_report_dev_status_margin(mut self, input: std::option::Option<bool>) -> Self {
            self.report_dev_status_margin = input;
            self
        }
        /// <p>The DRMin value.</p>
        pub fn dr_min(mut self, input: i32) -> Self {
            self.dr_min = Some(input);
            self
        }
        /// <p>The DRMin value.</p>
        pub fn set_dr_min(mut self, input: std::option::Option<i32>) -> Self {
            self.dr_min = input;
            self
        }
        /// <p>The DRMax value.</p>
        pub fn dr_max(mut self, input: i32) -> Self {
            self.dr_max = Some(input);
            self
        }
        /// <p>The DRMax value.</p>
        pub fn set_dr_max(mut self, input: std::option::Option<i32>) -> Self {
            self.dr_max = input;
            self
        }
        /// <p>The ChannelMask value.</p>
        pub fn channel_mask(mut self, input: impl Into<std::string::String>) -> Self {
            self.channel_mask = Some(input.into());
            self
        }
        /// <p>The ChannelMask value.</p>
        pub fn set_channel_mask(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.channel_mask = input;
            self
        }
        /// <p>The PRAllowed value that describes whether passive roaming is allowed.</p>
        pub fn pr_allowed(mut self, input: bool) -> Self {
            self.pr_allowed = Some(input);
            self
        }
        /// <p>The PRAllowed value that describes whether passive roaming is allowed.</p>
        pub fn set_pr_allowed(mut self, input: std::option::Option<bool>) -> Self {
            self.pr_allowed = input;
            self
        }
        /// <p>The HRAllowed value that describes whether handover roaming is allowed.</p>
        pub fn hr_allowed(mut self, input: bool) -> Self {
            self.hr_allowed = Some(input);
            self
        }
        /// <p>The HRAllowed value that describes whether handover roaming is allowed.</p>
        pub fn set_hr_allowed(mut self, input: std::option::Option<bool>) -> Self {
            self.hr_allowed = input;
            self
        }
        /// <p>The RAAllowed value that describes whether roaming activation is allowed.</p>
        pub fn ra_allowed(mut self, input: bool) -> Self {
            self.ra_allowed = Some(input);
            self
        }
        /// <p>The RAAllowed value that describes whether roaming activation is allowed.</p>
        pub fn set_ra_allowed(mut self, input: std::option::Option<bool>) -> Self {
            self.ra_allowed = input;
            self
        }
        /// <p>The NwkGeoLoc value.</p>
        pub fn nwk_geo_loc(mut self, input: bool) -> Self {
            self.nwk_geo_loc = Some(input);
            self
        }
        /// <p>The NwkGeoLoc value.</p>
        pub fn set_nwk_geo_loc(mut self, input: std::option::Option<bool>) -> Self {
            self.nwk_geo_loc = input;
            self
        }
        /// <p>The TargetPER value.</p>
        pub fn target_per(mut self, input: i32) -> Self {
            self.target_per = Some(input);
            self
        }
        /// <p>The TargetPER value.</p>
        pub fn set_target_per(mut self, input: std::option::Option<i32>) -> Self {
            self.target_per = input;
            self
        }
        /// <p>The MinGwDiversity value.</p>
        pub fn min_gw_diversity(mut self, input: i32) -> Self {
            self.min_gw_diversity = Some(input);
            self
        }
        /// <p>The MinGwDiversity value.</p>
        pub fn set_min_gw_diversity(mut self, input: std::option::Option<i32>) -> Self {
            self.min_gw_diversity = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanGetServiceProfileInfo`](crate::model::LoRaWanGetServiceProfileInfo).
        pub fn build(self) -> crate::model::LoRaWanGetServiceProfileInfo {
            crate::model::LoRaWanGetServiceProfileInfo {
                ul_rate: self.ul_rate,
                ul_bucket_size: self.ul_bucket_size,
                ul_rate_policy: self.ul_rate_policy,
                dl_rate: self.dl_rate,
                dl_bucket_size: self.dl_bucket_size,
                dl_rate_policy: self.dl_rate_policy,
                add_gw_metadata: self.add_gw_metadata.unwrap_or_default(),
                dev_status_req_freq: self.dev_status_req_freq,
                report_dev_status_battery: self.report_dev_status_battery.unwrap_or_default(),
                report_dev_status_margin: self.report_dev_status_margin.unwrap_or_default(),
                dr_min: self.dr_min.unwrap_or_default(),
                dr_max: self.dr_max.unwrap_or_default(),
                channel_mask: self.channel_mask,
                pr_allowed: self.pr_allowed.unwrap_or_default(),
                hr_allowed: self.hr_allowed.unwrap_or_default(),
                ra_allowed: self.ra_allowed.unwrap_or_default(),
                nwk_geo_loc: self.nwk_geo_loc.unwrap_or_default(),
                target_per: self.target_per.unwrap_or_default(),
                min_gw_diversity: self.min_gw_diversity,
            }
        }
    }
}

/// When writing a match expression against `WirelessGatewayServiceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let wirelessgatewayservicetype = unimplemented!();
/// match wirelessgatewayservicetype {
///     WirelessGatewayServiceType::Cups => { /* ... */ },
///     WirelessGatewayServiceType::Lns => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `wirelessgatewayservicetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WirelessGatewayServiceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WirelessGatewayServiceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WirelessGatewayServiceType::NewFeature` is defined.
/// Specifically, when `wirelessgatewayservicetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WirelessGatewayServiceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WirelessGatewayServiceType {
    #[allow(missing_docs)] // documentation missing in model
    Cups,
    #[allow(missing_docs)] // documentation missing in model
    Lns,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WirelessGatewayServiceType {
    fn from(s: &str) -> Self {
        match s {
            "CUPS" => WirelessGatewayServiceType::Cups,
            "LNS" => WirelessGatewayServiceType::Lns,
            other => WirelessGatewayServiceType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for WirelessGatewayServiceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WirelessGatewayServiceType::from(s))
    }
}
impl WirelessGatewayServiceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WirelessGatewayServiceType::Cups => "CUPS",
            WirelessGatewayServiceType::Lns => "LNS",
            WirelessGatewayServiceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CUPS", "LNS"]
    }
}
impl AsRef<str> for WirelessGatewayServiceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Global navigation satellite system (GNSS) object used for positioning.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Gnss {
    /// <p>Payload that contains the GNSS scan result, or NAV message, in hexadecimal notation.</p>
    #[doc(hidden)]
    pub payload: std::option::Option<std::string::String>,
    /// <p>Optional parameter that gives an estimate of the time when the GNSS scan information is taken, in seconds GPS time (GPST). If capture time is not specified, the local server time is used.</p>
    #[doc(hidden)]
    pub capture_time: std::option::Option<f32>,
    /// <p>Optional value that gives the capture time estimate accuracy, in seconds. If capture time accuracy is not specified, default value of 300 is used.</p>
    #[doc(hidden)]
    pub capture_time_accuracy: std::option::Option<f32>,
    /// <p>Optional assistance position information, specified using latitude and longitude values in degrees. The co-ordinates are inside the WGS84 reference frame.</p>
    #[doc(hidden)]
    pub assist_position: std::option::Option<std::vec::Vec<f32>>,
    /// <p>Optional assistance altitude, which is the altitude of the device at capture time, specified in meters above the WGS84 reference ellipsoid.</p>
    #[doc(hidden)]
    pub assist_altitude: std::option::Option<f32>,
    /// <p>Optional parameter that forces 2D solve, which modifies the positioning algorithm to a 2D solution problem. When this parameter is specified, the assistance altitude should have an accuracy of at least 10 meters.</p>
    #[doc(hidden)]
    pub use2_d_solver: bool,
}
impl Gnss {
    /// <p>Payload that contains the GNSS scan result, or NAV message, in hexadecimal notation.</p>
    pub fn payload(&self) -> std::option::Option<&str> {
        self.payload.as_deref()
    }
    /// <p>Optional parameter that gives an estimate of the time when the GNSS scan information is taken, in seconds GPS time (GPST). If capture time is not specified, the local server time is used.</p>
    pub fn capture_time(&self) -> std::option::Option<f32> {
        self.capture_time
    }
    /// <p>Optional value that gives the capture time estimate accuracy, in seconds. If capture time accuracy is not specified, default value of 300 is used.</p>
    pub fn capture_time_accuracy(&self) -> std::option::Option<f32> {
        self.capture_time_accuracy
    }
    /// <p>Optional assistance position information, specified using latitude and longitude values in degrees. The co-ordinates are inside the WGS84 reference frame.</p>
    pub fn assist_position(&self) -> std::option::Option<&[f32]> {
        self.assist_position.as_deref()
    }
    /// <p>Optional assistance altitude, which is the altitude of the device at capture time, specified in meters above the WGS84 reference ellipsoid.</p>
    pub fn assist_altitude(&self) -> std::option::Option<f32> {
        self.assist_altitude
    }
    /// <p>Optional parameter that forces 2D solve, which modifies the positioning algorithm to a 2D solution problem. When this parameter is specified, the assistance altitude should have an accuracy of at least 10 meters.</p>
    pub fn use2_d_solver(&self) -> bool {
        self.use2_d_solver
    }
}
impl Gnss {
    /// Creates a new builder-style object to manufacture [`Gnss`](crate::model::Gnss).
    pub fn builder() -> crate::model::gnss::Builder {
        crate::model::gnss::Builder::default()
    }
}

/// See [`Gnss`](crate::model::Gnss).
pub mod gnss {

    /// A builder for [`Gnss`](crate::model::Gnss).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) payload: std::option::Option<std::string::String>,
        pub(crate) capture_time: std::option::Option<f32>,
        pub(crate) capture_time_accuracy: std::option::Option<f32>,
        pub(crate) assist_position: std::option::Option<std::vec::Vec<f32>>,
        pub(crate) assist_altitude: std::option::Option<f32>,
        pub(crate) use2_d_solver: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Payload that contains the GNSS scan result, or NAV message, in hexadecimal notation.</p>
        pub fn payload(mut self, input: impl Into<std::string::String>) -> Self {
            self.payload = Some(input.into());
            self
        }
        /// <p>Payload that contains the GNSS scan result, or NAV message, in hexadecimal notation.</p>
        pub fn set_payload(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.payload = input;
            self
        }
        /// <p>Optional parameter that gives an estimate of the time when the GNSS scan information is taken, in seconds GPS time (GPST). If capture time is not specified, the local server time is used.</p>
        pub fn capture_time(mut self, input: f32) -> Self {
            self.capture_time = Some(input);
            self
        }
        /// <p>Optional parameter that gives an estimate of the time when the GNSS scan information is taken, in seconds GPS time (GPST). If capture time is not specified, the local server time is used.</p>
        pub fn set_capture_time(mut self, input: std::option::Option<f32>) -> Self {
            self.capture_time = input;
            self
        }
        /// <p>Optional value that gives the capture time estimate accuracy, in seconds. If capture time accuracy is not specified, default value of 300 is used.</p>
        pub fn capture_time_accuracy(mut self, input: f32) -> Self {
            self.capture_time_accuracy = Some(input);
            self
        }
        /// <p>Optional value that gives the capture time estimate accuracy, in seconds. If capture time accuracy is not specified, default value of 300 is used.</p>
        pub fn set_capture_time_accuracy(mut self, input: std::option::Option<f32>) -> Self {
            self.capture_time_accuracy = input;
            self
        }
        /// Appends an item to `assist_position`.
        ///
        /// To override the contents of this collection use [`set_assist_position`](Self::set_assist_position).
        ///
        /// <p>Optional assistance position information, specified using latitude and longitude values in degrees. The co-ordinates are inside the WGS84 reference frame.</p>
        pub fn assist_position(mut self, input: f32) -> Self {
            let mut v = self.assist_position.unwrap_or_default();
            v.push(input);
            self.assist_position = Some(v);
            self
        }
        /// <p>Optional assistance position information, specified using latitude and longitude values in degrees. The co-ordinates are inside the WGS84 reference frame.</p>
        pub fn set_assist_position(
            mut self,
            input: std::option::Option<std::vec::Vec<f32>>,
        ) -> Self {
            self.assist_position = input;
            self
        }
        /// <p>Optional assistance altitude, which is the altitude of the device at capture time, specified in meters above the WGS84 reference ellipsoid.</p>
        pub fn assist_altitude(mut self, input: f32) -> Self {
            self.assist_altitude = Some(input);
            self
        }
        /// <p>Optional assistance altitude, which is the altitude of the device at capture time, specified in meters above the WGS84 reference ellipsoid.</p>
        pub fn set_assist_altitude(mut self, input: std::option::Option<f32>) -> Self {
            self.assist_altitude = input;
            self
        }
        /// <p>Optional parameter that forces 2D solve, which modifies the positioning algorithm to a 2D solution problem. When this parameter is specified, the assistance altitude should have an accuracy of at least 10 meters.</p>
        pub fn use2_d_solver(mut self, input: bool) -> Self {
            self.use2_d_solver = Some(input);
            self
        }
        /// <p>Optional parameter that forces 2D solve, which modifies the positioning algorithm to a 2D solution problem. When this parameter is specified, the assistance altitude should have an accuracy of at least 10 meters.</p>
        pub fn set_use2_d_solver(mut self, input: std::option::Option<bool>) -> Self {
            self.use2_d_solver = input;
            self
        }
        /// Consumes the builder and constructs a [`Gnss`](crate::model::Gnss).
        pub fn build(self) -> crate::model::Gnss {
            crate::model::Gnss {
                payload: self.payload,
                capture_time: self.capture_time,
                capture_time_accuracy: self.capture_time_accuracy,
                assist_position: self.assist_position,
                assist_altitude: self.assist_altitude,
                use2_d_solver: self.use2_d_solver.unwrap_or_default(),
            }
        }
    }
}

/// <p>IP address used for resolving device location.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Ip {
    /// <p>IP address information.</p>
    #[doc(hidden)]
    pub ip_address: std::option::Option<std::string::String>,
}
impl Ip {
    /// <p>IP address information.</p>
    pub fn ip_address(&self) -> std::option::Option<&str> {
        self.ip_address.as_deref()
    }
}
impl Ip {
    /// Creates a new builder-style object to manufacture [`Ip`](crate::model::Ip).
    pub fn builder() -> crate::model::ip::Builder {
        crate::model::ip::Builder::default()
    }
}

/// See [`Ip`](crate::model::Ip).
pub mod ip {

    /// A builder for [`Ip`](crate::model::Ip).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_address: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>IP address information.</p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address = Some(input.into());
            self
        }
        /// <p>IP address information.</p>
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_address = input;
            self
        }
        /// Consumes the builder and constructs a [`Ip`](crate::model::Ip).
        pub fn build(self) -> crate::model::Ip {
            crate::model::Ip {
                ip_address: self.ip_address,
            }
        }
    }
}

/// <p>The cell towers that were used to perform the measurements.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CellTowers {
    /// <p>GSM object information.</p>
    #[doc(hidden)]
    pub gsm: std::option::Option<std::vec::Vec<crate::model::GsmObj>>,
    /// <p>WCDMA object information.</p>
    #[doc(hidden)]
    pub wcdma: std::option::Option<std::vec::Vec<crate::model::WcdmaObj>>,
    /// <p>TD-SCDMA object information.</p>
    #[doc(hidden)]
    pub tdscdma: std::option::Option<std::vec::Vec<crate::model::TdscdmaObj>>,
    /// <p>LTE object information.</p>
    #[doc(hidden)]
    pub lte: std::option::Option<std::vec::Vec<crate::model::LteObj>>,
    /// <p>CDMA object information.</p>
    #[doc(hidden)]
    pub cdma: std::option::Option<std::vec::Vec<crate::model::CdmaObj>>,
}
impl CellTowers {
    /// <p>GSM object information.</p>
    pub fn gsm(&self) -> std::option::Option<&[crate::model::GsmObj]> {
        self.gsm.as_deref()
    }
    /// <p>WCDMA object information.</p>
    pub fn wcdma(&self) -> std::option::Option<&[crate::model::WcdmaObj]> {
        self.wcdma.as_deref()
    }
    /// <p>TD-SCDMA object information.</p>
    pub fn tdscdma(&self) -> std::option::Option<&[crate::model::TdscdmaObj]> {
        self.tdscdma.as_deref()
    }
    /// <p>LTE object information.</p>
    pub fn lte(&self) -> std::option::Option<&[crate::model::LteObj]> {
        self.lte.as_deref()
    }
    /// <p>CDMA object information.</p>
    pub fn cdma(&self) -> std::option::Option<&[crate::model::CdmaObj]> {
        self.cdma.as_deref()
    }
}
impl CellTowers {
    /// Creates a new builder-style object to manufacture [`CellTowers`](crate::model::CellTowers).
    pub fn builder() -> crate::model::cell_towers::Builder {
        crate::model::cell_towers::Builder::default()
    }
}

/// See [`CellTowers`](crate::model::CellTowers).
pub mod cell_towers {

    /// A builder for [`CellTowers`](crate::model::CellTowers).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) gsm: std::option::Option<std::vec::Vec<crate::model::GsmObj>>,
        pub(crate) wcdma: std::option::Option<std::vec::Vec<crate::model::WcdmaObj>>,
        pub(crate) tdscdma: std::option::Option<std::vec::Vec<crate::model::TdscdmaObj>>,
        pub(crate) lte: std::option::Option<std::vec::Vec<crate::model::LteObj>>,
        pub(crate) cdma: std::option::Option<std::vec::Vec<crate::model::CdmaObj>>,
    }
    impl Builder {
        /// Appends an item to `gsm`.
        ///
        /// To override the contents of this collection use [`set_gsm`](Self::set_gsm).
        ///
        /// <p>GSM object information.</p>
        pub fn gsm(mut self, input: crate::model::GsmObj) -> Self {
            let mut v = self.gsm.unwrap_or_default();
            v.push(input);
            self.gsm = Some(v);
            self
        }
        /// <p>GSM object information.</p>
        pub fn set_gsm(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GsmObj>>,
        ) -> Self {
            self.gsm = input;
            self
        }
        /// Appends an item to `wcdma`.
        ///
        /// To override the contents of this collection use [`set_wcdma`](Self::set_wcdma).
        ///
        /// <p>WCDMA object information.</p>
        pub fn wcdma(mut self, input: crate::model::WcdmaObj) -> Self {
            let mut v = self.wcdma.unwrap_or_default();
            v.push(input);
            self.wcdma = Some(v);
            self
        }
        /// <p>WCDMA object information.</p>
        pub fn set_wcdma(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WcdmaObj>>,
        ) -> Self {
            self.wcdma = input;
            self
        }
        /// Appends an item to `tdscdma`.
        ///
        /// To override the contents of this collection use [`set_tdscdma`](Self::set_tdscdma).
        ///
        /// <p>TD-SCDMA object information.</p>
        pub fn tdscdma(mut self, input: crate::model::TdscdmaObj) -> Self {
            let mut v = self.tdscdma.unwrap_or_default();
            v.push(input);
            self.tdscdma = Some(v);
            self
        }
        /// <p>TD-SCDMA object information.</p>
        pub fn set_tdscdma(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TdscdmaObj>>,
        ) -> Self {
            self.tdscdma = input;
            self
        }
        /// Appends an item to `lte`.
        ///
        /// To override the contents of this collection use [`set_lte`](Self::set_lte).
        ///
        /// <p>LTE object information.</p>
        pub fn lte(mut self, input: crate::model::LteObj) -> Self {
            let mut v = self.lte.unwrap_or_default();
            v.push(input);
            self.lte = Some(v);
            self
        }
        /// <p>LTE object information.</p>
        pub fn set_lte(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LteObj>>,
        ) -> Self {
            self.lte = input;
            self
        }
        /// Appends an item to `cdma`.
        ///
        /// To override the contents of this collection use [`set_cdma`](Self::set_cdma).
        ///
        /// <p>CDMA object information.</p>
        pub fn cdma(mut self, input: crate::model::CdmaObj) -> Self {
            let mut v = self.cdma.unwrap_or_default();
            v.push(input);
            self.cdma = Some(v);
            self
        }
        /// <p>CDMA object information.</p>
        pub fn set_cdma(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CdmaObj>>,
        ) -> Self {
            self.cdma = input;
            self
        }
        /// Consumes the builder and constructs a [`CellTowers`](crate::model::CellTowers).
        pub fn build(self) -> crate::model::CellTowers {
            crate::model::CellTowers {
                gsm: self.gsm,
                wcdma: self.wcdma,
                tdscdma: self.tdscdma,
                lte: self.lte,
                cdma: self.cdma,
            }
        }
    }
}

/// <p>CDMA (Code-division multiple access) object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CdmaObj {
    /// <p>CDMA system ID (SID).</p>
    #[doc(hidden)]
    pub system_id: std::option::Option<i32>,
    /// <p>CDMA network ID (NID).</p>
    #[doc(hidden)]
    pub network_id: std::option::Option<i32>,
    /// <p>CDMA base station ID (BSID).</p>
    #[doc(hidden)]
    pub base_station_id: std::option::Option<i32>,
    /// <p>CDMA registration zone (RZ).</p>
    #[doc(hidden)]
    pub registration_zone: std::option::Option<i32>,
    /// <p>CDMA local identification (local ID) parameters.</p>
    #[doc(hidden)]
    pub cdma_local_id: std::option::Option<crate::model::CdmaLocalId>,
    /// <p>Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).</p>
    #[doc(hidden)]
    pub pilot_power: std::option::Option<i32>,
    /// <p>CDMA base station latitude in degrees.</p>
    #[doc(hidden)]
    pub base_lat: std::option::Option<f32>,
    /// <p>CDMA base station longtitude in degrees.</p>
    #[doc(hidden)]
    pub base_lng: std::option::Option<f32>,
    /// <p>CDMA network measurement reports.</p>
    #[doc(hidden)]
    pub cdma_nmr: std::option::Option<std::vec::Vec<crate::model::CdmaNmrObj>>,
}
impl CdmaObj {
    /// <p>CDMA system ID (SID).</p>
    pub fn system_id(&self) -> std::option::Option<i32> {
        self.system_id
    }
    /// <p>CDMA network ID (NID).</p>
    pub fn network_id(&self) -> std::option::Option<i32> {
        self.network_id
    }
    /// <p>CDMA base station ID (BSID).</p>
    pub fn base_station_id(&self) -> std::option::Option<i32> {
        self.base_station_id
    }
    /// <p>CDMA registration zone (RZ).</p>
    pub fn registration_zone(&self) -> std::option::Option<i32> {
        self.registration_zone
    }
    /// <p>CDMA local identification (local ID) parameters.</p>
    pub fn cdma_local_id(&self) -> std::option::Option<&crate::model::CdmaLocalId> {
        self.cdma_local_id.as_ref()
    }
    /// <p>Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).</p>
    pub fn pilot_power(&self) -> std::option::Option<i32> {
        self.pilot_power
    }
    /// <p>CDMA base station latitude in degrees.</p>
    pub fn base_lat(&self) -> std::option::Option<f32> {
        self.base_lat
    }
    /// <p>CDMA base station longtitude in degrees.</p>
    pub fn base_lng(&self) -> std::option::Option<f32> {
        self.base_lng
    }
    /// <p>CDMA network measurement reports.</p>
    pub fn cdma_nmr(&self) -> std::option::Option<&[crate::model::CdmaNmrObj]> {
        self.cdma_nmr.as_deref()
    }
}
impl CdmaObj {
    /// Creates a new builder-style object to manufacture [`CdmaObj`](crate::model::CdmaObj).
    pub fn builder() -> crate::model::cdma_obj::Builder {
        crate::model::cdma_obj::Builder::default()
    }
}

/// See [`CdmaObj`](crate::model::CdmaObj).
pub mod cdma_obj {

    /// A builder for [`CdmaObj`](crate::model::CdmaObj).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) system_id: std::option::Option<i32>,
        pub(crate) network_id: std::option::Option<i32>,
        pub(crate) base_station_id: std::option::Option<i32>,
        pub(crate) registration_zone: std::option::Option<i32>,
        pub(crate) cdma_local_id: std::option::Option<crate::model::CdmaLocalId>,
        pub(crate) pilot_power: std::option::Option<i32>,
        pub(crate) base_lat: std::option::Option<f32>,
        pub(crate) base_lng: std::option::Option<f32>,
        pub(crate) cdma_nmr: std::option::Option<std::vec::Vec<crate::model::CdmaNmrObj>>,
    }
    impl Builder {
        /// <p>CDMA system ID (SID).</p>
        pub fn system_id(mut self, input: i32) -> Self {
            self.system_id = Some(input);
            self
        }
        /// <p>CDMA system ID (SID).</p>
        pub fn set_system_id(mut self, input: std::option::Option<i32>) -> Self {
            self.system_id = input;
            self
        }
        /// <p>CDMA network ID (NID).</p>
        pub fn network_id(mut self, input: i32) -> Self {
            self.network_id = Some(input);
            self
        }
        /// <p>CDMA network ID (NID).</p>
        pub fn set_network_id(mut self, input: std::option::Option<i32>) -> Self {
            self.network_id = input;
            self
        }
        /// <p>CDMA base station ID (BSID).</p>
        pub fn base_station_id(mut self, input: i32) -> Self {
            self.base_station_id = Some(input);
            self
        }
        /// <p>CDMA base station ID (BSID).</p>
        pub fn set_base_station_id(mut self, input: std::option::Option<i32>) -> Self {
            self.base_station_id = input;
            self
        }
        /// <p>CDMA registration zone (RZ).</p>
        pub fn registration_zone(mut self, input: i32) -> Self {
            self.registration_zone = Some(input);
            self
        }
        /// <p>CDMA registration zone (RZ).</p>
        pub fn set_registration_zone(mut self, input: std::option::Option<i32>) -> Self {
            self.registration_zone = input;
            self
        }
        /// <p>CDMA local identification (local ID) parameters.</p>
        pub fn cdma_local_id(mut self, input: crate::model::CdmaLocalId) -> Self {
            self.cdma_local_id = Some(input);
            self
        }
        /// <p>CDMA local identification (local ID) parameters.</p>
        pub fn set_cdma_local_id(
            mut self,
            input: std::option::Option<crate::model::CdmaLocalId>,
        ) -> Self {
            self.cdma_local_id = input;
            self
        }
        /// <p>Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).</p>
        pub fn pilot_power(mut self, input: i32) -> Self {
            self.pilot_power = Some(input);
            self
        }
        /// <p>Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).</p>
        pub fn set_pilot_power(mut self, input: std::option::Option<i32>) -> Self {
            self.pilot_power = input;
            self
        }
        /// <p>CDMA base station latitude in degrees.</p>
        pub fn base_lat(mut self, input: f32) -> Self {
            self.base_lat = Some(input);
            self
        }
        /// <p>CDMA base station latitude in degrees.</p>
        pub fn set_base_lat(mut self, input: std::option::Option<f32>) -> Self {
            self.base_lat = input;
            self
        }
        /// <p>CDMA base station longtitude in degrees.</p>
        pub fn base_lng(mut self, input: f32) -> Self {
            self.base_lng = Some(input);
            self
        }
        /// <p>CDMA base station longtitude in degrees.</p>
        pub fn set_base_lng(mut self, input: std::option::Option<f32>) -> Self {
            self.base_lng = input;
            self
        }
        /// Appends an item to `cdma_nmr`.
        ///
        /// To override the contents of this collection use [`set_cdma_nmr`](Self::set_cdma_nmr).
        ///
        /// <p>CDMA network measurement reports.</p>
        pub fn cdma_nmr(mut self, input: crate::model::CdmaNmrObj) -> Self {
            let mut v = self.cdma_nmr.unwrap_or_default();
            v.push(input);
            self.cdma_nmr = Some(v);
            self
        }
        /// <p>CDMA network measurement reports.</p>
        pub fn set_cdma_nmr(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::CdmaNmrObj>>,
        ) -> Self {
            self.cdma_nmr = input;
            self
        }
        /// Consumes the builder and constructs a [`CdmaObj`](crate::model::CdmaObj).
        pub fn build(self) -> crate::model::CdmaObj {
            crate::model::CdmaObj {
                system_id: self.system_id,
                network_id: self.network_id,
                base_station_id: self.base_station_id,
                registration_zone: self.registration_zone,
                cdma_local_id: self.cdma_local_id,
                pilot_power: self.pilot_power,
                base_lat: self.base_lat,
                base_lng: self.base_lng,
                cdma_nmr: self.cdma_nmr,
            }
        }
    }
}

/// <p>CDMA object for network measurement reports.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CdmaNmrObj {
    /// <p>Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.</p>
    #[doc(hidden)]
    pub pn_offset: std::option::Option<i32>,
    /// <p>CDMA channel information.</p>
    #[doc(hidden)]
    pub cdma_channel: std::option::Option<i32>,
    /// <p>Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).</p>
    #[doc(hidden)]
    pub pilot_power: std::option::Option<i32>,
    /// <p>CDMA base station ID (BSID).</p>
    #[doc(hidden)]
    pub base_station_id: std::option::Option<i32>,
}
impl CdmaNmrObj {
    /// <p>Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.</p>
    pub fn pn_offset(&self) -> std::option::Option<i32> {
        self.pn_offset
    }
    /// <p>CDMA channel information.</p>
    pub fn cdma_channel(&self) -> std::option::Option<i32> {
        self.cdma_channel
    }
    /// <p>Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).</p>
    pub fn pilot_power(&self) -> std::option::Option<i32> {
        self.pilot_power
    }
    /// <p>CDMA base station ID (BSID).</p>
    pub fn base_station_id(&self) -> std::option::Option<i32> {
        self.base_station_id
    }
}
impl CdmaNmrObj {
    /// Creates a new builder-style object to manufacture [`CdmaNmrObj`](crate::model::CdmaNmrObj).
    pub fn builder() -> crate::model::cdma_nmr_obj::Builder {
        crate::model::cdma_nmr_obj::Builder::default()
    }
}

/// See [`CdmaNmrObj`](crate::model::CdmaNmrObj).
pub mod cdma_nmr_obj {

    /// A builder for [`CdmaNmrObj`](crate::model::CdmaNmrObj).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pn_offset: std::option::Option<i32>,
        pub(crate) cdma_channel: std::option::Option<i32>,
        pub(crate) pilot_power: std::option::Option<i32>,
        pub(crate) base_station_id: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.</p>
        pub fn pn_offset(mut self, input: i32) -> Self {
            self.pn_offset = Some(input);
            self
        }
        /// <p>Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.</p>
        pub fn set_pn_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.pn_offset = input;
            self
        }
        /// <p>CDMA channel information.</p>
        pub fn cdma_channel(mut self, input: i32) -> Self {
            self.cdma_channel = Some(input);
            self
        }
        /// <p>CDMA channel information.</p>
        pub fn set_cdma_channel(mut self, input: std::option::Option<i32>) -> Self {
            self.cdma_channel = input;
            self
        }
        /// <p>Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).</p>
        pub fn pilot_power(mut self, input: i32) -> Self {
            self.pilot_power = Some(input);
            self
        }
        /// <p>Transmit power level of the pilot signal, measured in dBm (decibel-milliwatts).</p>
        pub fn set_pilot_power(mut self, input: std::option::Option<i32>) -> Self {
            self.pilot_power = input;
            self
        }
        /// <p>CDMA base station ID (BSID).</p>
        pub fn base_station_id(mut self, input: i32) -> Self {
            self.base_station_id = Some(input);
            self
        }
        /// <p>CDMA base station ID (BSID).</p>
        pub fn set_base_station_id(mut self, input: std::option::Option<i32>) -> Self {
            self.base_station_id = input;
            self
        }
        /// Consumes the builder and constructs a [`CdmaNmrObj`](crate::model::CdmaNmrObj).
        pub fn build(self) -> crate::model::CdmaNmrObj {
            crate::model::CdmaNmrObj {
                pn_offset: self.pn_offset,
                cdma_channel: self.cdma_channel,
                pilot_power: self.pilot_power,
                base_station_id: self.base_station_id,
            }
        }
    }
}

/// <p>CDMA local ID information, which corresponds to the local identification parameters of a CDMA cell.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CdmaLocalId {
    /// <p>Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.</p>
    #[doc(hidden)]
    pub pn_offset: std::option::Option<i32>,
    /// <p>CDMA channel information.</p>
    #[doc(hidden)]
    pub cdma_channel: std::option::Option<i32>,
}
impl CdmaLocalId {
    /// <p>Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.</p>
    pub fn pn_offset(&self) -> std::option::Option<i32> {
        self.pn_offset
    }
    /// <p>CDMA channel information.</p>
    pub fn cdma_channel(&self) -> std::option::Option<i32> {
        self.cdma_channel
    }
}
impl CdmaLocalId {
    /// Creates a new builder-style object to manufacture [`CdmaLocalId`](crate::model::CdmaLocalId).
    pub fn builder() -> crate::model::cdma_local_id::Builder {
        crate::model::cdma_local_id::Builder::default()
    }
}

/// See [`CdmaLocalId`](crate::model::CdmaLocalId).
pub mod cdma_local_id {

    /// A builder for [`CdmaLocalId`](crate::model::CdmaLocalId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pn_offset: std::option::Option<i32>,
        pub(crate) cdma_channel: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.</p>
        pub fn pn_offset(mut self, input: i32) -> Self {
            self.pn_offset = Some(input);
            self
        }
        /// <p>Pseudo-noise offset, which is a characteristic of the signal from a cell on a radio tower.</p>
        pub fn set_pn_offset(mut self, input: std::option::Option<i32>) -> Self {
            self.pn_offset = input;
            self
        }
        /// <p>CDMA channel information.</p>
        pub fn cdma_channel(mut self, input: i32) -> Self {
            self.cdma_channel = Some(input);
            self
        }
        /// <p>CDMA channel information.</p>
        pub fn set_cdma_channel(mut self, input: std::option::Option<i32>) -> Self {
            self.cdma_channel = input;
            self
        }
        /// Consumes the builder and constructs a [`CdmaLocalId`](crate::model::CdmaLocalId).
        pub fn build(self) -> crate::model::CdmaLocalId {
            crate::model::CdmaLocalId {
                pn_offset: self.pn_offset,
                cdma_channel: self.cdma_channel,
            }
        }
    }
}

/// <p>LTE object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LteObj {
    /// <p>Mobile Country Code.</p>
    #[doc(hidden)]
    pub mcc: std::option::Option<i32>,
    /// <p>Mobile Network Code.</p>
    #[doc(hidden)]
    pub mnc: std::option::Option<i32>,
    /// <p>E-UTRAN (Evolved Universal Terrestrial Radio Access Network) Cell Global Identifier.</p>
    #[doc(hidden)]
    pub eutran_cid: std::option::Option<i32>,
    /// <p>LTE tracking area code.</p>
    #[doc(hidden)]
    pub tac: std::option::Option<i32>,
    /// <p>LTE local identification (local ID) information.</p>
    #[doc(hidden)]
    pub lte_local_id: std::option::Option<crate::model::LteLocalId>,
    /// <p>LTE timing advance.</p>
    #[doc(hidden)]
    pub lte_timing_advance: std::option::Option<i32>,
    /// <p>Signal power of the reference signal received, measured in dBm (decibel-milliwatts).</p>
    #[doc(hidden)]
    pub rsrp: std::option::Option<i32>,
    /// <p>Signal quality of the reference Signal received, measured in decibels (dB).</p>
    #[doc(hidden)]
    pub rsrq: std::option::Option<f32>,
    /// <p>Parameter that determines whether the LTE object is capable of supporting NR (new radio).</p>
    #[doc(hidden)]
    pub nr_capable: bool,
    /// <p>LTE object for network measurement reports.</p>
    #[doc(hidden)]
    pub lte_nmr: std::option::Option<std::vec::Vec<crate::model::LteNmrObj>>,
}
impl LteObj {
    /// <p>Mobile Country Code.</p>
    pub fn mcc(&self) -> std::option::Option<i32> {
        self.mcc
    }
    /// <p>Mobile Network Code.</p>
    pub fn mnc(&self) -> std::option::Option<i32> {
        self.mnc
    }
    /// <p>E-UTRAN (Evolved Universal Terrestrial Radio Access Network) Cell Global Identifier.</p>
    pub fn eutran_cid(&self) -> std::option::Option<i32> {
        self.eutran_cid
    }
    /// <p>LTE tracking area code.</p>
    pub fn tac(&self) -> std::option::Option<i32> {
        self.tac
    }
    /// <p>LTE local identification (local ID) information.</p>
    pub fn lte_local_id(&self) -> std::option::Option<&crate::model::LteLocalId> {
        self.lte_local_id.as_ref()
    }
    /// <p>LTE timing advance.</p>
    pub fn lte_timing_advance(&self) -> std::option::Option<i32> {
        self.lte_timing_advance
    }
    /// <p>Signal power of the reference signal received, measured in dBm (decibel-milliwatts).</p>
    pub fn rsrp(&self) -> std::option::Option<i32> {
        self.rsrp
    }
    /// <p>Signal quality of the reference Signal received, measured in decibels (dB).</p>
    pub fn rsrq(&self) -> std::option::Option<f32> {
        self.rsrq
    }
    /// <p>Parameter that determines whether the LTE object is capable of supporting NR (new radio).</p>
    pub fn nr_capable(&self) -> bool {
        self.nr_capable
    }
    /// <p>LTE object for network measurement reports.</p>
    pub fn lte_nmr(&self) -> std::option::Option<&[crate::model::LteNmrObj]> {
        self.lte_nmr.as_deref()
    }
}
impl LteObj {
    /// Creates a new builder-style object to manufacture [`LteObj`](crate::model::LteObj).
    pub fn builder() -> crate::model::lte_obj::Builder {
        crate::model::lte_obj::Builder::default()
    }
}

/// See [`LteObj`](crate::model::LteObj).
pub mod lte_obj {

    /// A builder for [`LteObj`](crate::model::LteObj).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mcc: std::option::Option<i32>,
        pub(crate) mnc: std::option::Option<i32>,
        pub(crate) eutran_cid: std::option::Option<i32>,
        pub(crate) tac: std::option::Option<i32>,
        pub(crate) lte_local_id: std::option::Option<crate::model::LteLocalId>,
        pub(crate) lte_timing_advance: std::option::Option<i32>,
        pub(crate) rsrp: std::option::Option<i32>,
        pub(crate) rsrq: std::option::Option<f32>,
        pub(crate) nr_capable: std::option::Option<bool>,
        pub(crate) lte_nmr: std::option::Option<std::vec::Vec<crate::model::LteNmrObj>>,
    }
    impl Builder {
        /// <p>Mobile Country Code.</p>
        pub fn mcc(mut self, input: i32) -> Self {
            self.mcc = Some(input);
            self
        }
        /// <p>Mobile Country Code.</p>
        pub fn set_mcc(mut self, input: std::option::Option<i32>) -> Self {
            self.mcc = input;
            self
        }
        /// <p>Mobile Network Code.</p>
        pub fn mnc(mut self, input: i32) -> Self {
            self.mnc = Some(input);
            self
        }
        /// <p>Mobile Network Code.</p>
        pub fn set_mnc(mut self, input: std::option::Option<i32>) -> Self {
            self.mnc = input;
            self
        }
        /// <p>E-UTRAN (Evolved Universal Terrestrial Radio Access Network) Cell Global Identifier.</p>
        pub fn eutran_cid(mut self, input: i32) -> Self {
            self.eutran_cid = Some(input);
            self
        }
        /// <p>E-UTRAN (Evolved Universal Terrestrial Radio Access Network) Cell Global Identifier.</p>
        pub fn set_eutran_cid(mut self, input: std::option::Option<i32>) -> Self {
            self.eutran_cid = input;
            self
        }
        /// <p>LTE tracking area code.</p>
        pub fn tac(mut self, input: i32) -> Self {
            self.tac = Some(input);
            self
        }
        /// <p>LTE tracking area code.</p>
        pub fn set_tac(mut self, input: std::option::Option<i32>) -> Self {
            self.tac = input;
            self
        }
        /// <p>LTE local identification (local ID) information.</p>
        pub fn lte_local_id(mut self, input: crate::model::LteLocalId) -> Self {
            self.lte_local_id = Some(input);
            self
        }
        /// <p>LTE local identification (local ID) information.</p>
        pub fn set_lte_local_id(
            mut self,
            input: std::option::Option<crate::model::LteLocalId>,
        ) -> Self {
            self.lte_local_id = input;
            self
        }
        /// <p>LTE timing advance.</p>
        pub fn lte_timing_advance(mut self, input: i32) -> Self {
            self.lte_timing_advance = Some(input);
            self
        }
        /// <p>LTE timing advance.</p>
        pub fn set_lte_timing_advance(mut self, input: std::option::Option<i32>) -> Self {
            self.lte_timing_advance = input;
            self
        }
        /// <p>Signal power of the reference signal received, measured in dBm (decibel-milliwatts).</p>
        pub fn rsrp(mut self, input: i32) -> Self {
            self.rsrp = Some(input);
            self
        }
        /// <p>Signal power of the reference signal received, measured in dBm (decibel-milliwatts).</p>
        pub fn set_rsrp(mut self, input: std::option::Option<i32>) -> Self {
            self.rsrp = input;
            self
        }
        /// <p>Signal quality of the reference Signal received, measured in decibels (dB).</p>
        pub fn rsrq(mut self, input: f32) -> Self {
            self.rsrq = Some(input);
            self
        }
        /// <p>Signal quality of the reference Signal received, measured in decibels (dB).</p>
        pub fn set_rsrq(mut self, input: std::option::Option<f32>) -> Self {
            self.rsrq = input;
            self
        }
        /// <p>Parameter that determines whether the LTE object is capable of supporting NR (new radio).</p>
        pub fn nr_capable(mut self, input: bool) -> Self {
            self.nr_capable = Some(input);
            self
        }
        /// <p>Parameter that determines whether the LTE object is capable of supporting NR (new radio).</p>
        pub fn set_nr_capable(mut self, input: std::option::Option<bool>) -> Self {
            self.nr_capable = input;
            self
        }
        /// Appends an item to `lte_nmr`.
        ///
        /// To override the contents of this collection use [`set_lte_nmr`](Self::set_lte_nmr).
        ///
        /// <p>LTE object for network measurement reports.</p>
        pub fn lte_nmr(mut self, input: crate::model::LteNmrObj) -> Self {
            let mut v = self.lte_nmr.unwrap_or_default();
            v.push(input);
            self.lte_nmr = Some(v);
            self
        }
        /// <p>LTE object for network measurement reports.</p>
        pub fn set_lte_nmr(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::LteNmrObj>>,
        ) -> Self {
            self.lte_nmr = input;
            self
        }
        /// Consumes the builder and constructs a [`LteObj`](crate::model::LteObj).
        pub fn build(self) -> crate::model::LteObj {
            crate::model::LteObj {
                mcc: self.mcc,
                mnc: self.mnc,
                eutran_cid: self.eutran_cid,
                tac: self.tac,
                lte_local_id: self.lte_local_id,
                lte_timing_advance: self.lte_timing_advance,
                rsrp: self.rsrp,
                rsrq: self.rsrq,
                nr_capable: self.nr_capable.unwrap_or_default(),
                lte_nmr: self.lte_nmr,
            }
        }
    }
}

/// <p>LTE object for network measurement reports.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LteNmrObj {
    /// <p>Physical cell ID.</p>
    #[doc(hidden)]
    pub pci: std::option::Option<i32>,
    /// <p>E-UTRA (Evolved universal terrestrial Radio Access) absolute radio frequency channel Number (EARFCN).</p>
    #[doc(hidden)]
    pub earfcn: std::option::Option<i32>,
    /// <p>E-UTRAN (Evolved Universal Terrestrial Radio Access Network) cell global identifier (EUTRANCID).</p>
    #[doc(hidden)]
    pub eutran_cid: std::option::Option<i32>,
    /// <p>Signal power of the reference signal received, measured in dBm (decibel-milliwatts).</p>
    #[doc(hidden)]
    pub rsrp: std::option::Option<i32>,
    /// <p>Signal quality of the reference Signal received, measured in decibels (dB).</p>
    #[doc(hidden)]
    pub rsrq: std::option::Option<f32>,
}
impl LteNmrObj {
    /// <p>Physical cell ID.</p>
    pub fn pci(&self) -> std::option::Option<i32> {
        self.pci
    }
    /// <p>E-UTRA (Evolved universal terrestrial Radio Access) absolute radio frequency channel Number (EARFCN).</p>
    pub fn earfcn(&self) -> std::option::Option<i32> {
        self.earfcn
    }
    /// <p>E-UTRAN (Evolved Universal Terrestrial Radio Access Network) cell global identifier (EUTRANCID).</p>
    pub fn eutran_cid(&self) -> std::option::Option<i32> {
        self.eutran_cid
    }
    /// <p>Signal power of the reference signal received, measured in dBm (decibel-milliwatts).</p>
    pub fn rsrp(&self) -> std::option::Option<i32> {
        self.rsrp
    }
    /// <p>Signal quality of the reference Signal received, measured in decibels (dB).</p>
    pub fn rsrq(&self) -> std::option::Option<f32> {
        self.rsrq
    }
}
impl LteNmrObj {
    /// Creates a new builder-style object to manufacture [`LteNmrObj`](crate::model::LteNmrObj).
    pub fn builder() -> crate::model::lte_nmr_obj::Builder {
        crate::model::lte_nmr_obj::Builder::default()
    }
}

/// See [`LteNmrObj`](crate::model::LteNmrObj).
pub mod lte_nmr_obj {

    /// A builder for [`LteNmrObj`](crate::model::LteNmrObj).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pci: std::option::Option<i32>,
        pub(crate) earfcn: std::option::Option<i32>,
        pub(crate) eutran_cid: std::option::Option<i32>,
        pub(crate) rsrp: std::option::Option<i32>,
        pub(crate) rsrq: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>Physical cell ID.</p>
        pub fn pci(mut self, input: i32) -> Self {
            self.pci = Some(input);
            self
        }
        /// <p>Physical cell ID.</p>
        pub fn set_pci(mut self, input: std::option::Option<i32>) -> Self {
            self.pci = input;
            self
        }
        /// <p>E-UTRA (Evolved universal terrestrial Radio Access) absolute radio frequency channel Number (EARFCN).</p>
        pub fn earfcn(mut self, input: i32) -> Self {
            self.earfcn = Some(input);
            self
        }
        /// <p>E-UTRA (Evolved universal terrestrial Radio Access) absolute radio frequency channel Number (EARFCN).</p>
        pub fn set_earfcn(mut self, input: std::option::Option<i32>) -> Self {
            self.earfcn = input;
            self
        }
        /// <p>E-UTRAN (Evolved Universal Terrestrial Radio Access Network) cell global identifier (EUTRANCID).</p>
        pub fn eutran_cid(mut self, input: i32) -> Self {
            self.eutran_cid = Some(input);
            self
        }
        /// <p>E-UTRAN (Evolved Universal Terrestrial Radio Access Network) cell global identifier (EUTRANCID).</p>
        pub fn set_eutran_cid(mut self, input: std::option::Option<i32>) -> Self {
            self.eutran_cid = input;
            self
        }
        /// <p>Signal power of the reference signal received, measured in dBm (decibel-milliwatts).</p>
        pub fn rsrp(mut self, input: i32) -> Self {
            self.rsrp = Some(input);
            self
        }
        /// <p>Signal power of the reference signal received, measured in dBm (decibel-milliwatts).</p>
        pub fn set_rsrp(mut self, input: std::option::Option<i32>) -> Self {
            self.rsrp = input;
            self
        }
        /// <p>Signal quality of the reference Signal received, measured in decibels (dB).</p>
        pub fn rsrq(mut self, input: f32) -> Self {
            self.rsrq = Some(input);
            self
        }
        /// <p>Signal quality of the reference Signal received, measured in decibels (dB).</p>
        pub fn set_rsrq(mut self, input: std::option::Option<f32>) -> Self {
            self.rsrq = input;
            self
        }
        /// Consumes the builder and constructs a [`LteNmrObj`](crate::model::LteNmrObj).
        pub fn build(self) -> crate::model::LteNmrObj {
            crate::model::LteNmrObj {
                pci: self.pci,
                earfcn: self.earfcn,
                eutran_cid: self.eutran_cid,
                rsrp: self.rsrp,
                rsrq: self.rsrq,
            }
        }
    }
}

/// <p>LTE local identification (local ID) information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LteLocalId {
    /// <p>Physical cell ID.</p>
    #[doc(hidden)]
    pub pci: std::option::Option<i32>,
    /// <p>Evolved universal terrestrial radio access (E-UTRA) absolute radio frequency channel number (FCN).</p>
    #[doc(hidden)]
    pub earfcn: std::option::Option<i32>,
}
impl LteLocalId {
    /// <p>Physical cell ID.</p>
    pub fn pci(&self) -> std::option::Option<i32> {
        self.pci
    }
    /// <p>Evolved universal terrestrial radio access (E-UTRA) absolute radio frequency channel number (FCN).</p>
    pub fn earfcn(&self) -> std::option::Option<i32> {
        self.earfcn
    }
}
impl LteLocalId {
    /// Creates a new builder-style object to manufacture [`LteLocalId`](crate::model::LteLocalId).
    pub fn builder() -> crate::model::lte_local_id::Builder {
        crate::model::lte_local_id::Builder::default()
    }
}

/// See [`LteLocalId`](crate::model::LteLocalId).
pub mod lte_local_id {

    /// A builder for [`LteLocalId`](crate::model::LteLocalId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pci: std::option::Option<i32>,
        pub(crate) earfcn: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Physical cell ID.</p>
        pub fn pci(mut self, input: i32) -> Self {
            self.pci = Some(input);
            self
        }
        /// <p>Physical cell ID.</p>
        pub fn set_pci(mut self, input: std::option::Option<i32>) -> Self {
            self.pci = input;
            self
        }
        /// <p>Evolved universal terrestrial radio access (E-UTRA) absolute radio frequency channel number (FCN).</p>
        pub fn earfcn(mut self, input: i32) -> Self {
            self.earfcn = Some(input);
            self
        }
        /// <p>Evolved universal terrestrial radio access (E-UTRA) absolute radio frequency channel number (FCN).</p>
        pub fn set_earfcn(mut self, input: std::option::Option<i32>) -> Self {
            self.earfcn = input;
            self
        }
        /// Consumes the builder and constructs a [`LteLocalId`](crate::model::LteLocalId).
        pub fn build(self) -> crate::model::LteLocalId {
            crate::model::LteLocalId {
                pci: self.pci,
                earfcn: self.earfcn,
            }
        }
    }
}

/// <p>TD-SCDMA object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TdscdmaObj {
    /// <p>Mobile Country Code.</p>
    #[doc(hidden)]
    pub mcc: std::option::Option<i32>,
    /// <p>Mobile Network Code.</p>
    #[doc(hidden)]
    pub mnc: std::option::Option<i32>,
    /// <p>Location Area Code.</p>
    #[doc(hidden)]
    pub lac: std::option::Option<i32>,
    /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
    #[doc(hidden)]
    pub utran_cid: std::option::Option<i32>,
    /// <p>TD-SCDMA local identification (local ID) information.</p>
    #[doc(hidden)]
    pub tdscdma_local_id: std::option::Option<crate::model::TdscdmaLocalId>,
    /// <p>TD-SCDMA Timing advance.</p>
    #[doc(hidden)]
    pub tdscdma_timing_advance: std::option::Option<i32>,
    /// <p>Signal power of the received signal (Received Signal Code Power), measured in decibel-milliwatts (dBm).</p>
    #[doc(hidden)]
    pub rscp: std::option::Option<i32>,
    /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
    #[doc(hidden)]
    pub path_loss: std::option::Option<i32>,
    /// <p>TD-SCDMA object for network measurement reports.</p>
    #[doc(hidden)]
    pub tdscdma_nmr: std::option::Option<std::vec::Vec<crate::model::TdscdmaNmrObj>>,
}
impl TdscdmaObj {
    /// <p>Mobile Country Code.</p>
    pub fn mcc(&self) -> std::option::Option<i32> {
        self.mcc
    }
    /// <p>Mobile Network Code.</p>
    pub fn mnc(&self) -> std::option::Option<i32> {
        self.mnc
    }
    /// <p>Location Area Code.</p>
    pub fn lac(&self) -> std::option::Option<i32> {
        self.lac
    }
    /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
    pub fn utran_cid(&self) -> std::option::Option<i32> {
        self.utran_cid
    }
    /// <p>TD-SCDMA local identification (local ID) information.</p>
    pub fn tdscdma_local_id(&self) -> std::option::Option<&crate::model::TdscdmaLocalId> {
        self.tdscdma_local_id.as_ref()
    }
    /// <p>TD-SCDMA Timing advance.</p>
    pub fn tdscdma_timing_advance(&self) -> std::option::Option<i32> {
        self.tdscdma_timing_advance
    }
    /// <p>Signal power of the received signal (Received Signal Code Power), measured in decibel-milliwatts (dBm).</p>
    pub fn rscp(&self) -> std::option::Option<i32> {
        self.rscp
    }
    /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
    pub fn path_loss(&self) -> std::option::Option<i32> {
        self.path_loss
    }
    /// <p>TD-SCDMA object for network measurement reports.</p>
    pub fn tdscdma_nmr(&self) -> std::option::Option<&[crate::model::TdscdmaNmrObj]> {
        self.tdscdma_nmr.as_deref()
    }
}
impl TdscdmaObj {
    /// Creates a new builder-style object to manufacture [`TdscdmaObj`](crate::model::TdscdmaObj).
    pub fn builder() -> crate::model::tdscdma_obj::Builder {
        crate::model::tdscdma_obj::Builder::default()
    }
}

/// See [`TdscdmaObj`](crate::model::TdscdmaObj).
pub mod tdscdma_obj {

    /// A builder for [`TdscdmaObj`](crate::model::TdscdmaObj).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mcc: std::option::Option<i32>,
        pub(crate) mnc: std::option::Option<i32>,
        pub(crate) lac: std::option::Option<i32>,
        pub(crate) utran_cid: std::option::Option<i32>,
        pub(crate) tdscdma_local_id: std::option::Option<crate::model::TdscdmaLocalId>,
        pub(crate) tdscdma_timing_advance: std::option::Option<i32>,
        pub(crate) rscp: std::option::Option<i32>,
        pub(crate) path_loss: std::option::Option<i32>,
        pub(crate) tdscdma_nmr: std::option::Option<std::vec::Vec<crate::model::TdscdmaNmrObj>>,
    }
    impl Builder {
        /// <p>Mobile Country Code.</p>
        pub fn mcc(mut self, input: i32) -> Self {
            self.mcc = Some(input);
            self
        }
        /// <p>Mobile Country Code.</p>
        pub fn set_mcc(mut self, input: std::option::Option<i32>) -> Self {
            self.mcc = input;
            self
        }
        /// <p>Mobile Network Code.</p>
        pub fn mnc(mut self, input: i32) -> Self {
            self.mnc = Some(input);
            self
        }
        /// <p>Mobile Network Code.</p>
        pub fn set_mnc(mut self, input: std::option::Option<i32>) -> Self {
            self.mnc = input;
            self
        }
        /// <p>Location Area Code.</p>
        pub fn lac(mut self, input: i32) -> Self {
            self.lac = Some(input);
            self
        }
        /// <p>Location Area Code.</p>
        pub fn set_lac(mut self, input: std::option::Option<i32>) -> Self {
            self.lac = input;
            self
        }
        /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
        pub fn utran_cid(mut self, input: i32) -> Self {
            self.utran_cid = Some(input);
            self
        }
        /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
        pub fn set_utran_cid(mut self, input: std::option::Option<i32>) -> Self {
            self.utran_cid = input;
            self
        }
        /// <p>TD-SCDMA local identification (local ID) information.</p>
        pub fn tdscdma_local_id(mut self, input: crate::model::TdscdmaLocalId) -> Self {
            self.tdscdma_local_id = Some(input);
            self
        }
        /// <p>TD-SCDMA local identification (local ID) information.</p>
        pub fn set_tdscdma_local_id(
            mut self,
            input: std::option::Option<crate::model::TdscdmaLocalId>,
        ) -> Self {
            self.tdscdma_local_id = input;
            self
        }
        /// <p>TD-SCDMA Timing advance.</p>
        pub fn tdscdma_timing_advance(mut self, input: i32) -> Self {
            self.tdscdma_timing_advance = Some(input);
            self
        }
        /// <p>TD-SCDMA Timing advance.</p>
        pub fn set_tdscdma_timing_advance(mut self, input: std::option::Option<i32>) -> Self {
            self.tdscdma_timing_advance = input;
            self
        }
        /// <p>Signal power of the received signal (Received Signal Code Power), measured in decibel-milliwatts (dBm).</p>
        pub fn rscp(mut self, input: i32) -> Self {
            self.rscp = Some(input);
            self
        }
        /// <p>Signal power of the received signal (Received Signal Code Power), measured in decibel-milliwatts (dBm).</p>
        pub fn set_rscp(mut self, input: std::option::Option<i32>) -> Self {
            self.rscp = input;
            self
        }
        /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
        pub fn path_loss(mut self, input: i32) -> Self {
            self.path_loss = Some(input);
            self
        }
        /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
        pub fn set_path_loss(mut self, input: std::option::Option<i32>) -> Self {
            self.path_loss = input;
            self
        }
        /// Appends an item to `tdscdma_nmr`.
        ///
        /// To override the contents of this collection use [`set_tdscdma_nmr`](Self::set_tdscdma_nmr).
        ///
        /// <p>TD-SCDMA object for network measurement reports.</p>
        pub fn tdscdma_nmr(mut self, input: crate::model::TdscdmaNmrObj) -> Self {
            let mut v = self.tdscdma_nmr.unwrap_or_default();
            v.push(input);
            self.tdscdma_nmr = Some(v);
            self
        }
        /// <p>TD-SCDMA object for network measurement reports.</p>
        pub fn set_tdscdma_nmr(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::TdscdmaNmrObj>>,
        ) -> Self {
            self.tdscdma_nmr = input;
            self
        }
        /// Consumes the builder and constructs a [`TdscdmaObj`](crate::model::TdscdmaObj).
        pub fn build(self) -> crate::model::TdscdmaObj {
            crate::model::TdscdmaObj {
                mcc: self.mcc,
                mnc: self.mnc,
                lac: self.lac,
                utran_cid: self.utran_cid,
                tdscdma_local_id: self.tdscdma_local_id,
                tdscdma_timing_advance: self.tdscdma_timing_advance,
                rscp: self.rscp,
                path_loss: self.path_loss,
                tdscdma_nmr: self.tdscdma_nmr,
            }
        }
    }
}

/// <p>TD-SCDMA object for network measurement reports.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TdscdmaNmrObj {
    /// <p>TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number.</p>
    #[doc(hidden)]
    pub uarfcn: std::option::Option<i32>,
    /// <p>Cell parameters for TD-SCDMA network measurement reports object.</p>
    #[doc(hidden)]
    pub cell_params: std::option::Option<i32>,
    /// <p>UTRAN (UMTS Terrestrial Radio Access Network) cell global identifier.</p>
    #[doc(hidden)]
    pub utran_cid: std::option::Option<i32>,
    /// <p>Code power of the received signal, measured in decibel-milliwatts (dBm).</p>
    #[doc(hidden)]
    pub rscp: std::option::Option<i32>,
    /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
    #[doc(hidden)]
    pub path_loss: std::option::Option<i32>,
}
impl TdscdmaNmrObj {
    /// <p>TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number.</p>
    pub fn uarfcn(&self) -> std::option::Option<i32> {
        self.uarfcn
    }
    /// <p>Cell parameters for TD-SCDMA network measurement reports object.</p>
    pub fn cell_params(&self) -> std::option::Option<i32> {
        self.cell_params
    }
    /// <p>UTRAN (UMTS Terrestrial Radio Access Network) cell global identifier.</p>
    pub fn utran_cid(&self) -> std::option::Option<i32> {
        self.utran_cid
    }
    /// <p>Code power of the received signal, measured in decibel-milliwatts (dBm).</p>
    pub fn rscp(&self) -> std::option::Option<i32> {
        self.rscp
    }
    /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
    pub fn path_loss(&self) -> std::option::Option<i32> {
        self.path_loss
    }
}
impl TdscdmaNmrObj {
    /// Creates a new builder-style object to manufacture [`TdscdmaNmrObj`](crate::model::TdscdmaNmrObj).
    pub fn builder() -> crate::model::tdscdma_nmr_obj::Builder {
        crate::model::tdscdma_nmr_obj::Builder::default()
    }
}

/// See [`TdscdmaNmrObj`](crate::model::TdscdmaNmrObj).
pub mod tdscdma_nmr_obj {

    /// A builder for [`TdscdmaNmrObj`](crate::model::TdscdmaNmrObj).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uarfcn: std::option::Option<i32>,
        pub(crate) cell_params: std::option::Option<i32>,
        pub(crate) utran_cid: std::option::Option<i32>,
        pub(crate) rscp: std::option::Option<i32>,
        pub(crate) path_loss: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number.</p>
        pub fn uarfcn(mut self, input: i32) -> Self {
            self.uarfcn = Some(input);
            self
        }
        /// <p>TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number.</p>
        pub fn set_uarfcn(mut self, input: std::option::Option<i32>) -> Self {
            self.uarfcn = input;
            self
        }
        /// <p>Cell parameters for TD-SCDMA network measurement reports object.</p>
        pub fn cell_params(mut self, input: i32) -> Self {
            self.cell_params = Some(input);
            self
        }
        /// <p>Cell parameters for TD-SCDMA network measurement reports object.</p>
        pub fn set_cell_params(mut self, input: std::option::Option<i32>) -> Self {
            self.cell_params = input;
            self
        }
        /// <p>UTRAN (UMTS Terrestrial Radio Access Network) cell global identifier.</p>
        pub fn utran_cid(mut self, input: i32) -> Self {
            self.utran_cid = Some(input);
            self
        }
        /// <p>UTRAN (UMTS Terrestrial Radio Access Network) cell global identifier.</p>
        pub fn set_utran_cid(mut self, input: std::option::Option<i32>) -> Self {
            self.utran_cid = input;
            self
        }
        /// <p>Code power of the received signal, measured in decibel-milliwatts (dBm).</p>
        pub fn rscp(mut self, input: i32) -> Self {
            self.rscp = Some(input);
            self
        }
        /// <p>Code power of the received signal, measured in decibel-milliwatts (dBm).</p>
        pub fn set_rscp(mut self, input: std::option::Option<i32>) -> Self {
            self.rscp = input;
            self
        }
        /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
        pub fn path_loss(mut self, input: i32) -> Self {
            self.path_loss = Some(input);
            self
        }
        /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
        pub fn set_path_loss(mut self, input: std::option::Option<i32>) -> Self {
            self.path_loss = input;
            self
        }
        /// Consumes the builder and constructs a [`TdscdmaNmrObj`](crate::model::TdscdmaNmrObj).
        pub fn build(self) -> crate::model::TdscdmaNmrObj {
            crate::model::TdscdmaNmrObj {
                uarfcn: self.uarfcn,
                cell_params: self.cell_params,
                utran_cid: self.utran_cid,
                rscp: self.rscp,
                path_loss: self.path_loss,
            }
        }
    }
}

/// <p>TD-SCDMA local identification (local Id) information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TdscdmaLocalId {
    /// <p>TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number (UARFCN).</p>
    #[doc(hidden)]
    pub uarfcn: std::option::Option<i32>,
    /// <p>Cell parameters for TD-SCDMA.</p>
    #[doc(hidden)]
    pub cell_params: std::option::Option<i32>,
}
impl TdscdmaLocalId {
    /// <p>TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number (UARFCN).</p>
    pub fn uarfcn(&self) -> std::option::Option<i32> {
        self.uarfcn
    }
    /// <p>Cell parameters for TD-SCDMA.</p>
    pub fn cell_params(&self) -> std::option::Option<i32> {
        self.cell_params
    }
}
impl TdscdmaLocalId {
    /// Creates a new builder-style object to manufacture [`TdscdmaLocalId`](crate::model::TdscdmaLocalId).
    pub fn builder() -> crate::model::tdscdma_local_id::Builder {
        crate::model::tdscdma_local_id::Builder::default()
    }
}

/// See [`TdscdmaLocalId`](crate::model::TdscdmaLocalId).
pub mod tdscdma_local_id {

    /// A builder for [`TdscdmaLocalId`](crate::model::TdscdmaLocalId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uarfcn: std::option::Option<i32>,
        pub(crate) cell_params: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number (UARFCN).</p>
        pub fn uarfcn(mut self, input: i32) -> Self {
            self.uarfcn = Some(input);
            self
        }
        /// <p>TD-SCDMA UTRA (Universal Terrestrial Radio Access Network) absolute RF channel number (UARFCN).</p>
        pub fn set_uarfcn(mut self, input: std::option::Option<i32>) -> Self {
            self.uarfcn = input;
            self
        }
        /// <p>Cell parameters for TD-SCDMA.</p>
        pub fn cell_params(mut self, input: i32) -> Self {
            self.cell_params = Some(input);
            self
        }
        /// <p>Cell parameters for TD-SCDMA.</p>
        pub fn set_cell_params(mut self, input: std::option::Option<i32>) -> Self {
            self.cell_params = input;
            self
        }
        /// Consumes the builder and constructs a [`TdscdmaLocalId`](crate::model::TdscdmaLocalId).
        pub fn build(self) -> crate::model::TdscdmaLocalId {
            crate::model::TdscdmaLocalId {
                uarfcn: self.uarfcn,
                cell_params: self.cell_params,
            }
        }
    }
}

/// <p>WCDMA.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WcdmaObj {
    /// <p>Mobile Country Code.</p>
    #[doc(hidden)]
    pub mcc: std::option::Option<i32>,
    /// <p>Mobile Network Code.</p>
    #[doc(hidden)]
    pub mnc: std::option::Option<i32>,
    /// <p>Location Area Code.</p>
    #[doc(hidden)]
    pub lac: std::option::Option<i32>,
    /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
    #[doc(hidden)]
    pub utran_cid: std::option::Option<i32>,
    /// <p>WCDMA local ID information.</p>
    #[doc(hidden)]
    pub wcdma_local_id: std::option::Option<crate::model::WcdmaLocalId>,
    /// <p>Received Signal Code Power (signal power) (dBm).</p>
    #[doc(hidden)]
    pub rscp: std::option::Option<i32>,
    /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
    #[doc(hidden)]
    pub path_loss: std::option::Option<i32>,
    /// <p>WCDMA object for network measurement reports.</p>
    #[doc(hidden)]
    pub wcdma_nmr: std::option::Option<std::vec::Vec<crate::model::WcdmaNmrObj>>,
}
impl WcdmaObj {
    /// <p>Mobile Country Code.</p>
    pub fn mcc(&self) -> std::option::Option<i32> {
        self.mcc
    }
    /// <p>Mobile Network Code.</p>
    pub fn mnc(&self) -> std::option::Option<i32> {
        self.mnc
    }
    /// <p>Location Area Code.</p>
    pub fn lac(&self) -> std::option::Option<i32> {
        self.lac
    }
    /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
    pub fn utran_cid(&self) -> std::option::Option<i32> {
        self.utran_cid
    }
    /// <p>WCDMA local ID information.</p>
    pub fn wcdma_local_id(&self) -> std::option::Option<&crate::model::WcdmaLocalId> {
        self.wcdma_local_id.as_ref()
    }
    /// <p>Received Signal Code Power (signal power) (dBm).</p>
    pub fn rscp(&self) -> std::option::Option<i32> {
        self.rscp
    }
    /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
    pub fn path_loss(&self) -> std::option::Option<i32> {
        self.path_loss
    }
    /// <p>WCDMA object for network measurement reports.</p>
    pub fn wcdma_nmr(&self) -> std::option::Option<&[crate::model::WcdmaNmrObj]> {
        self.wcdma_nmr.as_deref()
    }
}
impl WcdmaObj {
    /// Creates a new builder-style object to manufacture [`WcdmaObj`](crate::model::WcdmaObj).
    pub fn builder() -> crate::model::wcdma_obj::Builder {
        crate::model::wcdma_obj::Builder::default()
    }
}

/// See [`WcdmaObj`](crate::model::WcdmaObj).
pub mod wcdma_obj {

    /// A builder for [`WcdmaObj`](crate::model::WcdmaObj).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mcc: std::option::Option<i32>,
        pub(crate) mnc: std::option::Option<i32>,
        pub(crate) lac: std::option::Option<i32>,
        pub(crate) utran_cid: std::option::Option<i32>,
        pub(crate) wcdma_local_id: std::option::Option<crate::model::WcdmaLocalId>,
        pub(crate) rscp: std::option::Option<i32>,
        pub(crate) path_loss: std::option::Option<i32>,
        pub(crate) wcdma_nmr: std::option::Option<std::vec::Vec<crate::model::WcdmaNmrObj>>,
    }
    impl Builder {
        /// <p>Mobile Country Code.</p>
        pub fn mcc(mut self, input: i32) -> Self {
            self.mcc = Some(input);
            self
        }
        /// <p>Mobile Country Code.</p>
        pub fn set_mcc(mut self, input: std::option::Option<i32>) -> Self {
            self.mcc = input;
            self
        }
        /// <p>Mobile Network Code.</p>
        pub fn mnc(mut self, input: i32) -> Self {
            self.mnc = Some(input);
            self
        }
        /// <p>Mobile Network Code.</p>
        pub fn set_mnc(mut self, input: std::option::Option<i32>) -> Self {
            self.mnc = input;
            self
        }
        /// <p>Location Area Code.</p>
        pub fn lac(mut self, input: i32) -> Self {
            self.lac = Some(input);
            self
        }
        /// <p>Location Area Code.</p>
        pub fn set_lac(mut self, input: std::option::Option<i32>) -> Self {
            self.lac = input;
            self
        }
        /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
        pub fn utran_cid(mut self, input: i32) -> Self {
            self.utran_cid = Some(input);
            self
        }
        /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
        pub fn set_utran_cid(mut self, input: std::option::Option<i32>) -> Self {
            self.utran_cid = input;
            self
        }
        /// <p>WCDMA local ID information.</p>
        pub fn wcdma_local_id(mut self, input: crate::model::WcdmaLocalId) -> Self {
            self.wcdma_local_id = Some(input);
            self
        }
        /// <p>WCDMA local ID information.</p>
        pub fn set_wcdma_local_id(
            mut self,
            input: std::option::Option<crate::model::WcdmaLocalId>,
        ) -> Self {
            self.wcdma_local_id = input;
            self
        }
        /// <p>Received Signal Code Power (signal power) (dBm).</p>
        pub fn rscp(mut self, input: i32) -> Self {
            self.rscp = Some(input);
            self
        }
        /// <p>Received Signal Code Power (signal power) (dBm).</p>
        pub fn set_rscp(mut self, input: std::option::Option<i32>) -> Self {
            self.rscp = input;
            self
        }
        /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
        pub fn path_loss(mut self, input: i32) -> Self {
            self.path_loss = Some(input);
            self
        }
        /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
        pub fn set_path_loss(mut self, input: std::option::Option<i32>) -> Self {
            self.path_loss = input;
            self
        }
        /// Appends an item to `wcdma_nmr`.
        ///
        /// To override the contents of this collection use [`set_wcdma_nmr`](Self::set_wcdma_nmr).
        ///
        /// <p>WCDMA object for network measurement reports.</p>
        pub fn wcdma_nmr(mut self, input: crate::model::WcdmaNmrObj) -> Self {
            let mut v = self.wcdma_nmr.unwrap_or_default();
            v.push(input);
            self.wcdma_nmr = Some(v);
            self
        }
        /// <p>WCDMA object for network measurement reports.</p>
        pub fn set_wcdma_nmr(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::WcdmaNmrObj>>,
        ) -> Self {
            self.wcdma_nmr = input;
            self
        }
        /// Consumes the builder and constructs a [`WcdmaObj`](crate::model::WcdmaObj).
        pub fn build(self) -> crate::model::WcdmaObj {
            crate::model::WcdmaObj {
                mcc: self.mcc,
                mnc: self.mnc,
                lac: self.lac,
                utran_cid: self.utran_cid,
                wcdma_local_id: self.wcdma_local_id,
                rscp: self.rscp,
                path_loss: self.path_loss,
                wcdma_nmr: self.wcdma_nmr,
            }
        }
    }
}

/// <p>Network Measurement Reports.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WcdmaNmrObj {
    /// <p>WCDMA UTRA Absolute RF Channel Number downlink.</p>
    #[doc(hidden)]
    pub uarfcndl: std::option::Option<i32>,
    /// <p>Primary Scrambling Code.</p>
    #[doc(hidden)]
    pub psc: std::option::Option<i32>,
    /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
    #[doc(hidden)]
    pub utran_cid: std::option::Option<i32>,
    /// <p>Received Signal Code Power (signal power) (dBm)</p>
    #[doc(hidden)]
    pub rscp: std::option::Option<i32>,
    /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
    #[doc(hidden)]
    pub path_loss: std::option::Option<i32>,
}
impl WcdmaNmrObj {
    /// <p>WCDMA UTRA Absolute RF Channel Number downlink.</p>
    pub fn uarfcndl(&self) -> std::option::Option<i32> {
        self.uarfcndl
    }
    /// <p>Primary Scrambling Code.</p>
    pub fn psc(&self) -> std::option::Option<i32> {
        self.psc
    }
    /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
    pub fn utran_cid(&self) -> std::option::Option<i32> {
        self.utran_cid
    }
    /// <p>Received Signal Code Power (signal power) (dBm)</p>
    pub fn rscp(&self) -> std::option::Option<i32> {
        self.rscp
    }
    /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
    pub fn path_loss(&self) -> std::option::Option<i32> {
        self.path_loss
    }
}
impl WcdmaNmrObj {
    /// Creates a new builder-style object to manufacture [`WcdmaNmrObj`](crate::model::WcdmaNmrObj).
    pub fn builder() -> crate::model::wcdma_nmr_obj::Builder {
        crate::model::wcdma_nmr_obj::Builder::default()
    }
}

/// See [`WcdmaNmrObj`](crate::model::WcdmaNmrObj).
pub mod wcdma_nmr_obj {

    /// A builder for [`WcdmaNmrObj`](crate::model::WcdmaNmrObj).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uarfcndl: std::option::Option<i32>,
        pub(crate) psc: std::option::Option<i32>,
        pub(crate) utran_cid: std::option::Option<i32>,
        pub(crate) rscp: std::option::Option<i32>,
        pub(crate) path_loss: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>WCDMA UTRA Absolute RF Channel Number downlink.</p>
        pub fn uarfcndl(mut self, input: i32) -> Self {
            self.uarfcndl = Some(input);
            self
        }
        /// <p>WCDMA UTRA Absolute RF Channel Number downlink.</p>
        pub fn set_uarfcndl(mut self, input: std::option::Option<i32>) -> Self {
            self.uarfcndl = input;
            self
        }
        /// <p>Primary Scrambling Code.</p>
        pub fn psc(mut self, input: i32) -> Self {
            self.psc = Some(input);
            self
        }
        /// <p>Primary Scrambling Code.</p>
        pub fn set_psc(mut self, input: std::option::Option<i32>) -> Self {
            self.psc = input;
            self
        }
        /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
        pub fn utran_cid(mut self, input: i32) -> Self {
            self.utran_cid = Some(input);
            self
        }
        /// <p>UTRAN (UMTS Terrestrial Radio Access Network) Cell Global Identifier.</p>
        pub fn set_utran_cid(mut self, input: std::option::Option<i32>) -> Self {
            self.utran_cid = input;
            self
        }
        /// <p>Received Signal Code Power (signal power) (dBm)</p>
        pub fn rscp(mut self, input: i32) -> Self {
            self.rscp = Some(input);
            self
        }
        /// <p>Received Signal Code Power (signal power) (dBm)</p>
        pub fn set_rscp(mut self, input: std::option::Option<i32>) -> Self {
            self.rscp = input;
            self
        }
        /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
        pub fn path_loss(mut self, input: i32) -> Self {
            self.path_loss = Some(input);
            self
        }
        /// <p>Path loss, or path attenuation, is the reduction in power density of an electromagnetic wave as it propagates through space.</p>
        pub fn set_path_loss(mut self, input: std::option::Option<i32>) -> Self {
            self.path_loss = input;
            self
        }
        /// Consumes the builder and constructs a [`WcdmaNmrObj`](crate::model::WcdmaNmrObj).
        pub fn build(self) -> crate::model::WcdmaNmrObj {
            crate::model::WcdmaNmrObj {
                uarfcndl: self.uarfcndl,
                psc: self.psc,
                utran_cid: self.utran_cid,
                rscp: self.rscp,
                path_loss: self.path_loss,
            }
        }
    }
}

/// <p>WCDMA local identification (local ID) information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WcdmaLocalId {
    /// <p>WCDMA UTRA Absolute RF Channel Number downlink.</p>
    #[doc(hidden)]
    pub uarfcndl: std::option::Option<i32>,
    /// <p>Primary Scrambling Code.</p>
    #[doc(hidden)]
    pub psc: std::option::Option<i32>,
}
impl WcdmaLocalId {
    /// <p>WCDMA UTRA Absolute RF Channel Number downlink.</p>
    pub fn uarfcndl(&self) -> std::option::Option<i32> {
        self.uarfcndl
    }
    /// <p>Primary Scrambling Code.</p>
    pub fn psc(&self) -> std::option::Option<i32> {
        self.psc
    }
}
impl WcdmaLocalId {
    /// Creates a new builder-style object to manufacture [`WcdmaLocalId`](crate::model::WcdmaLocalId).
    pub fn builder() -> crate::model::wcdma_local_id::Builder {
        crate::model::wcdma_local_id::Builder::default()
    }
}

/// See [`WcdmaLocalId`](crate::model::WcdmaLocalId).
pub mod wcdma_local_id {

    /// A builder for [`WcdmaLocalId`](crate::model::WcdmaLocalId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) uarfcndl: std::option::Option<i32>,
        pub(crate) psc: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>WCDMA UTRA Absolute RF Channel Number downlink.</p>
        pub fn uarfcndl(mut self, input: i32) -> Self {
            self.uarfcndl = Some(input);
            self
        }
        /// <p>WCDMA UTRA Absolute RF Channel Number downlink.</p>
        pub fn set_uarfcndl(mut self, input: std::option::Option<i32>) -> Self {
            self.uarfcndl = input;
            self
        }
        /// <p>Primary Scrambling Code.</p>
        pub fn psc(mut self, input: i32) -> Self {
            self.psc = Some(input);
            self
        }
        /// <p>Primary Scrambling Code.</p>
        pub fn set_psc(mut self, input: std::option::Option<i32>) -> Self {
            self.psc = input;
            self
        }
        /// Consumes the builder and constructs a [`WcdmaLocalId`](crate::model::WcdmaLocalId).
        pub fn build(self) -> crate::model::WcdmaLocalId {
            crate::model::WcdmaLocalId {
                uarfcndl: self.uarfcndl,
                psc: self.psc,
            }
        }
    }
}

/// <p>GSM object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GsmObj {
    /// <p>Mobile Country Code.</p>
    #[doc(hidden)]
    pub mcc: std::option::Option<i32>,
    /// <p>Mobile Network Code.</p>
    #[doc(hidden)]
    pub mnc: std::option::Option<i32>,
    /// <p>Location area code.</p>
    #[doc(hidden)]
    pub lac: std::option::Option<i32>,
    /// <p>GERAN (GSM EDGE Radio Access Network) Cell Global Identifier.</p>
    #[doc(hidden)]
    pub geran_cid: std::option::Option<i32>,
    /// <p>GSM local identification (local ID) information.</p>
    #[doc(hidden)]
    pub gsm_local_id: std::option::Option<crate::model::GsmLocalId>,
    /// <p>Timing advance value, which corresponds to the length of time a signal takes to reach the base station from a mobile phone.</p>
    #[doc(hidden)]
    pub gsm_timing_advance: std::option::Option<i32>,
    /// <p>Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).</p>
    #[doc(hidden)]
    pub rx_level: std::option::Option<i32>,
    /// <p>GSM object for network measurement reports.</p>
    #[doc(hidden)]
    pub gsm_nmr: std::option::Option<std::vec::Vec<crate::model::GsmNmrObj>>,
}
impl GsmObj {
    /// <p>Mobile Country Code.</p>
    pub fn mcc(&self) -> std::option::Option<i32> {
        self.mcc
    }
    /// <p>Mobile Network Code.</p>
    pub fn mnc(&self) -> std::option::Option<i32> {
        self.mnc
    }
    /// <p>Location area code.</p>
    pub fn lac(&self) -> std::option::Option<i32> {
        self.lac
    }
    /// <p>GERAN (GSM EDGE Radio Access Network) Cell Global Identifier.</p>
    pub fn geran_cid(&self) -> std::option::Option<i32> {
        self.geran_cid
    }
    /// <p>GSM local identification (local ID) information.</p>
    pub fn gsm_local_id(&self) -> std::option::Option<&crate::model::GsmLocalId> {
        self.gsm_local_id.as_ref()
    }
    /// <p>Timing advance value, which corresponds to the length of time a signal takes to reach the base station from a mobile phone.</p>
    pub fn gsm_timing_advance(&self) -> std::option::Option<i32> {
        self.gsm_timing_advance
    }
    /// <p>Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).</p>
    pub fn rx_level(&self) -> std::option::Option<i32> {
        self.rx_level
    }
    /// <p>GSM object for network measurement reports.</p>
    pub fn gsm_nmr(&self) -> std::option::Option<&[crate::model::GsmNmrObj]> {
        self.gsm_nmr.as_deref()
    }
}
impl GsmObj {
    /// Creates a new builder-style object to manufacture [`GsmObj`](crate::model::GsmObj).
    pub fn builder() -> crate::model::gsm_obj::Builder {
        crate::model::gsm_obj::Builder::default()
    }
}

/// See [`GsmObj`](crate::model::GsmObj).
pub mod gsm_obj {

    /// A builder for [`GsmObj`](crate::model::GsmObj).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mcc: std::option::Option<i32>,
        pub(crate) mnc: std::option::Option<i32>,
        pub(crate) lac: std::option::Option<i32>,
        pub(crate) geran_cid: std::option::Option<i32>,
        pub(crate) gsm_local_id: std::option::Option<crate::model::GsmLocalId>,
        pub(crate) gsm_timing_advance: std::option::Option<i32>,
        pub(crate) rx_level: std::option::Option<i32>,
        pub(crate) gsm_nmr: std::option::Option<std::vec::Vec<crate::model::GsmNmrObj>>,
    }
    impl Builder {
        /// <p>Mobile Country Code.</p>
        pub fn mcc(mut self, input: i32) -> Self {
            self.mcc = Some(input);
            self
        }
        /// <p>Mobile Country Code.</p>
        pub fn set_mcc(mut self, input: std::option::Option<i32>) -> Self {
            self.mcc = input;
            self
        }
        /// <p>Mobile Network Code.</p>
        pub fn mnc(mut self, input: i32) -> Self {
            self.mnc = Some(input);
            self
        }
        /// <p>Mobile Network Code.</p>
        pub fn set_mnc(mut self, input: std::option::Option<i32>) -> Self {
            self.mnc = input;
            self
        }
        /// <p>Location area code.</p>
        pub fn lac(mut self, input: i32) -> Self {
            self.lac = Some(input);
            self
        }
        /// <p>Location area code.</p>
        pub fn set_lac(mut self, input: std::option::Option<i32>) -> Self {
            self.lac = input;
            self
        }
        /// <p>GERAN (GSM EDGE Radio Access Network) Cell Global Identifier.</p>
        pub fn geran_cid(mut self, input: i32) -> Self {
            self.geran_cid = Some(input);
            self
        }
        /// <p>GERAN (GSM EDGE Radio Access Network) Cell Global Identifier.</p>
        pub fn set_geran_cid(mut self, input: std::option::Option<i32>) -> Self {
            self.geran_cid = input;
            self
        }
        /// <p>GSM local identification (local ID) information.</p>
        pub fn gsm_local_id(mut self, input: crate::model::GsmLocalId) -> Self {
            self.gsm_local_id = Some(input);
            self
        }
        /// <p>GSM local identification (local ID) information.</p>
        pub fn set_gsm_local_id(
            mut self,
            input: std::option::Option<crate::model::GsmLocalId>,
        ) -> Self {
            self.gsm_local_id = input;
            self
        }
        /// <p>Timing advance value, which corresponds to the length of time a signal takes to reach the base station from a mobile phone.</p>
        pub fn gsm_timing_advance(mut self, input: i32) -> Self {
            self.gsm_timing_advance = Some(input);
            self
        }
        /// <p>Timing advance value, which corresponds to the length of time a signal takes to reach the base station from a mobile phone.</p>
        pub fn set_gsm_timing_advance(mut self, input: std::option::Option<i32>) -> Self {
            self.gsm_timing_advance = input;
            self
        }
        /// <p>Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).</p>
        pub fn rx_level(mut self, input: i32) -> Self {
            self.rx_level = Some(input);
            self
        }
        /// <p>Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).</p>
        pub fn set_rx_level(mut self, input: std::option::Option<i32>) -> Self {
            self.rx_level = input;
            self
        }
        /// Appends an item to `gsm_nmr`.
        ///
        /// To override the contents of this collection use [`set_gsm_nmr`](Self::set_gsm_nmr).
        ///
        /// <p>GSM object for network measurement reports.</p>
        pub fn gsm_nmr(mut self, input: crate::model::GsmNmrObj) -> Self {
            let mut v = self.gsm_nmr.unwrap_or_default();
            v.push(input);
            self.gsm_nmr = Some(v);
            self
        }
        /// <p>GSM object for network measurement reports.</p>
        pub fn set_gsm_nmr(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::GsmNmrObj>>,
        ) -> Self {
            self.gsm_nmr = input;
            self
        }
        /// Consumes the builder and constructs a [`GsmObj`](crate::model::GsmObj).
        pub fn build(self) -> crate::model::GsmObj {
            crate::model::GsmObj {
                mcc: self.mcc,
                mnc: self.mnc,
                lac: self.lac,
                geran_cid: self.geran_cid,
                gsm_local_id: self.gsm_local_id,
                gsm_timing_advance: self.gsm_timing_advance,
                rx_level: self.rx_level,
                gsm_nmr: self.gsm_nmr,
            }
        }
    }
}

/// <p>GSM object for network measurement reports.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GsmNmrObj {
    /// <p>GSM base station identity code (BSIC).</p>
    #[doc(hidden)]
    pub bsic: std::option::Option<i32>,
    /// <p>GSM broadcast control channel.</p>
    #[doc(hidden)]
    pub bcch: std::option::Option<i32>,
    /// <p>Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).</p>
    #[doc(hidden)]
    pub rx_level: std::option::Option<i32>,
    /// <p>Global identity information of the GSM object.</p>
    #[doc(hidden)]
    pub global_identity: std::option::Option<crate::model::GlobalIdentity>,
}
impl GsmNmrObj {
    /// <p>GSM base station identity code (BSIC).</p>
    pub fn bsic(&self) -> std::option::Option<i32> {
        self.bsic
    }
    /// <p>GSM broadcast control channel.</p>
    pub fn bcch(&self) -> std::option::Option<i32> {
        self.bcch
    }
    /// <p>Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).</p>
    pub fn rx_level(&self) -> std::option::Option<i32> {
        self.rx_level
    }
    /// <p>Global identity information of the GSM object.</p>
    pub fn global_identity(&self) -> std::option::Option<&crate::model::GlobalIdentity> {
        self.global_identity.as_ref()
    }
}
impl GsmNmrObj {
    /// Creates a new builder-style object to manufacture [`GsmNmrObj`](crate::model::GsmNmrObj).
    pub fn builder() -> crate::model::gsm_nmr_obj::Builder {
        crate::model::gsm_nmr_obj::Builder::default()
    }
}

/// See [`GsmNmrObj`](crate::model::GsmNmrObj).
pub mod gsm_nmr_obj {

    /// A builder for [`GsmNmrObj`](crate::model::GsmNmrObj).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bsic: std::option::Option<i32>,
        pub(crate) bcch: std::option::Option<i32>,
        pub(crate) rx_level: std::option::Option<i32>,
        pub(crate) global_identity: std::option::Option<crate::model::GlobalIdentity>,
    }
    impl Builder {
        /// <p>GSM base station identity code (BSIC).</p>
        pub fn bsic(mut self, input: i32) -> Self {
            self.bsic = Some(input);
            self
        }
        /// <p>GSM base station identity code (BSIC).</p>
        pub fn set_bsic(mut self, input: std::option::Option<i32>) -> Self {
            self.bsic = input;
            self
        }
        /// <p>GSM broadcast control channel.</p>
        pub fn bcch(mut self, input: i32) -> Self {
            self.bcch = Some(input);
            self
        }
        /// <p>GSM broadcast control channel.</p>
        pub fn set_bcch(mut self, input: std::option::Option<i32>) -> Self {
            self.bcch = input;
            self
        }
        /// <p>Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).</p>
        pub fn rx_level(mut self, input: i32) -> Self {
            self.rx_level = Some(input);
            self
        }
        /// <p>Rx level, which is the received signal power, measured in dBm (decibel-milliwatts).</p>
        pub fn set_rx_level(mut self, input: std::option::Option<i32>) -> Self {
            self.rx_level = input;
            self
        }
        /// <p>Global identity information of the GSM object.</p>
        pub fn global_identity(mut self, input: crate::model::GlobalIdentity) -> Self {
            self.global_identity = Some(input);
            self
        }
        /// <p>Global identity information of the GSM object.</p>
        pub fn set_global_identity(
            mut self,
            input: std::option::Option<crate::model::GlobalIdentity>,
        ) -> Self {
            self.global_identity = input;
            self
        }
        /// Consumes the builder and constructs a [`GsmNmrObj`](crate::model::GsmNmrObj).
        pub fn build(self) -> crate::model::GsmNmrObj {
            crate::model::GsmNmrObj {
                bsic: self.bsic,
                bcch: self.bcch,
                rx_level: self.rx_level,
                global_identity: self.global_identity,
            }
        }
    }
}

/// <p>Global identity information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GlobalIdentity {
    /// <p>Location area code of the global identity.</p>
    #[doc(hidden)]
    pub lac: std::option::Option<i32>,
    /// <p>GERAN (GSM EDGE Radio Access Network) cell global identifier.</p>
    #[doc(hidden)]
    pub geran_cid: std::option::Option<i32>,
}
impl GlobalIdentity {
    /// <p>Location area code of the global identity.</p>
    pub fn lac(&self) -> std::option::Option<i32> {
        self.lac
    }
    /// <p>GERAN (GSM EDGE Radio Access Network) cell global identifier.</p>
    pub fn geran_cid(&self) -> std::option::Option<i32> {
        self.geran_cid
    }
}
impl GlobalIdentity {
    /// Creates a new builder-style object to manufacture [`GlobalIdentity`](crate::model::GlobalIdentity).
    pub fn builder() -> crate::model::global_identity::Builder {
        crate::model::global_identity::Builder::default()
    }
}

/// See [`GlobalIdentity`](crate::model::GlobalIdentity).
pub mod global_identity {

    /// A builder for [`GlobalIdentity`](crate::model::GlobalIdentity).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) lac: std::option::Option<i32>,
        pub(crate) geran_cid: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Location area code of the global identity.</p>
        pub fn lac(mut self, input: i32) -> Self {
            self.lac = Some(input);
            self
        }
        /// <p>Location area code of the global identity.</p>
        pub fn set_lac(mut self, input: std::option::Option<i32>) -> Self {
            self.lac = input;
            self
        }
        /// <p>GERAN (GSM EDGE Radio Access Network) cell global identifier.</p>
        pub fn geran_cid(mut self, input: i32) -> Self {
            self.geran_cid = Some(input);
            self
        }
        /// <p>GERAN (GSM EDGE Radio Access Network) cell global identifier.</p>
        pub fn set_geran_cid(mut self, input: std::option::Option<i32>) -> Self {
            self.geran_cid = input;
            self
        }
        /// Consumes the builder and constructs a [`GlobalIdentity`](crate::model::GlobalIdentity).
        pub fn build(self) -> crate::model::GlobalIdentity {
            crate::model::GlobalIdentity {
                lac: self.lac,
                geran_cid: self.geran_cid,
            }
        }
    }
}

/// <p>GSM local ID information, which corresponds to the local identification parameters of a GSM cell.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GsmLocalId {
    /// <p>GSM base station identity code (BSIC).</p>
    #[doc(hidden)]
    pub bsic: std::option::Option<i32>,
    /// <p>GSM broadcast control channel.</p>
    #[doc(hidden)]
    pub bcch: std::option::Option<i32>,
}
impl GsmLocalId {
    /// <p>GSM base station identity code (BSIC).</p>
    pub fn bsic(&self) -> std::option::Option<i32> {
        self.bsic
    }
    /// <p>GSM broadcast control channel.</p>
    pub fn bcch(&self) -> std::option::Option<i32> {
        self.bcch
    }
}
impl GsmLocalId {
    /// Creates a new builder-style object to manufacture [`GsmLocalId`](crate::model::GsmLocalId).
    pub fn builder() -> crate::model::gsm_local_id::Builder {
        crate::model::gsm_local_id::Builder::default()
    }
}

/// See [`GsmLocalId`](crate::model::GsmLocalId).
pub mod gsm_local_id {

    /// A builder for [`GsmLocalId`](crate::model::GsmLocalId).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bsic: std::option::Option<i32>,
        pub(crate) bcch: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>GSM base station identity code (BSIC).</p>
        pub fn bsic(mut self, input: i32) -> Self {
            self.bsic = Some(input);
            self
        }
        /// <p>GSM base station identity code (BSIC).</p>
        pub fn set_bsic(mut self, input: std::option::Option<i32>) -> Self {
            self.bsic = input;
            self
        }
        /// <p>GSM broadcast control channel.</p>
        pub fn bcch(mut self, input: i32) -> Self {
            self.bcch = Some(input);
            self
        }
        /// <p>GSM broadcast control channel.</p>
        pub fn set_bcch(mut self, input: std::option::Option<i32>) -> Self {
            self.bcch = input;
            self
        }
        /// Consumes the builder and constructs a [`GsmLocalId`](crate::model::GsmLocalId).
        pub fn build(self) -> crate::model::GsmLocalId {
            crate::model::GsmLocalId {
                bsic: self.bsic,
                bcch: self.bcch,
            }
        }
    }
}

/// <p>Wi-Fi access point.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WiFiAccessPoint {
    /// <p>Wi-Fi MAC Address.</p>
    #[doc(hidden)]
    pub mac_address: std::option::Option<std::string::String>,
    /// <p>Recived signal strength of the WLAN measurement data.</p>
    #[doc(hidden)]
    pub rss: std::option::Option<i32>,
}
impl WiFiAccessPoint {
    /// <p>Wi-Fi MAC Address.</p>
    pub fn mac_address(&self) -> std::option::Option<&str> {
        self.mac_address.as_deref()
    }
    /// <p>Recived signal strength of the WLAN measurement data.</p>
    pub fn rss(&self) -> std::option::Option<i32> {
        self.rss
    }
}
impl WiFiAccessPoint {
    /// Creates a new builder-style object to manufacture [`WiFiAccessPoint`](crate::model::WiFiAccessPoint).
    pub fn builder() -> crate::model::wi_fi_access_point::Builder {
        crate::model::wi_fi_access_point::Builder::default()
    }
}

/// See [`WiFiAccessPoint`](crate::model::WiFiAccessPoint).
pub mod wi_fi_access_point {

    /// A builder for [`WiFiAccessPoint`](crate::model::WiFiAccessPoint).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) mac_address: std::option::Option<std::string::String>,
        pub(crate) rss: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Wi-Fi MAC Address.</p>
        pub fn mac_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.mac_address = Some(input.into());
            self
        }
        /// <p>Wi-Fi MAC Address.</p>
        pub fn set_mac_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mac_address = input;
            self
        }
        /// <p>Recived signal strength of the WLAN measurement data.</p>
        pub fn rss(mut self, input: i32) -> Self {
            self.rss = Some(input);
            self
        }
        /// <p>Recived signal strength of the WLAN measurement data.</p>
        pub fn set_rss(mut self, input: std::option::Option<i32>) -> Self {
            self.rss = input;
            self
        }
        /// Consumes the builder and constructs a [`WiFiAccessPoint`](crate::model::WiFiAccessPoint).
        pub fn build(self) -> crate::model::WiFiAccessPoint {
            crate::model::WiFiAccessPoint {
                mac_address: self.mac_address,
                rss: self.rss,
            }
        }
    }
}

/// <p>The accuracy of the estimated position in meters. An empty value indicates that no position data is available. A value of ‘0.0’ value indicates that position data is available. This data corresponds to the position information that you specified instead of the position computed by solver.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Accuracy {
    /// <p>The horizontal accuracy of the estimated position, which is the difference between the estimated location and the actual device location.</p>
    #[doc(hidden)]
    pub horizontal_accuracy: std::option::Option<f32>,
    /// <p>The vertical accuracy of the estimated position, which is the difference between the estimated altitude and actual device latitude in meters.</p>
    #[doc(hidden)]
    pub vertical_accuracy: std::option::Option<f32>,
}
impl Accuracy {
    /// <p>The horizontal accuracy of the estimated position, which is the difference between the estimated location and the actual device location.</p>
    pub fn horizontal_accuracy(&self) -> std::option::Option<f32> {
        self.horizontal_accuracy
    }
    /// <p>The vertical accuracy of the estimated position, which is the difference between the estimated altitude and actual device latitude in meters.</p>
    pub fn vertical_accuracy(&self) -> std::option::Option<f32> {
        self.vertical_accuracy
    }
}
impl Accuracy {
    /// Creates a new builder-style object to manufacture [`Accuracy`](crate::model::Accuracy).
    pub fn builder() -> crate::model::accuracy::Builder {
        crate::model::accuracy::Builder::default()
    }
}

/// See [`Accuracy`](crate::model::Accuracy).
pub mod accuracy {

    /// A builder for [`Accuracy`](crate::model::Accuracy).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) horizontal_accuracy: std::option::Option<f32>,
        pub(crate) vertical_accuracy: std::option::Option<f32>,
    }
    impl Builder {
        /// <p>The horizontal accuracy of the estimated position, which is the difference between the estimated location and the actual device location.</p>
        pub fn horizontal_accuracy(mut self, input: f32) -> Self {
            self.horizontal_accuracy = Some(input);
            self
        }
        /// <p>The horizontal accuracy of the estimated position, which is the difference between the estimated location and the actual device location.</p>
        pub fn set_horizontal_accuracy(mut self, input: std::option::Option<f32>) -> Self {
            self.horizontal_accuracy = input;
            self
        }
        /// <p>The vertical accuracy of the estimated position, which is the difference between the estimated altitude and actual device latitude in meters.</p>
        pub fn vertical_accuracy(mut self, input: f32) -> Self {
            self.vertical_accuracy = Some(input);
            self
        }
        /// <p>The vertical accuracy of the estimated position, which is the difference between the estimated altitude and actual device latitude in meters.</p>
        pub fn set_vertical_accuracy(mut self, input: std::option::Option<f32>) -> Self {
            self.vertical_accuracy = input;
            self
        }
        /// Consumes the builder and constructs a [`Accuracy`](crate::model::Accuracy).
        pub fn build(self) -> crate::model::Accuracy {
            crate::model::Accuracy {
                horizontal_accuracy: self.horizontal_accuracy,
                vertical_accuracy: self.vertical_accuracy,
            }
        }
    }
}

/// <p>The LoRaWAN information that is to be returned from getting multicast group information.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanMulticastGet {
    /// <p>Supported RfRegions</p>
    #[doc(hidden)]
    pub rf_region: std::option::Option<crate::model::SupportedRfRegion>,
    /// <p>DlClass for LoRaWAM, valid values are ClassB and ClassC.</p>
    #[doc(hidden)]
    pub dl_class: std::option::Option<crate::model::DlClass>,
    /// <p>Number of devices that are requested to be associated with the multicast group.</p>
    #[doc(hidden)]
    pub number_of_devices_requested: std::option::Option<i32>,
    /// <p>Number of devices that are associated to the multicast group.</p>
    #[doc(hidden)]
    pub number_of_devices_in_group: std::option::Option<i32>,
}
impl LoRaWanMulticastGet {
    /// <p>Supported RfRegions</p>
    pub fn rf_region(&self) -> std::option::Option<&crate::model::SupportedRfRegion> {
        self.rf_region.as_ref()
    }
    /// <p>DlClass for LoRaWAM, valid values are ClassB and ClassC.</p>
    pub fn dl_class(&self) -> std::option::Option<&crate::model::DlClass> {
        self.dl_class.as_ref()
    }
    /// <p>Number of devices that are requested to be associated with the multicast group.</p>
    pub fn number_of_devices_requested(&self) -> std::option::Option<i32> {
        self.number_of_devices_requested
    }
    /// <p>Number of devices that are associated to the multicast group.</p>
    pub fn number_of_devices_in_group(&self) -> std::option::Option<i32> {
        self.number_of_devices_in_group
    }
}
impl LoRaWanMulticastGet {
    /// Creates a new builder-style object to manufacture [`LoRaWanMulticastGet`](crate::model::LoRaWanMulticastGet).
    pub fn builder() -> crate::model::lo_ra_wan_multicast_get::Builder {
        crate::model::lo_ra_wan_multicast_get::Builder::default()
    }
}

/// See [`LoRaWanMulticastGet`](crate::model::LoRaWanMulticastGet).
pub mod lo_ra_wan_multicast_get {

    /// A builder for [`LoRaWanMulticastGet`](crate::model::LoRaWanMulticastGet).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rf_region: std::option::Option<crate::model::SupportedRfRegion>,
        pub(crate) dl_class: std::option::Option<crate::model::DlClass>,
        pub(crate) number_of_devices_requested: std::option::Option<i32>,
        pub(crate) number_of_devices_in_group: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>Supported RfRegions</p>
        pub fn rf_region(mut self, input: crate::model::SupportedRfRegion) -> Self {
            self.rf_region = Some(input);
            self
        }
        /// <p>Supported RfRegions</p>
        pub fn set_rf_region(
            mut self,
            input: std::option::Option<crate::model::SupportedRfRegion>,
        ) -> Self {
            self.rf_region = input;
            self
        }
        /// <p>DlClass for LoRaWAM, valid values are ClassB and ClassC.</p>
        pub fn dl_class(mut self, input: crate::model::DlClass) -> Self {
            self.dl_class = Some(input);
            self
        }
        /// <p>DlClass for LoRaWAM, valid values are ClassB and ClassC.</p>
        pub fn set_dl_class(mut self, input: std::option::Option<crate::model::DlClass>) -> Self {
            self.dl_class = input;
            self
        }
        /// <p>Number of devices that are requested to be associated with the multicast group.</p>
        pub fn number_of_devices_requested(mut self, input: i32) -> Self {
            self.number_of_devices_requested = Some(input);
            self
        }
        /// <p>Number of devices that are requested to be associated with the multicast group.</p>
        pub fn set_number_of_devices_requested(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_devices_requested = input;
            self
        }
        /// <p>Number of devices that are associated to the multicast group.</p>
        pub fn number_of_devices_in_group(mut self, input: i32) -> Self {
            self.number_of_devices_in_group = Some(input);
            self
        }
        /// <p>Number of devices that are associated to the multicast group.</p>
        pub fn set_number_of_devices_in_group(mut self, input: std::option::Option<i32>) -> Self {
            self.number_of_devices_in_group = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanMulticastGet`](crate::model::LoRaWanMulticastGet).
        pub fn build(self) -> crate::model::LoRaWanMulticastGet {
            crate::model::LoRaWanMulticastGet {
                rf_region: self.rf_region,
                dl_class: self.dl_class,
                number_of_devices_requested: self.number_of_devices_requested,
                number_of_devices_in_group: self.number_of_devices_in_group,
            }
        }
    }
}

/// <p>The LoRaWAN information returned from getting a FUOTA task.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanFuotaTaskGetInfo {
    /// <p>The frequency band (RFRegion) value.</p>
    #[doc(hidden)]
    pub rf_region: std::option::Option<std::string::String>,
    /// <p>Start time of a FUOTA task.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl LoRaWanFuotaTaskGetInfo {
    /// <p>The frequency band (RFRegion) value.</p>
    pub fn rf_region(&self) -> std::option::Option<&str> {
        self.rf_region.as_deref()
    }
    /// <p>Start time of a FUOTA task.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
}
impl LoRaWanFuotaTaskGetInfo {
    /// Creates a new builder-style object to manufacture [`LoRaWanFuotaTaskGetInfo`](crate::model::LoRaWanFuotaTaskGetInfo).
    pub fn builder() -> crate::model::lo_ra_wan_fuota_task_get_info::Builder {
        crate::model::lo_ra_wan_fuota_task_get_info::Builder::default()
    }
}

/// See [`LoRaWanFuotaTaskGetInfo`](crate::model::LoRaWanFuotaTaskGetInfo).
pub mod lo_ra_wan_fuota_task_get_info {

    /// A builder for [`LoRaWanFuotaTaskGetInfo`](crate::model::LoRaWanFuotaTaskGetInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) rf_region: std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The frequency band (RFRegion) value.</p>
        pub fn rf_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.rf_region = Some(input.into());
            self
        }
        /// <p>The frequency band (RFRegion) value.</p>
        pub fn set_rf_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rf_region = input;
            self
        }
        /// <p>Start time of a FUOTA task.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>Start time of a FUOTA task.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanFuotaTaskGetInfo`](crate::model::LoRaWanFuotaTaskGetInfo).
        pub fn build(self) -> crate::model::LoRaWanFuotaTaskGetInfo {
            crate::model::LoRaWanFuotaTaskGetInfo {
                rf_region: self.rf_region,
                start_time: self.start_time,
            }
        }
    }
}

/// When writing a match expression against `FuotaTaskStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let fuotataskstatus = unimplemented!();
/// match fuotataskstatus {
///     FuotaTaskStatus::DeleteWaiting => { /* ... */ },
///     FuotaTaskStatus::FuotaDone => { /* ... */ },
///     FuotaTaskStatus::FuotaSessionWaiting => { /* ... */ },
///     FuotaTaskStatus::InFuotaSession => { /* ... */ },
///     FuotaTaskStatus::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `fuotataskstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `FuotaTaskStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `FuotaTaskStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `FuotaTaskStatus::NewFeature` is defined.
/// Specifically, when `fuotataskstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `FuotaTaskStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// <p>The status of a FUOTA task.</p>
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum FuotaTaskStatus {
    #[allow(missing_docs)] // documentation missing in model
    DeleteWaiting,
    #[allow(missing_docs)] // documentation missing in model
    FuotaDone,
    #[allow(missing_docs)] // documentation missing in model
    FuotaSessionWaiting,
    #[allow(missing_docs)] // documentation missing in model
    InFuotaSession,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for FuotaTaskStatus {
    fn from(s: &str) -> Self {
        match s {
            "Delete_Waiting" => FuotaTaskStatus::DeleteWaiting,
            "FuotaDone" => FuotaTaskStatus::FuotaDone,
            "FuotaSession_Waiting" => FuotaTaskStatus::FuotaSessionWaiting,
            "In_FuotaSession" => FuotaTaskStatus::InFuotaSession,
            "Pending" => FuotaTaskStatus::Pending,
            other => FuotaTaskStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for FuotaTaskStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(FuotaTaskStatus::from(s))
    }
}
impl FuotaTaskStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            FuotaTaskStatus::DeleteWaiting => "Delete_Waiting",
            FuotaTaskStatus::FuotaDone => "FuotaDone",
            FuotaTaskStatus::FuotaSessionWaiting => "FuotaSession_Waiting",
            FuotaTaskStatus::InFuotaSession => "In_FuotaSession",
            FuotaTaskStatus::Pending => "Pending",
            FuotaTaskStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "Delete_Waiting",
            "FuotaDone",
            "FuotaSession_Waiting",
            "In_FuotaSession",
            "Pending",
        ]
    }
}
impl AsRef<str> for FuotaTaskStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>LoRaWANDeviceProfile object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanDeviceProfile {
    /// <p>The SupportsClassB value.</p>
    #[doc(hidden)]
    pub supports_class_b: bool,
    /// <p>The ClassBTimeout value.</p>
    #[doc(hidden)]
    pub class_b_timeout: std::option::Option<i32>,
    /// <p>The PingSlotPeriod value.</p>
    #[doc(hidden)]
    pub ping_slot_period: std::option::Option<i32>,
    /// <p>The PingSlotDR value.</p>
    #[doc(hidden)]
    pub ping_slot_dr: std::option::Option<i32>,
    /// <p>The PingSlotFreq value.</p>
    #[doc(hidden)]
    pub ping_slot_freq: std::option::Option<i32>,
    /// <p>The SupportsClassC value.</p>
    #[doc(hidden)]
    pub supports_class_c: bool,
    /// <p>The ClassCTimeout value.</p>
    #[doc(hidden)]
    pub class_c_timeout: std::option::Option<i32>,
    /// <p>The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.</p>
    #[doc(hidden)]
    pub mac_version: std::option::Option<std::string::String>,
    /// <p>The version of regional parameters.</p>
    #[doc(hidden)]
    pub reg_params_revision: std::option::Option<std::string::String>,
    /// <p>The RXDelay1 value.</p>
    #[doc(hidden)]
    pub rx_delay1: std::option::Option<i32>,
    /// <p>The RXDROffset1 value.</p>
    #[doc(hidden)]
    pub rx_dr_offset1: std::option::Option<i32>,
    /// <p>The RXDataRate2 value.</p>
    #[doc(hidden)]
    pub rx_data_rate2: std::option::Option<i32>,
    /// <p>The RXFreq2 value.</p>
    #[doc(hidden)]
    pub rx_freq2: std::option::Option<i32>,
    /// <p>The list of values that make up the FactoryPresetFreqs value.</p>
    #[doc(hidden)]
    pub factory_preset_freqs_list: std::option::Option<std::vec::Vec<i32>>,
    /// <p>The MaxEIRP value.</p>
    #[doc(hidden)]
    pub max_eirp: std::option::Option<i32>,
    /// <p>The MaxDutyCycle value.</p>
    #[doc(hidden)]
    pub max_duty_cycle: std::option::Option<i32>,
    /// <p>The frequency band (RFRegion) value.</p>
    #[doc(hidden)]
    pub rf_region: std::option::Option<std::string::String>,
    /// <p>The SupportsJoin value.</p>
    #[doc(hidden)]
    pub supports_join: std::option::Option<bool>,
    /// <p>The Supports32BitFCnt value.</p>
    #[doc(hidden)]
    pub supports32_bit_f_cnt: bool,
}
impl LoRaWanDeviceProfile {
    /// <p>The SupportsClassB value.</p>
    pub fn supports_class_b(&self) -> bool {
        self.supports_class_b
    }
    /// <p>The ClassBTimeout value.</p>
    pub fn class_b_timeout(&self) -> std::option::Option<i32> {
        self.class_b_timeout
    }
    /// <p>The PingSlotPeriod value.</p>
    pub fn ping_slot_period(&self) -> std::option::Option<i32> {
        self.ping_slot_period
    }
    /// <p>The PingSlotDR value.</p>
    pub fn ping_slot_dr(&self) -> std::option::Option<i32> {
        self.ping_slot_dr
    }
    /// <p>The PingSlotFreq value.</p>
    pub fn ping_slot_freq(&self) -> std::option::Option<i32> {
        self.ping_slot_freq
    }
    /// <p>The SupportsClassC value.</p>
    pub fn supports_class_c(&self) -> bool {
        self.supports_class_c
    }
    /// <p>The ClassCTimeout value.</p>
    pub fn class_c_timeout(&self) -> std::option::Option<i32> {
        self.class_c_timeout
    }
    /// <p>The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.</p>
    pub fn mac_version(&self) -> std::option::Option<&str> {
        self.mac_version.as_deref()
    }
    /// <p>The version of regional parameters.</p>
    pub fn reg_params_revision(&self) -> std::option::Option<&str> {
        self.reg_params_revision.as_deref()
    }
    /// <p>The RXDelay1 value.</p>
    pub fn rx_delay1(&self) -> std::option::Option<i32> {
        self.rx_delay1
    }
    /// <p>The RXDROffset1 value.</p>
    pub fn rx_dr_offset1(&self) -> std::option::Option<i32> {
        self.rx_dr_offset1
    }
    /// <p>The RXDataRate2 value.</p>
    pub fn rx_data_rate2(&self) -> std::option::Option<i32> {
        self.rx_data_rate2
    }
    /// <p>The RXFreq2 value.</p>
    pub fn rx_freq2(&self) -> std::option::Option<i32> {
        self.rx_freq2
    }
    /// <p>The list of values that make up the FactoryPresetFreqs value.</p>
    pub fn factory_preset_freqs_list(&self) -> std::option::Option<&[i32]> {
        self.factory_preset_freqs_list.as_deref()
    }
    /// <p>The MaxEIRP value.</p>
    pub fn max_eirp(&self) -> std::option::Option<i32> {
        self.max_eirp
    }
    /// <p>The MaxDutyCycle value.</p>
    pub fn max_duty_cycle(&self) -> std::option::Option<i32> {
        self.max_duty_cycle
    }
    /// <p>The frequency band (RFRegion) value.</p>
    pub fn rf_region(&self) -> std::option::Option<&str> {
        self.rf_region.as_deref()
    }
    /// <p>The SupportsJoin value.</p>
    pub fn supports_join(&self) -> std::option::Option<bool> {
        self.supports_join
    }
    /// <p>The Supports32BitFCnt value.</p>
    pub fn supports32_bit_f_cnt(&self) -> bool {
        self.supports32_bit_f_cnt
    }
}
impl LoRaWanDeviceProfile {
    /// Creates a new builder-style object to manufacture [`LoRaWanDeviceProfile`](crate::model::LoRaWanDeviceProfile).
    pub fn builder() -> crate::model::lo_ra_wan_device_profile::Builder {
        crate::model::lo_ra_wan_device_profile::Builder::default()
    }
}

/// See [`LoRaWanDeviceProfile`](crate::model::LoRaWanDeviceProfile).
pub mod lo_ra_wan_device_profile {

    /// A builder for [`LoRaWanDeviceProfile`](crate::model::LoRaWanDeviceProfile).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) supports_class_b: std::option::Option<bool>,
        pub(crate) class_b_timeout: std::option::Option<i32>,
        pub(crate) ping_slot_period: std::option::Option<i32>,
        pub(crate) ping_slot_dr: std::option::Option<i32>,
        pub(crate) ping_slot_freq: std::option::Option<i32>,
        pub(crate) supports_class_c: std::option::Option<bool>,
        pub(crate) class_c_timeout: std::option::Option<i32>,
        pub(crate) mac_version: std::option::Option<std::string::String>,
        pub(crate) reg_params_revision: std::option::Option<std::string::String>,
        pub(crate) rx_delay1: std::option::Option<i32>,
        pub(crate) rx_dr_offset1: std::option::Option<i32>,
        pub(crate) rx_data_rate2: std::option::Option<i32>,
        pub(crate) rx_freq2: std::option::Option<i32>,
        pub(crate) factory_preset_freqs_list: std::option::Option<std::vec::Vec<i32>>,
        pub(crate) max_eirp: std::option::Option<i32>,
        pub(crate) max_duty_cycle: std::option::Option<i32>,
        pub(crate) rf_region: std::option::Option<std::string::String>,
        pub(crate) supports_join: std::option::Option<bool>,
        pub(crate) supports32_bit_f_cnt: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The SupportsClassB value.</p>
        pub fn supports_class_b(mut self, input: bool) -> Self {
            self.supports_class_b = Some(input);
            self
        }
        /// <p>The SupportsClassB value.</p>
        pub fn set_supports_class_b(mut self, input: std::option::Option<bool>) -> Self {
            self.supports_class_b = input;
            self
        }
        /// <p>The ClassBTimeout value.</p>
        pub fn class_b_timeout(mut self, input: i32) -> Self {
            self.class_b_timeout = Some(input);
            self
        }
        /// <p>The ClassBTimeout value.</p>
        pub fn set_class_b_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.class_b_timeout = input;
            self
        }
        /// <p>The PingSlotPeriod value.</p>
        pub fn ping_slot_period(mut self, input: i32) -> Self {
            self.ping_slot_period = Some(input);
            self
        }
        /// <p>The PingSlotPeriod value.</p>
        pub fn set_ping_slot_period(mut self, input: std::option::Option<i32>) -> Self {
            self.ping_slot_period = input;
            self
        }
        /// <p>The PingSlotDR value.</p>
        pub fn ping_slot_dr(mut self, input: i32) -> Self {
            self.ping_slot_dr = Some(input);
            self
        }
        /// <p>The PingSlotDR value.</p>
        pub fn set_ping_slot_dr(mut self, input: std::option::Option<i32>) -> Self {
            self.ping_slot_dr = input;
            self
        }
        /// <p>The PingSlotFreq value.</p>
        pub fn ping_slot_freq(mut self, input: i32) -> Self {
            self.ping_slot_freq = Some(input);
            self
        }
        /// <p>The PingSlotFreq value.</p>
        pub fn set_ping_slot_freq(mut self, input: std::option::Option<i32>) -> Self {
            self.ping_slot_freq = input;
            self
        }
        /// <p>The SupportsClassC value.</p>
        pub fn supports_class_c(mut self, input: bool) -> Self {
            self.supports_class_c = Some(input);
            self
        }
        /// <p>The SupportsClassC value.</p>
        pub fn set_supports_class_c(mut self, input: std::option::Option<bool>) -> Self {
            self.supports_class_c = input;
            self
        }
        /// <p>The ClassCTimeout value.</p>
        pub fn class_c_timeout(mut self, input: i32) -> Self {
            self.class_c_timeout = Some(input);
            self
        }
        /// <p>The ClassCTimeout value.</p>
        pub fn set_class_c_timeout(mut self, input: std::option::Option<i32>) -> Self {
            self.class_c_timeout = input;
            self
        }
        /// <p>The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.</p>
        pub fn mac_version(mut self, input: impl Into<std::string::String>) -> Self {
            self.mac_version = Some(input.into());
            self
        }
        /// <p>The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.</p>
        pub fn set_mac_version(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.mac_version = input;
            self
        }
        /// <p>The version of regional parameters.</p>
        pub fn reg_params_revision(mut self, input: impl Into<std::string::String>) -> Self {
            self.reg_params_revision = Some(input.into());
            self
        }
        /// <p>The version of regional parameters.</p>
        pub fn set_reg_params_revision(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.reg_params_revision = input;
            self
        }
        /// <p>The RXDelay1 value.</p>
        pub fn rx_delay1(mut self, input: i32) -> Self {
            self.rx_delay1 = Some(input);
            self
        }
        /// <p>The RXDelay1 value.</p>
        pub fn set_rx_delay1(mut self, input: std::option::Option<i32>) -> Self {
            self.rx_delay1 = input;
            self
        }
        /// <p>The RXDROffset1 value.</p>
        pub fn rx_dr_offset1(mut self, input: i32) -> Self {
            self.rx_dr_offset1 = Some(input);
            self
        }
        /// <p>The RXDROffset1 value.</p>
        pub fn set_rx_dr_offset1(mut self, input: std::option::Option<i32>) -> Self {
            self.rx_dr_offset1 = input;
            self
        }
        /// <p>The RXDataRate2 value.</p>
        pub fn rx_data_rate2(mut self, input: i32) -> Self {
            self.rx_data_rate2 = Some(input);
            self
        }
        /// <p>The RXDataRate2 value.</p>
        pub fn set_rx_data_rate2(mut self, input: std::option::Option<i32>) -> Self {
            self.rx_data_rate2 = input;
            self
        }
        /// <p>The RXFreq2 value.</p>
        pub fn rx_freq2(mut self, input: i32) -> Self {
            self.rx_freq2 = Some(input);
            self
        }
        /// <p>The RXFreq2 value.</p>
        pub fn set_rx_freq2(mut self, input: std::option::Option<i32>) -> Self {
            self.rx_freq2 = input;
            self
        }
        /// Appends an item to `factory_preset_freqs_list`.
        ///
        /// To override the contents of this collection use [`set_factory_preset_freqs_list`](Self::set_factory_preset_freqs_list).
        ///
        /// <p>The list of values that make up the FactoryPresetFreqs value.</p>
        pub fn factory_preset_freqs_list(mut self, input: i32) -> Self {
            let mut v = self.factory_preset_freqs_list.unwrap_or_default();
            v.push(input);
            self.factory_preset_freqs_list = Some(v);
            self
        }
        /// <p>The list of values that make up the FactoryPresetFreqs value.</p>
        pub fn set_factory_preset_freqs_list(
            mut self,
            input: std::option::Option<std::vec::Vec<i32>>,
        ) -> Self {
            self.factory_preset_freqs_list = input;
            self
        }
        /// <p>The MaxEIRP value.</p>
        pub fn max_eirp(mut self, input: i32) -> Self {
            self.max_eirp = Some(input);
            self
        }
        /// <p>The MaxEIRP value.</p>
        pub fn set_max_eirp(mut self, input: std::option::Option<i32>) -> Self {
            self.max_eirp = input;
            self
        }
        /// <p>The MaxDutyCycle value.</p>
        pub fn max_duty_cycle(mut self, input: i32) -> Self {
            self.max_duty_cycle = Some(input);
            self
        }
        /// <p>The MaxDutyCycle value.</p>
        pub fn set_max_duty_cycle(mut self, input: std::option::Option<i32>) -> Self {
            self.max_duty_cycle = input;
            self
        }
        /// <p>The frequency band (RFRegion) value.</p>
        pub fn rf_region(mut self, input: impl Into<std::string::String>) -> Self {
            self.rf_region = Some(input.into());
            self
        }
        /// <p>The frequency band (RFRegion) value.</p>
        pub fn set_rf_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rf_region = input;
            self
        }
        /// <p>The SupportsJoin value.</p>
        pub fn supports_join(mut self, input: bool) -> Self {
            self.supports_join = Some(input);
            self
        }
        /// <p>The SupportsJoin value.</p>
        pub fn set_supports_join(mut self, input: std::option::Option<bool>) -> Self {
            self.supports_join = input;
            self
        }
        /// <p>The Supports32BitFCnt value.</p>
        pub fn supports32_bit_f_cnt(mut self, input: bool) -> Self {
            self.supports32_bit_f_cnt = Some(input);
            self
        }
        /// <p>The Supports32BitFCnt value.</p>
        pub fn set_supports32_bit_f_cnt(mut self, input: std::option::Option<bool>) -> Self {
            self.supports32_bit_f_cnt = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanDeviceProfile`](crate::model::LoRaWanDeviceProfile).
        pub fn build(self) -> crate::model::LoRaWanDeviceProfile {
            crate::model::LoRaWanDeviceProfile {
                supports_class_b: self.supports_class_b.unwrap_or_default(),
                class_b_timeout: self.class_b_timeout,
                ping_slot_period: self.ping_slot_period,
                ping_slot_dr: self.ping_slot_dr,
                ping_slot_freq: self.ping_slot_freq,
                supports_class_c: self.supports_class_c.unwrap_or_default(),
                class_c_timeout: self.class_c_timeout,
                mac_version: self.mac_version,
                reg_params_revision: self.reg_params_revision,
                rx_delay1: self.rx_delay1,
                rx_dr_offset1: self.rx_dr_offset1,
                rx_data_rate2: self.rx_data_rate2,
                rx_freq2: self.rx_freq2,
                factory_preset_freqs_list: self.factory_preset_freqs_list,
                max_eirp: self.max_eirp,
                max_duty_cycle: self.max_duty_cycle,
                rf_region: self.rf_region,
                supports_join: self.supports_join,
                supports32_bit_f_cnt: self.supports32_bit_f_cnt.unwrap_or_default(),
            }
        }
    }
}

/// <p>LoRaWANServiceProfile object.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct LoRaWanServiceProfile {
    /// <p>The AddGWMetaData value.</p>
    #[doc(hidden)]
    pub add_gw_metadata: bool,
    /// <p>The DrMin value.</p>
    #[doc(hidden)]
    pub dr_min: std::option::Option<i32>,
    /// <p>The DrMax value.</p>
    #[doc(hidden)]
    pub dr_max: std::option::Option<i32>,
}
impl LoRaWanServiceProfile {
    /// <p>The AddGWMetaData value.</p>
    pub fn add_gw_metadata(&self) -> bool {
        self.add_gw_metadata
    }
    /// <p>The DrMin value.</p>
    pub fn dr_min(&self) -> std::option::Option<i32> {
        self.dr_min
    }
    /// <p>The DrMax value.</p>
    pub fn dr_max(&self) -> std::option::Option<i32> {
        self.dr_max
    }
}
impl LoRaWanServiceProfile {
    /// Creates a new builder-style object to manufacture [`LoRaWanServiceProfile`](crate::model::LoRaWanServiceProfile).
    pub fn builder() -> crate::model::lo_ra_wan_service_profile::Builder {
        crate::model::lo_ra_wan_service_profile::Builder::default()
    }
}

/// See [`LoRaWanServiceProfile`](crate::model::LoRaWanServiceProfile).
pub mod lo_ra_wan_service_profile {

    /// A builder for [`LoRaWanServiceProfile`](crate::model::LoRaWanServiceProfile).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) add_gw_metadata: std::option::Option<bool>,
        pub(crate) dr_min: std::option::Option<i32>,
        pub(crate) dr_max: std::option::Option<i32>,
    }
    impl Builder {
        /// <p>The AddGWMetaData value.</p>
        pub fn add_gw_metadata(mut self, input: bool) -> Self {
            self.add_gw_metadata = Some(input);
            self
        }
        /// <p>The AddGWMetaData value.</p>
        pub fn set_add_gw_metadata(mut self, input: std::option::Option<bool>) -> Self {
            self.add_gw_metadata = input;
            self
        }
        /// <p>The DrMin value.</p>
        pub fn dr_min(mut self, input: i32) -> Self {
            self.dr_min = Some(input);
            self
        }
        /// <p>The DrMin value.</p>
        pub fn set_dr_min(mut self, input: std::option::Option<i32>) -> Self {
            self.dr_min = input;
            self
        }
        /// <p>The DrMax value.</p>
        pub fn dr_max(mut self, input: i32) -> Self {
            self.dr_max = Some(input);
            self
        }
        /// <p>The DrMax value.</p>
        pub fn set_dr_max(mut self, input: std::option::Option<i32>) -> Self {
            self.dr_max = input;
            self
        }
        /// Consumes the builder and constructs a [`LoRaWanServiceProfile`](crate::model::LoRaWanServiceProfile).
        pub fn build(self) -> crate::model::LoRaWanServiceProfile {
            crate::model::LoRaWanServiceProfile {
                add_gw_metadata: self.add_gw_metadata.unwrap_or_default(),
                dr_min: self.dr_min,
                dr_max: self.dr_max,
            }
        }
    }
}

/// <p>Information about a Sidewalk account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SidewalkAccountInfo {
    /// <p>The Sidewalk Amazon ID.</p>
    #[doc(hidden)]
    pub amazon_id: std::option::Option<std::string::String>,
    /// <p>The Sidewalk application server private key.</p>
    #[doc(hidden)]
    pub app_server_private_key: std::option::Option<std::string::String>,
}
impl SidewalkAccountInfo {
    /// <p>The Sidewalk Amazon ID.</p>
    pub fn amazon_id(&self) -> std::option::Option<&str> {
        self.amazon_id.as_deref()
    }
    /// <p>The Sidewalk application server private key.</p>
    pub fn app_server_private_key(&self) -> std::option::Option<&str> {
        self.app_server_private_key.as_deref()
    }
}
impl std::fmt::Debug for SidewalkAccountInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SidewalkAccountInfo");
        formatter.field("amazon_id", &self.amazon_id);
        formatter.field("app_server_private_key", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl SidewalkAccountInfo {
    /// Creates a new builder-style object to manufacture [`SidewalkAccountInfo`](crate::model::SidewalkAccountInfo).
    pub fn builder() -> crate::model::sidewalk_account_info::Builder {
        crate::model::sidewalk_account_info::Builder::default()
    }
}

/// See [`SidewalkAccountInfo`](crate::model::SidewalkAccountInfo).
pub mod sidewalk_account_info {

    /// A builder for [`SidewalkAccountInfo`](crate::model::SidewalkAccountInfo).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
    pub struct Builder {
        pub(crate) amazon_id: std::option::Option<std::string::String>,
        pub(crate) app_server_private_key: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The Sidewalk Amazon ID.</p>
        pub fn amazon_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.amazon_id = Some(input.into());
            self
        }
        /// <p>The Sidewalk Amazon ID.</p>
        pub fn set_amazon_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.amazon_id = input;
            self
        }
        /// <p>The Sidewalk application server private key.</p>
        pub fn app_server_private_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.app_server_private_key = Some(input.into());
            self
        }
        /// <p>The Sidewalk application server private key.</p>
        pub fn set_app_server_private_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.app_server_private_key = input;
            self
        }
        /// Consumes the builder and constructs a [`SidewalkAccountInfo`](crate::model::SidewalkAccountInfo).
        pub fn build(self) -> crate::model::SidewalkAccountInfo {
            crate::model::SidewalkAccountInfo {
                amazon_id: self.amazon_id,
                app_server_private_key: self.app_server_private_key,
            }
        }
    }
    impl std::fmt::Debug for Builder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut formatter = f.debug_struct("Builder");
            formatter.field("amazon_id", &self.amazon_id);
            formatter.field("app_server_private_key", &"*** Sensitive Data Redacted ***");
            formatter.finish()
        }
    }
}
