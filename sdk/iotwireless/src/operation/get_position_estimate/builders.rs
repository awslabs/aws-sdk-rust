// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub use crate::operation::get_position_estimate::_get_position_estimate_output::GetPositionEstimateOutputBuilder;

pub use crate::operation::get_position_estimate::_get_position_estimate_input::GetPositionEstimateInputBuilder;

/// Fluent builder constructing a request to `GetPositionEstimate`.
///
/// <p>Get estimated position information as a payload in GeoJSON format. The payload measurement data is resolved using solvers that are provided by third-party vendors.</p>
#[derive(std::clone::Clone, std::fmt::Debug)]
pub struct GetPositionEstimateFluentBuilder {
    handle: std::sync::Arc<crate::client::Handle>,
    inner: crate::operation::get_position_estimate::builders::GetPositionEstimateInputBuilder,
}
impl GetPositionEstimateFluentBuilder {
    /// Creates a new `GetPositionEstimate`.
    pub(crate) fn new(handle: std::sync::Arc<crate::client::Handle>) -> Self {
        Self {
            handle,
            inner: Default::default(),
        }
    }

    /// Consume this builder, creating a customizable operation that can be modified before being
    /// sent. The operation's inner [http::Request] can be modified as well.
    pub async fn customize(
        self,
    ) -> std::result::Result<
        crate::client::customize::CustomizableOperation<
            crate::operation::get_position_estimate::GetPositionEstimate,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::result::SdkError<
            crate::operation::get_position_estimate::GetPositionEstimateError,
        >,
    > {
        let handle = self.handle.clone();
        let operation = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        Ok(crate::client::customize::CustomizableOperation { handle, operation })
    }

    /// Sends the request and returns the response.
    ///
    /// If an error occurs, an `SdkError` will be returned with additional details that
    /// can be matched against.
    ///
    /// By default, any retryable failures will be retried twice. Retry behavior
    /// is configurable with the [RetryConfig](aws_smithy_types::retry::RetryConfig), which can be
    /// set when configuring the client.
    pub async fn send(
        self,
    ) -> std::result::Result<
        crate::operation::get_position_estimate::GetPositionEstimateOutput,
        aws_smithy_http::result::SdkError<
            crate::operation::get_position_estimate::GetPositionEstimateError,
        >,
    > {
        let op = self
            .inner
            .build()
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?
            .make_operation(&self.handle.conf)
            .await
            .map_err(aws_smithy_http::result::SdkError::construction_failure)?;
        self.handle.client.call(op).await
    }
    /// Appends an item to `WiFiAccessPoints`.
    ///
    /// To override the contents of this collection use [`set_wi_fi_access_points`](Self::set_wi_fi_access_points).
    ///
    /// <p>Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.</p>
    pub fn wi_fi_access_points(mut self, input: crate::types::WiFiAccessPoint) -> Self {
        self.inner = self.inner.wi_fi_access_points(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.</p>
    pub fn set_wi_fi_access_points(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::WiFiAccessPoint>>,
    ) -> Self {
        self.inner = self.inner.set_wi_fi_access_points(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.</p>
    pub fn cell_towers(mut self, input: crate::types::CellTowers) -> Self {
        self.inner = self.inner.cell_towers(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.</p>
    pub fn set_cell_towers(mut self, input: std::option::Option<crate::types::CellTowers>) -> Self {
        self.inner = self.inner.set_cell_towers(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.</p>
    pub fn ip(mut self, input: crate::types::Ip) -> Self {
        self.inner = self.inner.ip(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.</p>
    pub fn set_ip(mut self, input: std::option::Option<crate::types::Ip>) -> Self {
        self.inner = self.inner.set_ip(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.</p>
    pub fn gnss(mut self, input: crate::types::Gnss) -> Self {
        self.inner = self.inner.gnss(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.</p>
    pub fn set_gnss(mut self, input: std::option::Option<crate::types::Gnss>) -> Self {
        self.inner = self.inner.set_gnss(input);
        self
    }
    /// <p>Optional information that specifies the time when the position information will be resolved. It uses the UNIX timestamp format. If not specified, the time at which the request was received will be used.</p>
    pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.inner = self.inner.timestamp(input);
        self
    }
    /// <p>Optional information that specifies the time when the position information will be resolved. It uses the UNIX timestamp format. If not specified, the time at which the request was received will be used.</p>
    pub fn set_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.inner = self.inner.set_timestamp(input);
        self
    }
}
