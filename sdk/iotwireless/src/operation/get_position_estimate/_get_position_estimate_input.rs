// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct GetPositionEstimateInput {
    /// <p>Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.</p>
    #[doc(hidden)]
    pub wi_fi_access_points: std::option::Option<std::vec::Vec<crate::types::WiFiAccessPoint>>,
    /// <p>Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.</p>
    #[doc(hidden)]
    pub cell_towers: std::option::Option<crate::types::CellTowers>,
    /// <p>Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.</p>
    #[doc(hidden)]
    pub ip: std::option::Option<crate::types::Ip>,
    /// <p>Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.</p>
    #[doc(hidden)]
    pub gnss: std::option::Option<crate::types::Gnss>,
    /// <p>Optional information that specifies the time when the position information will be resolved. It uses the UNIX timestamp format. If not specified, the time at which the request was received will be used.</p>
    #[doc(hidden)]
    pub timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl GetPositionEstimateInput {
    /// <p>Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.</p>
    pub fn wi_fi_access_points(&self) -> std::option::Option<&[crate::types::WiFiAccessPoint]> {
        self.wi_fi_access_points.as_deref()
    }
    /// <p>Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.</p>
    pub fn cell_towers(&self) -> std::option::Option<&crate::types::CellTowers> {
        self.cell_towers.as_ref()
    }
    /// <p>Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.</p>
    pub fn ip(&self) -> std::option::Option<&crate::types::Ip> {
        self.ip.as_ref()
    }
    /// <p>Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.</p>
    pub fn gnss(&self) -> std::option::Option<&crate::types::Gnss> {
        self.gnss.as_ref()
    }
    /// <p>Optional information that specifies the time when the position information will be resolved. It uses the UNIX timestamp format. If not specified, the time at which the request was received will be used.</p>
    pub fn timestamp(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.timestamp.as_ref()
    }
}
impl GetPositionEstimateInput {
    /// Creates a new builder-style object to manufacture [`GetPositionEstimateInput`](crate::operation::get_position_estimate::GetPositionEstimateInput).
    pub fn builder(
    ) -> crate::operation::get_position_estimate::builders::GetPositionEstimateInputBuilder {
        crate::operation::get_position_estimate::builders::GetPositionEstimateInputBuilder::default(
        )
    }
}

/// A builder for [`GetPositionEstimateInput`](crate::operation::get_position_estimate::GetPositionEstimateInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct GetPositionEstimateInputBuilder {
    pub(crate) wi_fi_access_points:
        std::option::Option<std::vec::Vec<crate::types::WiFiAccessPoint>>,
    pub(crate) cell_towers: std::option::Option<crate::types::CellTowers>,
    pub(crate) ip: std::option::Option<crate::types::Ip>,
    pub(crate) gnss: std::option::Option<crate::types::Gnss>,
    pub(crate) timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl GetPositionEstimateInputBuilder {
    /// Appends an item to `wi_fi_access_points`.
    ///
    /// To override the contents of this collection use [`set_wi_fi_access_points`](Self::set_wi_fi_access_points).
    ///
    /// <p>Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.</p>
    pub fn wi_fi_access_points(mut self, input: crate::types::WiFiAccessPoint) -> Self {
        let mut v = self.wi_fi_access_points.unwrap_or_default();
        v.push(input);
        self.wi_fi_access_points = Some(v);
        self
    }
    /// <p>Retrieves an estimated device position by resolving WLAN measurement data. The position is resolved using HERE's Wi-Fi based solver.</p>
    pub fn set_wi_fi_access_points(
        mut self,
        input: std::option::Option<std::vec::Vec<crate::types::WiFiAccessPoint>>,
    ) -> Self {
        self.wi_fi_access_points = input;
        self
    }
    /// <p>Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.</p>
    pub fn cell_towers(mut self, input: crate::types::CellTowers) -> Self {
        self.cell_towers = Some(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving measurement data from cellular radio towers. The position is resolved using HERE's cellular-based solver.</p>
    pub fn set_cell_towers(mut self, input: std::option::Option<crate::types::CellTowers>) -> Self {
        self.cell_towers = input;
        self
    }
    /// <p>Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.</p>
    pub fn ip(mut self, input: crate::types::Ip) -> Self {
        self.ip = Some(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving the IP address information from the device. The position is resolved using MaxMind's IP-based solver.</p>
    pub fn set_ip(mut self, input: std::option::Option<crate::types::Ip>) -> Self {
        self.ip = input;
        self
    }
    /// <p>Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.</p>
    pub fn gnss(mut self, input: crate::types::Gnss) -> Self {
        self.gnss = Some(input);
        self
    }
    /// <p>Retrieves an estimated device position by resolving the global navigation satellite system (GNSS) scan data. The position is resolved using the GNSS solver powered by LoRa Cloud.</p>
    pub fn set_gnss(mut self, input: std::option::Option<crate::types::Gnss>) -> Self {
        self.gnss = input;
        self
    }
    /// <p>Optional information that specifies the time when the position information will be resolved. It uses the UNIX timestamp format. If not specified, the time at which the request was received will be used.</p>
    pub fn timestamp(mut self, input: aws_smithy_types::DateTime) -> Self {
        self.timestamp = Some(input);
        self
    }
    /// <p>Optional information that specifies the time when the position information will be resolved. It uses the UNIX timestamp format. If not specified, the time at which the request was received will be used.</p>
    pub fn set_timestamp(mut self, input: std::option::Option<aws_smithy_types::DateTime>) -> Self {
        self.timestamp = input;
        self
    }
    /// Consumes the builder and constructs a [`GetPositionEstimateInput`](crate::operation::get_position_estimate::GetPositionEstimateInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::get_position_estimate::GetPositionEstimateInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(
            crate::operation::get_position_estimate::GetPositionEstimateInput {
                wi_fi_access_points: self.wi_fi_access_points,
                cell_towers: self.cell_towers,
                ip: self.ip,
                gnss: self.gnss,
                timestamp: self.timestamp,
            },
        )
    }
}
