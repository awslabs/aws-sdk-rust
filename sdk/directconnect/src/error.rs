// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptDirectConnectGatewayAssociationProposalError {
    pub kind: AcceptDirectConnectGatewayAssociationProposalErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptDirectConnectGatewayAssociationProposalErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptDirectConnectGatewayAssociationProposalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException(_inner) =>
            _inner.fmt(f)
            ,
            AcceptDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException(_inner) =>
            _inner.fmt(f)
            ,
            AcceptDirectConnectGatewayAssociationProposalErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AcceptDirectConnectGatewayAssociationProposalError {
    fn code(&self) -> Option<&str> {
        AcceptDirectConnectGatewayAssociationProposalError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AcceptDirectConnectGatewayAssociationProposalError {
    pub fn new(
        kind: AcceptDirectConnectGatewayAssociationProposalErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptDirectConnectGatewayAssociationProposalErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptDirectConnectGatewayAssociationProposalErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for AcceptDirectConnectGatewayAssociationProposalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException(_inner) =>
            Some(_inner)
            ,
            AcceptDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException(_inner) =>
            Some(_inner)
            ,
            AcceptDirectConnectGatewayAssociationProposalErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AllocateConnectionOnInterconnectError {
    pub kind: AllocateConnectionOnInterconnectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AllocateConnectionOnInterconnectErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AllocateConnectionOnInterconnectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AllocateConnectionOnInterconnectErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            AllocateConnectionOnInterconnectErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            AllocateConnectionOnInterconnectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AllocateConnectionOnInterconnectError {
    fn code(&self) -> Option<&str> {
        AllocateConnectionOnInterconnectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AllocateConnectionOnInterconnectError {
    pub fn new(kind: AllocateConnectionOnInterconnectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AllocateConnectionOnInterconnectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AllocateConnectionOnInterconnectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateConnectionOnInterconnectErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateConnectionOnInterconnectErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for AllocateConnectionOnInterconnectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AllocateConnectionOnInterconnectErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            AllocateConnectionOnInterconnectErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            AllocateConnectionOnInterconnectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AllocateHostedConnectionError {
    pub kind: AllocateHostedConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AllocateHostedConnectionErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AllocateHostedConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AllocateHostedConnectionErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            AllocateHostedConnectionErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            AllocateHostedConnectionErrorKind::DuplicateTagKeysException(_inner) => _inner.fmt(f),
            AllocateHostedConnectionErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            AllocateHostedConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AllocateHostedConnectionError {
    fn code(&self) -> Option<&str> {
        AllocateHostedConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AllocateHostedConnectionError {
    pub fn new(kind: AllocateHostedConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AllocateHostedConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AllocateHostedConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateHostedConnectionErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateHostedConnectionErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateHostedConnectionErrorKind::DuplicateTagKeysException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateHostedConnectionErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for AllocateHostedConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AllocateHostedConnectionErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            AllocateHostedConnectionErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            AllocateHostedConnectionErrorKind::DuplicateTagKeysException(_inner) => Some(_inner),
            AllocateHostedConnectionErrorKind::TooManyTagsException(_inner) => Some(_inner),
            AllocateHostedConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AllocatePrivateVirtualInterfaceError {
    pub kind: AllocatePrivateVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AllocatePrivateVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AllocatePrivateVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AllocatePrivateVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            AllocatePrivateVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            AllocatePrivateVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                _inner.fmt(f)
            }
            AllocatePrivateVirtualInterfaceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            AllocatePrivateVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AllocatePrivateVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        AllocatePrivateVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AllocatePrivateVirtualInterfaceError {
    pub fn new(kind: AllocatePrivateVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AllocatePrivateVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AllocatePrivateVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocatePrivateVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocatePrivateVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocatePrivateVirtualInterfaceErrorKind::DuplicateTagKeysException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocatePrivateVirtualInterfaceErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for AllocatePrivateVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AllocatePrivateVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            AllocatePrivateVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            AllocatePrivateVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                Some(_inner)
            }
            AllocatePrivateVirtualInterfaceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            AllocatePrivateVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AllocatePublicVirtualInterfaceError {
    pub kind: AllocatePublicVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AllocatePublicVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AllocatePublicVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AllocatePublicVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            AllocatePublicVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            AllocatePublicVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                _inner.fmt(f)
            }
            AllocatePublicVirtualInterfaceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            AllocatePublicVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AllocatePublicVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        AllocatePublicVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AllocatePublicVirtualInterfaceError {
    pub fn new(kind: AllocatePublicVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AllocatePublicVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AllocatePublicVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocatePublicVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocatePublicVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocatePublicVirtualInterfaceErrorKind::DuplicateTagKeysException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocatePublicVirtualInterfaceErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for AllocatePublicVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AllocatePublicVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            AllocatePublicVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            AllocatePublicVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                Some(_inner)
            }
            AllocatePublicVirtualInterfaceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            AllocatePublicVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AllocateTransitVirtualInterfaceError {
    pub kind: AllocateTransitVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AllocateTransitVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AllocateTransitVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AllocateTransitVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            AllocateTransitVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            AllocateTransitVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                _inner.fmt(f)
            }
            AllocateTransitVirtualInterfaceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            AllocateTransitVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AllocateTransitVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        AllocateTransitVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AllocateTransitVirtualInterfaceError {
    pub fn new(kind: AllocateTransitVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AllocateTransitVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AllocateTransitVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateTransitVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateTransitVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateTransitVirtualInterfaceErrorKind::DuplicateTagKeysException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            AllocateTransitVirtualInterfaceErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for AllocateTransitVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AllocateTransitVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            AllocateTransitVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            AllocateTransitVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                Some(_inner)
            }
            AllocateTransitVirtualInterfaceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            AllocateTransitVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateConnectionWithLagError {
    pub kind: AssociateConnectionWithLagErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateConnectionWithLagErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateConnectionWithLagError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateConnectionWithLagErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            AssociateConnectionWithLagErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            AssociateConnectionWithLagErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateConnectionWithLagError {
    fn code(&self) -> Option<&str> {
        AssociateConnectionWithLagError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateConnectionWithLagError {
    pub fn new(kind: AssociateConnectionWithLagErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateConnectionWithLagErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateConnectionWithLagErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateConnectionWithLagErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateConnectionWithLagErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for AssociateConnectionWithLagError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateConnectionWithLagErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            AssociateConnectionWithLagErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            AssociateConnectionWithLagErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateHostedConnectionError {
    pub kind: AssociateHostedConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateHostedConnectionErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateHostedConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateHostedConnectionErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            AssociateHostedConnectionErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            AssociateHostedConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateHostedConnectionError {
    fn code(&self) -> Option<&str> {
        AssociateHostedConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateHostedConnectionError {
    pub fn new(kind: AssociateHostedConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateHostedConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateHostedConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateHostedConnectionErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateHostedConnectionErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for AssociateHostedConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateHostedConnectionErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            AssociateHostedConnectionErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            AssociateHostedConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateMacSecKeyError {
    pub kind: AssociateMacSecKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateMacSecKeyErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateMacSecKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateMacSecKeyErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            AssociateMacSecKeyErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            AssociateMacSecKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateMacSecKeyError {
    fn code(&self) -> Option<&str> {
        AssociateMacSecKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateMacSecKeyError {
    pub fn new(kind: AssociateMacSecKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateMacSecKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateMacSecKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateMacSecKeyErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateMacSecKeyErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for AssociateMacSecKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateMacSecKeyErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            AssociateMacSecKeyErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            AssociateMacSecKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateVirtualInterfaceError {
    pub kind: AssociateVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            AssociateVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            AssociateVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        AssociateVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateVirtualInterfaceError {
    pub fn new(kind: AssociateVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for AssociateVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            AssociateVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            AssociateVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfirmConnectionError {
    pub kind: ConfirmConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfirmConnectionErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfirmConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfirmConnectionErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            ConfirmConnectionErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            ConfirmConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConfirmConnectionError {
    fn code(&self) -> Option<&str> {
        ConfirmConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfirmConnectionError {
    pub fn new(kind: ConfirmConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfirmConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfirmConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmConnectionErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmConnectionErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for ConfirmConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfirmConnectionErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            ConfirmConnectionErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            ConfirmConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfirmPrivateVirtualInterfaceError {
    pub kind: ConfirmPrivateVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfirmPrivateVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfirmPrivateVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfirmPrivateVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            ConfirmPrivateVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            ConfirmPrivateVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConfirmPrivateVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        ConfirmPrivateVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfirmPrivateVirtualInterfaceError {
    pub fn new(kind: ConfirmPrivateVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfirmPrivateVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfirmPrivateVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmPrivateVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmPrivateVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for ConfirmPrivateVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfirmPrivateVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            ConfirmPrivateVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            ConfirmPrivateVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfirmPublicVirtualInterfaceError {
    pub kind: ConfirmPublicVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfirmPublicVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfirmPublicVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfirmPublicVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            ConfirmPublicVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            ConfirmPublicVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConfirmPublicVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        ConfirmPublicVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfirmPublicVirtualInterfaceError {
    pub fn new(kind: ConfirmPublicVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfirmPublicVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfirmPublicVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmPublicVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmPublicVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for ConfirmPublicVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfirmPublicVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            ConfirmPublicVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            ConfirmPublicVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ConfirmTransitVirtualInterfaceError {
    pub kind: ConfirmTransitVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ConfirmTransitVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ConfirmTransitVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ConfirmTransitVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            ConfirmTransitVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            ConfirmTransitVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ConfirmTransitVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        ConfirmTransitVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ConfirmTransitVirtualInterfaceError {
    pub fn new(kind: ConfirmTransitVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ConfirmTransitVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ConfirmTransitVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTransitVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ConfirmTransitVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for ConfirmTransitVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ConfirmTransitVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            ConfirmTransitVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            ConfirmTransitVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBGPPeerError {
    pub kind: CreateBGPPeerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBGPPeerErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBGPPeerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBGPPeerErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            CreateBGPPeerErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            CreateBGPPeerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBGPPeerError {
    fn code(&self) -> Option<&str> {
        CreateBGPPeerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBGPPeerError {
    pub fn new(kind: CreateBGPPeerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBGPPeerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBGPPeerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBGPPeerErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBGPPeerErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for CreateBGPPeerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBGPPeerErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            CreateBGPPeerErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            CreateBGPPeerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateConnectionError {
    pub kind: CreateConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateConnectionErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateConnectionErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::DuplicateTagKeysException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            CreateConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateConnectionError {
    fn code(&self) -> Option<&str> {
        CreateConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateConnectionError {
    pub fn new(kind: CreateConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::DuplicateTagKeysException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateConnectionErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for CreateConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateConnectionErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            CreateConnectionErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            CreateConnectionErrorKind::DuplicateTagKeysException(_inner) => Some(_inner),
            CreateConnectionErrorKind::TooManyTagsException(_inner) => Some(_inner),
            CreateConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDirectConnectGatewayError {
    pub kind: CreateDirectConnectGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDirectConnectGatewayErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDirectConnectGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDirectConnectGatewayErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateDirectConnectGatewayErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            CreateDirectConnectGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDirectConnectGatewayError {
    fn code(&self) -> Option<&str> {
        CreateDirectConnectGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDirectConnectGatewayError {
    pub fn new(kind: CreateDirectConnectGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDirectConnectGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDirectConnectGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDirectConnectGatewayErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDirectConnectGatewayErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for CreateDirectConnectGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDirectConnectGatewayErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            CreateDirectConnectGatewayErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            CreateDirectConnectGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDirectConnectGatewayAssociationError {
    pub kind: CreateDirectConnectGatewayAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDirectConnectGatewayAssociationErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDirectConnectGatewayAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDirectConnectGatewayAssociationErrorKind::DirectConnectClientException(
                _inner,
            ) => _inner.fmt(f),
            CreateDirectConnectGatewayAssociationErrorKind::DirectConnectServerException(
                _inner,
            ) => _inner.fmt(f),
            CreateDirectConnectGatewayAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDirectConnectGatewayAssociationError {
    fn code(&self) -> Option<&str> {
        CreateDirectConnectGatewayAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDirectConnectGatewayAssociationError {
    pub fn new(
        kind: CreateDirectConnectGatewayAssociationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDirectConnectGatewayAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDirectConnectGatewayAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDirectConnectGatewayAssociationErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDirectConnectGatewayAssociationErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for CreateDirectConnectGatewayAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDirectConnectGatewayAssociationErrorKind::DirectConnectClientException(
                _inner,
            ) => Some(_inner),
            CreateDirectConnectGatewayAssociationErrorKind::DirectConnectServerException(
                _inner,
            ) => Some(_inner),
            CreateDirectConnectGatewayAssociationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateDirectConnectGatewayAssociationProposalError {
    pub kind: CreateDirectConnectGatewayAssociationProposalErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateDirectConnectGatewayAssociationProposalErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateDirectConnectGatewayAssociationProposalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException(_inner) =>
            _inner.fmt(f)
            ,
            CreateDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException(_inner) =>
            _inner.fmt(f)
            ,
            CreateDirectConnectGatewayAssociationProposalErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateDirectConnectGatewayAssociationProposalError {
    fn code(&self) -> Option<&str> {
        CreateDirectConnectGatewayAssociationProposalError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateDirectConnectGatewayAssociationProposalError {
    pub fn new(
        kind: CreateDirectConnectGatewayAssociationProposalErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateDirectConnectGatewayAssociationProposalErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateDirectConnectGatewayAssociationProposalErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for CreateDirectConnectGatewayAssociationProposalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException(_inner) =>
            Some(_inner)
            ,
            CreateDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException(_inner) =>
            Some(_inner)
            ,
            CreateDirectConnectGatewayAssociationProposalErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateInterconnectError {
    pub kind: CreateInterconnectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateInterconnectErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateInterconnectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateInterconnectErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            CreateInterconnectErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            CreateInterconnectErrorKind::DuplicateTagKeysException(_inner) => _inner.fmt(f),
            CreateInterconnectErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            CreateInterconnectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateInterconnectError {
    fn code(&self) -> Option<&str> {
        CreateInterconnectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateInterconnectError {
    pub fn new(kind: CreateInterconnectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateInterconnectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateInterconnectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInterconnectErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInterconnectErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInterconnectErrorKind::DuplicateTagKeysException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateInterconnectErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for CreateInterconnectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateInterconnectErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            CreateInterconnectErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            CreateInterconnectErrorKind::DuplicateTagKeysException(_inner) => Some(_inner),
            CreateInterconnectErrorKind::TooManyTagsException(_inner) => Some(_inner),
            CreateInterconnectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateLagError {
    pub kind: CreateLagErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateLagErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateLagError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateLagErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            CreateLagErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            CreateLagErrorKind::DuplicateTagKeysException(_inner) => _inner.fmt(f),
            CreateLagErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            CreateLagErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateLagError {
    fn code(&self) -> Option<&str> {
        CreateLagError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateLagError {
    pub fn new(kind: CreateLagErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateLagErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateLagErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLagErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateLagErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(&self.kind, CreateLagErrorKind::DuplicateTagKeysException(_))
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, CreateLagErrorKind::TooManyTagsException(_))
    }
}
impl std::error::Error for CreateLagError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateLagErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            CreateLagErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            CreateLagErrorKind::DuplicateTagKeysException(_inner) => Some(_inner),
            CreateLagErrorKind::TooManyTagsException(_inner) => Some(_inner),
            CreateLagErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePrivateVirtualInterfaceError {
    pub kind: CreatePrivateVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePrivateVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePrivateVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePrivateVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            CreatePrivateVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            CreatePrivateVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                _inner.fmt(f)
            }
            CreatePrivateVirtualInterfaceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            CreatePrivateVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePrivateVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        CreatePrivateVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePrivateVirtualInterfaceError {
    pub fn new(kind: CreatePrivateVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePrivateVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePrivateVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePrivateVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePrivateVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePrivateVirtualInterfaceErrorKind::DuplicateTagKeysException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePrivateVirtualInterfaceErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for CreatePrivateVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePrivateVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            CreatePrivateVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            CreatePrivateVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                Some(_inner)
            }
            CreatePrivateVirtualInterfaceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            CreatePrivateVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePublicVirtualInterfaceError {
    pub kind: CreatePublicVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePublicVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePublicVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePublicVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            CreatePublicVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            CreatePublicVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                _inner.fmt(f)
            }
            CreatePublicVirtualInterfaceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            CreatePublicVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePublicVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        CreatePublicVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePublicVirtualInterfaceError {
    pub fn new(kind: CreatePublicVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePublicVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePublicVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePublicVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePublicVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePublicVirtualInterfaceErrorKind::DuplicateTagKeysException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePublicVirtualInterfaceErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for CreatePublicVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePublicVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            CreatePublicVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            CreatePublicVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                Some(_inner)
            }
            CreatePublicVirtualInterfaceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            CreatePublicVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateTransitVirtualInterfaceError {
    pub kind: CreateTransitVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateTransitVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateTransitVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateTransitVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            CreateTransitVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            CreateTransitVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                _inner.fmt(f)
            }
            CreateTransitVirtualInterfaceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            CreateTransitVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateTransitVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        CreateTransitVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateTransitVirtualInterfaceError {
    pub fn new(kind: CreateTransitVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateTransitVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateTransitVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTransitVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTransitVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTransitVirtualInterfaceErrorKind::DuplicateTagKeysException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateTransitVirtualInterfaceErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for CreateTransitVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateTransitVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            CreateTransitVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            CreateTransitVirtualInterfaceErrorKind::DuplicateTagKeysException(_inner) => {
                Some(_inner)
            }
            CreateTransitVirtualInterfaceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            CreateTransitVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBGPPeerError {
    pub kind: DeleteBGPPeerErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBGPPeerErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBGPPeerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBGPPeerErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DeleteBGPPeerErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DeleteBGPPeerErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBGPPeerError {
    fn code(&self) -> Option<&str> {
        DeleteBGPPeerError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBGPPeerError {
    pub fn new(kind: DeleteBGPPeerErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBGPPeerErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBGPPeerErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBGPPeerErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBGPPeerErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DeleteBGPPeerError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBGPPeerErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DeleteBGPPeerErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DeleteBGPPeerErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteConnectionError {
    pub kind: DeleteConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteConnectionErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteConnectionErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DeleteConnectionErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DeleteConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteConnectionError {
    fn code(&self) -> Option<&str> {
        DeleteConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteConnectionError {
    pub fn new(kind: DeleteConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteConnectionErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DeleteConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteConnectionErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DeleteConnectionErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DeleteConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDirectConnectGatewayError {
    pub kind: DeleteDirectConnectGatewayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDirectConnectGatewayErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDirectConnectGatewayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDirectConnectGatewayErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            DeleteDirectConnectGatewayErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            DeleteDirectConnectGatewayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDirectConnectGatewayError {
    fn code(&self) -> Option<&str> {
        DeleteDirectConnectGatewayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDirectConnectGatewayError {
    pub fn new(kind: DeleteDirectConnectGatewayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDirectConnectGatewayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDirectConnectGatewayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDirectConnectGatewayErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDirectConnectGatewayErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DeleteDirectConnectGatewayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDirectConnectGatewayErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            DeleteDirectConnectGatewayErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            DeleteDirectConnectGatewayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDirectConnectGatewayAssociationError {
    pub kind: DeleteDirectConnectGatewayAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDirectConnectGatewayAssociationErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDirectConnectGatewayAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDirectConnectGatewayAssociationErrorKind::DirectConnectClientException(
                _inner,
            ) => _inner.fmt(f),
            DeleteDirectConnectGatewayAssociationErrorKind::DirectConnectServerException(
                _inner,
            ) => _inner.fmt(f),
            DeleteDirectConnectGatewayAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDirectConnectGatewayAssociationError {
    fn code(&self) -> Option<&str> {
        DeleteDirectConnectGatewayAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDirectConnectGatewayAssociationError {
    pub fn new(
        kind: DeleteDirectConnectGatewayAssociationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDirectConnectGatewayAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDirectConnectGatewayAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDirectConnectGatewayAssociationErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDirectConnectGatewayAssociationErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DeleteDirectConnectGatewayAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDirectConnectGatewayAssociationErrorKind::DirectConnectClientException(
                _inner,
            ) => Some(_inner),
            DeleteDirectConnectGatewayAssociationErrorKind::DirectConnectServerException(
                _inner,
            ) => Some(_inner),
            DeleteDirectConnectGatewayAssociationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteDirectConnectGatewayAssociationProposalError {
    pub kind: DeleteDirectConnectGatewayAssociationProposalErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteDirectConnectGatewayAssociationProposalErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteDirectConnectGatewayAssociationProposalError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException(_inner) =>
            _inner.fmt(f)
            ,
            DeleteDirectConnectGatewayAssociationProposalErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteDirectConnectGatewayAssociationProposalError {
    fn code(&self) -> Option<&str> {
        DeleteDirectConnectGatewayAssociationProposalError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteDirectConnectGatewayAssociationProposalError {
    pub fn new(
        kind: DeleteDirectConnectGatewayAssociationProposalErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteDirectConnectGatewayAssociationProposalErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteDirectConnectGatewayAssociationProposalErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DeleteDirectConnectGatewayAssociationProposalError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException(_inner) =>
            Some(_inner)
            ,
            DeleteDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException(_inner) =>
            Some(_inner)
            ,
            DeleteDirectConnectGatewayAssociationProposalErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteInterconnectError {
    pub kind: DeleteInterconnectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteInterconnectErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteInterconnectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteInterconnectErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DeleteInterconnectErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DeleteInterconnectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteInterconnectError {
    fn code(&self) -> Option<&str> {
        DeleteInterconnectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteInterconnectError {
    pub fn new(kind: DeleteInterconnectErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteInterconnectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteInterconnectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInterconnectErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteInterconnectErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DeleteInterconnectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteInterconnectErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DeleteInterconnectErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DeleteInterconnectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteLagError {
    pub kind: DeleteLagErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteLagErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteLagError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteLagErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DeleteLagErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DeleteLagErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteLagError {
    fn code(&self) -> Option<&str> {
        DeleteLagError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteLagError {
    pub fn new(kind: DeleteLagErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteLagErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteLagErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLagErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteLagErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DeleteLagError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteLagErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DeleteLagErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DeleteLagErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteVirtualInterfaceError {
    pub kind: DeleteVirtualInterfaceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteVirtualInterfaceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteVirtualInterfaceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DeleteVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DeleteVirtualInterfaceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteVirtualInterfaceError {
    fn code(&self) -> Option<&str> {
        DeleteVirtualInterfaceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteVirtualInterfaceError {
    pub fn new(kind: DeleteVirtualInterfaceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteVirtualInterfaceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteVirtualInterfaceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualInterfaceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteVirtualInterfaceErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DeleteVirtualInterfaceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteVirtualInterfaceErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DeleteVirtualInterfaceErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DeleteVirtualInterfaceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConnectionLoaError {
    pub kind: DescribeConnectionLoaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConnectionLoaErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConnectionLoaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConnectionLoaErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DescribeConnectionLoaErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DescribeConnectionLoaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConnectionLoaError {
    fn code(&self) -> Option<&str> {
        DescribeConnectionLoaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConnectionLoaError {
    pub fn new(kind: DescribeConnectionLoaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConnectionLoaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConnectionLoaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionLoaErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionLoaErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeConnectionLoaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConnectionLoaErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DescribeConnectionLoaErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DescribeConnectionLoaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConnectionsError {
    pub kind: DescribeConnectionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConnectionsErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConnectionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConnectionsErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DescribeConnectionsErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DescribeConnectionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConnectionsError {
    fn code(&self) -> Option<&str> {
        DescribeConnectionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConnectionsError {
    pub fn new(kind: DescribeConnectionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConnectionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConnectionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionsErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionsErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeConnectionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConnectionsErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DescribeConnectionsErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DescribeConnectionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeConnectionsOnInterconnectError {
    pub kind: DescribeConnectionsOnInterconnectErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeConnectionsOnInterconnectErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeConnectionsOnInterconnectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeConnectionsOnInterconnectErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConnectionsOnInterconnectErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            DescribeConnectionsOnInterconnectErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeConnectionsOnInterconnectError {
    fn code(&self) -> Option<&str> {
        DescribeConnectionsOnInterconnectError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeConnectionsOnInterconnectError {
    pub fn new(
        kind: DescribeConnectionsOnInterconnectErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeConnectionsOnInterconnectErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeConnectionsOnInterconnectErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionsOnInterconnectErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeConnectionsOnInterconnectErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeConnectionsOnInterconnectError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeConnectionsOnInterconnectErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            DescribeConnectionsOnInterconnectErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            DescribeConnectionsOnInterconnectErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDirectConnectGatewayAssociationProposalsError {
    pub kind: DescribeDirectConnectGatewayAssociationProposalsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDirectConnectGatewayAssociationProposalsErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDirectConnectGatewayAssociationProposalsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDirectConnectGatewayAssociationProposalsErrorKind::DirectConnectClientException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeDirectConnectGatewayAssociationProposalsErrorKind::DirectConnectServerException(_inner) =>
            _inner.fmt(f)
            ,
            DescribeDirectConnectGatewayAssociationProposalsErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind
    for DescribeDirectConnectGatewayAssociationProposalsError
{
    fn code(&self) -> Option<&str> {
        DescribeDirectConnectGatewayAssociationProposalsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDirectConnectGatewayAssociationProposalsError {
    pub fn new(
        kind: DescribeDirectConnectGatewayAssociationProposalsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDirectConnectGatewayAssociationProposalsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDirectConnectGatewayAssociationProposalsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDirectConnectGatewayAssociationProposalsErrorKind::DirectConnectClientException(
                _
            )
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDirectConnectGatewayAssociationProposalsErrorKind::DirectConnectServerException(
                _
            )
        )
    }
}
impl std::error::Error for DescribeDirectConnectGatewayAssociationProposalsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDirectConnectGatewayAssociationProposalsErrorKind::DirectConnectClientException(_inner) =>
            Some(_inner)
            ,
            DescribeDirectConnectGatewayAssociationProposalsErrorKind::DirectConnectServerException(_inner) =>
            Some(_inner)
            ,
            DescribeDirectConnectGatewayAssociationProposalsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDirectConnectGatewayAssociationsError {
    pub kind: DescribeDirectConnectGatewayAssociationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDirectConnectGatewayAssociationsErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDirectConnectGatewayAssociationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDirectConnectGatewayAssociationsErrorKind::DirectConnectClientException(
                _inner,
            ) => _inner.fmt(f),
            DescribeDirectConnectGatewayAssociationsErrorKind::DirectConnectServerException(
                _inner,
            ) => _inner.fmt(f),
            DescribeDirectConnectGatewayAssociationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDirectConnectGatewayAssociationsError {
    fn code(&self) -> Option<&str> {
        DescribeDirectConnectGatewayAssociationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDirectConnectGatewayAssociationsError {
    pub fn new(
        kind: DescribeDirectConnectGatewayAssociationsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDirectConnectGatewayAssociationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDirectConnectGatewayAssociationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDirectConnectGatewayAssociationsErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDirectConnectGatewayAssociationsErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeDirectConnectGatewayAssociationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDirectConnectGatewayAssociationsErrorKind::DirectConnectClientException(
                _inner,
            ) => Some(_inner),
            DescribeDirectConnectGatewayAssociationsErrorKind::DirectConnectServerException(
                _inner,
            ) => Some(_inner),
            DescribeDirectConnectGatewayAssociationsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDirectConnectGatewayAttachmentsError {
    pub kind: DescribeDirectConnectGatewayAttachmentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDirectConnectGatewayAttachmentsErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDirectConnectGatewayAttachmentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDirectConnectGatewayAttachmentsErrorKind::DirectConnectClientException(
                _inner,
            ) => _inner.fmt(f),
            DescribeDirectConnectGatewayAttachmentsErrorKind::DirectConnectServerException(
                _inner,
            ) => _inner.fmt(f),
            DescribeDirectConnectGatewayAttachmentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDirectConnectGatewayAttachmentsError {
    fn code(&self) -> Option<&str> {
        DescribeDirectConnectGatewayAttachmentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDirectConnectGatewayAttachmentsError {
    pub fn new(
        kind: DescribeDirectConnectGatewayAttachmentsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDirectConnectGatewayAttachmentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDirectConnectGatewayAttachmentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDirectConnectGatewayAttachmentsErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDirectConnectGatewayAttachmentsErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeDirectConnectGatewayAttachmentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDirectConnectGatewayAttachmentsErrorKind::DirectConnectClientException(
                _inner,
            ) => Some(_inner),
            DescribeDirectConnectGatewayAttachmentsErrorKind::DirectConnectServerException(
                _inner,
            ) => Some(_inner),
            DescribeDirectConnectGatewayAttachmentsErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeDirectConnectGatewaysError {
    pub kind: DescribeDirectConnectGatewaysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeDirectConnectGatewaysErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeDirectConnectGatewaysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeDirectConnectGatewaysErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDirectConnectGatewaysErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            DescribeDirectConnectGatewaysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeDirectConnectGatewaysError {
    fn code(&self) -> Option<&str> {
        DescribeDirectConnectGatewaysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeDirectConnectGatewaysError {
    pub fn new(kind: DescribeDirectConnectGatewaysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeDirectConnectGatewaysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeDirectConnectGatewaysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDirectConnectGatewaysErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeDirectConnectGatewaysErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeDirectConnectGatewaysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeDirectConnectGatewaysErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            DescribeDirectConnectGatewaysErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            DescribeDirectConnectGatewaysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeHostedConnectionsError {
    pub kind: DescribeHostedConnectionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeHostedConnectionsErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeHostedConnectionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeHostedConnectionsErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            DescribeHostedConnectionsErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            DescribeHostedConnectionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeHostedConnectionsError {
    fn code(&self) -> Option<&str> {
        DescribeHostedConnectionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeHostedConnectionsError {
    pub fn new(kind: DescribeHostedConnectionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeHostedConnectionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeHostedConnectionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHostedConnectionsErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeHostedConnectionsErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeHostedConnectionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeHostedConnectionsErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            DescribeHostedConnectionsErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            DescribeHostedConnectionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInterconnectLoaError {
    pub kind: DescribeInterconnectLoaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInterconnectLoaErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInterconnectLoaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInterconnectLoaErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DescribeInterconnectLoaErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DescribeInterconnectLoaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInterconnectLoaError {
    fn code(&self) -> Option<&str> {
        DescribeInterconnectLoaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInterconnectLoaError {
    pub fn new(kind: DescribeInterconnectLoaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInterconnectLoaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInterconnectLoaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInterconnectLoaErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInterconnectLoaErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeInterconnectLoaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInterconnectLoaErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DescribeInterconnectLoaErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DescribeInterconnectLoaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeInterconnectsError {
    pub kind: DescribeInterconnectsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeInterconnectsErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeInterconnectsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeInterconnectsErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DescribeInterconnectsErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DescribeInterconnectsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeInterconnectsError {
    fn code(&self) -> Option<&str> {
        DescribeInterconnectsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeInterconnectsError {
    pub fn new(kind: DescribeInterconnectsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeInterconnectsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeInterconnectsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInterconnectsErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeInterconnectsErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeInterconnectsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeInterconnectsErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DescribeInterconnectsErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DescribeInterconnectsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeLagsError {
    pub kind: DescribeLagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLagsErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeLagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeLagsErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DescribeLagsErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DescribeLagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeLagsError {
    fn code(&self) -> Option<&str> {
        DescribeLagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLagsError {
    pub fn new(kind: DescribeLagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeLagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeLagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLagsErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLagsErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeLagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeLagsErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DescribeLagsErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DescribeLagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeLoaError {
    pub kind: DescribeLoaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLoaErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeLoaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeLoaErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DescribeLoaErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DescribeLoaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeLoaError {
    fn code(&self) -> Option<&str> {
        DescribeLoaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLoaError {
    pub fn new(kind: DescribeLoaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeLoaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeLoaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLoaErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLoaErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeLoaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeLoaErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DescribeLoaErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DescribeLoaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeLocationsError {
    pub kind: DescribeLocationsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeLocationsErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeLocationsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeLocationsErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DescribeLocationsErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DescribeLocationsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeLocationsError {
    fn code(&self) -> Option<&str> {
        DescribeLocationsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeLocationsError {
    pub fn new(kind: DescribeLocationsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeLocationsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeLocationsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLocationsErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeLocationsErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeLocationsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeLocationsErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DescribeLocationsErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DescribeLocationsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeTagsError {
    pub kind: DescribeTagsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeTagsErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeTagsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeTagsErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DescribeTagsErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DescribeTagsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeTagsError {
    fn code(&self) -> Option<&str> {
        DescribeTagsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeTagsError {
    pub fn new(kind: DescribeTagsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeTagsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeTagsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTagsErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeTagsErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeTagsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeTagsErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DescribeTagsErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DescribeTagsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeVirtualGatewaysError {
    pub kind: DescribeVirtualGatewaysErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeVirtualGatewaysErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeVirtualGatewaysError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeVirtualGatewaysErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DescribeVirtualGatewaysErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DescribeVirtualGatewaysErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeVirtualGatewaysError {
    fn code(&self) -> Option<&str> {
        DescribeVirtualGatewaysError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeVirtualGatewaysError {
    pub fn new(kind: DescribeVirtualGatewaysErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeVirtualGatewaysErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeVirtualGatewaysErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualGatewaysErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualGatewaysErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeVirtualGatewaysError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeVirtualGatewaysErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DescribeVirtualGatewaysErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DescribeVirtualGatewaysErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeVirtualInterfacesError {
    pub kind: DescribeVirtualInterfacesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeVirtualInterfacesErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeVirtualInterfacesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeVirtualInterfacesErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            DescribeVirtualInterfacesErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            DescribeVirtualInterfacesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeVirtualInterfacesError {
    fn code(&self) -> Option<&str> {
        DescribeVirtualInterfacesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeVirtualInterfacesError {
    pub fn new(kind: DescribeVirtualInterfacesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeVirtualInterfacesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeVirtualInterfacesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualInterfacesErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeVirtualInterfacesErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DescribeVirtualInterfacesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeVirtualInterfacesErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            DescribeVirtualInterfacesErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            DescribeVirtualInterfacesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateConnectionFromLagError {
    pub kind: DisassociateConnectionFromLagErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateConnectionFromLagErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateConnectionFromLagError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateConnectionFromLagErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateConnectionFromLagErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            DisassociateConnectionFromLagErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateConnectionFromLagError {
    fn code(&self) -> Option<&str> {
        DisassociateConnectionFromLagError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateConnectionFromLagError {
    pub fn new(kind: DisassociateConnectionFromLagErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateConnectionFromLagErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateConnectionFromLagErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateConnectionFromLagErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateConnectionFromLagErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DisassociateConnectionFromLagError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateConnectionFromLagErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            DisassociateConnectionFromLagErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            DisassociateConnectionFromLagErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateMacSecKeyError {
    pub kind: DisassociateMacSecKeyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateMacSecKeyErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateMacSecKeyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateMacSecKeyErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            DisassociateMacSecKeyErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            DisassociateMacSecKeyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateMacSecKeyError {
    fn code(&self) -> Option<&str> {
        DisassociateMacSecKeyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateMacSecKeyError {
    pub fn new(kind: DisassociateMacSecKeyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateMacSecKeyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateMacSecKeyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateMacSecKeyErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateMacSecKeyErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for DisassociateMacSecKeyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateMacSecKeyErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            DisassociateMacSecKeyErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            DisassociateMacSecKeyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListVirtualInterfaceTestHistoryError {
    pub kind: ListVirtualInterfaceTestHistoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListVirtualInterfaceTestHistoryErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListVirtualInterfaceTestHistoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListVirtualInterfaceTestHistoryErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            ListVirtualInterfaceTestHistoryErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            ListVirtualInterfaceTestHistoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListVirtualInterfaceTestHistoryError {
    fn code(&self) -> Option<&str> {
        ListVirtualInterfaceTestHistoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListVirtualInterfaceTestHistoryError {
    pub fn new(kind: ListVirtualInterfaceTestHistoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListVirtualInterfaceTestHistoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListVirtualInterfaceTestHistoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualInterfaceTestHistoryErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListVirtualInterfaceTestHistoryErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for ListVirtualInterfaceTestHistoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListVirtualInterfaceTestHistoryErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            ListVirtualInterfaceTestHistoryErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            ListVirtualInterfaceTestHistoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StartBgpFailoverTestError {
    pub kind: StartBgpFailoverTestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StartBgpFailoverTestErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StartBgpFailoverTestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StartBgpFailoverTestErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            StartBgpFailoverTestErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            StartBgpFailoverTestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StartBgpFailoverTestError {
    fn code(&self) -> Option<&str> {
        StartBgpFailoverTestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StartBgpFailoverTestError {
    pub fn new(kind: StartBgpFailoverTestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StartBgpFailoverTestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StartBgpFailoverTestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBgpFailoverTestErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            StartBgpFailoverTestErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for StartBgpFailoverTestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StartBgpFailoverTestErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            StartBgpFailoverTestErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            StartBgpFailoverTestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopBgpFailoverTestError {
    pub kind: StopBgpFailoverTestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopBgpFailoverTestErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopBgpFailoverTestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopBgpFailoverTestErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            StopBgpFailoverTestErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            StopBgpFailoverTestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopBgpFailoverTestError {
    fn code(&self) -> Option<&str> {
        StopBgpFailoverTestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopBgpFailoverTestError {
    pub fn new(kind: StopBgpFailoverTestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopBgpFailoverTestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopBgpFailoverTestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopBgpFailoverTestErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            StopBgpFailoverTestErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for StopBgpFailoverTestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopBgpFailoverTestErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            StopBgpFailoverTestErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            StopBgpFailoverTestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    DuplicateTagKeysException(crate::error::DuplicateTagKeysException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::DuplicateTagKeysException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::DirectConnectServerException(_)
        )
    }
    pub fn is_duplicate_tag_keys_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::DuplicateTagKeysException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TooManyTagsException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            TagResourceErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            TagResourceErrorKind::DuplicateTagKeysException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            UntagResourceErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateConnectionError {
    pub kind: UpdateConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateConnectionErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateConnectionErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            UpdateConnectionErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            UpdateConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateConnectionError {
    fn code(&self) -> Option<&str> {
        UpdateConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateConnectionError {
    pub fn new(kind: UpdateConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateConnectionErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for UpdateConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateConnectionErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            UpdateConnectionErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            UpdateConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDirectConnectGatewayAssociationError {
    pub kind: UpdateDirectConnectGatewayAssociationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDirectConnectGatewayAssociationErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDirectConnectGatewayAssociationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDirectConnectGatewayAssociationErrorKind::DirectConnectClientException(
                _inner,
            ) => _inner.fmt(f),
            UpdateDirectConnectGatewayAssociationErrorKind::DirectConnectServerException(
                _inner,
            ) => _inner.fmt(f),
            UpdateDirectConnectGatewayAssociationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDirectConnectGatewayAssociationError {
    fn code(&self) -> Option<&str> {
        UpdateDirectConnectGatewayAssociationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDirectConnectGatewayAssociationError {
    pub fn new(
        kind: UpdateDirectConnectGatewayAssociationErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDirectConnectGatewayAssociationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDirectConnectGatewayAssociationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDirectConnectGatewayAssociationErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDirectConnectGatewayAssociationErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for UpdateDirectConnectGatewayAssociationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDirectConnectGatewayAssociationErrorKind::DirectConnectClientException(
                _inner,
            ) => Some(_inner),
            UpdateDirectConnectGatewayAssociationErrorKind::DirectConnectServerException(
                _inner,
            ) => Some(_inner),
            UpdateDirectConnectGatewayAssociationErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateLagError {
    pub kind: UpdateLagErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateLagErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateLagError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateLagErrorKind::DirectConnectClientException(_inner) => _inner.fmt(f),
            UpdateLagErrorKind::DirectConnectServerException(_inner) => _inner.fmt(f),
            UpdateLagErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateLagError {
    fn code(&self) -> Option<&str> {
        UpdateLagError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateLagError {
    pub fn new(kind: UpdateLagErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateLagErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateLagErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLagErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateLagErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for UpdateLagError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateLagErrorKind::DirectConnectClientException(_inner) => Some(_inner),
            UpdateLagErrorKind::DirectConnectServerException(_inner) => Some(_inner),
            UpdateLagErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateVirtualInterfaceAttributesError {
    pub kind: UpdateVirtualInterfaceAttributesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateVirtualInterfaceAttributesErrorKind {
    DirectConnectClientException(crate::error::DirectConnectClientException),
    DirectConnectServerException(crate::error::DirectConnectServerException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateVirtualInterfaceAttributesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateVirtualInterfaceAttributesErrorKind::DirectConnectClientException(_inner) => {
                _inner.fmt(f)
            }
            UpdateVirtualInterfaceAttributesErrorKind::DirectConnectServerException(_inner) => {
                _inner.fmt(f)
            }
            UpdateVirtualInterfaceAttributesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateVirtualInterfaceAttributesError {
    fn code(&self) -> Option<&str> {
        UpdateVirtualInterfaceAttributesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateVirtualInterfaceAttributesError {
    pub fn new(kind: UpdateVirtualInterfaceAttributesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateVirtualInterfaceAttributesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateVirtualInterfaceAttributesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_direct_connect_client_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualInterfaceAttributesErrorKind::DirectConnectClientException(_)
        )
    }
    pub fn is_direct_connect_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateVirtualInterfaceAttributesErrorKind::DirectConnectServerException(_)
        )
    }
}
impl std::error::Error for UpdateVirtualInterfaceAttributesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateVirtualInterfaceAttributesErrorKind::DirectConnectClientException(_inner) => {
                Some(_inner)
            }
            UpdateVirtualInterfaceAttributesErrorKind::DirectConnectServerException(_inner) => {
                Some(_inner)
            }
            UpdateVirtualInterfaceAttributesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>A server-side error occurred.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DirectConnectServerException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DirectConnectServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DirectConnectServerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DirectConnectServerException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectConnectServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectConnectServerException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for DirectConnectServerException {}
/// See [`DirectConnectServerException`](crate::error::DirectConnectServerException)
pub mod direct_connect_server_exception {
    /// A builder for [`DirectConnectServerException`](crate::error::DirectConnectServerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DirectConnectServerException`](crate::error::DirectConnectServerException)
        pub fn build(self) -> crate::error::DirectConnectServerException {
            crate::error::DirectConnectServerException {
                message: self.message,
            }
        }
    }
}
impl DirectConnectServerException {
    /// Creates a new builder-style object to manufacture [`DirectConnectServerException`](crate::error::DirectConnectServerException)
    pub fn builder() -> crate::error::direct_connect_server_exception::Builder {
        crate::error::direct_connect_server_exception::Builder::default()
    }
}

/// <p>One or more parameters are not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DirectConnectClientException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DirectConnectClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DirectConnectClientException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DirectConnectClientException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectConnectClientException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectConnectClientException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for DirectConnectClientException {}
/// See [`DirectConnectClientException`](crate::error::DirectConnectClientException)
pub mod direct_connect_client_exception {
    /// A builder for [`DirectConnectClientException`](crate::error::DirectConnectClientException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DirectConnectClientException`](crate::error::DirectConnectClientException)
        pub fn build(self) -> crate::error::DirectConnectClientException {
            crate::error::DirectConnectClientException {
                message: self.message,
            }
        }
    }
}
impl DirectConnectClientException {
    /// Creates a new builder-style object to manufacture [`DirectConnectClientException`](crate::error::DirectConnectClientException)
    pub fn builder() -> crate::error::direct_connect_client_exception::Builder {
        crate::error::direct_connect_client_exception::Builder::default()
    }
}

/// <p>You have reached the limit on the number of tags that can be assigned.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyTagsException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyTagsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyTagsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsException {}
/// See [`TooManyTagsException`](crate::error::TooManyTagsException)
pub mod too_many_tags_exception {
    /// A builder for [`TooManyTagsException`](crate::error::TooManyTagsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTagsException`](crate::error::TooManyTagsException)
        pub fn build(self) -> crate::error::TooManyTagsException {
            crate::error::TooManyTagsException {
                message: self.message,
            }
        }
    }
}
impl TooManyTagsException {
    /// Creates a new builder-style object to manufacture [`TooManyTagsException`](crate::error::TooManyTagsException)
    pub fn builder() -> crate::error::too_many_tags_exception::Builder {
        crate::error::too_many_tags_exception::Builder::default()
    }
}

/// <p>A tag key was specified more than once.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DuplicateTagKeysException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DuplicateTagKeysException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DuplicateTagKeysException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DuplicateTagKeysException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DuplicateTagKeysException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateTagKeysException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for DuplicateTagKeysException {}
/// See [`DuplicateTagKeysException`](crate::error::DuplicateTagKeysException)
pub mod duplicate_tag_keys_exception {
    /// A builder for [`DuplicateTagKeysException`](crate::error::DuplicateTagKeysException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DuplicateTagKeysException`](crate::error::DuplicateTagKeysException)
        pub fn build(self) -> crate::error::DuplicateTagKeysException {
            crate::error::DuplicateTagKeysException {
                message: self.message,
            }
        }
    }
}
impl DuplicateTagKeysException {
    /// Creates a new builder-style object to manufacture [`DuplicateTagKeysException`](crate::error::DuplicateTagKeysException)
    pub fn builder() -> crate::error::duplicate_tag_keys_exception::Builder {
        crate::error::duplicate_tag_keys_exception::Builder::default()
    }
}
