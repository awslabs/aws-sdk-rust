// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_direct_connect_gateway_association_proposal_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptDirectConnectGatewayAssociationProposalOutput,
    crate::error::AcceptDirectConnectGatewayAssociationProposalError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AcceptDirectConnectGatewayAssociationProposalError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::AcceptDirectConnectGatewayAssociationProposalError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::AcceptDirectConnectGatewayAssociationProposalError { meta: generic, kind: crate::error::AcceptDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AcceptDirectConnectGatewayAssociationProposalError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::AcceptDirectConnectGatewayAssociationProposalError { meta: generic, kind: crate::error::AcceptDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AcceptDirectConnectGatewayAssociationProposalError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AcceptDirectConnectGatewayAssociationProposalError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_direct_connect_gateway_association_proposal_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptDirectConnectGatewayAssociationProposalOutput,
    crate::error::AcceptDirectConnectGatewayAssociationProposalError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::accept_direct_connect_gateway_association_proposal_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_accept_direct_connect_gateway_association_proposal(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::AcceptDirectConnectGatewayAssociationProposalError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_connection_on_interconnect_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateConnectionOnInterconnectOutput,
    crate::error::AllocateConnectionOnInterconnectError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AllocateConnectionOnInterconnectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AllocateConnectionOnInterconnectError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::AllocateConnectionOnInterconnectError { meta: generic, kind: crate::error::AllocateConnectionOnInterconnectErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocateConnectionOnInterconnectError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::AllocateConnectionOnInterconnectError { meta: generic, kind: crate::error::AllocateConnectionOnInterconnectErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocateConnectionOnInterconnectError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AllocateConnectionOnInterconnectError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_connection_on_interconnect_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateConnectionOnInterconnectOutput,
    crate::error::AllocateConnectionOnInterconnectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::allocate_connection_on_interconnect_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_allocate_connection_on_interconnect(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AllocateConnectionOnInterconnectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_hosted_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateHostedConnectionOutput,
    crate::error::AllocateHostedConnectionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AllocateHostedConnectionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AllocateHostedConnectionError {
                meta: generic,
                kind: crate::error::AllocateHostedConnectionErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        "DirectConnectServerException" => {
            crate::error::AllocateHostedConnectionError {
                meta: generic,
                kind: crate::error::AllocateHostedConnectionErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        "DuplicateTagKeysException" => {
            crate::error::AllocateHostedConnectionError {
                meta: generic,
                kind: crate::error::AllocateHostedConnectionErrorKind::DuplicateTagKeysException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::duplicate_tag_keys_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TooManyTagsException" => crate::error::AllocateHostedConnectionError {
            meta: generic,
            kind: crate::error::AllocateHostedConnectionErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AllocateHostedConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_hosted_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateHostedConnectionOutput,
    crate::error::AllocateHostedConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::allocate_hosted_connection_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_allocate_hosted_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_private_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocatePrivateVirtualInterfaceOutput,
    crate::error::AllocatePrivateVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::AllocatePrivateVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::AllocatePrivateVirtualInterfaceErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::AllocatePrivateVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::AllocatePrivateVirtualInterfaceErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DuplicateTagKeysException" => crate::error::AllocatePrivateVirtualInterfaceError {
            meta: generic,
            kind: crate::error::AllocatePrivateVirtualInterfaceErrorKind::DuplicateTagKeysException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::duplicate_tag_keys_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "TooManyTagsException" => crate::error::AllocatePrivateVirtualInterfaceError {
            meta: generic,
            kind: crate::error::AllocatePrivateVirtualInterfaceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AllocatePrivateVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_private_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocatePrivateVirtualInterfaceOutput,
    crate::error::AllocatePrivateVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::allocate_private_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_allocate_private_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_public_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocatePublicVirtualInterfaceOutput,
    crate::error::AllocatePublicVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AllocatePublicVirtualInterfaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::AllocatePublicVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::AllocatePublicVirtualInterfaceErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::AllocatePublicVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::AllocatePublicVirtualInterfaceErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DuplicateTagKeysException" => crate::error::AllocatePublicVirtualInterfaceError {
            meta: generic,
            kind: crate::error::AllocatePublicVirtualInterfaceErrorKind::DuplicateTagKeysException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::duplicate_tag_keys_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "TooManyTagsException" => crate::error::AllocatePublicVirtualInterfaceError {
            meta: generic,
            kind: crate::error::AllocatePublicVirtualInterfaceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AllocatePublicVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_public_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocatePublicVirtualInterfaceOutput,
    crate::error::AllocatePublicVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::allocate_public_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_allocate_public_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_transit_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateTransitVirtualInterfaceOutput,
    crate::error::AllocateTransitVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AllocateTransitVirtualInterfaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::AllocateTransitVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::AllocateTransitVirtualInterfaceErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::AllocateTransitVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::AllocateTransitVirtualInterfaceErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DuplicateTagKeysException" => crate::error::AllocateTransitVirtualInterfaceError {
            meta: generic,
            kind: crate::error::AllocateTransitVirtualInterfaceErrorKind::DuplicateTagKeysException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::duplicate_tag_keys_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "TooManyTagsException" => crate::error::AllocateTransitVirtualInterfaceError {
            meta: generic,
            kind: crate::error::AllocateTransitVirtualInterfaceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AllocateTransitVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_transit_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateTransitVirtualInterfaceOutput,
    crate::error::AllocateTransitVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::allocate_transit_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_allocate_transit_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_connection_with_lag_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateConnectionWithLagOutput,
    crate::error::AssociateConnectionWithLagError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AssociateConnectionWithLagError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateConnectionWithLagError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::AssociateConnectionWithLagError {
            meta: generic,
            kind: crate::error::AssociateConnectionWithLagErrorKind::DirectConnectClientException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateConnectionWithLagError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "DirectConnectServerException" => crate::error::AssociateConnectionWithLagError {
            meta: generic,
            kind: crate::error::AssociateConnectionWithLagErrorKind::DirectConnectServerException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateConnectionWithLagError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::AssociateConnectionWithLagError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_connection_with_lag_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateConnectionWithLagOutput,
    crate::error::AssociateConnectionWithLagError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_connection_with_lag_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_associate_connection_with_lag(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateConnectionWithLagError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_hosted_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateHostedConnectionOutput,
    crate::error::AssociateHostedConnectionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AssociateHostedConnectionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateHostedConnectionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::AssociateHostedConnectionError {
            meta: generic,
            kind: crate::error::AssociateHostedConnectionErrorKind::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::AssociateHostedConnectionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DirectConnectServerException" => crate::error::AssociateHostedConnectionError {
            meta: generic,
            kind: crate::error::AssociateHostedConnectionErrorKind::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::AssociateHostedConnectionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AssociateHostedConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_hosted_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateHostedConnectionOutput,
    crate::error::AssociateHostedConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_hosted_connection_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_associate_hosted_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateHostedConnectionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_mac_sec_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateMacSecKeyOutput,
    crate::error::AssociateMacSecKeyError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AssociateMacSecKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AssociateMacSecKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AssociateMacSecKeyError {
                meta: generic,
                kind: crate::error::AssociateMacSecKeyErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateMacSecKeyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::AssociateMacSecKeyError {
                meta: generic,
                kind: crate::error::AssociateMacSecKeyErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateMacSecKeyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::AssociateMacSecKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_mac_sec_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateMacSecKeyOutput,
    crate::error::AssociateMacSecKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_mac_sec_key_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_associate_mac_sec_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateMacSecKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateVirtualInterfaceOutput,
    crate::error::AssociateVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AssociateVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::AssociateVirtualInterfaceError {
            meta: generic,
            kind: crate::error::AssociateVirtualInterfaceErrorKind::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::AssociateVirtualInterfaceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DirectConnectServerException" => crate::error::AssociateVirtualInterfaceError {
            meta: generic,
            kind: crate::error::AssociateVirtualInterfaceErrorKind::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::AssociateVirtualInterfaceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::AssociateVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateVirtualInterfaceOutput,
    crate::error::AssociateVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_associate_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ConfirmConnectionOutput, crate::error::ConfirmConnectionError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ConfirmConnectionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ConfirmConnectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::ConfirmConnectionError {
                meta: generic,
                kind: crate::error::ConfirmConnectionErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ConfirmConnectionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::ConfirmConnectionError {
                meta: generic,
                kind: crate::error::ConfirmConnectionErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ConfirmConnectionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ConfirmConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ConfirmConnectionOutput, crate::error::ConfirmConnectionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::confirm_connection_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_confirm_connection(response.body().as_ref(), output)
                .map_err(crate::error::ConfirmConnectionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_private_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmPrivateVirtualInterfaceOutput,
    crate::error::ConfirmPrivateVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ConfirmPrivateVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ConfirmPrivateVirtualInterfaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::ConfirmPrivateVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::ConfirmPrivateVirtualInterfaceErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ConfirmPrivateVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::ConfirmPrivateVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::ConfirmPrivateVirtualInterfaceErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ConfirmPrivateVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::ConfirmPrivateVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_private_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmPrivateVirtualInterfaceOutput,
    crate::error::ConfirmPrivateVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::confirm_private_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_confirm_private_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ConfirmPrivateVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_public_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmPublicVirtualInterfaceOutput,
    crate::error::ConfirmPublicVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ConfirmPublicVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ConfirmPublicVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::ConfirmPublicVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::ConfirmPublicVirtualInterfaceErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ConfirmPublicVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::ConfirmPublicVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::ConfirmPublicVirtualInterfaceErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ConfirmPublicVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::ConfirmPublicVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_public_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmPublicVirtualInterfaceOutput,
    crate::error::ConfirmPublicVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::confirm_public_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_confirm_public_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ConfirmPublicVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_transit_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmTransitVirtualInterfaceOutput,
    crate::error::ConfirmTransitVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ConfirmTransitVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ConfirmTransitVirtualInterfaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::ConfirmTransitVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::ConfirmTransitVirtualInterfaceErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ConfirmTransitVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::ConfirmTransitVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::ConfirmTransitVirtualInterfaceErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ConfirmTransitVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::ConfirmTransitVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_transit_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmTransitVirtualInterfaceOutput,
    crate::error::ConfirmTransitVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::confirm_transit_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_confirm_transit_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ConfirmTransitVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_bgp_peer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateBgpPeerOutput, crate::error::CreateBGPPeerError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateBGPPeerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateBGPPeerError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateBGPPeerError {
                meta: generic,
                kind: crate::error::CreateBGPPeerErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBGPPeerError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::CreateBGPPeerError {
                meta: generic,
                kind: crate::error::CreateBGPPeerErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBGPPeerError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::CreateBGPPeerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_bgp_peer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateBgpPeerOutput, crate::error::CreateBGPPeerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_bgp_peer_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_bgp_peer(response.body().as_ref(), output)
                .map_err(crate::error::CreateBGPPeerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateConnectionOutput, crate::error::CreateConnectionError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateConnectionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateConnectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateConnectionError {
                meta: generic,
                kind: crate::error::CreateConnectionErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateConnectionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::CreateConnectionError {
                meta: generic,
                kind: crate::error::CreateConnectionErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateConnectionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DuplicateTagKeysException" => {
            crate::error::CreateConnectionError {
                meta: generic,
                kind: crate::error::CreateConnectionErrorKind::DuplicateTagKeysException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::duplicate_tag_keys_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateConnectionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TooManyTagsException" => crate::error::CreateConnectionError {
            meta: generic,
            kind: crate::error::CreateConnectionErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateConnectionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateConnectionOutput, crate::error::CreateConnectionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_connection_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_connection(response.body().as_ref(), output)
                .map_err(crate::error::CreateConnectionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayOutput,
    crate::error::CreateDirectConnectGatewayError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDirectConnectGatewayError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDirectConnectGatewayError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::CreateDirectConnectGatewayError {
            meta: generic,
            kind: crate::error::CreateDirectConnectGatewayErrorKind::DirectConnectClientException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "DirectConnectServerException" => crate::error::CreateDirectConnectGatewayError {
            meta: generic,
            kind: crate::error::CreateDirectConnectGatewayErrorKind::DirectConnectServerException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::CreateDirectConnectGatewayError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayOutput,
    crate::error::CreateDirectConnectGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_direct_connect_gateway_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_direct_connect_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDirectConnectGatewayError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayAssociationOutput,
    crate::error::CreateDirectConnectGatewayAssociationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDirectConnectGatewayAssociationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateDirectConnectGatewayAssociationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::CreateDirectConnectGatewayAssociationError { meta: generic, kind: crate::error::CreateDirectConnectGatewayAssociationErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayAssociationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::CreateDirectConnectGatewayAssociationError { meta: generic, kind: crate::error::CreateDirectConnectGatewayAssociationErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayAssociationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateDirectConnectGatewayAssociationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayAssociationOutput,
    crate::error::CreateDirectConnectGatewayAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_direct_connect_gateway_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_direct_connect_gateway_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDirectConnectGatewayAssociationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_association_proposal_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayAssociationProposalOutput,
    crate::error::CreateDirectConnectGatewayAssociationProposalError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateDirectConnectGatewayAssociationProposalError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateDirectConnectGatewayAssociationProposalError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::CreateDirectConnectGatewayAssociationProposalError { meta: generic, kind: crate::error::CreateDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayAssociationProposalError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::CreateDirectConnectGatewayAssociationProposalError { meta: generic, kind: crate::error::CreateDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayAssociationProposalError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateDirectConnectGatewayAssociationProposalError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_association_proposal_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayAssociationProposalOutput,
    crate::error::CreateDirectConnectGatewayAssociationProposalError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::create_direct_connect_gateway_association_proposal_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_direct_connect_gateway_association_proposal(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateDirectConnectGatewayAssociationProposalError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_interconnect_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInterconnectOutput,
    crate::error::CreateInterconnectError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateInterconnectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateInterconnectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateInterconnectError {
                meta: generic,
                kind: crate::error::CreateInterconnectErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateInterconnectError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::CreateInterconnectError {
                meta: generic,
                kind: crate::error::CreateInterconnectErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateInterconnectError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DuplicateTagKeysException" => {
            crate::error::CreateInterconnectError {
                meta: generic,
                kind: crate::error::CreateInterconnectErrorKind::DuplicateTagKeysException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::duplicate_tag_keys_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateInterconnectError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TooManyTagsException" => crate::error::CreateInterconnectError {
            meta: generic,
            kind: crate::error::CreateInterconnectErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateInterconnectError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateInterconnectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_interconnect_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInterconnectOutput,
    crate::error::CreateInterconnectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_interconnect_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_interconnect(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateInterconnectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_lag_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateLagOutput, crate::error::CreateLagError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateLagError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateLagError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateLagError {
                meta: generic,
                kind: crate::error::CreateLagErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateLagError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::CreateLagError {
                meta: generic,
                kind: crate::error::CreateLagErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateLagError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DuplicateTagKeysException" => {
            crate::error::CreateLagError {
                meta: generic,
                kind: crate::error::CreateLagErrorKind::DuplicateTagKeysException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::duplicate_tag_keys_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateLagError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TooManyTagsException" => crate::error::CreateLagError {
            meta: generic,
            kind: crate::error::CreateLagErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateLagError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateLagError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_lag_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateLagOutput, crate::error::CreateLagError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_lag_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_lag(response.body().as_ref(), output)
            .map_err(crate::error::CreateLagError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_private_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePrivateVirtualInterfaceOutput,
    crate::error::CreatePrivateVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreatePrivateVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::CreatePrivateVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::CreatePrivateVirtualInterfaceErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::CreatePrivateVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::CreatePrivateVirtualInterfaceErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DuplicateTagKeysException" => crate::error::CreatePrivateVirtualInterfaceError {
            meta: generic,
            kind: crate::error::CreatePrivateVirtualInterfaceErrorKind::DuplicateTagKeysException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::duplicate_tag_keys_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "TooManyTagsException" => crate::error::CreatePrivateVirtualInterfaceError {
            meta: generic,
            kind: crate::error::CreatePrivateVirtualInterfaceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreatePrivateVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_private_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePrivateVirtualInterfaceOutput,
    crate::error::CreatePrivateVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_private_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_private_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_public_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePublicVirtualInterfaceOutput,
    crate::error::CreatePublicVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreatePublicVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::CreatePublicVirtualInterfaceError {
            meta: generic,
            kind: crate::error::CreatePublicVirtualInterfaceErrorKind::DirectConnectClientException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "DirectConnectServerException" => crate::error::CreatePublicVirtualInterfaceError {
            meta: generic,
            kind: crate::error::CreatePublicVirtualInterfaceErrorKind::DirectConnectServerException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "DuplicateTagKeysException" => crate::error::CreatePublicVirtualInterfaceError {
            meta: generic,
            kind: crate::error::CreatePublicVirtualInterfaceErrorKind::DuplicateTagKeysException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyTagsException" => crate::error::CreatePublicVirtualInterfaceError {
            meta: generic,
            kind: crate::error::CreatePublicVirtualInterfaceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreatePublicVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_public_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePublicVirtualInterfaceOutput,
    crate::error::CreatePublicVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_public_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_public_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitVirtualInterfaceOutput,
    crate::error::CreateTransitVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateTransitVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::CreateTransitVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::CreateTransitVirtualInterfaceErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::CreateTransitVirtualInterfaceError {
            meta: generic,
            kind:
                crate::error::CreateTransitVirtualInterfaceErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DuplicateTagKeysException" => crate::error::CreateTransitVirtualInterfaceError {
            meta: generic,
            kind: crate::error::CreateTransitVirtualInterfaceErrorKind::DuplicateTagKeysException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::duplicate_tag_keys_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "TooManyTagsException" => crate::error::CreateTransitVirtualInterfaceError {
            meta: generic,
            kind: crate::error::CreateTransitVirtualInterfaceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateTransitVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitVirtualInterfaceOutput,
    crate::error::CreateTransitVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_transit_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bgp_peer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteBgpPeerOutput, crate::error::DeleteBGPPeerError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteBGPPeerError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteBGPPeerError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteBGPPeerError {
                meta: generic,
                kind: crate::error::DeleteBGPPeerErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBGPPeerError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DeleteBGPPeerError {
                meta: generic,
                kind: crate::error::DeleteBGPPeerErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBGPPeerError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DeleteBGPPeerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bgp_peer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteBgpPeerOutput, crate::error::DeleteBGPPeerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bgp_peer_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_delete_bgp_peer(response.body().as_ref(), output)
                .map_err(crate::error::DeleteBGPPeerError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteConnectionOutput, crate::error::DeleteConnectionError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteConnectionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteConnectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteConnectionError {
                meta: generic,
                kind: crate::error::DeleteConnectionErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteConnectionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DeleteConnectionError {
                meta: generic,
                kind: crate::error::DeleteConnectionErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteConnectionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DeleteConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteConnectionOutput, crate::error::DeleteConnectionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_connection_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_delete_connection(response.body().as_ref(), output)
                .map_err(crate::error::DeleteConnectionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayOutput,
    crate::error::DeleteDirectConnectGatewayError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDirectConnectGatewayError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDirectConnectGatewayError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DeleteDirectConnectGatewayError {
            meta: generic,
            kind: crate::error::DeleteDirectConnectGatewayErrorKind::DirectConnectClientException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "DirectConnectServerException" => crate::error::DeleteDirectConnectGatewayError {
            meta: generic,
            kind: crate::error::DeleteDirectConnectGatewayErrorKind::DirectConnectServerException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        _ => crate::error::DeleteDirectConnectGatewayError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayOutput,
    crate::error::DeleteDirectConnectGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_direct_connect_gateway_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_direct_connect_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDirectConnectGatewayError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayAssociationOutput,
    crate::error::DeleteDirectConnectGatewayAssociationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDirectConnectGatewayAssociationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeleteDirectConnectGatewayAssociationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DeleteDirectConnectGatewayAssociationError { meta: generic, kind: crate::error::DeleteDirectConnectGatewayAssociationErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayAssociationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::DeleteDirectConnectGatewayAssociationError { meta: generic, kind: crate::error::DeleteDirectConnectGatewayAssociationErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayAssociationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteDirectConnectGatewayAssociationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayAssociationOutput,
    crate::error::DeleteDirectConnectGatewayAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_direct_connect_gateway_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_direct_connect_gateway_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDirectConnectGatewayAssociationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_association_proposal_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayAssociationProposalOutput,
    crate::error::DeleteDirectConnectGatewayAssociationProposalError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteDirectConnectGatewayAssociationProposalError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeleteDirectConnectGatewayAssociationProposalError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DeleteDirectConnectGatewayAssociationProposalError { meta: generic, kind: crate::error::DeleteDirectConnectGatewayAssociationProposalErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayAssociationProposalError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::DeleteDirectConnectGatewayAssociationProposalError { meta: generic, kind: crate::error::DeleteDirectConnectGatewayAssociationProposalErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayAssociationProposalError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteDirectConnectGatewayAssociationProposalError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_association_proposal_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayAssociationProposalOutput,
    crate::error::DeleteDirectConnectGatewayAssociationProposalError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::delete_direct_connect_gateway_association_proposal_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_delete_direct_connect_gateway_association_proposal(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeleteDirectConnectGatewayAssociationProposalError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_interconnect_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInterconnectOutput,
    crate::error::DeleteInterconnectError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteInterconnectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteInterconnectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteInterconnectError {
                meta: generic,
                kind: crate::error::DeleteInterconnectErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteInterconnectError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DeleteInterconnectError {
                meta: generic,
                kind: crate::error::DeleteInterconnectErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteInterconnectError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DeleteInterconnectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_interconnect_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInterconnectOutput,
    crate::error::DeleteInterconnectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_interconnect_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_interconnect(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteInterconnectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_lag_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteLagOutput, crate::error::DeleteLagError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteLagError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteLagError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteLagError {
                meta: generic,
                kind: crate::error::DeleteLagErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteLagError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DeleteLagError {
                meta: generic,
                kind: crate::error::DeleteLagErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteLagError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DeleteLagError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_lag_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteLagOutput, crate::error::DeleteLagError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_lag_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_lag(response.body().as_ref(), output)
            .map_err(crate::error::DeleteLagError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVirtualInterfaceOutput,
    crate::error::DeleteVirtualInterfaceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteVirtualInterfaceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteVirtualInterfaceError {
                meta: generic,
                kind: crate::error::DeleteVirtualInterfaceErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DeleteVirtualInterfaceError {
                meta: generic,
                kind: crate::error::DeleteVirtualInterfaceErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteVirtualInterfaceError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        _ => crate::error::DeleteVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVirtualInterfaceOutput,
    crate::error::DeleteVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteVirtualInterfaceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connection_loa_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionLoaOutput,
    crate::error::DescribeConnectionLoaError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConnectionLoaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeConnectionLoaError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeConnectionLoaError {
                meta: generic,
                kind: crate::error::DescribeConnectionLoaErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionLoaError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DescribeConnectionLoaError {
                meta: generic,
                kind: crate::error::DescribeConnectionLoaErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionLoaError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeConnectionLoaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connection_loa_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionLoaOutput,
    crate::error::DescribeConnectionLoaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_connection_loa_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_connection_loa(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeConnectionLoaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionsOutput,
    crate::error::DescribeConnectionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConnectionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeConnectionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeConnectionsError {
                meta: generic,
                kind: crate::error::DescribeConnectionsErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DescribeConnectionsError {
                meta: generic,
                kind: crate::error::DescribeConnectionsErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeConnectionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionsOutput,
    crate::error::DescribeConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_connections_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_connections(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeConnectionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connections_on_interconnect_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionsOnInterconnectOutput,
    crate::error::DescribeConnectionsOnInterconnectError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeConnectionsOnInterconnectError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeConnectionsOnInterconnectError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DescribeConnectionsOnInterconnectError { meta: generic, kind: crate::error::DescribeConnectionsOnInterconnectErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionsOnInterconnectError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::DescribeConnectionsOnInterconnectError { meta: generic, kind: crate::error::DescribeConnectionsOnInterconnectErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionsOnInterconnectError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeConnectionsOnInterconnectError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connections_on_interconnect_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionsOnInterconnectOutput,
    crate::error::DescribeConnectionsOnInterconnectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_connections_on_interconnect_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_connections_on_interconnect(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeConnectionsOnInterconnectError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_association_proposals_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAssociationProposalsOutput,
    crate::error::DescribeDirectConnectGatewayAssociationProposalsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDirectConnectGatewayAssociationProposalsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeDirectConnectGatewayAssociationProposalsError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DescribeDirectConnectGatewayAssociationProposalsError { meta: generic, kind: crate::error::DescribeDirectConnectGatewayAssociationProposalsErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationProposalsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::DescribeDirectConnectGatewayAssociationProposalsError { meta: generic, kind: crate::error::DescribeDirectConnectGatewayAssociationProposalsErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationProposalsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeDirectConnectGatewayAssociationProposalsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_association_proposals_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAssociationProposalsOutput,
    crate::error::DescribeDirectConnectGatewayAssociationProposalsError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::describe_direct_connect_gateway_association_proposals_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_direct_connect_gateway_association_proposals(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationProposalsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAssociationsOutput,
    crate::error::DescribeDirectConnectGatewayAssociationsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDirectConnectGatewayAssociationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeDirectConnectGatewayAssociationsError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DescribeDirectConnectGatewayAssociationsError { meta: generic, kind: crate::error::DescribeDirectConnectGatewayAssociationsErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::DescribeDirectConnectGatewayAssociationsError { meta: generic, kind: crate::error::DescribeDirectConnectGatewayAssociationsErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeDirectConnectGatewayAssociationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAssociationsOutput,
    crate::error::DescribeDirectConnectGatewayAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_direct_connect_gateway_associations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_direct_connect_gateway_associations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDirectConnectGatewayAssociationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_attachments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAttachmentsOutput,
    crate::error::DescribeDirectConnectGatewayAttachmentsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDirectConnectGatewayAttachmentsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeDirectConnectGatewayAttachmentsError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DescribeDirectConnectGatewayAttachmentsError { meta: generic, kind: crate::error::DescribeDirectConnectGatewayAttachmentsErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAttachmentsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::DescribeDirectConnectGatewayAttachmentsError { meta: generic, kind: crate::error::DescribeDirectConnectGatewayAttachmentsErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAttachmentsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeDirectConnectGatewayAttachmentsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_attachments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAttachmentsOutput,
    crate::error::DescribeDirectConnectGatewayAttachmentsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_direct_connect_gateway_attachments_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_direct_connect_gateway_attachments(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDirectConnectGatewayAttachmentsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewaysOutput,
    crate::error::DescribeDirectConnectGatewaysError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeDirectConnectGatewaysError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDirectConnectGatewaysError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DescribeDirectConnectGatewaysError {
            meta: generic,
            kind:
                crate::error::DescribeDirectConnectGatewaysErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewaysError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::DescribeDirectConnectGatewaysError {
            meta: generic,
            kind:
                crate::error::DescribeDirectConnectGatewaysErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewaysError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DescribeDirectConnectGatewaysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewaysOutput,
    crate::error::DescribeDirectConnectGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_direct_connect_gateways_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_direct_connect_gateways(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeDirectConnectGatewaysError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hosted_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHostedConnectionsOutput,
    crate::error::DescribeHostedConnectionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeHostedConnectionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeHostedConnectionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DescribeHostedConnectionsError {
            meta: generic,
            kind: crate::error::DescribeHostedConnectionsErrorKind::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeHostedConnectionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DirectConnectServerException" => crate::error::DescribeHostedConnectionsError {
            meta: generic,
            kind: crate::error::DescribeHostedConnectionsErrorKind::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeHostedConnectionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeHostedConnectionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hosted_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHostedConnectionsOutput,
    crate::error::DescribeHostedConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_hosted_connections_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_hosted_connections(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeHostedConnectionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_interconnect_loa_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInterconnectLoaOutput,
    crate::error::DescribeInterconnectLoaError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeInterconnectLoaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInterconnectLoaError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeInterconnectLoaError {
                meta: generic,
                kind: crate::error::DescribeInterconnectLoaErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeInterconnectLoaError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DescribeInterconnectLoaError {
                meta: generic,
                kind: crate::error::DescribeInterconnectLoaErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeInterconnectLoaError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        _ => crate::error::DescribeInterconnectLoaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_interconnect_loa_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInterconnectLoaOutput,
    crate::error::DescribeInterconnectLoaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_interconnect_loa_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_interconnect_loa(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInterconnectLoaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_interconnects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInterconnectsOutput,
    crate::error::DescribeInterconnectsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeInterconnectsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeInterconnectsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeInterconnectsError {
                meta: generic,
                kind: crate::error::DescribeInterconnectsErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeInterconnectsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DescribeInterconnectsError {
                meta: generic,
                kind: crate::error::DescribeInterconnectsErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeInterconnectsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeInterconnectsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_interconnects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInterconnectsOutput,
    crate::error::DescribeInterconnectsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_interconnects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_interconnects(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInterconnectsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_lags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLagsOutput, crate::error::DescribeLagsError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeLagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeLagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeLagsError {
                meta: generic,
                kind: crate::error::DescribeLagsErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeLagsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DescribeLagsError {
                meta: generic,
                kind: crate::error::DescribeLagsErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeLagsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeLagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_lags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLagsOutput, crate::error::DescribeLagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_lags_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_lags(response.body().as_ref(), output)
            .map_err(crate::error::DescribeLagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_loa_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLoaOutput, crate::error::DescribeLoaError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeLoaError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeLoaError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeLoaError {
                meta: generic,
                kind: crate::error::DescribeLoaErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeLoaError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DescribeLoaError {
                meta: generic,
                kind: crate::error::DescribeLoaErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeLoaError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeLoaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_loa_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLoaOutput, crate::error::DescribeLoaError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_loa_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_loa(response.body().as_ref(), output)
            .map_err(crate::error::DescribeLoaError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_locations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLocationsOutput, crate::error::DescribeLocationsError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeLocationsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeLocationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeLocationsError {
                meta: generic,
                kind: crate::error::DescribeLocationsErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeLocationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DescribeLocationsError {
                meta: generic,
                kind: crate::error::DescribeLocationsErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeLocationsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeLocationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_locations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLocationsOutput, crate::error::DescribeLocationsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_locations_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_describe_locations(response.body().as_ref(), output)
                .map_err(crate::error::DescribeLocationsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeTagsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeTagsError {
                meta: generic,
                kind: crate::error::DescribeTagsErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeTagsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DescribeTagsError {
                meta: generic,
                kind: crate::error::DescribeTagsErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeTagsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DescribeTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_tags_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_tags(response.body().as_ref(), output)
            .map_err(crate::error::DescribeTagsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_virtual_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVirtualGatewaysOutput,
    crate::error::DescribeVirtualGatewaysError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeVirtualGatewaysError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeVirtualGatewaysError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeVirtualGatewaysError {
                meta: generic,
                kind: crate::error::DescribeVirtualGatewaysErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeVirtualGatewaysError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DescribeVirtualGatewaysError {
                meta: generic,
                kind: crate::error::DescribeVirtualGatewaysErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeVirtualGatewaysError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        _ => crate::error::DescribeVirtualGatewaysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_virtual_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVirtualGatewaysOutput,
    crate::error::DescribeVirtualGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_virtual_gateways_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_virtual_gateways(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVirtualGatewaysError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_virtual_interfaces_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVirtualInterfacesOutput,
    crate::error::DescribeVirtualInterfacesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeVirtualInterfacesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeVirtualInterfacesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DescribeVirtualInterfacesError {
            meta: generic,
            kind: crate::error::DescribeVirtualInterfacesErrorKind::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeVirtualInterfacesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "DirectConnectServerException" => crate::error::DescribeVirtualInterfacesError {
            meta: generic,
            kind: crate::error::DescribeVirtualInterfacesErrorKind::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::DescribeVirtualInterfacesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DescribeVirtualInterfacesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_virtual_interfaces_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVirtualInterfacesOutput,
    crate::error::DescribeVirtualInterfacesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_virtual_interfaces_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_virtual_interfaces(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVirtualInterfacesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_connection_from_lag_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateConnectionFromLagOutput,
    crate::error::DisassociateConnectionFromLagError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DisassociateConnectionFromLagError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DisassociateConnectionFromLagError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DisassociateConnectionFromLagError {
            meta: generic,
            kind:
                crate::error::DisassociateConnectionFromLagErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateConnectionFromLagError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::DisassociateConnectionFromLagError {
            meta: generic,
            kind:
                crate::error::DisassociateConnectionFromLagErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateConnectionFromLagError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::DisassociateConnectionFromLagError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_connection_from_lag_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateConnectionFromLagOutput,
    crate::error::DisassociateConnectionFromLagError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_connection_from_lag_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_disassociate_connection_from_lag(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisassociateConnectionFromLagError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_mac_sec_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateMacSecKeyOutput,
    crate::error::DisassociateMacSecKeyError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DisassociateMacSecKeyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DisassociateMacSecKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DisassociateMacSecKeyError {
                meta: generic,
                kind: crate::error::DisassociateMacSecKeyErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateMacSecKeyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::DisassociateMacSecKeyError {
                meta: generic,
                kind: crate::error::DisassociateMacSecKeyErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateMacSecKeyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DisassociateMacSecKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_mac_sec_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateMacSecKeyOutput,
    crate::error::DisassociateMacSecKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_mac_sec_key_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_disassociate_mac_sec_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisassociateMacSecKeyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_virtual_interface_test_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVirtualInterfaceTestHistoryOutput,
    crate::error::ListVirtualInterfaceTestHistoryError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListVirtualInterfaceTestHistoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListVirtualInterfaceTestHistoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::ListVirtualInterfaceTestHistoryError {
            meta: generic,
            kind:
                crate::error::ListVirtualInterfaceTestHistoryErrorKind::DirectConnectClientException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_client_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListVirtualInterfaceTestHistoryError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "DirectConnectServerException" => crate::error::ListVirtualInterfaceTestHistoryError {
            meta: generic,
            kind:
                crate::error::ListVirtualInterfaceTestHistoryErrorKind::DirectConnectServerException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::direct_connect_server_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListVirtualInterfaceTestHistoryError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        _ => crate::error::ListVirtualInterfaceTestHistoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_virtual_interface_test_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVirtualInterfaceTestHistoryOutput,
    crate::error::ListVirtualInterfaceTestHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_virtual_interface_test_history_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_virtual_interface_test_history(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListVirtualInterfaceTestHistoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_bgp_failover_test_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartBgpFailoverTestOutput,
    crate::error::StartBgpFailoverTestError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartBgpFailoverTestError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartBgpFailoverTestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::StartBgpFailoverTestError {
                meta: generic,
                kind: crate::error::StartBgpFailoverTestErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::StartBgpFailoverTestError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::StartBgpFailoverTestError {
                meta: generic,
                kind: crate::error::StartBgpFailoverTestErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::StartBgpFailoverTestError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::StartBgpFailoverTestError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_bgp_failover_test_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartBgpFailoverTestOutput,
    crate::error::StartBgpFailoverTestError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_bgp_failover_test_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_start_bgp_failover_test(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartBgpFailoverTestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_bgp_failover_test_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopBgpFailoverTestOutput,
    crate::error::StopBgpFailoverTestError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StopBgpFailoverTestError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopBgpFailoverTestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::StopBgpFailoverTestError {
                meta: generic,
                kind: crate::error::StopBgpFailoverTestErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::StopBgpFailoverTestError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::StopBgpFailoverTestError {
                meta: generic,
                kind: crate::error::StopBgpFailoverTestErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::StopBgpFailoverTestError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::StopBgpFailoverTestError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_bgp_failover_test_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopBgpFailoverTestOutput,
    crate::error::StopBgpFailoverTestError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_bgp_failover_test_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_stop_bgp_failover_test(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopBgpFailoverTestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::TagResourceError {
                meta: generic,
                kind: crate::error::TagResourceErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::TagResourceError {
                meta: generic,
                kind: crate::error::TagResourceErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DuplicateTagKeysException" => {
            crate::error::TagResourceError {
                meta: generic,
                kind: crate::error::TagResourceErrorKind::DuplicateTagKeysException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::duplicate_tag_keys_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_duplicate_tag_keys_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TooManyTagsException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::UntagResourceError {
                meta: generic,
                kind: crate::error::UntagResourceErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::UntagResourceError {
                meta: generic,
                kind: crate::error::UntagResourceErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateConnectionOutput, crate::error::UpdateConnectionError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateConnectionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateConnectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::UpdateConnectionError {
                meta: generic,
                kind: crate::error::UpdateConnectionErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateConnectionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::UpdateConnectionError {
                meta: generic,
                kind: crate::error::UpdateConnectionErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateConnectionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UpdateConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateConnectionOutput, crate::error::UpdateConnectionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_connection_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_update_connection(response.body().as_ref(), output)
                .map_err(crate::error::UpdateConnectionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_direct_connect_gateway_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDirectConnectGatewayAssociationOutput,
    crate::error::UpdateDirectConnectGatewayAssociationError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateDirectConnectGatewayAssociationError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateDirectConnectGatewayAssociationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::UpdateDirectConnectGatewayAssociationError { meta: generic, kind: crate::error::UpdateDirectConnectGatewayAssociationErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDirectConnectGatewayAssociationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::UpdateDirectConnectGatewayAssociationError { meta: generic, kind: crate::error::UpdateDirectConnectGatewayAssociationErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDirectConnectGatewayAssociationError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateDirectConnectGatewayAssociationError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_direct_connect_gateway_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDirectConnectGatewayAssociationOutput,
    crate::error::UpdateDirectConnectGatewayAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_direct_connect_gateway_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_direct_connect_gateway_association(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateDirectConnectGatewayAssociationError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_lag_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateLagOutput, crate::error::UpdateLagError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateLagError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateLagError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::UpdateLagError {
                meta: generic,
                kind: crate::error::UpdateLagErrorKind::DirectConnectClientException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateLagError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectConnectServerException" => {
            crate::error::UpdateLagError {
                meta: generic,
                kind: crate::error::UpdateLagErrorKind::DirectConnectServerException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateLagError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UpdateLagError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_lag_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateLagOutput, crate::error::UpdateLagError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_lag_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_lag(response.body().as_ref(), output)
            .map_err(crate::error::UpdateLagError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_virtual_interface_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateVirtualInterfaceAttributesOutput,
    crate::error::UpdateVirtualInterfaceAttributesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateVirtualInterfaceAttributesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateVirtualInterfaceAttributesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::UpdateVirtualInterfaceAttributesError { meta: generic, kind: crate::error::UpdateVirtualInterfaceAttributesErrorKind::DirectConnectClientException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_client_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateVirtualInterfaceAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectConnectServerException" => crate::error::UpdateVirtualInterfaceAttributesError { meta: generic, kind: crate::error::UpdateVirtualInterfaceAttributesErrorKind::DirectConnectServerException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_direct_connect_server_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateVirtualInterfaceAttributesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateVirtualInterfaceAttributesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_virtual_interface_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateVirtualInterfaceAttributesOutput,
    crate::error::UpdateVirtualInterfaceAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_virtual_interface_attributes_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_virtual_interface_attributes(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateVirtualInterfaceAttributesError::unhandled)?;
        output.build()
    })
}
