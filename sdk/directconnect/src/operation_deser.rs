// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_direct_connect_gateway_association_proposal_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptDirectConnectGatewayAssociationProposalOutput,
    crate::error::AcceptDirectConnectGatewayAssociationProposalError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AcceptDirectConnectGatewayAssociationProposalError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::AcceptDirectConnectGatewayAssociationProposalError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::AcceptDirectConnectGatewayAssociationProposalError::DirectConnectClientException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AcceptDirectConnectGatewayAssociationProposalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DirectConnectServerException" => crate::error::AcceptDirectConnectGatewayAssociationProposalError::DirectConnectServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AcceptDirectConnectGatewayAssociationProposalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::AcceptDirectConnectGatewayAssociationProposalError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_accept_direct_connect_gateway_association_proposal_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AcceptDirectConnectGatewayAssociationProposalOutput,
    crate::error::AcceptDirectConnectGatewayAssociationProposalError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::accept_direct_connect_gateway_association_proposal_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_accept_direct_connect_gateway_association_proposal(response.body().as_ref(), output).map_err(crate::error::AcceptDirectConnectGatewayAssociationProposalError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_connection_on_interconnect_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateConnectionOnInterconnectOutput,
    crate::error::AllocateConnectionOnInterconnectError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AllocateConnectionOnInterconnectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AllocateConnectionOnInterconnectError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AllocateConnectionOnInterconnectError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocateConnectionOnInterconnectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::AllocateConnectionOnInterconnectError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocateConnectionOnInterconnectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AllocateConnectionOnInterconnectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_connection_on_interconnect_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateConnectionOnInterconnectOutput,
    crate::error::AllocateConnectionOnInterconnectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::allocate_connection_on_interconnect_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_allocate_connection_on_interconnect(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::AllocateConnectionOnInterconnectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_hosted_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateHostedConnectionOutput,
    crate::error::AllocateHostedConnectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AllocateHostedConnectionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AllocateHostedConnectionError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::AllocateHostedConnectionError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => {
            crate::error::AllocateHostedConnectionError::DuplicateTagKeysException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => {
            crate::error::AllocateHostedConnectionError::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AllocateHostedConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_hosted_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateHostedConnectionOutput,
    crate::error::AllocateHostedConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::allocate_hosted_connection_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_allocate_hosted_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AllocateHostedConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_private_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocatePrivateVirtualInterfaceOutput,
    crate::error::AllocatePrivateVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AllocatePrivateVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::AllocatePrivateVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => {
            crate::error::AllocatePrivateVirtualInterfaceError::DuplicateTagKeysException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => {
            crate::error::AllocatePrivateVirtualInterfaceError::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AllocatePrivateVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_private_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocatePrivateVirtualInterfaceOutput,
    crate::error::AllocatePrivateVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::allocate_private_virtual_interface_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_allocate_private_virtual_interface(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::AllocatePrivateVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_public_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocatePublicVirtualInterfaceOutput,
    crate::error::AllocatePublicVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AllocatePublicVirtualInterfaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AllocatePublicVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::AllocatePublicVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => {
            crate::error::AllocatePublicVirtualInterfaceError::DuplicateTagKeysException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => {
            crate::error::AllocatePublicVirtualInterfaceError::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AllocatePublicVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_public_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocatePublicVirtualInterfaceOutput,
    crate::error::AllocatePublicVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::allocate_public_virtual_interface_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_allocate_public_virtual_interface(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::AllocatePublicVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_transit_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateTransitVirtualInterfaceOutput,
    crate::error::AllocateTransitVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AllocateTransitVirtualInterfaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AllocateTransitVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::AllocateTransitVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => {
            crate::error::AllocateTransitVirtualInterfaceError::DuplicateTagKeysException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => {
            crate::error::AllocateTransitVirtualInterfaceError::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AllocateTransitVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_allocate_transit_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AllocateTransitVirtualInterfaceOutput,
    crate::error::AllocateTransitVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::allocate_transit_virtual_interface_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_allocate_transit_virtual_interface(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::AllocateTransitVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_connection_with_lag_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateConnectionWithLagOutput,
    crate::error::AssociateConnectionWithLagError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateConnectionWithLagError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateConnectionWithLagError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AssociateConnectionWithLagError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateConnectionWithLagError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::AssociateConnectionWithLagError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateConnectionWithLagError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AssociateConnectionWithLagError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_connection_with_lag_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateConnectionWithLagOutput,
    crate::error::AssociateConnectionWithLagError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_connection_with_lag_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_associate_connection_with_lag(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateConnectionWithLagError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_hosted_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateHostedConnectionOutput,
    crate::error::AssociateHostedConnectionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateHostedConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateHostedConnectionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AssociateHostedConnectionError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateHostedConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::AssociateHostedConnectionError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateHostedConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AssociateHostedConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_hosted_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateHostedConnectionOutput,
    crate::error::AssociateHostedConnectionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_hosted_connection_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_associate_hosted_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateHostedConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_mac_sec_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateMacSecKeyOutput,
    crate::error::AssociateMacSecKeyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateMacSecKeyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::AssociateMacSecKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AssociateMacSecKeyError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateMacSecKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::AssociateMacSecKeyError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateMacSecKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AssociateMacSecKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_mac_sec_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateMacSecKeyOutput,
    crate::error::AssociateMacSecKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_mac_sec_key_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_associate_mac_sec_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateMacSecKeyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateVirtualInterfaceOutput,
    crate::error::AssociateVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::AssociateVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::AssociateVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::AssociateVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::AssociateVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateVirtualInterfaceOutput,
    crate::error::AssociateVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_associate_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::AssociateVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ConfirmConnectionOutput, crate::error::ConfirmConnectionError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ConfirmConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ConfirmConnectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::ConfirmConnectionError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ConfirmConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::ConfirmConnectionError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ConfirmConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ConfirmConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ConfirmConnectionOutput, crate::error::ConfirmConnectionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::confirm_connection_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_confirm_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ConfirmConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_customer_agreement_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmCustomerAgreementOutput,
    crate::error::ConfirmCustomerAgreementError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ConfirmCustomerAgreementError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ConfirmCustomerAgreementError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::ConfirmCustomerAgreementError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ConfirmCustomerAgreementError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::ConfirmCustomerAgreementError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ConfirmCustomerAgreementError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ConfirmCustomerAgreementError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_customer_agreement_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmCustomerAgreementOutput,
    crate::error::ConfirmCustomerAgreementError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::confirm_customer_agreement_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_confirm_customer_agreement(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ConfirmCustomerAgreementError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_private_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmPrivateVirtualInterfaceOutput,
    crate::error::ConfirmPrivateVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ConfirmPrivateVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ConfirmPrivateVirtualInterfaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::ConfirmPrivateVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ConfirmPrivateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::ConfirmPrivateVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ConfirmPrivateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ConfirmPrivateVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_private_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmPrivateVirtualInterfaceOutput,
    crate::error::ConfirmPrivateVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::confirm_private_virtual_interface_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_confirm_private_virtual_interface(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ConfirmPrivateVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_public_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmPublicVirtualInterfaceOutput,
    crate::error::ConfirmPublicVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ConfirmPublicVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ConfirmPublicVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::ConfirmPublicVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ConfirmPublicVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::ConfirmPublicVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ConfirmPublicVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ConfirmPublicVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_public_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmPublicVirtualInterfaceOutput,
    crate::error::ConfirmPublicVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::confirm_public_virtual_interface_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_confirm_public_virtual_interface(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ConfirmPublicVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_transit_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmTransitVirtualInterfaceOutput,
    crate::error::ConfirmTransitVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ConfirmTransitVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ConfirmTransitVirtualInterfaceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::ConfirmTransitVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ConfirmTransitVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::ConfirmTransitVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ConfirmTransitVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ConfirmTransitVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_confirm_transit_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ConfirmTransitVirtualInterfaceOutput,
    crate::error::ConfirmTransitVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::confirm_transit_virtual_interface_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_confirm_transit_virtual_interface(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ConfirmTransitVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_bgp_peer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateBgpPeerOutput, crate::error::CreateBGPPeerError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateBGPPeerError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateBGPPeerError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateBGPPeerError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBGPPeerError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::CreateBGPPeerError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBGPPeerError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateBGPPeerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_bgp_peer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateBgpPeerOutput, crate::error::CreateBGPPeerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_bgp_peer_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_bgp_peer(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateBGPPeerError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateConnectionOutput, crate::error::CreateConnectionError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateConnectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateConnectionError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::CreateConnectionError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => {
            crate::error::CreateConnectionError::DuplicateTagKeysException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => crate::error::CreateConnectionError::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_tags_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateConnectionError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateConnectionOutput, crate::error::CreateConnectionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_connection_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayOutput,
    crate::error::CreateDirectConnectGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDirectConnectGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateDirectConnectGatewayError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateDirectConnectGatewayError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::CreateDirectConnectGatewayError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateDirectConnectGatewayError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayOutput,
    crate::error::CreateDirectConnectGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_direct_connect_gateway_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_direct_connect_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateDirectConnectGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayAssociationOutput,
    crate::error::CreateDirectConnectGatewayAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDirectConnectGatewayAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateDirectConnectGatewayAssociationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateDirectConnectGatewayAssociationError::DirectConnectClientException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayAssociationError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "DirectConnectServerException" => {
            crate::error::CreateDirectConnectGatewayAssociationError::DirectConnectServerException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayAssociationError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::CreateDirectConnectGatewayAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayAssociationOutput,
    crate::error::CreateDirectConnectGatewayAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_direct_connect_gateway_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_direct_connect_gateway_association(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_association_proposal_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayAssociationProposalOutput,
    crate::error::CreateDirectConnectGatewayAssociationProposalError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateDirectConnectGatewayAssociationProposalError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::CreateDirectConnectGatewayAssociationProposalError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::CreateDirectConnectGatewayAssociationProposalError::DirectConnectClientException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayAssociationProposalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DirectConnectServerException" => crate::error::CreateDirectConnectGatewayAssociationProposalError::DirectConnectServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayAssociationProposalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateDirectConnectGatewayAssociationProposalError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_direct_connect_gateway_association_proposal_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateDirectConnectGatewayAssociationProposalOutput,
    crate::error::CreateDirectConnectGatewayAssociationProposalError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_direct_connect_gateway_association_proposal_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_direct_connect_gateway_association_proposal(response.body().as_ref(), output).map_err(crate::error::CreateDirectConnectGatewayAssociationProposalError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_interconnect_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInterconnectOutput,
    crate::error::CreateInterconnectError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateInterconnectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateInterconnectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateInterconnectError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInterconnectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::CreateInterconnectError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInterconnectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => {
            crate::error::CreateInterconnectError::DuplicateTagKeysException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInterconnectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => crate::error::CreateInterconnectError::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_tags_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateInterconnectError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateInterconnectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_interconnect_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateInterconnectOutput,
    crate::error::CreateInterconnectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_interconnect_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_interconnect(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateInterconnectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_lag_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateLagOutput, crate::error::CreateLagError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateLagError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateLagError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateLagError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLagError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::CreateLagError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLagError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => crate::error::CreateLagError::DuplicateTagKeysException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLagError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyTagsException" => crate::error::CreateLagError::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_tags_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateLagError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateLagError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_lag_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateLagOutput, crate::error::CreateLagError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_lag_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_lag(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateLagError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_private_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePrivateVirtualInterfaceOutput,
    crate::error::CreatePrivateVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreatePrivateVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreatePrivateVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::CreatePrivateVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => {
            crate::error::CreatePrivateVirtualInterfaceError::DuplicateTagKeysException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => {
            crate::error::CreatePrivateVirtualInterfaceError::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreatePrivateVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_private_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePrivateVirtualInterfaceOutput,
    crate::error::CreatePrivateVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_private_virtual_interface_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_create_private_virtual_interface(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreatePrivateVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_public_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePublicVirtualInterfaceOutput,
    crate::error::CreatePublicVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreatePublicVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreatePublicVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::CreatePublicVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => {
            crate::error::CreatePublicVirtualInterfaceError::DuplicateTagKeysException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => {
            crate::error::CreatePublicVirtualInterfaceError::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreatePublicVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_public_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePublicVirtualInterfaceOutput,
    crate::error::CreatePublicVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_public_virtual_interface_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_create_public_virtual_interface(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreatePublicVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitVirtualInterfaceOutput,
    crate::error::CreateTransitVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateTransitVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::CreateTransitVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::CreateTransitVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => {
            crate::error::CreateTransitVirtualInterfaceError::DuplicateTagKeysException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => {
            crate::error::CreateTransitVirtualInterfaceError::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateTransitVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_transit_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateTransitVirtualInterfaceOutput,
    crate::error::CreateTransitVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_transit_virtual_interface_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_create_transit_virtual_interface(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateTransitVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bgp_peer_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteBgpPeerOutput, crate::error::DeleteBGPPeerError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteBGPPeerError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteBGPPeerError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteBGPPeerError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBGPPeerError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DeleteBGPPeerError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBGPPeerError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteBGPPeerError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_bgp_peer_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteBgpPeerOutput, crate::error::DeleteBGPPeerError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_bgp_peer_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_bgp_peer(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteBGPPeerError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteConnectionOutput, crate::error::DeleteConnectionError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteConnectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteConnectionError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DeleteConnectionError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteConnectionOutput, crate::error::DeleteConnectionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_connection_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayOutput,
    crate::error::DeleteDirectConnectGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteDirectConnectGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteDirectConnectGatewayError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteDirectConnectGatewayError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DeleteDirectConnectGatewayError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteDirectConnectGatewayError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayOutput,
    crate::error::DeleteDirectConnectGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_direct_connect_gateway_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_direct_connect_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteDirectConnectGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayAssociationOutput,
    crate::error::DeleteDirectConnectGatewayAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteDirectConnectGatewayAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeleteDirectConnectGatewayAssociationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteDirectConnectGatewayAssociationError::DirectConnectClientException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayAssociationError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "DirectConnectServerException" => {
            crate::error::DeleteDirectConnectGatewayAssociationError::DirectConnectServerException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayAssociationError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::DeleteDirectConnectGatewayAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayAssociationOutput,
    crate::error::DeleteDirectConnectGatewayAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_direct_connect_gateway_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_direct_connect_gateway_association(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_association_proposal_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayAssociationProposalOutput,
    crate::error::DeleteDirectConnectGatewayAssociationProposalError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteDirectConnectGatewayAssociationProposalError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DeleteDirectConnectGatewayAssociationProposalError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DeleteDirectConnectGatewayAssociationProposalError::DirectConnectClientException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayAssociationProposalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DirectConnectServerException" => crate::error::DeleteDirectConnectGatewayAssociationProposalError::DirectConnectServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayAssociationProposalError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeleteDirectConnectGatewayAssociationProposalError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_direct_connect_gateway_association_proposal_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteDirectConnectGatewayAssociationProposalOutput,
    crate::error::DeleteDirectConnectGatewayAssociationProposalError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_direct_connect_gateway_association_proposal_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_direct_connect_gateway_association_proposal(response.body().as_ref(), output).map_err(crate::error::DeleteDirectConnectGatewayAssociationProposalError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_interconnect_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInterconnectOutput,
    crate::error::DeleteInterconnectError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteInterconnectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteInterconnectError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteInterconnectError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInterconnectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DeleteInterconnectError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteInterconnectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteInterconnectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_interconnect_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteInterconnectOutput,
    crate::error::DeleteInterconnectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_interconnect_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_interconnect(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteInterconnectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_lag_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteLagOutput, crate::error::DeleteLagError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteLagError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteLagError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteLagError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteLagError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DeleteLagError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteLagError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteLagError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_lag_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteLagOutput, crate::error::DeleteLagError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_lag_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_lag(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteLagError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_virtual_interface_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVirtualInterfaceOutput,
    crate::error::DeleteVirtualInterfaceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteVirtualInterfaceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteVirtualInterfaceError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DeleteVirtualInterfaceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DeleteVirtualInterfaceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteVirtualInterfaceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteVirtualInterfaceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_virtual_interface_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteVirtualInterfaceOutput,
    crate::error::DeleteVirtualInterfaceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_virtual_interface_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_virtual_interface(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteVirtualInterfaceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connection_loa_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionLoaOutput,
    crate::error::DescribeConnectionLoaError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeConnectionLoaError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeConnectionLoaError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeConnectionLoaError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionLoaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeConnectionLoaError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionLoaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeConnectionLoaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connection_loa_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionLoaOutput,
    crate::error::DescribeConnectionLoaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_connection_loa_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_connection_loa(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeConnectionLoaError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionsOutput,
    crate::error::DescribeConnectionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeConnectionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeConnectionsError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeConnectionsError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeConnectionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionsOutput,
    crate::error::DescribeConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_connections_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_connections(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeConnectionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connections_on_interconnect_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionsOnInterconnectOutput,
    crate::error::DescribeConnectionsOnInterconnectError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeConnectionsOnInterconnectError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeConnectionsOnInterconnectError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeConnectionsOnInterconnectError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionsOnInterconnectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeConnectionsOnInterconnectError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionsOnInterconnectError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeConnectionsOnInterconnectError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_connections_on_interconnect_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeConnectionsOnInterconnectOutput,
    crate::error::DescribeConnectionsOnInterconnectError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_connections_on_interconnect_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_connections_on_interconnect(response.body().as_ref(), output).map_err(crate::error::DescribeConnectionsOnInterconnectError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_customer_metadata_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCustomerMetadataOutput,
    crate::error::DescribeCustomerMetadataError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeCustomerMetadataError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeCustomerMetadataError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeCustomerMetadataError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeCustomerMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeCustomerMetadataError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeCustomerMetadataError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeCustomerMetadataError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_customer_metadata_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeCustomerMetadataOutput,
    crate::error::DescribeCustomerMetadataError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_customer_metadata_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_customer_metadata(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeCustomerMetadataError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_association_proposals_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAssociationProposalsOutput,
    crate::error::DescribeDirectConnectGatewayAssociationProposalsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDirectConnectGatewayAssociationProposalsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeDirectConnectGatewayAssociationProposalsError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DescribeDirectConnectGatewayAssociationProposalsError::DirectConnectClientException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationProposalsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DirectConnectServerException" => crate::error::DescribeDirectConnectGatewayAssociationProposalsError::DirectConnectServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationProposalsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeDirectConnectGatewayAssociationProposalsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_association_proposals_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAssociationProposalsOutput,
    crate::error::DescribeDirectConnectGatewayAssociationProposalsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_direct_connect_gateway_association_proposals_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_direct_connect_gateway_association_proposals(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationProposalsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_associations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAssociationsOutput,
    crate::error::DescribeDirectConnectGatewayAssociationsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDirectConnectGatewayAssociationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeDirectConnectGatewayAssociationsError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => crate::error::DescribeDirectConnectGatewayAssociationsError::DirectConnectClientException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "DirectConnectServerException" => crate::error::DescribeDirectConnectGatewayAssociationsError::DirectConnectServerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DescribeDirectConnectGatewayAssociationsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_associations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAssociationsOutput,
    crate::error::DescribeDirectConnectGatewayAssociationsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_direct_connect_gateway_associations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_direct_connect_gateway_associations(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAssociationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_attachments_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAttachmentsOutput,
    crate::error::DescribeDirectConnectGatewayAttachmentsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDirectConnectGatewayAttachmentsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DescribeDirectConnectGatewayAttachmentsError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeDirectConnectGatewayAttachmentsError::DirectConnectClientException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAttachmentsError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "DirectConnectServerException" => {
            crate::error::DescribeDirectConnectGatewayAttachmentsError::DirectConnectServerException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAttachmentsError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::DescribeDirectConnectGatewayAttachmentsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateway_attachments_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewayAttachmentsOutput,
    crate::error::DescribeDirectConnectGatewayAttachmentsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::describe_direct_connect_gateway_attachments_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_direct_connect_gateway_attachments(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewayAttachmentsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewaysOutput,
    crate::error::DescribeDirectConnectGatewaysError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeDirectConnectGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeDirectConnectGatewaysError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeDirectConnectGatewaysError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewaysError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeDirectConnectGatewaysError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeDirectConnectGatewaysError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeDirectConnectGatewaysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_direct_connect_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeDirectConnectGatewaysOutput,
    crate::error::DescribeDirectConnectGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_direct_connect_gateways_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_describe_direct_connect_gateways(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DescribeDirectConnectGatewaysError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hosted_connections_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHostedConnectionsOutput,
    crate::error::DescribeHostedConnectionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeHostedConnectionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeHostedConnectionsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeHostedConnectionsError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeHostedConnectionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeHostedConnectionsError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeHostedConnectionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeHostedConnectionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_hosted_connections_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeHostedConnectionsOutput,
    crate::error::DescribeHostedConnectionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_hosted_connections_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_hosted_connections(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeHostedConnectionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_interconnect_loa_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInterconnectLoaOutput,
    crate::error::DescribeInterconnectLoaError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInterconnectLoaError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeInterconnectLoaError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeInterconnectLoaError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInterconnectLoaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeInterconnectLoaError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInterconnectLoaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeInterconnectLoaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_interconnect_loa_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInterconnectLoaOutput,
    crate::error::DescribeInterconnectLoaError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_interconnect_loa_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_interconnect_loa(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInterconnectLoaError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_interconnects_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInterconnectsOutput,
    crate::error::DescribeInterconnectsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeInterconnectsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeInterconnectsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeInterconnectsError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInterconnectsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeInterconnectsError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeInterconnectsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeInterconnectsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_interconnects_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeInterconnectsOutput,
    crate::error::DescribeInterconnectsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_interconnects_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_interconnects(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeInterconnectsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_lags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLagsOutput, crate::error::DescribeLagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeLagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeLagsError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeLagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeLagsError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeLagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeLagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_lags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLagsOutput, crate::error::DescribeLagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_lags_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_lags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeLagsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_loa_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLoaOutput, crate::error::DescribeLoaError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLoaError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeLoaError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeLoaError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeLoaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeLoaError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeLoaError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeLoaError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_loa_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLoaOutput, crate::error::DescribeLoaError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_loa_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_loa(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeLoaError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_locations_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLocationsOutput, crate::error::DescribeLocationsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeLocationsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeLocationsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeLocationsError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeLocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeLocationsError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeLocationsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeLocationsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_locations_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeLocationsOutput, crate::error::DescribeLocationsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_locations_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_locations(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeLocationsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_router_configuration_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRouterConfigurationOutput,
    crate::error::DescribeRouterConfigurationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeRouterConfigurationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeRouterConfigurationError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeRouterConfigurationError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRouterConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeRouterConfigurationError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeRouterConfigurationError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeRouterConfigurationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_router_configuration_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeRouterConfigurationOutput,
    crate::error::DescribeRouterConfigurationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_router_configuration_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_router_configuration(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeRouterConfigurationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_tags_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeTagsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DescribeTagsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeTagsError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeTagsError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeTagsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeTagsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_tags_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_tags_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_tags(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeTagsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_virtual_gateways_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVirtualGatewaysOutput,
    crate::error::DescribeVirtualGatewaysError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVirtualGatewaysError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeVirtualGatewaysError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeVirtualGatewaysError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVirtualGatewaysError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeVirtualGatewaysError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVirtualGatewaysError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeVirtualGatewaysError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_virtual_gateways_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVirtualGatewaysOutput,
    crate::error::DescribeVirtualGatewaysError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_virtual_gateways_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_virtual_gateways(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVirtualGatewaysError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_virtual_interfaces_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVirtualInterfacesOutput,
    crate::error::DescribeVirtualInterfacesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeVirtualInterfacesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeVirtualInterfacesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DescribeVirtualInterfacesError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVirtualInterfacesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DescribeVirtualInterfacesError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeVirtualInterfacesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeVirtualInterfacesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_virtual_interfaces_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeVirtualInterfacesOutput,
    crate::error::DescribeVirtualInterfacesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_virtual_interfaces_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_virtual_interfaces(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeVirtualInterfacesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_connection_from_lag_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateConnectionFromLagOutput,
    crate::error::DisassociateConnectionFromLagError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateConnectionFromLagError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DisassociateConnectionFromLagError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DisassociateConnectionFromLagError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateConnectionFromLagError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DisassociateConnectionFromLagError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateConnectionFromLagError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DisassociateConnectionFromLagError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_connection_from_lag_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateConnectionFromLagOutput,
    crate::error::DisassociateConnectionFromLagError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_connection_from_lag_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_disassociate_connection_from_lag(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DisassociateConnectionFromLagError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_mac_sec_key_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateMacSecKeyOutput,
    crate::error::DisassociateMacSecKeyError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateMacSecKeyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DisassociateMacSecKeyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::DisassociateMacSecKeyError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateMacSecKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::DisassociateMacSecKeyError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateMacSecKeyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DisassociateMacSecKeyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_mac_sec_key_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateMacSecKeyOutput,
    crate::error::DisassociateMacSecKeyError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_mac_sec_key_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_disassociate_mac_sec_key(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DisassociateMacSecKeyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_virtual_interface_test_history_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVirtualInterfaceTestHistoryOutput,
    crate::error::ListVirtualInterfaceTestHistoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListVirtualInterfaceTestHistoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListVirtualInterfaceTestHistoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::ListVirtualInterfaceTestHistoryError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListVirtualInterfaceTestHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::ListVirtualInterfaceTestHistoryError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListVirtualInterfaceTestHistoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListVirtualInterfaceTestHistoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_virtual_interface_test_history_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListVirtualInterfaceTestHistoryOutput,
    crate::error::ListVirtualInterfaceTestHistoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_virtual_interface_test_history_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_list_virtual_interface_test_history(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::ListVirtualInterfaceTestHistoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_bgp_failover_test_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartBgpFailoverTestOutput,
    crate::error::StartBgpFailoverTestError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StartBgpFailoverTestError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StartBgpFailoverTestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::StartBgpFailoverTestError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartBgpFailoverTestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::StartBgpFailoverTestError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartBgpFailoverTestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::StartBgpFailoverTestError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_start_bgp_failover_test_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartBgpFailoverTestOutput,
    crate::error::StartBgpFailoverTestError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::start_bgp_failover_test_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_start_bgp_failover_test(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StartBgpFailoverTestError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_bgp_failover_test_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopBgpFailoverTestOutput,
    crate::error::StopBgpFailoverTestError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::StopBgpFailoverTestError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::StopBgpFailoverTestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::StopBgpFailoverTestError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopBgpFailoverTestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::StopBgpFailoverTestError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StopBgpFailoverTestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::StopBgpFailoverTestError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_stop_bgp_failover_test_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StopBgpFailoverTestOutput,
    crate::error::StopBgpFailoverTestError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::stop_bgp_failover_test_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_stop_bgp_failover_test(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::StopBgpFailoverTestError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::TagResourceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::TagResourceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DuplicateTagKeysException" => crate::error::TagResourceError::DuplicateTagKeysException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::duplicate_tag_keys_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_duplicate_tag_keys_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyTagsException" => crate::error::TagResourceError::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_tags_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::UntagResourceError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::UntagResourceError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_connection_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateConnectionOutput, crate::error::UpdateConnectionError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateConnectionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateConnectionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::UpdateConnectionError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::UpdateConnectionError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateConnectionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateConnectionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_connection_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateConnectionOutput, crate::error::UpdateConnectionError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_connection_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_connection(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateConnectionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_direct_connect_gateway_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDirectConnectGatewayOutput,
    crate::error::UpdateDirectConnectGatewayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDirectConnectGatewayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateDirectConnectGatewayError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::UpdateDirectConnectGatewayError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDirectConnectGatewayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::UpdateDirectConnectGatewayError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDirectConnectGatewayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateDirectConnectGatewayError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_direct_connect_gateway_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDirectConnectGatewayOutput,
    crate::error::UpdateDirectConnectGatewayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_direct_connect_gateway_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_direct_connect_gateway(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateDirectConnectGatewayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_direct_connect_gateway_association_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDirectConnectGatewayAssociationOutput,
    crate::error::UpdateDirectConnectGatewayAssociationError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDirectConnectGatewayAssociationError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateDirectConnectGatewayAssociationError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::UpdateDirectConnectGatewayAssociationError::DirectConnectClientException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_client_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDirectConnectGatewayAssociationError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "DirectConnectServerException" => {
            crate::error::UpdateDirectConnectGatewayAssociationError::DirectConnectServerException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::direct_connect_server_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDirectConnectGatewayAssociationError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::UpdateDirectConnectGatewayAssociationError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_direct_connect_gateway_association_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDirectConnectGatewayAssociationOutput,
    crate::error::UpdateDirectConnectGatewayAssociationError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_direct_connect_gateway_association_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_direct_connect_gateway_association(response.body().as_ref(), output).map_err(crate::error::UpdateDirectConnectGatewayAssociationError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_lag_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateLagOutput, crate::error::UpdateLagError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateLagError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateLagError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::UpdateLagError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateLagError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::UpdateLagError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateLagError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateLagError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_lag_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateLagOutput, crate::error::UpdateLagError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_lag_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_lag(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateLagError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_virtual_interface_attributes_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateVirtualInterfaceAttributesOutput,
    crate::error::UpdateVirtualInterfaceAttributesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateVirtualInterfaceAttributesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateVirtualInterfaceAttributesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "DirectConnectClientException" => {
            crate::error::UpdateVirtualInterfaceAttributesError::DirectConnectClientException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_client_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_client_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateVirtualInterfaceAttributesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectConnectServerException" => {
            crate::error::UpdateVirtualInterfaceAttributesError::DirectConnectServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::direct_connect_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_direct_connect_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateVirtualInterfaceAttributesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateVirtualInterfaceAttributesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_virtual_interface_attributes_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateVirtualInterfaceAttributesOutput,
    crate::error::UpdateVirtualInterfaceAttributesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_virtual_interface_attributes_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_update_virtual_interface_attributes(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::UpdateVirtualInterfaceAttributesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}
