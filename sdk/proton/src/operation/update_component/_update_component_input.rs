// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateComponentInput {
    /// <p>The name of the component to update.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The deployment type. It defines the mode for updating a component, as follows:</p>
    /// <dl>
    /// <dt></dt>
    /// <dd>
    /// <p> <code>NONE</code> </p>
    /// <p>In this mode, a deployment <i>doesn't</i> occur. Only the requested metadata parameters are updated. You can only specify <code>description</code> in this mode.</p>
    /// </dd>
    /// <dt></dt>
    /// <dd>
    /// <p> <code>CURRENT_VERSION</code> </p>
    /// <p>In this mode, the component is deployed and updated with the new <code>serviceSpec</code>, <code>templateSource</code>, and/or <code>type</code> that you provide. Only requested parameters are updated.</p>
    /// </dd>
    /// </dl>
    #[doc(hidden)]
    pub deployment_type: std::option::Option<crate::types::ComponentDeploymentUpdateType>,
    /// <p>An optional customer-provided description of the component.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The name of the service that <code>serviceInstanceName</code> is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    #[doc(hidden)]
    pub service_name: std::option::Option<std::string::String>,
    /// <p>The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    #[doc(hidden)]
    pub service_instance_name: std::option::Option<std::string::String>,
    /// <p>The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.</p>
    #[doc(hidden)]
    pub service_spec: std::option::Option<std::string::String>,
    /// <p>A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.</p> <note>
    /// <p>Components support a single IaC file, even if you use Terraform as your template language.</p>
    /// </note>
    #[doc(hidden)]
    pub template_file: std::option::Option<std::string::String>,
}
impl UpdateComponentInput {
    /// <p>The name of the component to update.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The deployment type. It defines the mode for updating a component, as follows:</p>
    /// <dl>
    /// <dt></dt>
    /// <dd>
    /// <p> <code>NONE</code> </p>
    /// <p>In this mode, a deployment <i>doesn't</i> occur. Only the requested metadata parameters are updated. You can only specify <code>description</code> in this mode.</p>
    /// </dd>
    /// <dt></dt>
    /// <dd>
    /// <p> <code>CURRENT_VERSION</code> </p>
    /// <p>In this mode, the component is deployed and updated with the new <code>serviceSpec</code>, <code>templateSource</code>, and/or <code>type</code> that you provide. Only requested parameters are updated.</p>
    /// </dd>
    /// </dl>
    pub fn deployment_type(
        &self,
    ) -> std::option::Option<&crate::types::ComponentDeploymentUpdateType> {
        self.deployment_type.as_ref()
    }
    /// <p>An optional customer-provided description of the component.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name of the service that <code>serviceInstanceName</code> is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn service_name(&self) -> std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn service_instance_name(&self) -> std::option::Option<&str> {
        self.service_instance_name.as_deref()
    }
    /// <p>The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.</p>
    pub fn service_spec(&self) -> std::option::Option<&str> {
        self.service_spec.as_deref()
    }
    /// <p>A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.</p> <note>
    /// <p>Components support a single IaC file, even if you use Terraform as your template language.</p>
    /// </note>
    pub fn template_file(&self) -> std::option::Option<&str> {
        self.template_file.as_deref()
    }
}
impl std::fmt::Debug for UpdateComponentInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateComponentInput");
        formatter.field("name", &self.name);
        formatter.field("deployment_type", &self.deployment_type);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("service_name", &self.service_name);
        formatter.field("service_instance_name", &self.service_instance_name);
        formatter.field("service_spec", &"*** Sensitive Data Redacted ***");
        formatter.field("template_file", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl UpdateComponentInput {
    /// Creates a new builder-style object to manufacture [`UpdateComponentInput`](crate::operation::update_component::UpdateComponentInput).
    pub fn builder() -> crate::operation::update_component::builders::UpdateComponentInputBuilder {
        crate::operation::update_component::builders::UpdateComponentInputBuilder::default()
    }
}

/// A builder for [`UpdateComponentInput`](crate::operation::update_component::UpdateComponentInput).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default)]
pub struct UpdateComponentInputBuilder {
    pub(crate) name: std::option::Option<std::string::String>,
    pub(crate) deployment_type: std::option::Option<crate::types::ComponentDeploymentUpdateType>,
    pub(crate) description: std::option::Option<std::string::String>,
    pub(crate) service_name: std::option::Option<std::string::String>,
    pub(crate) service_instance_name: std::option::Option<std::string::String>,
    pub(crate) service_spec: std::option::Option<std::string::String>,
    pub(crate) template_file: std::option::Option<std::string::String>,
}
impl UpdateComponentInputBuilder {
    /// <p>The name of the component to update.</p>
    pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
        self.name = Some(input.into());
        self
    }
    /// <p>The name of the component to update.</p>
    pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The deployment type. It defines the mode for updating a component, as follows:</p>
    /// <dl>
    /// <dt></dt>
    /// <dd>
    /// <p> <code>NONE</code> </p>
    /// <p>In this mode, a deployment <i>doesn't</i> occur. Only the requested metadata parameters are updated. You can only specify <code>description</code> in this mode.</p>
    /// </dd>
    /// <dt></dt>
    /// <dd>
    /// <p> <code>CURRENT_VERSION</code> </p>
    /// <p>In this mode, the component is deployed and updated with the new <code>serviceSpec</code>, <code>templateSource</code>, and/or <code>type</code> that you provide. Only requested parameters are updated.</p>
    /// </dd>
    /// </dl>
    pub fn deployment_type(mut self, input: crate::types::ComponentDeploymentUpdateType) -> Self {
        self.deployment_type = Some(input);
        self
    }
    /// <p>The deployment type. It defines the mode for updating a component, as follows:</p>
    /// <dl>
    /// <dt></dt>
    /// <dd>
    /// <p> <code>NONE</code> </p>
    /// <p>In this mode, a deployment <i>doesn't</i> occur. Only the requested metadata parameters are updated. You can only specify <code>description</code> in this mode.</p>
    /// </dd>
    /// <dt></dt>
    /// <dd>
    /// <p> <code>CURRENT_VERSION</code> </p>
    /// <p>In this mode, the component is deployed and updated with the new <code>serviceSpec</code>, <code>templateSource</code>, and/or <code>type</code> that you provide. Only requested parameters are updated.</p>
    /// </dd>
    /// </dl>
    pub fn set_deployment_type(
        mut self,
        input: std::option::Option<crate::types::ComponentDeploymentUpdateType>,
    ) -> Self {
        self.deployment_type = input;
        self
    }
    /// <p>An optional customer-provided description of the component.</p>
    pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
        self.description = Some(input.into());
        self
    }
    /// <p>An optional customer-provided description of the component.</p>
    pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>The name of the service that <code>serviceInstanceName</code> is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn service_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.service_name = Some(input.into());
        self
    }
    /// <p>The name of the service that <code>serviceInstanceName</code> is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn set_service_name(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.service_name = input;
        self
    }
    /// <p>The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn service_instance_name(mut self, input: impl Into<std::string::String>) -> Self {
        self.service_instance_name = Some(input.into());
        self
    }
    /// <p>The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn set_service_instance_name(
        mut self,
        input: std::option::Option<std::string::String>,
    ) -> Self {
        self.service_instance_name = input;
        self
    }
    /// <p>The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.</p>
    pub fn service_spec(mut self, input: impl Into<std::string::String>) -> Self {
        self.service_spec = Some(input.into());
        self
    }
    /// <p>The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.</p>
    pub fn set_service_spec(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.service_spec = input;
        self
    }
    /// <p>A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.</p> <note>
    /// <p>Components support a single IaC file, even if you use Terraform as your template language.</p>
    /// </note>
    pub fn template_file(mut self, input: impl Into<std::string::String>) -> Self {
        self.template_file = Some(input.into());
        self
    }
    /// <p>A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.</p> <note>
    /// <p>Components support a single IaC file, even if you use Terraform as your template language.</p>
    /// </note>
    pub fn set_template_file(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.template_file = input;
        self
    }
    /// Consumes the builder and constructs a [`UpdateComponentInput`](crate::operation::update_component::UpdateComponentInput).
    pub fn build(
        self,
    ) -> Result<
        crate::operation::update_component::UpdateComponentInput,
        aws_smithy_http::operation::error::BuildError,
    > {
        Ok(crate::operation::update_component::UpdateComponentInput {
            name: self.name,
            deployment_type: self.deployment_type,
            description: self.description,
            service_name: self.service_name,
            service_instance_name: self.service_instance_name,
            service_spec: self.service_spec,
            template_file: self.template_file,
        })
    }
}
impl std::fmt::Debug for UpdateComponentInputBuilder {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateComponentInputBuilder");
        formatter.field("name", &self.name);
        formatter.field("deployment_type", &self.deployment_type);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("service_name", &self.service_name);
        formatter.field("service_instance_name", &self.service_instance_name);
        formatter.field("service_spec", &"*** Sensitive Data Redacted ***");
        formatter.field("template_file", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
