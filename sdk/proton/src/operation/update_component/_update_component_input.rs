// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct UpdateComponentInput {
    /// <p>The name of the component to update.</p>
    pub name: ::std::option::Option<::std::string::String>,
    /// <p>The deployment type. It defines the mode for updating a component, as follows:</p>
    /// <dl>
    /// <dt></dt>
    /// <dd>
    /// <p><code>NONE</code></p>
    /// <p>In this mode, a deployment <i>doesn't</i> occur. Only the requested metadata parameters are updated. You can only specify <code>description</code> in this mode.</p>
    /// </dd>
    /// <dt></dt>
    /// <dd>
    /// <p><code>CURRENT_VERSION</code></p>
    /// <p>In this mode, the component is deployed and updated with the new <code>serviceSpec</code>, <code>templateSource</code>, and/or <code>type</code> that you provide. Only requested parameters are updated.</p>
    /// </dd>
    /// </dl>
    pub deployment_type: ::std::option::Option<crate::types::ComponentDeploymentUpdateType>,
    /// <p>An optional customer-provided description of the component.</p>
    pub description: ::std::option::Option<::std::string::String>,
    /// <p>The name of the service that <code>serviceInstanceName</code> is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub service_name: ::std::option::Option<::std::string::String>,
    /// <p>The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub service_instance_name: ::std::option::Option<::std::string::String>,
    /// <p>The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.</p>
    pub service_spec: ::std::option::Option<::std::string::String>,
    /// <p>A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.</p><note>
    /// <p>Components support a single IaC file, even if you use Terraform as your template language.</p>
    /// </note>
    pub template_file: ::std::option::Option<::std::string::String>,
    /// <p>The client token for the updated component.</p>
    pub client_token: ::std::option::Option<::std::string::String>,
}
impl UpdateComponentInput {
    /// <p>The name of the component to update.</p>
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The deployment type. It defines the mode for updating a component, as follows:</p>
    /// <dl>
    /// <dt></dt>
    /// <dd>
    /// <p><code>NONE</code></p>
    /// <p>In this mode, a deployment <i>doesn't</i> occur. Only the requested metadata parameters are updated. You can only specify <code>description</code> in this mode.</p>
    /// </dd>
    /// <dt></dt>
    /// <dd>
    /// <p><code>CURRENT_VERSION</code></p>
    /// <p>In this mode, the component is deployed and updated with the new <code>serviceSpec</code>, <code>templateSource</code>, and/or <code>type</code> that you provide. Only requested parameters are updated.</p>
    /// </dd>
    /// </dl>
    pub fn deployment_type(&self) -> ::std::option::Option<&crate::types::ComponentDeploymentUpdateType> {
        self.deployment_type.as_ref()
    }
    /// <p>An optional customer-provided description of the component.</p>
    pub fn description(&self) -> ::std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The name of the service that <code>serviceInstanceName</code> is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn service_name(&self) -> ::std::option::Option<&str> {
        self.service_name.as_deref()
    }
    /// <p>The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn service_instance_name(&self) -> ::std::option::Option<&str> {
        self.service_instance_name.as_deref()
    }
    /// <p>The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.</p>
    pub fn service_spec(&self) -> ::std::option::Option<&str> {
        self.service_spec.as_deref()
    }
    /// <p>A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.</p><note>
    /// <p>Components support a single IaC file, even if you use Terraform as your template language.</p>
    /// </note>
    pub fn template_file(&self) -> ::std::option::Option<&str> {
        self.template_file.as_deref()
    }
    /// <p>The client token for the updated component.</p>
    pub fn client_token(&self) -> ::std::option::Option<&str> {
        self.client_token.as_deref()
    }
}
impl ::std::fmt::Debug for UpdateComponentInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateComponentInput");
        formatter.field("name", &self.name);
        formatter.field("deployment_type", &self.deployment_type);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("service_name", &self.service_name);
        formatter.field("service_instance_name", &self.service_instance_name);
        formatter.field("service_spec", &"*** Sensitive Data Redacted ***");
        formatter.field("template_file", &"*** Sensitive Data Redacted ***");
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}
impl UpdateComponentInput {
    /// Creates a new builder-style object to manufacture [`UpdateComponentInput`](crate::operation::update_component::UpdateComponentInput).
    pub fn builder() -> crate::operation::update_component::builders::UpdateComponentInputBuilder {
        crate::operation::update_component::builders::UpdateComponentInputBuilder::default()
    }
}

/// A builder for [`UpdateComponentInput`](crate::operation::update_component::UpdateComponentInput).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
pub struct UpdateComponentInputBuilder {
    pub(crate) name: ::std::option::Option<::std::string::String>,
    pub(crate) deployment_type: ::std::option::Option<crate::types::ComponentDeploymentUpdateType>,
    pub(crate) description: ::std::option::Option<::std::string::String>,
    pub(crate) service_name: ::std::option::Option<::std::string::String>,
    pub(crate) service_instance_name: ::std::option::Option<::std::string::String>,
    pub(crate) service_spec: ::std::option::Option<::std::string::String>,
    pub(crate) template_file: ::std::option::Option<::std::string::String>,
    pub(crate) client_token: ::std::option::Option<::std::string::String>,
}
impl UpdateComponentInputBuilder {
    /// <p>The name of the component to update.</p>
    /// This field is required.
    pub fn name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the component to update.</p>
    pub fn set_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.name = input;
        self
    }
    /// <p>The name of the component to update.</p>
    pub fn get_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.name
    }
    /// <p>The deployment type. It defines the mode for updating a component, as follows:</p>
    /// <dl>
    /// <dt></dt>
    /// <dd>
    /// <p><code>NONE</code></p>
    /// <p>In this mode, a deployment <i>doesn't</i> occur. Only the requested metadata parameters are updated. You can only specify <code>description</code> in this mode.</p>
    /// </dd>
    /// <dt></dt>
    /// <dd>
    /// <p><code>CURRENT_VERSION</code></p>
    /// <p>In this mode, the component is deployed and updated with the new <code>serviceSpec</code>, <code>templateSource</code>, and/or <code>type</code> that you provide. Only requested parameters are updated.</p>
    /// </dd>
    /// </dl>
    /// This field is required.
    pub fn deployment_type(mut self, input: crate::types::ComponentDeploymentUpdateType) -> Self {
        self.deployment_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>The deployment type. It defines the mode for updating a component, as follows:</p>
    /// <dl>
    /// <dt></dt>
    /// <dd>
    /// <p><code>NONE</code></p>
    /// <p>In this mode, a deployment <i>doesn't</i> occur. Only the requested metadata parameters are updated. You can only specify <code>description</code> in this mode.</p>
    /// </dd>
    /// <dt></dt>
    /// <dd>
    /// <p><code>CURRENT_VERSION</code></p>
    /// <p>In this mode, the component is deployed and updated with the new <code>serviceSpec</code>, <code>templateSource</code>, and/or <code>type</code> that you provide. Only requested parameters are updated.</p>
    /// </dd>
    /// </dl>
    pub fn set_deployment_type(mut self, input: ::std::option::Option<crate::types::ComponentDeploymentUpdateType>) -> Self {
        self.deployment_type = input;
        self
    }
    /// <p>The deployment type. It defines the mode for updating a component, as follows:</p>
    /// <dl>
    /// <dt></dt>
    /// <dd>
    /// <p><code>NONE</code></p>
    /// <p>In this mode, a deployment <i>doesn't</i> occur. Only the requested metadata parameters are updated. You can only specify <code>description</code> in this mode.</p>
    /// </dd>
    /// <dt></dt>
    /// <dd>
    /// <p><code>CURRENT_VERSION</code></p>
    /// <p>In this mode, the component is deployed and updated with the new <code>serviceSpec</code>, <code>templateSource</code>, and/or <code>type</code> that you provide. Only requested parameters are updated.</p>
    /// </dd>
    /// </dl>
    pub fn get_deployment_type(&self) -> &::std::option::Option<crate::types::ComponentDeploymentUpdateType> {
        &self.deployment_type
    }
    /// <p>An optional customer-provided description of the component.</p>
    pub fn description(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.description = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>An optional customer-provided description of the component.</p>
    pub fn set_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.description = input;
        self
    }
    /// <p>An optional customer-provided description of the component.</p>
    pub fn get_description(&self) -> &::std::option::Option<::std::string::String> {
        &self.description
    }
    /// <p>The name of the service that <code>serviceInstanceName</code> is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn service_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the service that <code>serviceInstanceName</code> is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn set_service_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_name = input;
        self
    }
    /// <p>The name of the service that <code>serviceInstanceName</code> is associated with. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn get_service_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_name
    }
    /// <p>The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn service_instance_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_instance_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn set_service_instance_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_instance_name = input;
        self
    }
    /// <p>The name of the service instance that you want to attach this component to. Don't specify to keep the component's current service instance attachment. Specify an empty string to detach the component from the service instance it's attached to. Specify non-empty values for both <code>serviceInstanceName</code> and <code>serviceName</code> or for neither of them.</p>
    pub fn get_service_instance_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_instance_name
    }
    /// <p>The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.</p>
    pub fn service_spec(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.service_spec = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.</p>
    pub fn set_service_spec(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.service_spec = input;
        self
    }
    /// <p>The service spec that you want the component to use to access service inputs. Set this only when the component is attached to a service instance.</p>
    pub fn get_service_spec(&self) -> &::std::option::Option<::std::string::String> {
        &self.service_spec
    }
    /// <p>A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.</p><note>
    /// <p>Components support a single IaC file, even if you use Terraform as your template language.</p>
    /// </note>
    pub fn template_file(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.template_file = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.</p><note>
    /// <p>Components support a single IaC file, even if you use Terraform as your template language.</p>
    /// </note>
    pub fn set_template_file(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.template_file = input;
        self
    }
    /// <p>A path to the Infrastructure as Code (IaC) file describing infrastructure that a custom component provisions.</p><note>
    /// <p>Components support a single IaC file, even if you use Terraform as your template language.</p>
    /// </note>
    pub fn get_template_file(&self) -> &::std::option::Option<::std::string::String> {
        &self.template_file
    }
    /// <p>The client token for the updated component.</p>
    pub fn client_token(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.client_token = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The client token for the updated component.</p>
    pub fn set_client_token(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.client_token = input;
        self
    }
    /// <p>The client token for the updated component.</p>
    pub fn get_client_token(&self) -> &::std::option::Option<::std::string::String> {
        &self.client_token
    }
    /// Consumes the builder and constructs a [`UpdateComponentInput`](crate::operation::update_component::UpdateComponentInput).
    pub fn build(
        self,
    ) -> ::std::result::Result<crate::operation::update_component::UpdateComponentInput, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::operation::update_component::UpdateComponentInput {
            name: self.name,
            deployment_type: self.deployment_type,
            description: self.description,
            service_name: self.service_name,
            service_instance_name: self.service_instance_name,
            service_spec: self.service_spec,
            template_file: self.template_file,
            client_token: self.client_token,
        })
    }
}
impl ::std::fmt::Debug for UpdateComponentInputBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateComponentInputBuilder");
        formatter.field("name", &self.name);
        formatter.field("deployment_type", &self.deployment_type);
        formatter.field("description", &"*** Sensitive Data Redacted ***");
        formatter.field("service_name", &self.service_name);
        formatter.field("service_instance_name", &self.service_instance_name);
        formatter.field("service_spec", &"*** Sensitive Data Redacted ***");
        formatter.field("template_file", &"*** Sensitive Data Redacted ***");
        formatter.field("client_token", &self.client_token);
        formatter.finish()
    }
}
