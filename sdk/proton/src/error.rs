// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AcceptEnvironmentAccountConnectionError {
    pub kind: AcceptEnvironmentAccountConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AcceptEnvironmentAccountConnectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AcceptEnvironmentAccountConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AcceptEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            AcceptEnvironmentAccountConnectionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            AcceptEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            AcceptEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            AcceptEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            AcceptEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            AcceptEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AcceptEnvironmentAccountConnectionError {
    fn code(&self) -> Option<&str> {
        AcceptEnvironmentAccountConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            AcceptEnvironmentAccountConnectionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            AcceptEnvironmentAccountConnectionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl AcceptEnvironmentAccountConnectionError {
    pub fn new(
        kind: AcceptEnvironmentAccountConnectionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AcceptEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AcceptEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptEnvironmentAccountConnectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptEnvironmentAccountConnectionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptEnvironmentAccountConnectionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptEnvironmentAccountConnectionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            AcceptEnvironmentAccountConnectionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for AcceptEnvironmentAccountConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AcceptEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            AcceptEnvironmentAccountConnectionErrorKind::ConflictException(_inner) => Some(_inner),
            AcceptEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            AcceptEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            AcceptEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            AcceptEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            AcceptEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelEnvironmentDeploymentError {
    pub kind: CancelEnvironmentDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelEnvironmentDeploymentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelEnvironmentDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelEnvironmentDeploymentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CancelEnvironmentDeploymentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CancelEnvironmentDeploymentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CancelEnvironmentDeploymentErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CancelEnvironmentDeploymentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelEnvironmentDeploymentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CancelEnvironmentDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelEnvironmentDeploymentError {
    fn code(&self) -> Option<&str> {
        CancelEnvironmentDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CancelEnvironmentDeploymentErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CancelEnvironmentDeploymentErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CancelEnvironmentDeploymentError {
    pub fn new(kind: CancelEnvironmentDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelEnvironmentDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelEnvironmentDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelEnvironmentDeploymentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelEnvironmentDeploymentErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelEnvironmentDeploymentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelEnvironmentDeploymentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelEnvironmentDeploymentErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelEnvironmentDeploymentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CancelEnvironmentDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelEnvironmentDeploymentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CancelEnvironmentDeploymentErrorKind::ConflictException(_inner) => Some(_inner),
            CancelEnvironmentDeploymentErrorKind::InternalServerException(_inner) => Some(_inner),
            CancelEnvironmentDeploymentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CancelEnvironmentDeploymentErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelEnvironmentDeploymentErrorKind::ValidationException(_inner) => Some(_inner),
            CancelEnvironmentDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelServiceInstanceDeploymentError {
    pub kind: CancelServiceInstanceDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelServiceInstanceDeploymentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelServiceInstanceDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelServiceInstanceDeploymentErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CancelServiceInstanceDeploymentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CancelServiceInstanceDeploymentErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            CancelServiceInstanceDeploymentErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CancelServiceInstanceDeploymentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelServiceInstanceDeploymentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CancelServiceInstanceDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelServiceInstanceDeploymentError {
    fn code(&self) -> Option<&str> {
        CancelServiceInstanceDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CancelServiceInstanceDeploymentErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CancelServiceInstanceDeploymentErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CancelServiceInstanceDeploymentError {
    pub fn new(kind: CancelServiceInstanceDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelServiceInstanceDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelServiceInstanceDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServiceInstanceDeploymentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServiceInstanceDeploymentErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServiceInstanceDeploymentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServiceInstanceDeploymentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServiceInstanceDeploymentErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServiceInstanceDeploymentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CancelServiceInstanceDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelServiceInstanceDeploymentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CancelServiceInstanceDeploymentErrorKind::ConflictException(_inner) => Some(_inner),
            CancelServiceInstanceDeploymentErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            CancelServiceInstanceDeploymentErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CancelServiceInstanceDeploymentErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelServiceInstanceDeploymentErrorKind::ValidationException(_inner) => Some(_inner),
            CancelServiceInstanceDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelServicePipelineDeploymentError {
    pub kind: CancelServicePipelineDeploymentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelServicePipelineDeploymentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelServicePipelineDeploymentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelServicePipelineDeploymentErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CancelServicePipelineDeploymentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CancelServicePipelineDeploymentErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            CancelServicePipelineDeploymentErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CancelServicePipelineDeploymentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CancelServicePipelineDeploymentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CancelServicePipelineDeploymentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelServicePipelineDeploymentError {
    fn code(&self) -> Option<&str> {
        CancelServicePipelineDeploymentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CancelServicePipelineDeploymentErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CancelServicePipelineDeploymentErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CancelServicePipelineDeploymentError {
    pub fn new(kind: CancelServicePipelineDeploymentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelServicePipelineDeploymentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelServicePipelineDeploymentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServicePipelineDeploymentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServicePipelineDeploymentErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServicePipelineDeploymentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServicePipelineDeploymentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServicePipelineDeploymentErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CancelServicePipelineDeploymentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CancelServicePipelineDeploymentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelServicePipelineDeploymentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CancelServicePipelineDeploymentErrorKind::ConflictException(_inner) => Some(_inner),
            CancelServicePipelineDeploymentErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            CancelServicePipelineDeploymentErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CancelServicePipelineDeploymentErrorKind::ThrottlingException(_inner) => Some(_inner),
            CancelServicePipelineDeploymentErrorKind::ValidationException(_inner) => Some(_inner),
            CancelServicePipelineDeploymentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEnvironmentError {
    pub kind: CreateEnvironmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEnvironmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEnvironmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEnvironmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateEnvironmentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateEnvironmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateEnvironmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateEnvironmentErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateEnvironmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateEnvironmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateEnvironmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEnvironmentError {
    fn code(&self) -> Option<&str> {
        CreateEnvironmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateEnvironmentErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateEnvironmentErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateEnvironmentError {
    pub fn new(kind: CreateEnvironmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEnvironmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEnvironmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateEnvironmentErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateEnvironmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEnvironmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateEnvironmentErrorKind::ConflictException(_inner) => Some(_inner),
            CreateEnvironmentErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateEnvironmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateEnvironmentErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateEnvironmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateEnvironmentErrorKind::ValidationException(_inner) => Some(_inner),
            CreateEnvironmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEnvironmentAccountConnectionError {
    pub kind: CreateEnvironmentAccountConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEnvironmentAccountConnectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEnvironmentAccountConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateEnvironmentAccountConnectionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            CreateEnvironmentAccountConnectionErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            CreateEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            CreateEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEnvironmentAccountConnectionError {
    fn code(&self) -> Option<&str> {
        CreateEnvironmentAccountConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateEnvironmentAccountConnectionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateEnvironmentAccountConnectionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateEnvironmentAccountConnectionError {
    pub fn new(
        kind: CreateEnvironmentAccountConnectionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentAccountConnectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentAccountConnectionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentAccountConnectionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentAccountConnectionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentAccountConnectionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentAccountConnectionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateEnvironmentAccountConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreateEnvironmentAccountConnectionErrorKind::ConflictException(_inner) => Some(_inner),
            CreateEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            CreateEnvironmentAccountConnectionErrorKind::ServiceQuotaExceededException(_inner) => {
                Some(_inner)
            }
            CreateEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            CreateEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            CreateEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEnvironmentTemplateError {
    pub kind: CreateEnvironmentTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEnvironmentTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEnvironmentTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEnvironmentTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateEnvironmentTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateEnvironmentTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateEnvironmentTemplateErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateEnvironmentTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateEnvironmentTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateEnvironmentTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEnvironmentTemplateError {
    fn code(&self) -> Option<&str> {
        CreateEnvironmentTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateEnvironmentTemplateErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateEnvironmentTemplateErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateEnvironmentTemplateError {
    pub fn new(kind: CreateEnvironmentTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEnvironmentTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEnvironmentTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateEnvironmentTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEnvironmentTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateEnvironmentTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            CreateEnvironmentTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateEnvironmentTemplateErrorKind::ServiceQuotaExceededException(_inner) => {
                Some(_inner)
            }
            CreateEnvironmentTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateEnvironmentTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            CreateEnvironmentTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateEnvironmentTemplateVersionError {
    pub kind: CreateEnvironmentTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateEnvironmentTemplateVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateEnvironmentTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateEnvironmentTemplateVersionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreateEnvironmentTemplateVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateEnvironmentTemplateVersionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            CreateEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateEnvironmentTemplateVersionErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateEnvironmentTemplateVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateEnvironmentTemplateVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateEnvironmentTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateEnvironmentTemplateVersionError {
    fn code(&self) -> Option<&str> {
        CreateEnvironmentTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateEnvironmentTemplateVersionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateEnvironmentTemplateVersionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateEnvironmentTemplateVersionError {
    pub fn new(kind: CreateEnvironmentTemplateVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateEnvironmentTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateEnvironmentTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateVersionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateEnvironmentTemplateVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateEnvironmentTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateEnvironmentTemplateVersionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreateEnvironmentTemplateVersionErrorKind::ConflictException(_inner) => Some(_inner),
            CreateEnvironmentTemplateVersionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            CreateEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateEnvironmentTemplateVersionErrorKind::ServiceQuotaExceededException(_inner) => {
                Some(_inner)
            }
            CreateEnvironmentTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateEnvironmentTemplateVersionErrorKind::ValidationException(_inner) => Some(_inner),
            CreateEnvironmentTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateServiceError {
    pub kind: CreateServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateServiceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateServiceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateServiceError {
    fn code(&self) -> Option<&str> {
        CreateServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateServiceErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateServiceErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateServiceError {
    pub fn new(kind: CreateServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, CreateServiceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for CreateServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateServiceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateServiceErrorKind::ConflictException(_inner) => Some(_inner),
            CreateServiceErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateServiceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            CreateServiceErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateServiceErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateServiceErrorKind::ValidationException(_inner) => Some(_inner),
            CreateServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateServiceTemplateError {
    pub kind: CreateServiceTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateServiceTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateServiceTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateServiceTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateServiceTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateServiceTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateServiceTemplateErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            CreateServiceTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateServiceTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateServiceTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateServiceTemplateError {
    fn code(&self) -> Option<&str> {
        CreateServiceTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateServiceTemplateErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateServiceTemplateErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateServiceTemplateError {
    pub fn new(kind: CreateServiceTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateServiceTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateServiceTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateServiceTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateServiceTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateServiceTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            CreateServiceTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateServiceTemplateErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            CreateServiceTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateServiceTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            CreateServiceTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateServiceTemplateVersionError {
    pub kind: CreateServiceTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateServiceTemplateVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateServiceTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateServiceTemplateVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateServiceTemplateVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            CreateServiceTemplateVersionErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            CreateServiceTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreateServiceTemplateVersionErrorKind::ServiceQuotaExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreateServiceTemplateVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            CreateServiceTemplateVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            CreateServiceTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateServiceTemplateVersionError {
    fn code(&self) -> Option<&str> {
        CreateServiceTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            CreateServiceTemplateVersionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            CreateServiceTemplateVersionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl CreateServiceTemplateVersionError {
    pub fn new(kind: CreateServiceTemplateVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateServiceTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateServiceTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateVersionErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateServiceTemplateVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for CreateServiceTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateServiceTemplateVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            CreateServiceTemplateVersionErrorKind::ConflictException(_inner) => Some(_inner),
            CreateServiceTemplateVersionErrorKind::InternalServerException(_inner) => Some(_inner),
            CreateServiceTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            CreateServiceTemplateVersionErrorKind::ServiceQuotaExceededException(_inner) => {
                Some(_inner)
            }
            CreateServiceTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            CreateServiceTemplateVersionErrorKind::ValidationException(_inner) => Some(_inner),
            CreateServiceTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEnvironmentError {
    pub kind: DeleteEnvironmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEnvironmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEnvironmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEnvironmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteEnvironmentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteEnvironmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteEnvironmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteEnvironmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteEnvironmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteEnvironmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEnvironmentError {
    fn code(&self) -> Option<&str> {
        DeleteEnvironmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteEnvironmentErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteEnvironmentErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteEnvironmentError {
    pub fn new(kind: DeleteEnvironmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEnvironmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEnvironmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteEnvironmentErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteEnvironmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEnvironmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteEnvironmentErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteEnvironmentErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteEnvironmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteEnvironmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteEnvironmentErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteEnvironmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEnvironmentAccountConnectionError {
    pub kind: DeleteEnvironmentAccountConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEnvironmentAccountConnectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEnvironmentAccountConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEnvironmentAccountConnectionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEnvironmentAccountConnectionError {
    fn code(&self) -> Option<&str> {
        DeleteEnvironmentAccountConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteEnvironmentAccountConnectionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteEnvironmentAccountConnectionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteEnvironmentAccountConnectionError {
    pub fn new(
        kind: DeleteEnvironmentAccountConnectionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentAccountConnectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentAccountConnectionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentAccountConnectionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentAccountConnectionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentAccountConnectionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteEnvironmentAccountConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DeleteEnvironmentAccountConnectionErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            DeleteEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            DeleteEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            DeleteEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEnvironmentTemplateError {
    pub kind: DeleteEnvironmentTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEnvironmentTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEnvironmentTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEnvironmentTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteEnvironmentTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteEnvironmentTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteEnvironmentTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteEnvironmentTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteEnvironmentTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteEnvironmentTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEnvironmentTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteEnvironmentTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteEnvironmentTemplateErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteEnvironmentTemplateErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteEnvironmentTemplateError {
    pub fn new(kind: DeleteEnvironmentTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEnvironmentTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEnvironmentTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteEnvironmentTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEnvironmentTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteEnvironmentTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteEnvironmentTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteEnvironmentTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteEnvironmentTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteEnvironmentTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteEnvironmentTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteEnvironmentTemplateVersionError {
    pub kind: DeleteEnvironmentTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteEnvironmentTemplateVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteEnvironmentTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteEnvironmentTemplateVersionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEnvironmentTemplateVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteEnvironmentTemplateVersionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteEnvironmentTemplateVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteEnvironmentTemplateVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteEnvironmentTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteEnvironmentTemplateVersionError {
    fn code(&self) -> Option<&str> {
        DeleteEnvironmentTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteEnvironmentTemplateVersionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteEnvironmentTemplateVersionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteEnvironmentTemplateVersionError {
    pub fn new(kind: DeleteEnvironmentTemplateVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteEnvironmentTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteEnvironmentTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteEnvironmentTemplateVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteEnvironmentTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteEnvironmentTemplateVersionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            DeleteEnvironmentTemplateVersionErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteEnvironmentTemplateVersionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            DeleteEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteEnvironmentTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteEnvironmentTemplateVersionErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteEnvironmentTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServiceError {
    pub kind: DeleteServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServiceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServiceError {
    fn code(&self) -> Option<&str> {
        DeleteServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteServiceErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteServiceErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteServiceError {
    pub fn new(kind: DeleteServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, DeleteServiceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for DeleteServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServiceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteServiceErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteServiceErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteServiceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteServiceErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteServiceErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServiceTemplateError {
    pub kind: DeleteServiceTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServiceTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServiceTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServiceTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteServiceTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteServiceTemplateErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteServiceTemplateErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteServiceTemplateError {
    pub fn new(kind: DeleteServiceTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServiceTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServiceTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteServiceTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServiceTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteServiceTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteServiceTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteServiceTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            DeleteServiceTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteServiceTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteServiceTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteServiceTemplateVersionError {
    pub kind: DeleteServiceTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteServiceTemplateVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteServiceTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteServiceTemplateVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateVersionErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DeleteServiceTemplateVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            DeleteServiceTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteServiceTemplateVersionError {
    fn code(&self) -> Option<&str> {
        DeleteServiceTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            DeleteServiceTemplateVersionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            DeleteServiceTemplateVersionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl DeleteServiceTemplateVersionError {
    pub fn new(kind: DeleteServiceTemplateVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteServiceTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteServiceTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteServiceTemplateVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for DeleteServiceTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteServiceTemplateVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            DeleteServiceTemplateVersionErrorKind::ConflictException(_inner) => Some(_inner),
            DeleteServiceTemplateVersionErrorKind::InternalServerException(_inner) => Some(_inner),
            DeleteServiceTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            DeleteServiceTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            DeleteServiceTemplateVersionErrorKind::ValidationException(_inner) => Some(_inner),
            DeleteServiceTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetAccountSettingsError {
    pub kind: GetAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetAccountSettingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetAccountSettingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetAccountSettingsError {
    fn code(&self) -> Option<&str> {
        GetAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetAccountSettingsErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            GetAccountSettingsErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl GetAccountSettingsError {
    pub fn new(kind: GetAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetAccountSettingsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetAccountSettingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::InternalServerException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::ValidationException(_inner) => Some(_inner),
            GetAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEnvironmentError {
    pub kind: GetEnvironmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEnvironmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEnvironmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEnvironmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetEnvironmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetEnvironmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetEnvironmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetEnvironmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetEnvironmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEnvironmentError {
    fn code(&self) -> Option<&str> {
        GetEnvironmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetEnvironmentErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            GetEnvironmentErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl GetEnvironmentError {
    pub fn new(kind: GetEnvironmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEnvironmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEnvironmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetEnvironmentErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetEnvironmentErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetEnvironmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEnvironmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetEnvironmentErrorKind::InternalServerException(_inner) => Some(_inner),
            GetEnvironmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetEnvironmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetEnvironmentErrorKind::ValidationException(_inner) => Some(_inner),
            GetEnvironmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEnvironmentAccountConnectionError {
    pub kind: GetEnvironmentAccountConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEnvironmentAccountConnectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEnvironmentAccountConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            GetEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEnvironmentAccountConnectionError {
    fn code(&self) -> Option<&str> {
        GetEnvironmentAccountConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetEnvironmentAccountConnectionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            GetEnvironmentAccountConnectionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl GetEnvironmentAccountConnectionError {
    pub fn new(kind: GetEnvironmentAccountConnectionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentAccountConnectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentAccountConnectionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentAccountConnectionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentAccountConnectionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetEnvironmentAccountConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            GetEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => Some(_inner),
            GetEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEnvironmentTemplateError {
    pub kind: GetEnvironmentTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEnvironmentTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEnvironmentTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEnvironmentTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetEnvironmentTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetEnvironmentTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetEnvironmentTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetEnvironmentTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetEnvironmentTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEnvironmentTemplateError {
    fn code(&self) -> Option<&str> {
        GetEnvironmentTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetEnvironmentTemplateErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            GetEnvironmentTemplateErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl GetEnvironmentTemplateError {
    pub fn new(kind: GetEnvironmentTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEnvironmentTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEnvironmentTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetEnvironmentTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEnvironmentTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetEnvironmentTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            GetEnvironmentTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetEnvironmentTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetEnvironmentTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            GetEnvironmentTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetEnvironmentTemplateVersionError {
    pub kind: GetEnvironmentTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetEnvironmentTemplateVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetEnvironmentTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetEnvironmentTemplateVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetEnvironmentTemplateVersionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            GetEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetEnvironmentTemplateVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetEnvironmentTemplateVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetEnvironmentTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetEnvironmentTemplateVersionError {
    fn code(&self) -> Option<&str> {
        GetEnvironmentTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetEnvironmentTemplateVersionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            GetEnvironmentTemplateVersionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl GetEnvironmentTemplateVersionError {
    pub fn new(kind: GetEnvironmentTemplateVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetEnvironmentTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetEnvironmentTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentTemplateVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentTemplateVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetEnvironmentTemplateVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetEnvironmentTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetEnvironmentTemplateVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetEnvironmentTemplateVersionErrorKind::InternalServerException(_inner) => Some(_inner),
            GetEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            GetEnvironmentTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetEnvironmentTemplateVersionErrorKind::ValidationException(_inner) => Some(_inner),
            GetEnvironmentTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceError {
    pub kind: GetServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetServiceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetServiceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetServiceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetServiceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceError {
    fn code(&self) -> Option<&str> {
        GetServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetServiceErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            GetServiceErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None,
        }
    }
}
impl GetServiceError {
    pub fn new(kind: GetServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, GetServiceErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, GetServiceErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, GetServiceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, GetServiceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for GetServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetServiceErrorKind::InternalServerException(_inner) => Some(_inner),
            GetServiceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetServiceErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetServiceErrorKind::ValidationException(_inner) => Some(_inner),
            GetServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceInstanceError {
    pub kind: GetServiceInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceInstanceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceInstanceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetServiceInstanceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetServiceInstanceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetServiceInstanceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetServiceInstanceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetServiceInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceInstanceError {
    fn code(&self) -> Option<&str> {
        GetServiceInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetServiceInstanceErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            GetServiceInstanceErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl GetServiceInstanceError {
    pub fn new(kind: GetServiceInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceInstanceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceInstanceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceInstanceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceInstanceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceInstanceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetServiceInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceInstanceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetServiceInstanceErrorKind::InternalServerException(_inner) => Some(_inner),
            GetServiceInstanceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetServiceInstanceErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetServiceInstanceErrorKind::ValidationException(_inner) => Some(_inner),
            GetServiceInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceTemplateError {
    pub kind: GetServiceTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetServiceTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetServiceTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetServiceTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetServiceTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetServiceTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceTemplateError {
    fn code(&self) -> Option<&str> {
        GetServiceTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetServiceTemplateErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            GetServiceTemplateErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl GetServiceTemplateError {
    pub fn new(kind: GetServiceTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetServiceTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetServiceTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            GetServiceTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetServiceTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetServiceTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            GetServiceTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetServiceTemplateVersionError {
    pub kind: GetServiceTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetServiceTemplateVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetServiceTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetServiceTemplateVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            GetServiceTemplateVersionErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            GetServiceTemplateVersionErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetServiceTemplateVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            GetServiceTemplateVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            GetServiceTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetServiceTemplateVersionError {
    fn code(&self) -> Option<&str> {
        GetServiceTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            GetServiceTemplateVersionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            GetServiceTemplateVersionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl GetServiceTemplateVersionError {
    pub fn new(kind: GetServiceTemplateVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetServiceTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetServiceTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceTemplateVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceTemplateVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetServiceTemplateVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for GetServiceTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetServiceTemplateVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            GetServiceTemplateVersionErrorKind::InternalServerException(_inner) => Some(_inner),
            GetServiceTemplateVersionErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            GetServiceTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            GetServiceTemplateVersionErrorKind::ValidationException(_inner) => Some(_inner),
            GetServiceTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEnvironmentAccountConnectionsError {
    pub kind: ListEnvironmentAccountConnectionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEnvironmentAccountConnectionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEnvironmentAccountConnectionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEnvironmentAccountConnectionsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListEnvironmentAccountConnectionsErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            ListEnvironmentAccountConnectionsErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            ListEnvironmentAccountConnectionsErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            ListEnvironmentAccountConnectionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEnvironmentAccountConnectionsError {
    fn code(&self) -> Option<&str> {
        ListEnvironmentAccountConnectionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListEnvironmentAccountConnectionsErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListEnvironmentAccountConnectionsErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListEnvironmentAccountConnectionsError {
    pub fn new(
        kind: ListEnvironmentAccountConnectionsErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEnvironmentAccountConnectionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEnvironmentAccountConnectionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentAccountConnectionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentAccountConnectionsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentAccountConnectionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentAccountConnectionsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListEnvironmentAccountConnectionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEnvironmentAccountConnectionsErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            ListEnvironmentAccountConnectionsErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            ListEnvironmentAccountConnectionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListEnvironmentAccountConnectionsErrorKind::ValidationException(_inner) => Some(_inner),
            ListEnvironmentAccountConnectionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEnvironmentsError {
    pub kind: ListEnvironmentsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEnvironmentsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEnvironmentsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEnvironmentsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListEnvironmentsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListEnvironmentsErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListEnvironmentsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListEnvironmentsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListEnvironmentsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEnvironmentsError {
    fn code(&self) -> Option<&str> {
        ListEnvironmentsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListEnvironmentsErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListEnvironmentsErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListEnvironmentsError {
    pub fn new(kind: ListEnvironmentsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEnvironmentsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEnvironmentsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListEnvironmentsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEnvironmentsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListEnvironmentsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListEnvironmentsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListEnvironmentsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListEnvironmentsErrorKind::ValidationException(_inner) => Some(_inner),
            ListEnvironmentsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEnvironmentTemplatesError {
    pub kind: ListEnvironmentTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEnvironmentTemplatesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEnvironmentTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEnvironmentTemplatesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListEnvironmentTemplatesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListEnvironmentTemplatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListEnvironmentTemplatesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListEnvironmentTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEnvironmentTemplatesError {
    fn code(&self) -> Option<&str> {
        ListEnvironmentTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListEnvironmentTemplatesErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListEnvironmentTemplatesErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListEnvironmentTemplatesError {
    pub fn new(kind: ListEnvironmentTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEnvironmentTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEnvironmentTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentTemplatesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentTemplatesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentTemplatesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentTemplatesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListEnvironmentTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEnvironmentTemplatesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListEnvironmentTemplatesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListEnvironmentTemplatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListEnvironmentTemplatesErrorKind::ValidationException(_inner) => Some(_inner),
            ListEnvironmentTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListEnvironmentTemplateVersionsError {
    pub kind: ListEnvironmentTemplateVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListEnvironmentTemplateVersionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListEnvironmentTemplateVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListEnvironmentTemplateVersionsErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            ListEnvironmentTemplateVersionsErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            ListEnvironmentTemplateVersionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListEnvironmentTemplateVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListEnvironmentTemplateVersionsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListEnvironmentTemplateVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListEnvironmentTemplateVersionsError {
    fn code(&self) -> Option<&str> {
        ListEnvironmentTemplateVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListEnvironmentTemplateVersionsErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListEnvironmentTemplateVersionsErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListEnvironmentTemplateVersionsError {
    pub fn new(kind: ListEnvironmentTemplateVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListEnvironmentTemplateVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListEnvironmentTemplateVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentTemplateVersionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentTemplateVersionsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentTemplateVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentTemplateVersionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListEnvironmentTemplateVersionsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListEnvironmentTemplateVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListEnvironmentTemplateVersionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListEnvironmentTemplateVersionsErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            ListEnvironmentTemplateVersionsErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            ListEnvironmentTemplateVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListEnvironmentTemplateVersionsErrorKind::ValidationException(_inner) => Some(_inner),
            ListEnvironmentTemplateVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServiceInstancesError {
    pub kind: ListServiceInstancesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServiceInstancesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServiceInstancesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServiceInstancesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListServiceInstancesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListServiceInstancesErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListServiceInstancesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListServiceInstancesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListServiceInstancesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServiceInstancesError {
    fn code(&self) -> Option<&str> {
        ListServiceInstancesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListServiceInstancesErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListServiceInstancesErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListServiceInstancesError {
    pub fn new(kind: ListServiceInstancesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServiceInstancesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServiceInstancesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceInstancesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceInstancesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceInstancesErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceInstancesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceInstancesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListServiceInstancesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServiceInstancesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListServiceInstancesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListServiceInstancesErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListServiceInstancesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListServiceInstancesErrorKind::ValidationException(_inner) => Some(_inner),
            ListServiceInstancesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServicesError {
    pub kind: ListServicesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServicesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServicesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServicesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListServicesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListServicesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListServicesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListServicesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServicesError {
    fn code(&self) -> Option<&str> {
        ListServicesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListServicesErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListServicesErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None,
        }
    }
}
impl ListServicesError {
    pub fn new(kind: ListServicesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServicesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServicesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListServicesErrorKind::AccessDeniedException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServicesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, ListServicesErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, ListServicesErrorKind::ValidationException(_))
    }
}
impl std::error::Error for ListServicesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServicesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListServicesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListServicesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListServicesErrorKind::ValidationException(_inner) => Some(_inner),
            ListServicesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServiceTemplatesError {
    pub kind: ListServiceTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServiceTemplatesErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServiceTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServiceTemplatesErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListServiceTemplatesErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListServiceTemplatesErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListServiceTemplatesErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListServiceTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServiceTemplatesError {
    fn code(&self) -> Option<&str> {
        ListServiceTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListServiceTemplatesErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListServiceTemplatesErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListServiceTemplatesError {
    pub fn new(kind: ListServiceTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServiceTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServiceTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceTemplatesErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceTemplatesErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceTemplatesErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceTemplatesErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListServiceTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServiceTemplatesErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListServiceTemplatesErrorKind::InternalServerException(_inner) => Some(_inner),
            ListServiceTemplatesErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListServiceTemplatesErrorKind::ValidationException(_inner) => Some(_inner),
            ListServiceTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListServiceTemplateVersionsError {
    pub kind: ListServiceTemplateVersionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListServiceTemplateVersionsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListServiceTemplateVersionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListServiceTemplateVersionsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListServiceTemplateVersionsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListServiceTemplateVersionsErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            ListServiceTemplateVersionsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListServiceTemplateVersionsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListServiceTemplateVersionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListServiceTemplateVersionsError {
    fn code(&self) -> Option<&str> {
        ListServiceTemplateVersionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListServiceTemplateVersionsErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListServiceTemplateVersionsErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListServiceTemplateVersionsError {
    pub fn new(kind: ListServiceTemplateVersionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListServiceTemplateVersionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListServiceTemplateVersionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceTemplateVersionsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceTemplateVersionsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceTemplateVersionsErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceTemplateVersionsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListServiceTemplateVersionsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListServiceTemplateVersionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListServiceTemplateVersionsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListServiceTemplateVersionsErrorKind::InternalServerException(_inner) => Some(_inner),
            ListServiceTemplateVersionsErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListServiceTemplateVersionsErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListServiceTemplateVersionsErrorKind::ValidationException(_inner) => Some(_inner),
            ListServiceTemplateVersionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            ListTagsForResourceErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            ListTagsForResourceErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ValidationException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RejectEnvironmentAccountConnectionError {
    pub kind: RejectEnvironmentAccountConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RejectEnvironmentAccountConnectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RejectEnvironmentAccountConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RejectEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            RejectEnvironmentAccountConnectionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            RejectEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            RejectEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            RejectEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            RejectEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            RejectEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RejectEnvironmentAccountConnectionError {
    fn code(&self) -> Option<&str> {
        RejectEnvironmentAccountConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            RejectEnvironmentAccountConnectionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            RejectEnvironmentAccountConnectionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl RejectEnvironmentAccountConnectionError {
    pub fn new(
        kind: RejectEnvironmentAccountConnectionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RejectEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RejectEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectEnvironmentAccountConnectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectEnvironmentAccountConnectionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectEnvironmentAccountConnectionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectEnvironmentAccountConnectionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            RejectEnvironmentAccountConnectionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for RejectEnvironmentAccountConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RejectEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            RejectEnvironmentAccountConnectionErrorKind::ConflictException(_inner) => Some(_inner),
            RejectEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            RejectEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            RejectEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            RejectEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            RejectEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            TagResourceErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            TagResourceErrorKind::ThrottlingException(inner) => Some(inner.retryable_error_kind()),
            _ => None,
        }
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServerException(_))
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            TagResourceErrorKind::ConflictException(_inner) => Some(_inner),
            TagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            TagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            TagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UntagResourceErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UntagResourceErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UntagResourceErrorKind::ConflictException(_inner) => Some(_inner),
            UntagResourceErrorKind::InternalServerException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UntagResourceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UntagResourceErrorKind::ValidationException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateAccountSettingsError {
    pub kind: UpdateAccountSettingsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateAccountSettingsErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateAccountSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateAccountSettingsErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateAccountSettingsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateAccountSettingsError {
    fn code(&self) -> Option<&str> {
        UpdateAccountSettingsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateAccountSettingsErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateAccountSettingsErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateAccountSettingsError {
    pub fn new(kind: UpdateAccountSettingsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateAccountSettingsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateAccountSettingsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::InternalServerException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateAccountSettingsErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateAccountSettingsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateAccountSettingsErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateAccountSettingsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEnvironmentError {
    pub kind: UpdateEnvironmentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEnvironmentErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEnvironmentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEnvironmentErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateEnvironmentErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateEnvironmentErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateEnvironmentErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateEnvironmentErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateEnvironmentErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateEnvironmentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEnvironmentError {
    fn code(&self) -> Option<&str> {
        UpdateEnvironmentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateEnvironmentErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateEnvironmentErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateEnvironmentError {
    pub fn new(kind: UpdateEnvironmentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEnvironmentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEnvironmentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateEnvironmentErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateEnvironmentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEnvironmentErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateEnvironmentErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateEnvironmentErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateEnvironmentErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateEnvironmentErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateEnvironmentErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateEnvironmentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEnvironmentAccountConnectionError {
    pub kind: UpdateEnvironmentAccountConnectionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEnvironmentAccountConnectionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEnvironmentAccountConnectionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateEnvironmentAccountConnectionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            UpdateEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => {
                _inner.fmt(f)
            }
            UpdateEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => {
                _inner.fmt(f)
            }
            UpdateEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEnvironmentAccountConnectionError {
    fn code(&self) -> Option<&str> {
        UpdateEnvironmentAccountConnectionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateEnvironmentAccountConnectionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateEnvironmentAccountConnectionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateEnvironmentAccountConnectionError {
    pub fn new(
        kind: UpdateEnvironmentAccountConnectionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEnvironmentAccountConnectionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentAccountConnectionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentAccountConnectionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentAccountConnectionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentAccountConnectionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentAccountConnectionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateEnvironmentAccountConnectionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEnvironmentAccountConnectionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateEnvironmentAccountConnectionErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateEnvironmentAccountConnectionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            UpdateEnvironmentAccountConnectionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateEnvironmentAccountConnectionErrorKind::ThrottlingException(_inner) => {
                Some(_inner)
            }
            UpdateEnvironmentAccountConnectionErrorKind::ValidationException(_inner) => {
                Some(_inner)
            }
            UpdateEnvironmentAccountConnectionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEnvironmentTemplateError {
    pub kind: UpdateEnvironmentTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEnvironmentTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEnvironmentTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEnvironmentTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateEnvironmentTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateEnvironmentTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateEnvironmentTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateEnvironmentTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateEnvironmentTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateEnvironmentTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEnvironmentTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateEnvironmentTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateEnvironmentTemplateErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateEnvironmentTemplateErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateEnvironmentTemplateError {
    pub fn new(kind: UpdateEnvironmentTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEnvironmentTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEnvironmentTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateEnvironmentTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEnvironmentTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateEnvironmentTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateEnvironmentTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateEnvironmentTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateEnvironmentTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateEnvironmentTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateEnvironmentTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateEnvironmentTemplateVersionError {
    pub kind: UpdateEnvironmentTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateEnvironmentTemplateVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateEnvironmentTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateEnvironmentTemplateVersionErrorKind::AccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateEnvironmentTemplateVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateEnvironmentTemplateVersionErrorKind::InternalServerException(_inner) => {
                _inner.fmt(f)
            }
            UpdateEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateEnvironmentTemplateVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateEnvironmentTemplateVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateEnvironmentTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateEnvironmentTemplateVersionError {
    fn code(&self) -> Option<&str> {
        UpdateEnvironmentTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateEnvironmentTemplateVersionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateEnvironmentTemplateVersionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateEnvironmentTemplateVersionError {
    pub fn new(kind: UpdateEnvironmentTemplateVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateEnvironmentTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateEnvironmentTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateEnvironmentTemplateVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateEnvironmentTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateEnvironmentTemplateVersionErrorKind::AccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateEnvironmentTemplateVersionErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateEnvironmentTemplateVersionErrorKind::InternalServerException(_inner) => {
                Some(_inner)
            }
            UpdateEnvironmentTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateEnvironmentTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateEnvironmentTemplateVersionErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateEnvironmentTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServiceError {
    pub kind: UpdateServiceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServiceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ServiceQuotaExceededException(crate::error::ServiceQuotaExceededException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServiceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ServiceQuotaExceededException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateServiceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServiceError {
    fn code(&self) -> Option<&str> {
        UpdateServiceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateServiceErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateServiceErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateServiceError {
    pub fn new(kind: UpdateServiceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServiceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServiceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::AccessDeniedException(_))
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::ConflictException(_))
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_service_quota_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceErrorKind::ServiceQuotaExceededException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::ThrottlingException(_))
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self.kind, UpdateServiceErrorKind::ValidationException(_))
    }
}
impl std::error::Error for UpdateServiceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServiceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateServiceErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateServiceErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateServiceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateServiceErrorKind::ServiceQuotaExceededException(_inner) => Some(_inner),
            UpdateServiceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateServiceErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateServiceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServiceInstanceError {
    pub kind: UpdateServiceInstanceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServiceInstanceErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServiceInstanceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServiceInstanceErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateServiceInstanceErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateServiceInstanceErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateServiceInstanceErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateServiceInstanceErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateServiceInstanceErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateServiceInstanceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServiceInstanceError {
    fn code(&self) -> Option<&str> {
        UpdateServiceInstanceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateServiceInstanceErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateServiceInstanceErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateServiceInstanceError {
    pub fn new(kind: UpdateServiceInstanceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServiceInstanceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServiceInstanceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceInstanceErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceInstanceErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceInstanceErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceInstanceErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceInstanceErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceInstanceErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateServiceInstanceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServiceInstanceErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateServiceInstanceErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateServiceInstanceErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateServiceInstanceErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateServiceInstanceErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateServiceInstanceErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateServiceInstanceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServicePipelineError {
    pub kind: UpdateServicePipelineErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServicePipelineErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServicePipelineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServicePipelineErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateServicePipelineErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateServicePipelineErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateServicePipelineErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateServicePipelineErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateServicePipelineErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateServicePipelineErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServicePipelineError {
    fn code(&self) -> Option<&str> {
        UpdateServicePipelineError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateServicePipelineErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateServicePipelineErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateServicePipelineError {
    pub fn new(kind: UpdateServicePipelineErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServicePipelineErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServicePipelineErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePipelineErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePipelineErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePipelineErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePipelineErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePipelineErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServicePipelineErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateServicePipelineError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServicePipelineErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateServicePipelineErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateServicePipelineErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateServicePipelineErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateServicePipelineErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateServicePipelineErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateServicePipelineErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServiceTemplateError {
    pub kind: UpdateServiceTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServiceTemplateErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServiceTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServiceTemplateErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateErrorKind::ResourceNotFoundException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServiceTemplateError {
    fn code(&self) -> Option<&str> {
        UpdateServiceTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateServiceTemplateErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateServiceTemplateErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateServiceTemplateError {
    pub fn new(kind: UpdateServiceTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServiceTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServiceTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateServiceTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServiceTemplateErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateServiceTemplateErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateServiceTemplateErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateServiceTemplateErrorKind::ResourceNotFoundException(_inner) => Some(_inner),
            UpdateServiceTemplateErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateServiceTemplateErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateServiceTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateServiceTemplateVersionError {
    pub kind: UpdateServiceTemplateVersionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateServiceTemplateVersionErrorKind {
    AccessDeniedException(crate::error::AccessDeniedException),
    ConflictException(crate::error::ConflictException),
    InternalServerException(crate::error::InternalServerException),
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    ThrottlingException(crate::error::ThrottlingException),
    ValidationException(crate::error::ValidationException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateServiceTemplateVersionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateServiceTemplateVersionErrorKind::AccessDeniedException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateVersionErrorKind::ConflictException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateVersionErrorKind::InternalServerException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateServiceTemplateVersionErrorKind::ThrottlingException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateVersionErrorKind::ValidationException(_inner) => _inner.fmt(f),
            UpdateServiceTemplateVersionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateServiceTemplateVersionError {
    fn code(&self) -> Option<&str> {
        UpdateServiceTemplateVersionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        match &self.kind {
            UpdateServiceTemplateVersionErrorKind::InternalServerException(inner) => {
                Some(inner.retryable_error_kind())
            }
            UpdateServiceTemplateVersionErrorKind::ThrottlingException(inner) => {
                Some(inner.retryable_error_kind())
            }
            _ => None,
        }
    }
}
impl UpdateServiceTemplateVersionError {
    pub fn new(kind: UpdateServiceTemplateVersionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateServiceTemplateVersionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateServiceTemplateVersionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display
    // as implemented by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateVersionErrorKind::AccessDeniedException(_)
        )
    }
    pub fn is_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateVersionErrorKind::ConflictException(_)
        )
    }
    pub fn is_internal_server_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateVersionErrorKind::InternalServerException(_)
        )
    }
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateVersionErrorKind::ResourceNotFoundException(_)
        )
    }
    pub fn is_throttling_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateVersionErrorKind::ThrottlingException(_)
        )
    }
    pub fn is_validation_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateServiceTemplateVersionErrorKind::ValidationException(_)
        )
    }
}
impl std::error::Error for UpdateServiceTemplateVersionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateServiceTemplateVersionErrorKind::AccessDeniedException(_inner) => Some(_inner),
            UpdateServiceTemplateVersionErrorKind::ConflictException(_inner) => Some(_inner),
            UpdateServiceTemplateVersionErrorKind::InternalServerException(_inner) => Some(_inner),
            UpdateServiceTemplateVersionErrorKind::ResourceNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateServiceTemplateVersionErrorKind::ThrottlingException(_inner) => Some(_inner),
            UpdateServiceTemplateVersionErrorKind::ValidationException(_inner) => Some(_inner),
            UpdateServiceTemplateVersionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>The input is invalid or an out-of-range value was supplied for the input parameter.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl ValidationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// <p>The request was denied due to request throttling.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ThrottlingException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ThrottlingException");
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl ThrottlingException {
    pub fn retryable_error_kind(&self) -> smithy_types::retry::ErrorKind {
        smithy_types::retry::ErrorKind::ThrottlingError
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ThrottlingException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ThrottlingException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for ThrottlingException {}
/// See [`ThrottlingException`](crate::error::ThrottlingException)
pub mod throttling_exception {
    /// A builder for [`ThrottlingException`](crate::error::ThrottlingException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ThrottlingException`](crate::error::ThrottlingException)
        pub fn build(self) -> crate::error::ThrottlingException {
            crate::error::ThrottlingException {
                message: self.message,
            }
        }
    }
}
impl ThrottlingException {
    /// Creates a new builder-style object to manufacture [`ThrottlingException`](crate::error::ThrottlingException)
    pub fn builder() -> crate::error::throttling_exception::Builder {
        crate::error::throttling_exception::Builder::default()
    }
}

/// <p>The requested resource <i>wasn't</i> found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// <p>The request failed to register with the service.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServerException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServerException");
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl InternalServerException {
    pub fn retryable_error_kind(&self) -> smithy_types::retry::ErrorKind {
        smithy_types::retry::ErrorKind::ServerError
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServerException {}
/// See [`InternalServerException`](crate::error::InternalServerException)
pub mod internal_server_exception {
    /// A builder for [`InternalServerException`](crate::error::InternalServerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServerException`](crate::error::InternalServerException)
        pub fn build(self) -> crate::error::InternalServerException {
            crate::error::InternalServerException {
                message: self.message,
            }
        }
    }
}
impl InternalServerException {
    /// Creates a new builder-style object to manufacture [`InternalServerException`](crate::error::InternalServerException)
    pub fn builder() -> crate::error::internal_server_exception::Builder {
        crate::error::internal_server_exception::Builder::default()
    }
}

/// <p>There <i>isn't</i> sufficient access for performing this action.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl AccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}

/// <p>A quota was exceeded. For more information, see <a href="https://docs.aws.amazon.com/proton/latest/adminguide/ag-limits.html">AWS Proton
/// Quotas</a> in the <i>AWS Proton Administrator Guide</i>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceQuotaExceededException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceQuotaExceededException");
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl ServiceQuotaExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ServiceQuotaExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceQuotaExceededException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for ServiceQuotaExceededException {}
/// See [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
pub mod service_quota_exceeded_exception {
    /// A builder for [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
        pub fn build(self) -> crate::error::ServiceQuotaExceededException {
            crate::error::ServiceQuotaExceededException {
                message: self.message,
            }
        }
    }
}
impl ServiceQuotaExceededException {
    /// Creates a new builder-style object to manufacture [`ServiceQuotaExceededException`](crate::error::ServiceQuotaExceededException)
    pub fn builder() -> crate::error::service_quota_exceeded_exception::Builder {
        crate::error::service_quota_exceeded_exception::Builder::default()
    }
}

/// <p>The request <i>couldn't</i> be made due to a conflicting operation or resource.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConflictException {
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConflictException");
        formatter.field("message", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}
impl ConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConflictException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConflictException {}
/// See [`ConflictException`](crate::error::ConflictException)
pub mod conflict_exception {
    /// A builder for [`ConflictException`](crate::error::ConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConflictException`](crate::error::ConflictException)
        pub fn build(self) -> crate::error::ConflictException {
            crate::error::ConflictException {
                message: self.message,
            }
        }
    }
}
impl ConflictException {
    /// Creates a new builder-style object to manufacture [`ConflictException`](crate::error::ConflictException)
    pub fn builder() -> crate::error::conflict_exception::Builder {
        crate::error::conflict_exception::Builder::default()
    }
}
