// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
pub fn cancel_rotate_secret_deser_operation(
    input: &[u8],
    mut builder: crate::output::cancel_rotate_secret_output::Builder,
) -> std::result::Result<crate::output::cancel_rotate_secret_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CancelRotateSecretOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_version_id(parsed_body.version_id);
    Ok(builder)
}

pub fn create_secret_deser_operation(
    input: &[u8],
    mut builder: crate::output::create_secret_output::Builder,
) -> std::result::Result<crate::output::create_secret_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::CreateSecretOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_version_id(parsed_body.version_id);
    builder = builder.set_replication_status(parsed_body.replication_status);
    Ok(builder)
}

pub fn delete_resource_policy_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_resource_policy_output::Builder,
) -> std::result::Result<crate::output::delete_resource_policy_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteResourcePolicyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    Ok(builder)
}

pub fn delete_secret_deser_operation(
    input: &[u8],
    mut builder: crate::output::delete_secret_output::Builder,
) -> std::result::Result<crate::output::delete_secret_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DeleteSecretOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_deletion_date(parsed_body.deletion_date);
    Ok(builder)
}

pub fn describe_secret_deser_operation(
    input: &[u8],
    mut builder: crate::output::describe_secret_output::Builder,
) -> std::result::Result<crate::output::describe_secret_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::DescribeSecretOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_description(parsed_body.description);
    builder = builder.set_kms_key_id(parsed_body.kms_key_id);
    builder = builder.set_rotation_enabled(parsed_body.rotation_enabled);
    builder = builder.set_rotation_lambda_arn(parsed_body.rotation_lambda_arn);
    builder = builder.set_rotation_rules(parsed_body.rotation_rules);
    builder = builder.set_last_rotated_date(parsed_body.last_rotated_date);
    builder = builder.set_last_changed_date(parsed_body.last_changed_date);
    builder = builder.set_last_accessed_date(parsed_body.last_accessed_date);
    builder = builder.set_deleted_date(parsed_body.deleted_date);
    builder = builder.set_tags(parsed_body.tags);
    builder = builder.set_version_ids_to_stages(parsed_body.version_ids_to_stages);
    builder = builder.set_owning_service(parsed_body.owning_service);
    builder = builder.set_created_date(parsed_body.created_date);
    builder = builder.set_primary_region(parsed_body.primary_region);
    builder = builder.set_replication_status(parsed_body.replication_status);
    Ok(builder)
}

pub fn get_random_password_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_random_password_output::Builder,
) -> std::result::Result<crate::output::get_random_password_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetRandomPasswordOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_random_password(parsed_body.random_password);
    Ok(builder)
}

pub fn get_resource_policy_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_resource_policy_output::Builder,
) -> std::result::Result<crate::output::get_resource_policy_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetResourcePolicyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_resource_policy(parsed_body.resource_policy);
    Ok(builder)
}

pub fn get_secret_value_deser_operation(
    input: &[u8],
    mut builder: crate::output::get_secret_value_output::Builder,
) -> std::result::Result<crate::output::get_secret_value_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::GetSecretValueOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_version_id(parsed_body.version_id);
    builder = builder.set_secret_binary(parsed_body.secret_binary);
    builder = builder.set_secret_string(parsed_body.secret_string);
    builder = builder.set_version_stages(parsed_body.version_stages);
    builder = builder.set_created_date(parsed_body.created_date);
    Ok(builder)
}

pub fn list_secrets_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_secrets_output::Builder,
) -> std::result::Result<crate::output::list_secrets_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::ListSecretsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_secret_list(parsed_body.secret_list);
    builder = builder.set_next_token(parsed_body.next_token);
    Ok(builder)
}

pub fn list_secret_version_ids_deser_operation(
    input: &[u8],
    mut builder: crate::output::list_secret_version_ids_output::Builder,
) -> std::result::Result<crate::output::list_secret_version_ids_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ListSecretVersionIdsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_versions(parsed_body.versions);
    builder = builder.set_next_token(parsed_body.next_token);
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    Ok(builder)
}

pub fn put_resource_policy_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_resource_policy_output::Builder,
) -> std::result::Result<crate::output::put_resource_policy_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PutResourcePolicyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    Ok(builder)
}

pub fn put_secret_value_deser_operation(
    input: &[u8],
    mut builder: crate::output::put_secret_value_output::Builder,
) -> std::result::Result<crate::output::put_secret_value_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::PutSecretValueOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_version_id(parsed_body.version_id);
    builder = builder.set_version_stages(parsed_body.version_stages);
    Ok(builder)
}

pub fn remove_regions_from_replication_deser_operation(
    input: &[u8],
    mut builder: crate::output::remove_regions_from_replication_output::Builder,
) -> std::result::Result<
    crate::output::remove_regions_from_replication_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::RemoveRegionsFromReplicationOutputBody = if input.is_empty()
    {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_replication_status(parsed_body.replication_status);
    Ok(builder)
}

pub fn replicate_secret_to_regions_deser_operation(
    input: &[u8],
    mut builder: crate::output::replicate_secret_to_regions_output::Builder,
) -> std::result::Result<
    crate::output::replicate_secret_to_regions_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::ReplicateSecretToRegionsOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_replication_status(parsed_body.replication_status);
    Ok(builder)
}

pub fn restore_secret_deser_operation(
    input: &[u8],
    mut builder: crate::output::restore_secret_output::Builder,
) -> std::result::Result<crate::output::restore_secret_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::RestoreSecretOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    Ok(builder)
}

pub fn rotate_secret_deser_operation(
    input: &[u8],
    mut builder: crate::output::rotate_secret_output::Builder,
) -> std::result::Result<crate::output::rotate_secret_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::RotateSecretOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_version_id(parsed_body.version_id);
    Ok(builder)
}

pub fn stop_replication_to_replica_deser_operation(
    input: &[u8],
    mut builder: crate::output::stop_replication_to_replica_output::Builder,
) -> std::result::Result<
    crate::output::stop_replication_to_replica_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::StopReplicationToReplicaOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    Ok(builder)
}

pub fn update_secret_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_secret_output::Builder,
) -> std::result::Result<crate::output::update_secret_output::Builder, serde_json::Error> {
    let parsed_body: crate::serializer::UpdateSecretOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    builder = builder.set_version_id(parsed_body.version_id);
    Ok(builder)
}

pub fn update_secret_version_stage_deser_operation(
    input: &[u8],
    mut builder: crate::output::update_secret_version_stage_output::Builder,
) -> std::result::Result<
    crate::output::update_secret_version_stage_output::Builder,
    serde_json::Error,
> {
    let parsed_body: crate::serializer::UpdateSecretVersionStageOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_arn(parsed_body.arn);
    builder = builder.set_name(parsed_body.name);
    Ok(builder)
}

pub fn validate_resource_policy_deser_operation(
    input: &[u8],
    mut builder: crate::output::validate_resource_policy_output::Builder,
) -> std::result::Result<crate::output::validate_resource_policy_output::Builder, serde_json::Error>
{
    let parsed_body: crate::serializer::ValidateResourcePolicyOutputBody = if input.is_empty() {
        // To enable JSON parsing to succeed, replace an empty body
        // with an empty JSON body. If a member was required, it will fail slightly later
        // during the operation construction phase when a required field was missing.
        serde_json::from_slice(b"{}")?
    } else {
        serde_json::from_slice(input)?
    };
    builder = builder.set_policy_validation_passed(Some(parsed_body.policy_validation_passed));
    builder = builder.set_validation_errors(parsed_body.validation_errors);
    Ok(builder)
}
