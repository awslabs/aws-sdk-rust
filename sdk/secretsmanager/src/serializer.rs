// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelRotateSecretInputBody<'a> {
    /// <p>Specifies the secret to cancel a rotation request. You can specify either the Amazon
    /// Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for CancelRotateSecretInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelRotateSecretInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSecretInputBody<'a> {
    /// <p>Specifies the friendly name of the new secret.</p>
    /// <p>The secret name must be ASCII letters, digits, or the following characters :
    /// /_+=.@-</p>
    /// <note>
    /// <p>Do not end your secret name with a hyphen followed by six characters. If you do so, you
    /// risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager
    /// automatically adds a hyphen and six random characters at the end of the ARN.</p>
    /// </note>
    pub name: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) If you include <code>SecretString</code> or <code>SecretBinary</code>, then an
    /// initial version is created as part of the secret, and this parameter specifies a unique
    /// identifier for the new version. </p>
    /// <note>
    /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes it
    /// as the value for this parameter in the request. If you don't use the SDK and instead
    /// generate a raw HTTP request to the Secrets Manager service endpoint, then you must generate a
    /// <code>ClientRequestToken</code> yourself for the new version and include the value in the
    /// request.</p>
    /// </note>
    /// <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
    /// creation of duplicate versions if there are failures and retries during a rotation. We
    /// recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    /// ensure uniqueness of your versions within the specified secret. </p>
    /// <ul>
    /// <li>
    /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    /// of the secret then a new version of the secret is created. </p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and the version <code>SecretString</code>
    /// and <code>SecretBinary</code> values are the same as those in the request, then the
    /// request is ignored.</p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and that version's
    /// <code>SecretString</code> and <code>SecretBinary</code> values are different from those
    /// in the request, then the request fails because you cannot modify an existing version.
    /// Instead, use <a>PutSecretValue</a> to create a new version.</p>
    /// </li>
    /// </ul>
    /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
    pub client_request_token: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies a user-provided description of the secret.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies the ARN, Key ID, or alias of the AWS KMS customer master key (CMK) to
    /// be used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values in the
    /// versions stored in this secret.</p>
    /// <p>You can specify any of the supported ways to identify a AWS KMS key ID. If you need to
    /// reference a CMK in a different account, you can use only the key ARN or the alias ARN.</p>
    /// <p>If you don't specify this value, then Secrets Manager defaults to using the AWS account's
    /// default CMK (the one named <code>aws/secretsmanager</code>). If a AWS KMS CMK with that name doesn't yet
    /// exist, then Secrets Manager creates it for you automatically the first time it needs to encrypt a
    /// version's <code>SecretString</code> or <code>SecretBinary</code> fields.</p>
    /// <important>
    /// <p>You can use the account default CMK to encrypt and decrypt only if you call this
    /// operation using credentials from the same account that owns the secret. If the secret
    /// resides in a different account, then you must create a custom CMK and specify the ARN in
    /// this field. </p>
    /// </important>
    pub kms_key_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
    /// the secret. To use this parameter in the command-line tools, we recommend that you store your
    /// binary data in a file and then use the appropriate technique for your tool to pass the
    /// contents of the file as a parameter.</p>
    /// <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
    /// both. They cannot both be empty.</p>
    /// <p>This parameter is not available using the Secrets Manager console. It can be accessed only by
    /// using the AWS CLI or one of the AWS SDKs.</p>
    pub secret_binary: &'a std::option::Option<smithy_types::Blob>,
    /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
    /// the secret.</p>
    /// <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
    /// both. They cannot both be empty.</p>
    /// <p>If you create a secret by using the Secrets Manager console then Secrets Manager puts the protected
    /// secret text in only the <code>SecretString</code> parameter. The Secrets Manager console stores the
    /// information as a JSON structure of key/value pairs that the Lambda rotation function knows how
    /// to parse.</p>
    /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
    /// specify key/value pairs. For information on how to format a JSON parameter for the various
    /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    /// <p>
    /// <code>{"username":"bob","password":"abc123xyz456"}</code>
    /// </p>
    /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    /// use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
    pub secret_string: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies a list of user-defined tags that are attached to the secret. Each tag
    /// is a "Key" and "Value" pair of strings. This operation only appends tags to the existing list
    /// of tags. To remove tags, you must use <a>UntagResource</a>.</p>
    /// <important>
    /// <ul>
    /// <li>
    /// <p>Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag
    /// from one with key "abc".</p>
    /// </li>
    /// <li>
    /// <p>If you check tags in IAM policy <code>Condition</code> elements as part of your
    /// security strategy, then adding or removing a tag can change permissions. If the
    /// successful completion of this operation would result in you losing your permissions for
    /// this secret, then this operation is blocked and returns an <code>Access Denied</code>
    /// error.</p>
    /// </li>
    /// </ul>
    /// </important>
    /// <p>This parameter requires a JSON text string argument. For information on how to format a
    /// JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    /// <p>
    /// <code>[{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]</code>
    /// </p>
    /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    /// use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per secret—50</p>
    /// </li>
    /// <li>
    /// <p>Maximum key length—127 Unicode characters in UTF-8</p>
    /// </li>
    /// <li>
    /// <p>Maximum value length—255 Unicode characters in UTF-8</p>
    /// </li>
    /// <li>
    /// <p>Tag keys and values are case sensitive.</p>
    /// </li>
    /// <li>
    /// <p>Do not use the <code>aws:</code> prefix in your tag names or values because AWS reserves it
    /// for AWS use. You can't edit or delete tag names or values with this
    /// prefix. Tags with this prefix do not count against your tags per secret limit.</p>
    /// </li>
    /// <li>
    /// <p>If you use your tagging schema across multiple services and resources,
    /// remember other services might have restrictions on allowed characters. Generally
    /// allowed characters: letters, spaces, and numbers representable in UTF-8, plus the
    /// following special characters: + - = . _ : / @.</p>
    /// </li>
    /// </ul>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>(Optional) Add a list of regions to replicate secrets. Secrets Manager replicates the KMSKeyID objects to the list of regions specified in
    /// the parameter.</p>
    pub add_replica_regions:
        &'a std::option::Option<std::vec::Vec<crate::model::ReplicaRegionType>>,
    /// <p>(Optional) If set, the replication overwrites a secret with the same name in the
    /// destination region.</p>
    pub force_overwrite_replica_secret: &'a bool,
}
impl<'a> std::fmt::Debug for CreateSecretInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSecretInputBody");
        formatter.field("name", &self.name);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("description", &self.description);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("secret_binary", &"*** Sensitive Data Redacted ***");
        formatter.field("secret_string", &"*** Sensitive Data Redacted ***");
        formatter.field("tags", &self.tags);
        formatter.field("add_replica_regions", &self.add_replica_regions);
        formatter.field(
            "force_overwrite_replica_secret",
            &self.force_overwrite_replica_secret,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteResourcePolicyInputBody<'a> {
    /// <p>Specifies the secret that you want to delete the attached resource-based policy for. You
    /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DeleteResourcePolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteResourcePolicyInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSecretInputBody<'a> {
    /// <p>Specifies the secret to delete. You can specify either the Amazon Resource Name (ARN) or
    /// the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies the number of days that Secrets Manager waits before Secrets Manager can delete the
    /// secret. You can't use both this parameter and the <code>ForceDeleteWithoutRecovery</code>
    /// parameter in the same API call.</p>
    /// <p>This value can range from 7 to 30 days with a default value of 30.</p>
    pub recovery_window_in_days: &'a std::option::Option<i64>,
    /// <p>(Optional) Specifies that the secret is to be deleted without any recovery window. You
    /// can't use both this parameter and the <code>RecoveryWindowInDays</code> parameter in the same
    /// API call.</p>
    /// <p>An asynchronous background process performs the actual deletion, so there can be a short
    /// delay before the operation completes. If you write code to delete and then immediately
    /// recreate a secret with the same name, ensure that your code includes appropriate back off and
    /// retry logic.</p>
    /// <important>
    /// <p>Use this parameter with caution. This parameter causes the operation to skip the normal
    /// waiting period before the permanent deletion that AWS would normally impose with the
    /// <code>RecoveryWindowInDays</code> parameter. If you delete a secret with the
    /// <code>ForceDeleteWithouRecovery</code> parameter, then you have no opportunity to recover
    /// the secret. You lose the secret permanently.</p>
    /// </important>
    /// <important>
    /// <p>If you use this parameter and include a previously deleted or nonexistent secret, the
    /// operation does not return the error <code>ResourceNotFoundException</code> in order to
    /// correctly handle retries.</p>
    /// </important>
    pub force_delete_without_recovery: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for DeleteSecretInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSecretInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("recovery_window_in_days", &self.recovery_window_in_days);
        formatter.field(
            "force_delete_without_recovery",
            &self.force_delete_without_recovery,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSecretInputBody<'a> {
    /// <p>The identifier of the secret whose details you want to retrieve. You can specify either
    /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for DescribeSecretInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSecretInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRandomPasswordInputBody<'a> {
    /// <p>The desired length of the generated password. The default value if you do not include this
    /// parameter is 32 characters.</p>
    pub password_length: &'a std::option::Option<i64>,
    /// <p>A string that includes characters that should not be included in the generated password.
    /// The default is that all characters from the included sets can be used.</p>
    pub exclude_characters: &'a std::option::Option<std::string::String>,
    /// <p>Specifies that the generated password should not include digits. The default if you do not
    /// include this switch parameter is that digits can be included.</p>
    pub exclude_numbers: &'a std::option::Option<bool>,
    /// <p>Specifies that the generated password should not include punctuation characters. The
    /// default if you do not include this switch parameter is that punctuation characters can be
    /// included.</p>
    /// <p>The following are the punctuation characters that <i>can</i> be included in
    /// the generated password if you don't explicitly exclude them with
    /// <code>ExcludeCharacters</code> or <code>ExcludePunctuation</code>:</p>
    /// <p>
    /// <code>! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | }
    /// ~</code>
    /// </p>
    pub exclude_punctuation: &'a std::option::Option<bool>,
    /// <p>Specifies that the generated password should not include uppercase letters. The default if
    /// you do not include this switch parameter is that uppercase letters can be included.</p>
    pub exclude_uppercase: &'a std::option::Option<bool>,
    /// <p>Specifies that the generated password should not include lowercase letters. The default if
    /// you do not include this switch parameter is that lowercase letters can be included.</p>
    pub exclude_lowercase: &'a std::option::Option<bool>,
    /// <p>Specifies that the generated password can include the space character. The default if you
    /// do not include this switch parameter is that the space character is not included.</p>
    pub include_space: &'a std::option::Option<bool>,
    /// <p>A boolean value that specifies whether the generated password must include at least one of
    /// every allowed character type. The default value is <code>True</code> and the operation
    /// requires at least one of every character type.</p>
    pub require_each_included_type: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for GetRandomPasswordInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRandomPasswordInputBody");
        formatter.field("password_length", &self.password_length);
        formatter.field("exclude_characters", &self.exclude_characters);
        formatter.field("exclude_numbers", &self.exclude_numbers);
        formatter.field("exclude_punctuation", &self.exclude_punctuation);
        formatter.field("exclude_uppercase", &self.exclude_uppercase);
        formatter.field("exclude_lowercase", &self.exclude_lowercase);
        formatter.field("include_space", &self.include_space);
        formatter.field(
            "require_each_included_type",
            &self.require_each_included_type,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetResourcePolicyInputBody<'a> {
    /// <p>Specifies the secret that you want to retrieve the attached resource-based policy for. You
    /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetResourcePolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetResourcePolicyInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSecretValueInputBody<'a> {
    /// <p>Specifies the secret containing the version that you want to retrieve. You can specify
    /// either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>Specifies the unique identifier of the version of the secret that you want to retrieve. If
    /// you specify both this parameter and <code>VersionStage</code>,  the two parameters must refer
    /// to the same secret version. If you don't specify either a <code>VersionStage</code> or
    /// <code>VersionId</code> then the default is to perform the operation on the version with the
    /// <code>VersionStage</code> value of <code>AWSCURRENT</code>.</p>
    /// <p>This value is typically a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value with
    /// 32 hexadecimal digits.</p>
    pub version_id: &'a std::option::Option<std::string::String>,
    /// <p>Specifies the secret version that you want to retrieve by the staging label attached to
    /// the version.</p>
    /// <p>Staging labels are used to keep track of different versions during the rotation process.
    /// If you specify both this parameter and <code>VersionId</code>,  the two parameters must refer
    /// to the same secret version . If you don't specify either a <code>VersionStage</code> or
    /// <code>VersionId</code>, then the default is to perform the operation on the version with the
    /// <code>VersionStage</code> value of <code>AWSCURRENT</code>.</p>
    pub version_stage: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for GetSecretValueInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSecretValueInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("version_id", &self.version_id);
        formatter.field("version_stage", &self.version_stage);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSecretsInputBody<'a> {
    /// <p>(Optional) Limits the number of results you want to include in
    /// the response. If you don't include this parameter, it defaults to a value that's
    /// specific to the operation. If additional items exist beyond the maximum you specify, the
    /// <code>NextToken</code> response element is present and has a value (isn't null). Include
    /// that value as the <code>NextToken</code> request parameter in the next call to the operation to
    /// get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
    /// even when there are more results available. You should check <code>NextToken</code> after every
    /// operation to ensure that you receive all of the results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>(Optional) Use this parameter in a request if you receive a
    /// <code>NextToken</code> response in a previous request indicating there's more
    /// output available. In a subsequent call, set it to the value of the previous call
    /// <code>NextToken</code> response to indicate where the output should continue from.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>Lists the secret request filters.</p>
    pub filters: &'a std::option::Option<std::vec::Vec<crate::model::Filter>>,
    /// <p>Lists secrets in the requested order. </p>
    pub sort_order: &'a std::option::Option<crate::model::SortOrderType>,
}
impl<'a> std::fmt::Debug for ListSecretsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSecretsInputBody");
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("filters", &self.filters);
        formatter.field("sort_order", &self.sort_order);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSecretVersionIdsInputBody<'a> {
    /// <p>The identifier for the secret containing the versions you want to list. You can specify
    /// either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Limits the number of results you want to include in
    /// the response. If you don't include this parameter, it defaults to a value that's
    /// specific to the operation. If additional items exist beyond the maximum you specify, the
    /// <code>NextToken</code> response element is present and has a value (isn't null). Include
    /// that value as the <code>NextToken</code> request parameter in the next call to the operation to
    /// get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
    /// even when there are more results available. You should check <code>NextToken</code> after every
    /// operation to ensure that you receive all of the results.</p>
    pub max_results: &'a std::option::Option<i32>,
    /// <p>(Optional) Use this parameter in a request if you receive a
    /// <code>NextToken</code> response in a previous request indicating there's more
    /// output available. In a subsequent call, set it to the value of the previous call
    /// <code>NextToken</code> response to indicate where the output should continue from.</p>
    pub next_token: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies that you want the results to include versions that do not have any
    /// staging labels attached to them. Such versions are considered deprecated and are subject to
    /// deletion by Secrets Manager as needed.</p>
    pub include_deprecated: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for ListSecretVersionIdsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSecretVersionIdsInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("max_results", &self.max_results);
        formatter.field("next_token", &self.next_token);
        formatter.field("include_deprecated", &self.include_deprecated);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutResourcePolicyInputBody<'a> {
    /// <p>Specifies the secret that you want to attach the resource-based policy. You can specify
    /// either the ARN or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>A JSON-formatted string constructed according to the grammar and syntax for an AWS
    /// resource-based policy. The policy in the string identifies who can access or manage this
    /// secret and its versions. For information on how to format a JSON parameter for the various
    /// command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
    /// JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    pub resource_policy: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) If you set the parameter, <code>BlockPublicPolicy</code> to true, then you
    /// block resource-based policies that allow broad access to the secret.</p>
    pub block_public_policy: &'a std::option::Option<bool>,
}
impl<'a> std::fmt::Debug for PutResourcePolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutResourcePolicyInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("resource_policy", &self.resource_policy);
        formatter.field("block_public_policy", &self.block_public_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutSecretValueInputBody<'a> {
    /// <p>Specifies the secret to which you want to add a new version. You can specify either the
    /// Amazon Resource Name (ARN) or the friendly name of the secret. The secret must already
    /// exist.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies a unique identifier for the new version of the secret. </p>
    /// <note>
    /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    /// in the request. If you don't use the SDK and instead generate a raw HTTP request to the
    /// Secrets Manager service endpoint, then you must generate a <code>ClientRequestToken</code> yourself
    /// for new versions and include that value in the request. </p>
    /// </note>
    /// <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
    /// creation of duplicate versions if there are failures and retries during the Lambda rotation
    /// function's processing. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    /// ensure uniqueness within the specified secret. </p>
    /// <ul>
    /// <li>
    /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    /// of the secret then a new version of the secret is created. </p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and that version's
    /// <code>SecretString</code> or <code>SecretBinary</code> values are the same as those in
    /// the request then the request is ignored (the operation is idempotent). </p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and the version of the
    /// <code>SecretString</code> and <code>SecretBinary</code> values are different from those
    /// in the request then the request fails because you cannot modify an existing secret
    /// version. You can only create new versions to store new secret values.</p>
    /// </li>
    /// </ul>
    /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
    pub client_request_token: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
    /// the secret. To use this parameter in the command-line tools, we recommend that you store your
    /// binary data in a file and then use the appropriate technique for your tool to pass the
    /// contents of the file as a parameter. Either <code>SecretBinary</code> or
    /// <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
    /// <p>This parameter is not accessible if the secret using the Secrets Manager console.</p>
    /// <p></p>
    pub secret_binary: &'a std::option::Option<smithy_types::Blob>,
    /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
    /// the secret. Either <code>SecretString</code> or <code>SecretBinary</code> must have a value,
    /// but not both. They cannot both be empty.</p>
    /// <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
    /// protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
    /// stores the information as a JSON structure of key/value pairs that the default Lambda rotation
    /// function knows how to parse.</p>
    /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
    /// specify key/value pairs. For information on how to format a JSON parameter for the various
    /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    /// Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    /// <p> For example:</p>
    /// <p>
    /// <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
    /// </p>
    /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    /// use single quotes to avoid confusion with the double quotes required in the JSON text.</p>
    pub secret_string: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies a list of staging labels that are attached to this version of the
    /// secret. These staging labels are used to track the versions through the rotation process by
    /// the Lambda rotation function.</p>
    /// <p>A staging label must be unique to a single version of the secret. If you specify a staging
    /// label that's already associated with a different version of the same secret then that staging
    /// label is automatically removed from the other version and attached to this version.</p>
    /// <p>If you do not specify a value for <code>VersionStages</code> then Secrets Manager automatically
    /// moves the staging label <code>AWSCURRENT</code> to this new version.</p>
    pub version_stages: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for PutSecretValueInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutSecretValueInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("secret_binary", &"*** Sensitive Data Redacted ***");
        formatter.field("secret_string", &"*** Sensitive Data Redacted ***");
        formatter.field("version_stages", &self.version_stages);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveRegionsFromReplicationInputBody<'a> {
    /// <p>Remove a secret by <code>SecretId</code> from replica Regions.</p>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>Remove replication from specific Regions.</p>
    pub remove_replica_regions: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for RemoveRegionsFromReplicationInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveRegionsFromReplicationInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("remove_replica_regions", &self.remove_replica_regions);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicateSecretToRegionsInputBody<'a> {
    /// <p>Use the <code>Secret Id</code> to replicate a secret to regions.</p>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>Add Regions to replicate the secret.</p>
    pub add_replica_regions:
        &'a std::option::Option<std::vec::Vec<crate::model::ReplicaRegionType>>,
    /// <p>(Optional) If set, Secrets Manager replication overwrites a secret with the same name in the
    /// destination region.</p>
    pub force_overwrite_replica_secret: &'a bool,
}
impl<'a> std::fmt::Debug for ReplicateSecretToRegionsInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicateSecretToRegionsInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("add_replica_regions", &self.add_replica_regions);
        formatter.field(
            "force_overwrite_replica_secret",
            &self.force_overwrite_replica_secret,
        );
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RestoreSecretInputBody<'a> {
    /// <p>Specifies the secret that you want to restore from a previously scheduled deletion. You
    /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for RestoreSecretInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestoreSecretInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RotateSecretInputBody<'a> {
    /// <p>Specifies the secret that you want to rotate. You can specify either the Amazon Resource
    /// Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies a unique identifier for the new version of the secret that helps
    /// ensure idempotency. </p>
    /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    /// in the request for this parameter. If you don't use the SDK and instead generate a raw HTTP
    /// request to the Secrets Manager service endpoint, then you must generate a
    /// <code>ClientRequestToken</code> yourself for new versions and include that value in the
    /// request.</p>
    /// <p>You only need to specify your own value if you implement your own retry logic and want to
    /// ensure that a given secret is not created twice. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    /// ensure uniqueness within the specified secret. </p>
    /// <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
    /// there are failures and retries during the function's processing. This value becomes the
    /// <code>VersionId</code> of the new version.</p>
    pub client_request_token: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies the ARN of the Lambda function that can rotate the secret.</p>
    pub rotation_lambda_arn: &'a std::option::Option<std::string::String>,
    /// <p>A structure that defines the rotation configuration for this secret.</p>
    pub rotation_rules: &'a std::option::Option<crate::model::RotationRulesType>,
}
impl<'a> std::fmt::Debug for RotateSecretInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RotateSecretInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("rotation_lambda_arn", &self.rotation_lambda_arn);
        formatter.field("rotation_rules", &self.rotation_rules);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct StopReplicationToReplicaInputBody<'a> {
    /// <p>Response to <code>StopReplicationToReplica</code> of a secret, based on the <code>SecretId</code>.</p>
    pub secret_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for StopReplicationToReplicaInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopReplicationToReplicaInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInputBody<'a> {
    /// <p>The identifier for the secret that you want to attach tags to. You can specify either the
    /// Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>The tags to attach to the secret. Each element in the list consists of a <code>Key</code>
    /// and a <code>Value</code>.</p>
    /// <p>This parameter to the API requires a JSON text string argument. For information on how to
    /// format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>. For the
    /// AWS CLI, you can also use the syntax: <code>--Tags Key="Key1",Value="Value1"
    /// Key="Key2",Value="Value2"[,…]</code>
    /// </p>
    pub tags: &'a std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl<'a> std::fmt::Debug for TagResourceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInputBody<'a> {
    /// <p>The identifier for the secret that you want to remove tags from. You can specify either
    /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>A list of tag key names to remove from the secret. You don't specify the value. Both the
    /// key and its associated value are removed.</p>
    /// <p>This parameter to the API requires a JSON text string argument. For information on how to
    /// format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    pub tag_keys: &'a std::option::Option<std::vec::Vec<std::string::String>>,
}
impl<'a> std::fmt::Debug for UntagResourceInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("tag_keys", &self.tag_keys);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSecretInputBody<'a> {
    /// <p>Specifies the secret that you want to modify or to which you want to add a new version.
    /// You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    /// secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) If you want to add a new version to the secret, this parameter specifies a
    /// unique identifier for the new version that helps ensure idempotency. </p>
    /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    /// in the request. If you don't use the SDK and instead generate a raw HTTP request to the Secrets Manager
    /// service endpoint, then you must generate a <code>ClientRequestToken</code> yourself for new
    /// versions and include that value in the request.</p>
    /// <p>You typically only need to interact with this value if you implement your own retry logic
    /// and want to ensure that a given secret is not created twice. We recommend that you generate a
    /// <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a>
    /// value to ensure uniqueness within the specified secret. </p>
    /// <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
    /// there are failures and retries during the Lambda rotation function's processing.</p>
    /// <ul>
    /// <li>
    /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    /// of the secret then a new version of the secret is created. </p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and that version's
    /// <code>SecretString</code> and <code>SecretBinary</code> values are the same as those in
    /// the request then the request is ignored (the operation is idempotent). </p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and that version's
    /// <code>SecretString</code> and <code>SecretBinary</code> values are different from the
    /// request then an error occurs because you cannot modify an existing secret value.</p>
    /// </li>
    /// </ul>
    /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
    pub client_request_token: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies an updated user-provided description of the secret.</p>
    pub description: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies an updated ARN or alias of the AWS KMS customer master key (CMK) to be
    /// used to encrypt the protected text in new versions of this secret.</p>
    /// <important>
    /// <p>You can only use the account's default CMK to encrypt and decrypt if you call this
    /// operation using credentials from the same account that owns the secret. If the secret is in
    /// a different account, then you must create a custom CMK and provide the ARN of that CMK in
    /// this field. The user making the call must have permissions to both the secret and the CMK in
    /// their respective accounts.</p>
    /// </important>
    pub kms_key_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies updated binary data that you want to encrypt and store in the new
    /// version of the secret. To use this parameter in the command-line tools, we recommend that you
    /// store your binary data in a file and then use the appropriate technique for your tool to pass
    /// the contents of the file as a parameter. Either <code>SecretBinary</code> or
    /// <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
    /// <p>This parameter is not accessible using the Secrets Manager console.</p>
    pub secret_binary: &'a std::option::Option<smithy_types::Blob>,
    /// <p>(Optional) Specifies updated text data that you want to encrypt and store in this new
    /// version of the secret. Either <code>SecretBinary</code> or <code>SecretString</code> must have
    /// a value, but not both. They cannot both be empty.</p>
    /// <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
    /// protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
    /// stores the information as a JSON structure of key/value pairs that the default Lambda rotation
    /// function knows how to parse.</p>
    /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
    /// specify key/value pairs. For information on how to format a JSON parameter for the various
    /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    /// <p>
    /// <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
    /// </p>
    /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    /// use single quotes to avoid confusion with the double quotes required in the JSON text. You can
    /// also 'escape' the double quote character in the embedded JSON text by prefacing each with a
    /// backslash. For example, the following string is surrounded by double-quotes. All of the
    /// embedded double quotes are escaped:</p>
    /// <p>
    /// <code>"[{\"username\":\"bob\"},{\"password\":\"abc123xyz456\"}]"</code>
    /// </p>
    pub secret_string: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateSecretInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSecretInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("description", &self.description);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("secret_binary", &"*** Sensitive Data Redacted ***");
        formatter.field("secret_string", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSecretVersionStageInputBody<'a> {
    /// <p>Specifies the secret with the version with the list of staging labels you want to modify.
    /// You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    /// secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>The staging label to add to this version.</p>
    pub version_stage: &'a std::option::Option<std::string::String>,
    /// <p>Specifies the secret version ID of the version that the staging label is to be removed
    /// from. If the staging label you are trying to attach to one version is already attached to a
    /// different version, then you must include this parameter and specify the version that the label
    /// is to be removed from. If the label is attached and you either do not specify this parameter,
    /// or the version ID does not match, then the operation fails.</p>
    pub remove_from_version_id: &'a std::option::Option<std::string::String>,
    /// <p>(Optional) The secret version ID that you want to add the staging label. If you want to
    /// remove a label from a version, then do not specify this parameter.</p>
    /// <p>If the staging label is already attached to a different version of the secret, then you
    /// must also specify the <code>RemoveFromVersionId</code> parameter. </p>
    pub move_to_version_id: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for UpdateSecretVersionStageInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSecretVersionStageInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("version_stage", &self.version_stage);
        formatter.field("remove_from_version_id", &self.remove_from_version_id);
        formatter.field("move_to_version_id", &self.move_to_version_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateResourcePolicyInputBody<'a> {
    /// <p> (Optional) The identifier of the secret with the resource-based policy you want to
    /// validate. You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    /// secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: &'a std::option::Option<std::string::String>,
    /// <p>A JSON-formatted string constructed according to the grammar and syntax for an AWS
    /// resource-based policy. The policy in the string identifies who can access or manage this
    /// secret and its versions. For information on how to format a JSON parameter for the various
    /// command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
    /// JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.publi</p>
    pub resource_policy: &'a std::option::Option<std::string::String>,
}
impl<'a> std::fmt::Debug for ValidateResourcePolicyInputBody<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidateResourcePolicyInputBody");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("resource_policy", &self.resource_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelRotateSecretOutputBody {
    /// <p>The ARN of the secret for which rotation was canceled.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret for which rotation was canceled.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the version of the secret created during the rotation. This
    /// version might not be complete, and should be evaluated for possible deletion. At the very
    /// least, you should remove the <code>VersionStage</code> value <code>AWSPENDING</code> to enable this
    /// version to be deleted. Failing to clean up a cancelled rotation can block you from
    /// successfully starting future rotations.</p>
    #[serde(rename = "VersionId")]
    #[serde(default)]
    pub version_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CancelRotateSecretOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelRotateSecretOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSecretOutputBody {
    /// <p>The Amazon Resource Name (ARN) of the secret that you just created.</p>
    /// <note>
    /// <p>Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    /// you initially create a secret. This affects only the ARN and not the actual friendly name.
    /// This ensures that if you create a new secret with the same name as an old secret that you
    /// previously deleted, then users with access to the old secret <i>don't</i>
    /// automatically get access to the new secret because the ARNs are different.</p>
    /// </note>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret that you just created.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique identifier associated with the version of the secret you just created.</p>
    #[serde(rename = "VersionId")]
    #[serde(default)]
    pub version_id: std::option::Option<std::string::String>,
    /// <p>Describes a list of replication status objects as <code>InProgress</code>, <code>Failed</code> or <code>InSync</code>.</p>
    #[serde(rename = "ReplicationStatus")]
    #[serde(default)]
    pub replication_status: std::option::Option<std::vec::Vec<crate::model::ReplicationStatusType>>,
}
impl std::fmt::Debug for CreateSecretOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSecretOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("version_id", &self.version_id);
        formatter.field("replication_status", &self.replication_status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteResourcePolicyOutputBody {
    /// <p>The ARN of the secret that the resource-based policy was deleted for.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret that the resource-based policy was deleted for.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteResourcePolicyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteResourcePolicyOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSecretOutputBody {
    /// <p>The ARN of the secret that is now scheduled for deletion.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret currently scheduled for deletion.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The date and time after which this secret can be deleted by Secrets Manager and can no longer be
    /// restored. This value is the date and time of the delete request plus the number of days
    /// specified in <code>RecoveryWindowInDays</code>.</p>
    #[serde(rename = "DeletionDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub deletion_date: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for DeleteSecretOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSecretOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("deletion_date", &self.deletion_date);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSecretOutputBody {
    /// <p>The ARN of the secret.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The user-provided friendly name of the secret.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The user-provided description of the secret.</p>
    #[serde(rename = "Description")]
    #[serde(default)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The ARN or alias of the AWS KMS customer master key (CMK) that's used to encrypt the
    /// <code>SecretString</code> or <code>SecretBinary</code> fields in each version of the secret.
    /// If you don't provide a key, then Secrets Manager defaults to encrypting the secret fields with the
    /// default AWS KMS CMK (the one named <code>awssecretsmanager</code>) for this account.</p>
    #[serde(rename = "KmsKeyId")]
    #[serde(default)]
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies whether automatic rotation is enabled for this secret.</p>
    /// <p>To enable rotation, use <a>RotateSecret</a> with
    /// <code>AutomaticallyRotateAfterDays</code> set to a value greater than 0. To disable
    /// rotation, use <a>CancelRotateSecret</a>.</p>
    #[serde(rename = "RotationEnabled")]
    #[serde(default)]
    pub rotation_enabled: std::option::Option<bool>,
    /// <p>The ARN of a Lambda function that's invoked by Secrets Manager to rotate the
    /// secret either automatically per the schedule or manually by a call to
    /// <code>RotateSecret</code>.</p>
    #[serde(rename = "RotationLambdaARN")]
    #[serde(default)]
    pub rotation_lambda_arn: std::option::Option<std::string::String>,
    /// <p>A structure with the rotation configuration for this secret.</p>
    #[serde(rename = "RotationRules")]
    #[serde(default)]
    pub rotation_rules: std::option::Option<crate::model::RotationRulesType>,
    /// <p>The last date and time that the rotation process for this secret was invoked.</p>
    /// <p>The most recent date and time that the Secrets Manager rotation process successfully
    /// completed. If the secret doesn't rotate, Secrets Manager returns a null value.</p>
    #[serde(rename = "LastRotatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_rotated_date: std::option::Option<smithy_types::Instant>,
    /// <p>The last date and time that this secret was modified in any way.</p>
    #[serde(rename = "LastChangedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_changed_date: std::option::Option<smithy_types::Instant>,
    /// <p>The last date that this secret was accessed. This value is truncated to midnight of the
    /// date and therefore shows only the date, not the time.</p>
    #[serde(rename = "LastAccessedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub last_accessed_date: std::option::Option<smithy_types::Instant>,
    /// <p>This value exists if the secret is scheduled for deletion. Some time after the specified
    /// date and time, Secrets Manager deletes the secret and all of its versions.</p>
    /// <p>If a secret is scheduled for deletion, then its details, including the encrypted secret
    /// information, is not accessible. To cancel a scheduled deletion and restore access, use <a>RestoreSecret</a>.</p>
    #[serde(rename = "DeletedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub deleted_date: std::option::Option<smithy_types::Instant>,
    /// <p>The list of user-defined tags that are associated with the secret. To add tags to a
    /// secret, use <a>TagResource</a>. To remove tags, use <a>UntagResource</a>.</p>
    #[serde(rename = "Tags")]
    #[serde(default)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>A list of all of the currently assigned <code>VersionStage</code> staging labels and the
    /// <code>VersionId</code> that each is attached to. Staging labels are used to keep track of
    /// the different versions during the rotation process.</p>
    /// <note>
    /// <p>A version that does not have any staging labels attached is considered deprecated and
    /// subject to deletion. Such versions are not included in this list.</p>
    /// </note>
    #[serde(rename = "VersionIdsToStages")]
    #[serde(default)]
    pub version_ids_to_stages: std::option::Option<
        std::collections::HashMap<std::string::String, std::vec::Vec<std::string::String>>,
    >,
    /// <p>Returns the name of the service that created this secret.</p>
    #[serde(rename = "OwningService")]
    #[serde(default)]
    pub owning_service: std::option::Option<std::string::String>,
    /// <p>The date you created the secret.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
    /// <p>Specifies the primary region for secret replication. </p>
    #[serde(rename = "PrimaryRegion")]
    #[serde(default)]
    pub primary_region: std::option::Option<std::string::String>,
    /// <p>Describes a list of replication status objects as <code>InProgress</code>, <code>Failed</code> or <code>InSync</code>.<code>P</code>
    /// </p>
    #[serde(rename = "ReplicationStatus")]
    #[serde(default)]
    pub replication_status: std::option::Option<std::vec::Vec<crate::model::ReplicationStatusType>>,
}
impl std::fmt::Debug for DescribeSecretOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSecretOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("description", &self.description);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("rotation_enabled", &self.rotation_enabled);
        formatter.field("rotation_lambda_arn", &self.rotation_lambda_arn);
        formatter.field("rotation_rules", &self.rotation_rules);
        formatter.field("last_rotated_date", &self.last_rotated_date);
        formatter.field("last_changed_date", &self.last_changed_date);
        formatter.field("last_accessed_date", &self.last_accessed_date);
        formatter.field("deleted_date", &self.deleted_date);
        formatter.field("tags", &self.tags);
        formatter.field("version_ids_to_stages", &self.version_ids_to_stages);
        formatter.field("owning_service", &self.owning_service);
        formatter.field("created_date", &self.created_date);
        formatter.field("primary_region", &self.primary_region);
        formatter.field("replication_status", &self.replication_status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRandomPasswordOutputBody {
    /// <p>A string with the generated password.</p>
    #[serde(rename = "RandomPassword")]
    #[serde(default)]
    pub random_password: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetRandomPasswordOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRandomPasswordOutputBody");
        formatter.field("random_password", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetResourcePolicyOutputBody {
    /// <p>The ARN of the secret that the resource-based policy was retrieved for.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret that the resource-based policy was retrieved for.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>A JSON-formatted string that describes the permissions that are associated with the
    /// attached secret. These permissions are combined with any permissions that are associated with
    /// the user or role that attempts to access this secret. The combined permissions specify who can
    /// access the secret and what actions they can perform. For more information, see <a href="http://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html">Authentication and Access Control for
    /// AWS Secrets Manager</a> in the <i>AWS Secrets Manager User Guide</i>.</p>
    #[serde(rename = "ResourcePolicy")]
    #[serde(default)]
    pub resource_policy: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetResourcePolicyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetResourcePolicyOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("resource_policy", &self.resource_policy);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSecretValueOutputBody {
    /// <p>The ARN of the secret.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique identifier of this version of the secret.</p>
    #[serde(rename = "VersionId")]
    #[serde(default)]
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The decrypted part of the protected secret information that was originally provided as
    /// binary data in the form of a byte array. The response parameter represents the binary data as
    /// a <a href="https://tools.ietf.org/html/rfc4648#section-4">base64-encoded</a>
    /// string.</p>
    /// <p>This parameter is not used if the secret is created by the Secrets Manager console.</p>
    /// <p>If you store custom information in this field of the secret, then you must code your
    /// Lambda rotation function to parse and interpret whatever you store in the
    /// <code>SecretString</code> or <code>SecretBinary</code> fields.</p>
    #[serde(rename = "SecretBinary")]
    #[serde(deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesblob_deser")]
    #[serde(default)]
    pub secret_binary: std::option::Option<smithy_types::Blob>,
    /// <p>The decrypted part of the protected secret information that was originally provided as a
    /// string.</p>
    /// <p>If you create this secret by using the Secrets Manager console then only the
    /// <code>SecretString</code> parameter contains data. Secrets Manager stores the information as a
    /// JSON structure of key/value pairs that the Lambda rotation function knows how to parse.</p>
    /// <p>If you store custom information in the secret by using the <a>CreateSecret</a>,
    /// <a>UpdateSecret</a>, or <a>PutSecretValue</a> API operations instead
    /// of the Secrets Manager console, or by using the <b>Other secret type</b> in
    /// the console, then you must code your Lambda rotation function to parse and interpret those
    /// values.</p>
    #[serde(rename = "SecretString")]
    #[serde(default)]
    pub secret_string: std::option::Option<std::string::String>,
    /// <p>A list of all of the staging labels currently attached to this version of the
    /// secret.</p>
    #[serde(rename = "VersionStages")]
    #[serde(default)]
    pub version_stages: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The date and time that this version of the secret was created.</p>
    #[serde(rename = "CreatedDate")]
    #[serde(
        deserialize_with = "crate::serde_util::stdoptionoptionsmithytypesinstant_epoch_seconds_deser"
    )]
    #[serde(default)]
    pub created_date: std::option::Option<smithy_types::Instant>,
}
impl std::fmt::Debug for GetSecretValueOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSecretValueOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("version_id", &self.version_id);
        formatter.field("secret_binary", &"*** Sensitive Data Redacted ***");
        formatter.field("secret_string", &"*** Sensitive Data Redacted ***");
        formatter.field("version_stages", &self.version_stages);
        formatter.field("created_date", &self.created_date);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSecretsOutputBody {
    /// <p>A list of the secrets in the account.</p>
    #[serde(rename = "SecretList")]
    #[serde(default)]
    pub secret_list: std::option::Option<std::vec::Vec<crate::model::SecretListEntry>>,
    /// <p>If present in the response, this value indicates that
    /// there's more output available than included in the current response. This can
    /// occur even when the response includes no values at all, such as when you ask for a filtered view
    /// of a very long list. Use this value in the <code>NextToken</code> request parameter in a
    /// subsequent call to the operation to continue processing and get the next part of the output. You
    /// should repeat this until the <code>NextToken</code> response element comes back empty (as
    /// <code>null</code>).</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListSecretsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSecretsOutputBody");
        formatter.field("secret_list", &self.secret_list);
        formatter.field("next_token", &self.next_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSecretVersionIdsOutputBody {
    /// <p>The list of the currently available versions of the specified secret.</p>
    #[serde(rename = "Versions")]
    #[serde(default)]
    pub versions: std::option::Option<std::vec::Vec<crate::model::SecretVersionsListEntry>>,
    /// <p>If present in the response, this value indicates that
    /// there's more output available than included in the current response. This can
    /// occur even when the response includes no values at all, such as when you ask for a filtered view
    /// of a very long list. Use this value in the <code>NextToken</code> request parameter in a
    /// subsequent call to the operation to continue processing and get the next part of the output. You
    /// should repeat this until the <code>NextToken</code> response element comes back empty (as
    /// <code>null</code>).</p>
    #[serde(rename = "NextToken")]
    #[serde(default)]
    pub next_token: std::option::Option<std::string::String>,
    /// <p>The Amazon Resource Name (ARN) for the secret.</p>
    /// <note>
    /// <p>Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    /// you initially create a secret. This affects only the ARN and not the actual friendly name.
    /// This ensures that if you create a new secret with the same name as an old secret that you
    /// previously deleted, then users with access to the old secret <i>don't</i>
    /// automatically get access to the new secret because the ARNs are different.</p>
    /// </note>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ListSecretVersionIdsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSecretVersionIdsOutputBody");
        formatter.field("versions", &self.versions);
        formatter.field("next_token", &self.next_token);
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutResourcePolicyOutputBody {
    /// <p>The ARN of the secret retrieved by the resource-based policy.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret retrieved by the resource-based policy.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutResourcePolicyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutResourcePolicyOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PutSecretValueOutputBody {
    /// <p>The Amazon Resource Name (ARN) for the secret for which you just created a version.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret for which you just created or updated a version.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The unique identifier of the version of the secret you just created or updated.</p>
    #[serde(rename = "VersionId")]
    #[serde(default)]
    pub version_id: std::option::Option<std::string::String>,
    /// <p>The list of staging labels that are currently attached to this version of the secret.
    /// Staging labels are used to track a version as it progresses through the secret rotation
    /// process.</p>
    #[serde(rename = "VersionStages")]
    #[serde(default)]
    pub version_stages: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for PutSecretValueOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutSecretValueOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("version_id", &self.version_id);
        formatter.field("version_stages", &self.version_stages);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RemoveRegionsFromReplicationOutputBody {
    /// <p>The secret <code>ARN</code> removed from replication regions.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Describes the remaining replication status after you remove regions from the replication list.</p>
    #[serde(rename = "ReplicationStatus")]
    #[serde(default)]
    pub replication_status: std::option::Option<std::vec::Vec<crate::model::ReplicationStatusType>>,
}
impl std::fmt::Debug for RemoveRegionsFromReplicationOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RemoveRegionsFromReplicationOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("replication_status", &self.replication_status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplicateSecretToRegionsOutputBody {
    /// <p>Replicate a secret based on the <code>ReplicaRegionType</code>> consisting of a
    /// Region(required) and a KMSKeyId (optional) which can be the ARN, KeyID, or Alias. </p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>Describes the secret replication status as <code>PENDING</code>, <code>SUCCESS</code> or <code>FAIL</code>.</p>
    #[serde(rename = "ReplicationStatus")]
    #[serde(default)]
    pub replication_status: std::option::Option<std::vec::Vec<crate::model::ReplicationStatusType>>,
}
impl std::fmt::Debug for ReplicateSecretToRegionsOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplicateSecretToRegionsOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("replication_status", &self.replication_status);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RestoreSecretOutputBody {
    /// <p>The ARN of the secret that was restored.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret that was restored.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RestoreSecretOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestoreSecretOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct RotateSecretOutputBody {
    /// <p>The ARN of the secret.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The ID of the new version of the secret created by the rotation started by this
    /// request.</p>
    #[serde(rename = "VersionId")]
    #[serde(default)]
    pub version_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RotateSecretOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RotateSecretOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct StopReplicationToReplicaOutputBody {
    /// <p>Response <code>StopReplicationToReplica</code> of a secret, based on the <code>ARN,</code>.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for StopReplicationToReplicaOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("StopReplicationToReplicaOutputBody");
        formatter.field("arn", &self.arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSecretOutputBody {
    /// <p>The ARN of the secret that was updated.</p>
    /// <note>
    /// <p>Secrets Manager automatically adds several random characters to the name at the end of the ARN when
    /// you initially create a secret. This affects only the ARN and not the actual friendly name.
    /// This ensures that if you create a new secret with the same name as an old secret that you
    /// previously deleted, then users with access to the old secret <i>don't</i>
    /// automatically get access to the new secret because the ARNs are different.</p>
    /// </note>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret that was updated.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
    /// <p>If a new version of the secret was created by this operation, then <code>VersionId</code>
    /// contains the unique identifier of the new version.</p>
    #[serde(rename = "VersionId")]
    #[serde(default)]
    pub version_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateSecretOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSecretOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSecretVersionStageOutputBody {
    /// <p>The ARN of the secret with the modified staging label.</p>
    #[serde(rename = "ARN")]
    #[serde(default)]
    pub arn: std::option::Option<std::string::String>,
    /// <p>The friendly name of the secret with the modified staging label.</p>
    #[serde(rename = "Name")]
    #[serde(default)]
    pub name: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateSecretVersionStageOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSecretVersionStageOutputBody");
        formatter.field("arn", &self.arn);
        formatter.field("name", &self.name);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::default::Default, serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateResourcePolicyOutputBody {
    /// <p>Returns a message stating that your Reource Policy passed validation. </p>
    #[serde(rename = "PolicyValidationPassed")]
    #[serde(default)]
    pub policy_validation_passed: bool,
    /// <p>Returns an error message if your policy doesn't pass validatation.</p>
    #[serde(rename = "ValidationErrors")]
    #[serde(default)]
    pub validation_errors: std::option::Option<std::vec::Vec<crate::model::ValidationErrorsEntry>>,
}
impl std::fmt::Debug for ValidateResourcePolicyOutputBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidateResourcePolicyOutputBody");
        formatter.field("policy_validation_passed", &self.policy_validation_passed);
        formatter.field("validation_errors", &self.validation_errors);
        formatter.finish()
    }
}
