// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(Debug)]
pub(crate) struct Handle<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    client: smithy_client::Client<C, M, R>,
    conf: crate::Config,
}

/// An ergonomic service client for `secretsmanager`.
///
/// This client allows ergonomic access to a `secretsmanager`-shaped service.
/// Each method corresponds to an endpoint defined in the service's Smithy model,
/// and the request and response shapes are auto-generated from that same model.
///
/// # Using a Client
///
/// Once you have a client set up, you can access the service's endpoints
/// by calling the appropriate method on [`Client`]. Each such method
/// returns a request builder for that endpoint, with methods for setting
/// the various fields of the request. Once your request is complete, use
/// the `send` method to send the request. `send` returns a future, which
/// you then have to `.await` to get the service's response.
///
/// [builder pattern]: https://rust-lang.github.io/api-guidelines/type-safety.html#c-builder
/// [SigV4-signed requests]: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
#[derive(std::fmt::Debug)]
pub struct Client<
    C = smithy_client::erase::DynConnector,
    M = aws_hyper::AwsMiddleware,
    R = smithy_client::retry::Standard,
> {
    handle: std::sync::Arc<Handle<C, M, R>>,
}

impl<C, M, R> std::clone::Clone for Client<C, M, R> {
    fn clone(&self) -> Self {
        Self {
            handle: self.handle.clone(),
        }
    }
}

#[doc(inline)]
pub use smithy_client::Builder;

impl<C, M, R> From<smithy_client::Client<C, M, R>> for Client<C, M, R> {
    fn from(client: smithy_client::Client<C, M, R>) -> Self {
        Self::with_config(client, crate::Config::builder().build())
    }
}

impl<C, M, R> Client<C, M, R> {
    pub fn with_config(client: smithy_client::Client<C, M, R>, conf: crate::Config) -> Self {
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl<C, M, R> Client<C, M, R>
where
    C: smithy_client::bounds::SmithyConnector,
    M: smithy_client::bounds::SmithyMiddleware<C>,
    R: smithy_client::retry::NewRequestPolicy,
{
    pub fn cancel_rotate_secret(&self) -> fluent_builders::CancelRotateSecret<C, M, R> {
        fluent_builders::CancelRotateSecret::new(self.handle.clone())
    }
    pub fn create_secret(&self) -> fluent_builders::CreateSecret<C, M, R> {
        fluent_builders::CreateSecret::new(self.handle.clone())
    }
    pub fn delete_resource_policy(&self) -> fluent_builders::DeleteResourcePolicy<C, M, R> {
        fluent_builders::DeleteResourcePolicy::new(self.handle.clone())
    }
    pub fn delete_secret(&self) -> fluent_builders::DeleteSecret<C, M, R> {
        fluent_builders::DeleteSecret::new(self.handle.clone())
    }
    pub fn describe_secret(&self) -> fluent_builders::DescribeSecret<C, M, R> {
        fluent_builders::DescribeSecret::new(self.handle.clone())
    }
    pub fn get_random_password(&self) -> fluent_builders::GetRandomPassword<C, M, R> {
        fluent_builders::GetRandomPassword::new(self.handle.clone())
    }
    pub fn get_resource_policy(&self) -> fluent_builders::GetResourcePolicy<C, M, R> {
        fluent_builders::GetResourcePolicy::new(self.handle.clone())
    }
    pub fn get_secret_value(&self) -> fluent_builders::GetSecretValue<C, M, R> {
        fluent_builders::GetSecretValue::new(self.handle.clone())
    }
    pub fn list_secrets(&self) -> fluent_builders::ListSecrets<C, M, R> {
        fluent_builders::ListSecrets::new(self.handle.clone())
    }
    pub fn list_secret_version_ids(&self) -> fluent_builders::ListSecretVersionIds<C, M, R> {
        fluent_builders::ListSecretVersionIds::new(self.handle.clone())
    }
    pub fn put_resource_policy(&self) -> fluent_builders::PutResourcePolicy<C, M, R> {
        fluent_builders::PutResourcePolicy::new(self.handle.clone())
    }
    pub fn put_secret_value(&self) -> fluent_builders::PutSecretValue<C, M, R> {
        fluent_builders::PutSecretValue::new(self.handle.clone())
    }
    pub fn remove_regions_from_replication(
        &self,
    ) -> fluent_builders::RemoveRegionsFromReplication<C, M, R> {
        fluent_builders::RemoveRegionsFromReplication::new(self.handle.clone())
    }
    pub fn replicate_secret_to_regions(
        &self,
    ) -> fluent_builders::ReplicateSecretToRegions<C, M, R> {
        fluent_builders::ReplicateSecretToRegions::new(self.handle.clone())
    }
    pub fn restore_secret(&self) -> fluent_builders::RestoreSecret<C, M, R> {
        fluent_builders::RestoreSecret::new(self.handle.clone())
    }
    pub fn rotate_secret(&self) -> fluent_builders::RotateSecret<C, M, R> {
        fluent_builders::RotateSecret::new(self.handle.clone())
    }
    pub fn stop_replication_to_replica(
        &self,
    ) -> fluent_builders::StopReplicationToReplica<C, M, R> {
        fluent_builders::StopReplicationToReplica::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C, M, R> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C, M, R> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_secret(&self) -> fluent_builders::UpdateSecret<C, M, R> {
        fluent_builders::UpdateSecret::new(self.handle.clone())
    }
    pub fn update_secret_version_stage(
        &self,
    ) -> fluent_builders::UpdateSecretVersionStage<C, M, R> {
        fluent_builders::UpdateSecretVersionStage::new(self.handle.clone())
    }
    pub fn validate_resource_policy(&self) -> fluent_builders::ValidateResourcePolicy<C, M, R> {
        fluent_builders::ValidateResourcePolicy::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct CancelRotateSecret<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::cancel_rotate_secret_input::Builder,
    }
    impl<C, M, R> CancelRotateSecret<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CancelRotateSecretOutput,
            smithy_http::result::SdkError<crate::error::CancelRotateSecretError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CancelRotateSecretInputOperationOutputAlias,
                crate::output::CancelRotateSecretOutput,
                crate::error::CancelRotateSecretError,
                crate::input::CancelRotateSecretInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret to cancel a rotation request. You can specify either the Amazon
        /// Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateSecret<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::create_secret_input::Builder,
    }
    impl<C, M, R> CreateSecret<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateSecretOutput,
            smithy_http::result::SdkError<crate::error::CreateSecretError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::CreateSecretInputOperationOutputAlias,
                crate::output::CreateSecretOutput,
                crate::error::CreateSecretError,
                crate::input::CreateSecretInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the friendly name of the new secret.</p>
        /// <p>The secret name must be ASCII letters, digits, or the following characters :
        /// /_+=.@-</p>
        /// <note>
        /// <p>Do not end your secret name with a hyphen followed by six characters. If you do so, you
        /// risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager
        /// automatically adds a hyphen and six random characters at the end of the ARN.</p>
        /// </note>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>(Optional) If you include <code>SecretString</code> or <code>SecretBinary</code>, then an
        /// initial version is created as part of the secret, and this parameter specifies a unique
        /// identifier for the new version. </p>
        /// <note>
        /// <p>If you use the Amazon Web Services CLI or one of the Amazon Web Services SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes it
        /// as the value for this parameter in the request. If you don't use the SDK and instead
        /// generate a raw HTTP request to the Secrets Manager service endpoint, then you must generate a
        /// <code>ClientRequestToken</code> yourself for the new version and include the value in the
        /// request.</p>
        /// </note>
        /// <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
        /// creation of duplicate versions if there are failures and retries during a rotation. We
        /// recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
        /// ensure uniqueness of your versions within the specified secret. </p>
        /// <ul>
        /// <li>
        /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
        /// of the secret then a new version of the secret is created. </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and the version <code>SecretString</code>
        /// and <code>SecretBinary</code> values are the same as those in the request, then the
        /// request is ignored.</p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> and <code>SecretBinary</code> values are different from those
        /// in the request, then the request fails because you cannot modify an existing version.
        /// Instead, use <a>PutSecretValue</a> to create a new version.</p>
        /// </li>
        /// </ul>
        /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>(Optional) Specifies a user-provided description of the secret.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>(Optional) Specifies the ARN, Key ID, or alias of the Amazon Web Services KMS customer master key (CMK) to
        /// be used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values in the
        /// versions stored in this secret.</p>
        /// <p>You can specify any of the supported ways to identify a Amazon Web Services KMS key ID. If you need to
        /// reference a CMK in a different account, you can use only the key ARN or the alias ARN.</p>
        /// <p>If you don't specify this value, then Secrets Manager defaults to using the Amazon Web Services account's
        /// default CMK (the one named <code>aws/secretsmanager</code>). If a Amazon Web Services KMS CMK with that name doesn't yet
        /// exist, then Secrets Manager creates it for you automatically the first time it needs to encrypt a
        /// version's <code>SecretString</code> or <code>SecretBinary</code> fields.</p>
        /// <important>
        /// <p>You can use the account default CMK to encrypt and decrypt only if you call this
        /// operation using credentials from the same account that owns the secret. If the secret
        /// resides in a different account, then you must create a custom CMK and specify the ARN in
        /// this field. </p>
        /// </important>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(inp);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
        /// the secret. To use this parameter in the command-line tools, we recommend that you store your
        /// binary data in a file and then use the appropriate technique for your tool to pass the
        /// contents of the file as a parameter.</p>
        /// <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
        /// both. They cannot both be empty.</p>
        /// <p>This parameter is not available using the Secrets Manager console. It can be accessed only by
        /// using the Amazon Web Services CLI or one of the Amazon Web Services SDKs.</p>
        pub fn secret_binary(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.secret_binary(inp);
            self
        }
        pub fn set_secret_binary(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_secret_binary(input);
            self
        }
        /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
        /// the secret.</p>
        /// <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
        /// both. They cannot both be empty.</p>
        /// <p>If you create a secret by using the Secrets Manager console then Secrets Manager puts the protected
        /// secret text in only the <code>SecretString</code> parameter. The Secrets Manager console stores the
        /// information as a JSON structure of key/value pairs that the Lambda rotation function knows how
        /// to parse.</p>
        /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
        /// specify key/value pairs. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>CLI User Guide</i>. For example:</p>
        /// <p>
        /// <code>{"username":"bob","password":"abc123xyz456"}</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
        pub fn secret_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_string(inp);
            self
        }
        pub fn set_secret_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_secret_string(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>(Optional) Specifies a list of user-defined tags that are attached to the secret. Each tag
        /// is a "Key" and "Value" pair of strings. This operation only appends tags to the existing list
        /// of tags. To remove tags, you must use <a>UntagResource</a>.</p>
        /// <important>
        /// <ul>
        /// <li>
        /// <p>Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag
        /// from one with key "abc".</p>
        /// </li>
        /// <li>
        /// <p>If you check tags in IAM policy <code>Condition</code> elements as part of your
        /// security strategy, then adding or removing a tag can change permissions. If the
        /// successful completion of this operation would result in you losing your permissions for
        /// this secret, then this operation is blocked and returns an <code>Access Denied</code>
        /// error.</p>
        /// </li>
        /// </ul>
        /// </important>
        /// <p>This parameter requires a JSON text string argument. For information on how to format a
        /// JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>CLI User Guide</i>. For example:</p>
        /// <p>
        /// <code>[{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per secret—50</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length—127 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length—255 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use the <code>aws:</code> prefix in your tag names or values because Amazon Web Services reserves it
        /// for Amazon Web Services use. You can't edit or delete tag names or values with this
        /// prefix. Tags with this prefix do not count against your tags per secret limit.</p>
        /// </li>
        /// <li>
        /// <p>If you use your tagging schema across multiple services and resources,
        /// remember other services might have restrictions on allowed characters. Generally
        /// allowed characters: letters, spaces, and numbers representable in UTF-8, plus the
        /// following special characters: + - = . _ : / @.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
        /// Appends an item to `AddReplicaRegions`.
        ///
        /// To override the contents of this collection use [`set_add_replica_regions`](Self::set_add_replica_regions).
        /// <p>(Optional) Add a list of regions to replicate secrets. Secrets Manager replicates the KMSKeyID objects to the list of regions specified in
        /// the parameter.</p>
        pub fn add_replica_regions(
            mut self,
            inp: impl Into<crate::model::ReplicaRegionType>,
        ) -> Self {
            self.inner = self.inner.add_replica_regions(inp);
            self
        }
        pub fn set_add_replica_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReplicaRegionType>>,
        ) -> Self {
            self.inner = self.inner.set_add_replica_regions(input);
            self
        }
        /// <p>(Optional) If set, the replication overwrites a secret with the same name in the
        /// destination region.</p>
        pub fn force_overwrite_replica_secret(mut self, inp: bool) -> Self {
            self.inner = self.inner.force_overwrite_replica_secret(inp);
            self
        }
        pub fn set_force_overwrite_replica_secret(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_force_overwrite_replica_secret(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteResourcePolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_resource_policy_input::Builder,
    }
    impl<C, M, R> DeleteResourcePolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteResourcePolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteResourcePolicyInputOperationOutputAlias,
                crate::output::DeleteResourcePolicyOutput,
                crate::error::DeleteResourcePolicyError,
                crate::input::DeleteResourcePolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret that you want to delete the attached resource-based policy for. You
        /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteSecret<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::delete_secret_input::Builder,
    }
    impl<C, M, R> DeleteSecret<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteSecretOutput,
            smithy_http::result::SdkError<crate::error::DeleteSecretError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DeleteSecretInputOperationOutputAlias,
                crate::output::DeleteSecretOutput,
                crate::error::DeleteSecretError,
                crate::input::DeleteSecretInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret to delete. You can specify either the Amazon Resource Name (ARN) or
        /// the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// <p>(Optional) Specifies the number of days that Secrets Manager waits before Secrets Manager can delete the
        /// secret. You can't use both this parameter and the <code>ForceDeleteWithoutRecovery</code>
        /// parameter in the same API call.</p>
        /// <p>This value can range from 7 to 30 days with a default value of 30.</p>
        pub fn recovery_window_in_days(mut self, inp: i64) -> Self {
            self.inner = self.inner.recovery_window_in_days(inp);
            self
        }
        pub fn set_recovery_window_in_days(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_recovery_window_in_days(input);
            self
        }
        /// <p>(Optional) Specifies that the secret is to be deleted without any recovery window. You
        /// can't use both this parameter and the <code>RecoveryWindowInDays</code> parameter in the same
        /// API call.</p>
        /// <p>An asynchronous background process performs the actual deletion, so there can be a short
        /// delay before the operation completes. If you write code to delete and then immediately
        /// recreate a secret with the same name, ensure that your code includes appropriate back off and
        /// retry logic.</p>
        /// <important>
        /// <p>Use this parameter with caution. This parameter causes the operation to skip the normal
        /// waiting period before the permanent deletion that Amazon Web Services would normally impose with the
        /// <code>RecoveryWindowInDays</code> parameter. If you delete a secret with the
        /// <code>ForceDeleteWithouRecovery</code> parameter, then you have no opportunity to recover
        /// the secret. You lose the secret permanently.</p>
        /// </important>
        /// <important>
        /// <p>If you use this parameter and include a previously deleted or nonexistent secret, the
        /// operation does not return the error <code>ResourceNotFoundException</code> in order to
        /// correctly handle retries.</p>
        /// </important>
        pub fn force_delete_without_recovery(mut self, inp: bool) -> Self {
            self.inner = self.inner.force_delete_without_recovery(inp);
            self
        }
        pub fn set_force_delete_without_recovery(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_force_delete_without_recovery(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeSecret<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::describe_secret_input::Builder,
    }
    impl<C, M, R> DescribeSecret<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeSecretOutput,
            smithy_http::result::SdkError<crate::error::DescribeSecretError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::DescribeSecretInputOperationOutputAlias,
                crate::output::DescribeSecretOutput,
                crate::error::DescribeSecretError,
                crate::input::DescribeSecretInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier of the secret whose details you want to retrieve. You can specify either
        /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRandomPassword<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_random_password_input::Builder,
    }
    impl<C, M, R> GetRandomPassword<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRandomPasswordOutput,
            smithy_http::result::SdkError<crate::error::GetRandomPasswordError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetRandomPasswordInputOperationOutputAlias,
                crate::output::GetRandomPasswordOutput,
                crate::error::GetRandomPasswordError,
                crate::input::GetRandomPasswordInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The desired length of the generated password. The default value if you do not include this
        /// parameter is 32 characters.</p>
        pub fn password_length(mut self, inp: i64) -> Self {
            self.inner = self.inner.password_length(inp);
            self
        }
        pub fn set_password_length(mut self, input: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_password_length(input);
            self
        }
        /// <p>A string that includes characters that should not be included in the generated password.
        /// The default is that all characters from the included sets can be used.</p>
        pub fn exclude_characters(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclude_characters(inp);
            self
        }
        pub fn set_exclude_characters(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclude_characters(input);
            self
        }
        /// <p>Specifies that the generated password should not include digits. The default if you do not
        /// include this switch parameter is that digits can be included.</p>
        pub fn exclude_numbers(mut self, inp: bool) -> Self {
            self.inner = self.inner.exclude_numbers(inp);
            self
        }
        pub fn set_exclude_numbers(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_exclude_numbers(input);
            self
        }
        /// <p>Specifies that the generated password should not include punctuation characters. The
        /// default if you do not include this switch parameter is that punctuation characters can be
        /// included.</p>
        /// <p>The following are the punctuation characters that <i>can</i> be included in
        /// the generated password if you don't explicitly exclude them with
        /// <code>ExcludeCharacters</code> or <code>ExcludePunctuation</code>:</p>
        /// <p>
        /// <code>! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | }
        /// ~</code>
        /// </p>
        pub fn exclude_punctuation(mut self, inp: bool) -> Self {
            self.inner = self.inner.exclude_punctuation(inp);
            self
        }
        pub fn set_exclude_punctuation(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_exclude_punctuation(input);
            self
        }
        /// <p>Specifies that the generated password should not include uppercase letters. The default if
        /// you do not include this switch parameter is that uppercase letters can be included.</p>
        pub fn exclude_uppercase(mut self, inp: bool) -> Self {
            self.inner = self.inner.exclude_uppercase(inp);
            self
        }
        pub fn set_exclude_uppercase(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_exclude_uppercase(input);
            self
        }
        /// <p>Specifies that the generated password should not include lowercase letters. The default if
        /// you do not include this switch parameter is that lowercase letters can be included.</p>
        pub fn exclude_lowercase(mut self, inp: bool) -> Self {
            self.inner = self.inner.exclude_lowercase(inp);
            self
        }
        pub fn set_exclude_lowercase(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_exclude_lowercase(input);
            self
        }
        /// <p>Specifies that the generated password can include the space character. The default if you
        /// do not include this switch parameter is that the space character is not included.</p>
        pub fn include_space(mut self, inp: bool) -> Self {
            self.inner = self.inner.include_space(inp);
            self
        }
        pub fn set_include_space(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_space(input);
            self
        }
        /// <p>A boolean value that specifies whether the generated password must include at least one of
        /// every allowed character type. The default value is <code>True</code> and the operation
        /// requires at least one of every character type.</p>
        pub fn require_each_included_type(mut self, inp: bool) -> Self {
            self.inner = self.inner.require_each_included_type(inp);
            self
        }
        pub fn set_require_each_included_type(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_require_each_included_type(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetResourcePolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_resource_policy_input::Builder,
    }
    impl<C, M, R> GetResourcePolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::GetResourcePolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetResourcePolicyInputOperationOutputAlias,
                crate::output::GetResourcePolicyOutput,
                crate::error::GetResourcePolicyError,
                crate::input::GetResourcePolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret that you want to retrieve the attached resource-based policy for. You
        /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetSecretValue<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::get_secret_value_input::Builder,
    }
    impl<C, M, R> GetSecretValue<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetSecretValueOutput,
            smithy_http::result::SdkError<crate::error::GetSecretValueError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::GetSecretValueInputOperationOutputAlias,
                crate::output::GetSecretValueOutput,
                crate::error::GetSecretValueError,
                crate::input::GetSecretValueInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret containing the version that you want to retrieve. You can specify
        /// either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// <p>Specifies the unique identifier of the version of the secret that you want to retrieve. If
        /// you specify both this parameter and <code>VersionStage</code>,  the two parameters must refer
        /// to the same secret version. If you don't specify either a <code>VersionStage</code> or
        /// <code>VersionId</code> then the default is to perform the operation on the version with the
        /// <code>VersionStage</code> value of <code>AWSCURRENT</code>.</p>
        /// <p>This value is typically a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value with
        /// 32 hexadecimal digits.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(input);
            self
        }
        /// <p>Specifies the secret version that you want to retrieve by the staging label attached to
        /// the version.</p>
        /// <p>Staging labels are used to keep track of different versions during the rotation process.
        /// If you specify both this parameter and <code>VersionId</code>,  the two parameters must refer
        /// to the same secret version . If you don't specify either a <code>VersionStage</code> or
        /// <code>VersionId</code>, then the default is to perform the operation on the version with the
        /// <code>VersionStage</code> value of <code>AWSCURRENT</code>.</p>
        pub fn version_stage(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_stage(inp);
            self
        }
        pub fn set_version_stage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_version_stage(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSecrets<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_secrets_input::Builder,
    }
    impl<C, M, R> ListSecrets<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSecretsOutput,
            smithy_http::result::SdkError<crate::error::ListSecretsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListSecretsInputOperationOutputAlias,
                crate::output::ListSecretsOutput,
                crate::error::ListSecretsError,
                crate::input::ListSecretsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>(Optional) Limits the number of results you want to include in
        /// the response. If you don't include this parameter, it defaults to a value that's
        /// specific to the operation. If additional items exist beyond the maximum you specify, the
        /// <code>NextToken</code> response element is present and has a value (isn't null). Include
        /// that value as the <code>NextToken</code> request parameter in the next call to the operation to
        /// get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
        /// even when there are more results available. You should check <code>NextToken</code> after every
        /// operation to ensure that you receive all of the results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>(Optional) Use this parameter in a request if you receive a
        /// <code>NextToken</code> response in a previous request indicating there's more
        /// output available. In a subsequent call, set it to the value of the previous call
        /// <code>NextToken</code> response to indicate where the output should continue from.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// Appends an item to `Filters`.
        ///
        /// To override the contents of this collection use [`set_filters`](Self::set_filters).
        /// <p>Lists the secret request filters.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(input);
            self
        }
        /// <p>Lists secrets in the requested order. </p>
        pub fn sort_order(mut self, inp: crate::model::SortOrderType) -> Self {
            self.inner = self.inner.sort_order(inp);
            self
        }
        pub fn set_sort_order(
            mut self,
            input: std::option::Option<crate::model::SortOrderType>,
        ) -> Self {
            self.inner = self.inner.set_sort_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListSecretVersionIds<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::list_secret_version_ids_input::Builder,
    }
    impl<C, M, R> ListSecretVersionIds<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListSecretVersionIdsOutput,
            smithy_http::result::SdkError<crate::error::ListSecretVersionIdsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ListSecretVersionIdsInputOperationOutputAlias,
                crate::output::ListSecretVersionIdsOutput,
                crate::error::ListSecretVersionIdsError,
                crate::input::ListSecretVersionIdsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the secret containing the versions you want to list. You can specify
        /// either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// <p>(Optional) Limits the number of results you want to include in
        /// the response. If you don't include this parameter, it defaults to a value that's
        /// specific to the operation. If additional items exist beyond the maximum you specify, the
        /// <code>NextToken</code> response element is present and has a value (isn't null). Include
        /// that value as the <code>NextToken</code> request parameter in the next call to the operation to
        /// get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
        /// even when there are more results available. You should check <code>NextToken</code> after every
        /// operation to ensure that you receive all of the results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>(Optional) Use this parameter in a request if you receive a
        /// <code>NextToken</code> response in a previous request indicating there's more
        /// output available. In a subsequent call, set it to the value of the previous call
        /// <code>NextToken</code> response to indicate where the output should continue from.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>(Optional) Specifies that you want the results to include versions that do not have any
        /// staging labels attached to them. Such versions are considered deprecated and are subject to
        /// deletion by Secrets Manager as needed.</p>
        pub fn include_deprecated(mut self, inp: bool) -> Self {
            self.inner = self.inner.include_deprecated(inp);
            self
        }
        pub fn set_include_deprecated(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_deprecated(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutResourcePolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_resource_policy_input::Builder,
    }
    impl<C, M, R> PutResourcePolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutResourcePolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutResourcePolicyInputOperationOutputAlias,
                crate::output::PutResourcePolicyOutput,
                crate::error::PutResourcePolicyError,
                crate::input::PutResourcePolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret that you want to attach the resource-based policy. You can specify
        /// either the ARN or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// <p>A JSON-formatted string constructed according to the grammar and syntax for an Amazon Web Services
        /// resource-based policy. The policy in the string identifies who can access or manage this
        /// secret and its versions. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
        /// JSON for Parameters</a> in the <i>CLI User Guide</i>.</p>
        pub fn resource_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_policy(inp);
            self
        }
        pub fn set_resource_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_policy(input);
            self
        }
        /// <p>(Optional) If you set the parameter, <code>BlockPublicPolicy</code> to true, then you
        /// block resource-based policies that allow broad access to the secret.</p>
        pub fn block_public_policy(mut self, inp: bool) -> Self {
            self.inner = self.inner.block_public_policy(inp);
            self
        }
        pub fn set_block_public_policy(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_block_public_policy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutSecretValue<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::put_secret_value_input::Builder,
    }
    impl<C, M, R> PutSecretValue<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutSecretValueOutput,
            smithy_http::result::SdkError<crate::error::PutSecretValueError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::PutSecretValueInputOperationOutputAlias,
                crate::output::PutSecretValueOutput,
                crate::error::PutSecretValueError,
                crate::input::PutSecretValueInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret to which you want to add a new version. You can specify either the
        /// Amazon Resource Name (ARN) or the friendly name of the secret. The secret must already
        /// exist.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// <p>(Optional) Specifies a unique identifier for the new version of the secret. </p>
        /// <note>
        /// <p>If you use the Amazon Web Services CLI or one of the Amazon Web Services SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
        /// in the request. If you don't use the SDK and instead generate a raw HTTP request to the
        /// Secrets Manager service endpoint, then you must generate a <code>ClientRequestToken</code> yourself
        /// for new versions and include that value in the request. </p>
        /// </note>
        /// <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
        /// creation of duplicate versions if there are failures and retries during the Lambda rotation
        /// function's processing. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
        /// ensure uniqueness within the specified secret. </p>
        /// <ul>
        /// <li>
        /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
        /// of the secret then a new version of the secret is created. </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> or <code>SecretBinary</code> values are the same as those in
        /// the request then the request is ignored (the operation is idempotent). </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and the version of the
        /// <code>SecretString</code> and <code>SecretBinary</code> values are different from those
        /// in the request then the request fails because you cannot modify an existing secret
        /// version. You can only create new versions to store new secret values.</p>
        /// </li>
        /// </ul>
        /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
        /// the secret. To use this parameter in the command-line tools, we recommend that you store your
        /// binary data in a file and then use the appropriate technique for your tool to pass the
        /// contents of the file as a parameter. Either <code>SecretBinary</code> or
        /// <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
        /// <p>This parameter is not accessible if the secret using the Secrets Manager console.</p>
        /// <p></p>
        pub fn secret_binary(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.secret_binary(inp);
            self
        }
        pub fn set_secret_binary(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_secret_binary(input);
            self
        }
        /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
        /// the secret. Either <code>SecretString</code> or <code>SecretBinary</code> must have a value,
        /// but not both. They cannot both be empty.</p>
        /// <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
        /// protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
        /// stores the information as a JSON structure of key/value pairs that the default Lambda rotation
        /// function knows how to parse.</p>
        /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
        /// specify key/value pairs. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>CLI User Guide</i>.</p>
        /// <p> For example:</p>
        /// <p>
        /// <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text.</p>
        pub fn secret_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_string(inp);
            self
        }
        pub fn set_secret_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_secret_string(input);
            self
        }
        /// Appends an item to `VersionStages`.
        ///
        /// To override the contents of this collection use [`set_version_stages`](Self::set_version_stages).
        /// <p>(Optional) Specifies a list of staging labels that are attached to this version of the
        /// secret. These staging labels are used to track the versions through the rotation process by
        /// the Lambda rotation function.</p>
        /// <p>A staging label must be unique to a single version of the secret. If you specify a staging
        /// label that's already associated with a different version of the same secret then that staging
        /// label is automatically removed from the other version and attached to this version.</p>
        /// <p>If you do not specify a value for <code>VersionStages</code> then Secrets Manager automatically
        /// moves the staging label <code>AWSCURRENT</code> to this new version.</p>
        pub fn version_stages(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_stages(inp);
            self
        }
        pub fn set_version_stages(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_version_stages(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RemoveRegionsFromReplication<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::remove_regions_from_replication_input::Builder,
    }
    impl<C, M, R> RemoveRegionsFromReplication<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RemoveRegionsFromReplicationOutput,
            smithy_http::result::SdkError<crate::error::RemoveRegionsFromReplicationError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RemoveRegionsFromReplicationInputOperationOutputAlias,
                crate::output::RemoveRegionsFromReplicationOutput,
                crate::error::RemoveRegionsFromReplicationError,
                crate::input::RemoveRegionsFromReplicationInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Remove a secret by <code>SecretId</code> from replica Regions.</p>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// Appends an item to `RemoveReplicaRegions`.
        ///
        /// To override the contents of this collection use [`set_remove_replica_regions`](Self::set_remove_replica_regions).
        /// <p>Remove replication from specific Regions.</p>
        pub fn remove_replica_regions(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remove_replica_regions(inp);
            self
        }
        pub fn set_remove_replica_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_remove_replica_regions(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ReplicateSecretToRegions<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::replicate_secret_to_regions_input::Builder,
    }
    impl<C, M, R> ReplicateSecretToRegions<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ReplicateSecretToRegionsOutput,
            smithy_http::result::SdkError<crate::error::ReplicateSecretToRegionsError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ReplicateSecretToRegionsInputOperationOutputAlias,
                crate::output::ReplicateSecretToRegionsOutput,
                crate::error::ReplicateSecretToRegionsError,
                crate::input::ReplicateSecretToRegionsInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Use the <code>Secret Id</code> to replicate a secret to regions.</p>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// Appends an item to `AddReplicaRegions`.
        ///
        /// To override the contents of this collection use [`set_add_replica_regions`](Self::set_add_replica_regions).
        /// <p>Add Regions to replicate the secret.</p>
        pub fn add_replica_regions(
            mut self,
            inp: impl Into<crate::model::ReplicaRegionType>,
        ) -> Self {
            self.inner = self.inner.add_replica_regions(inp);
            self
        }
        pub fn set_add_replica_regions(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ReplicaRegionType>>,
        ) -> Self {
            self.inner = self.inner.set_add_replica_regions(input);
            self
        }
        /// <p>(Optional) If set, Secrets Manager replication overwrites a secret with the same name in the
        /// destination region.</p>
        pub fn force_overwrite_replica_secret(mut self, inp: bool) -> Self {
            self.inner = self.inner.force_overwrite_replica_secret(inp);
            self
        }
        pub fn set_force_overwrite_replica_secret(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.inner = self.inner.set_force_overwrite_replica_secret(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RestoreSecret<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::restore_secret_input::Builder,
    }
    impl<C, M, R> RestoreSecret<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RestoreSecretOutput,
            smithy_http::result::SdkError<crate::error::RestoreSecretError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RestoreSecretInputOperationOutputAlias,
                crate::output::RestoreSecretOutput,
                crate::error::RestoreSecretError,
                crate::input::RestoreSecretInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret that you want to restore from a previously scheduled deletion. You
        /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct RotateSecret<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::rotate_secret_input::Builder,
    }
    impl<C, M, R> RotateSecret<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::RotateSecretOutput,
            smithy_http::result::SdkError<crate::error::RotateSecretError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::RotateSecretInputOperationOutputAlias,
                crate::output::RotateSecretOutput,
                crate::error::RotateSecretError,
                crate::input::RotateSecretInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret that you want to rotate. You can specify either the Amazon Resource
        /// Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// <p>(Optional) Specifies a unique identifier for the new version of the secret that helps
        /// ensure idempotency. </p>
        /// <p>If you use the Amazon Web Services CLI or one of the Amazon Web Services SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
        /// in the request for this parameter. If you don't use the SDK and instead generate a raw HTTP
        /// request to the Secrets Manager service endpoint, then you must generate a
        /// <code>ClientRequestToken</code> yourself for new versions and include that value in the
        /// request.</p>
        /// <p>You only need to specify your own value if you implement your own retry logic and want to
        /// ensure that a given secret is not created twice. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
        /// ensure uniqueness within the specified secret. </p>
        /// <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
        /// there are failures and retries during the function's processing. This value becomes the
        /// <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>(Optional) Specifies the ARN of the Lambda function that can rotate the secret.</p>
        pub fn rotation_lambda_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rotation_lambda_arn(inp);
            self
        }
        pub fn set_rotation_lambda_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rotation_lambda_arn(input);
            self
        }
        /// <p>A structure that defines the rotation configuration for this secret.</p>
        pub fn rotation_rules(mut self, inp: crate::model::RotationRulesType) -> Self {
            self.inner = self.inner.rotation_rules(inp);
            self
        }
        pub fn set_rotation_rules(
            mut self,
            input: std::option::Option<crate::model::RotationRulesType>,
        ) -> Self {
            self.inner = self.inner.set_rotation_rules(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct StopReplicationToReplica<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::stop_replication_to_replica_input::Builder,
    }
    impl<C, M, R> StopReplicationToReplica<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::StopReplicationToReplicaOutput,
            smithy_http::result::SdkError<crate::error::StopReplicationToReplicaError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::StopReplicationToReplicaInputOperationOutputAlias,
                crate::output::StopReplicationToReplicaOutput,
                crate::error::StopReplicationToReplicaError,
                crate::input::StopReplicationToReplicaInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Response to <code>StopReplicationToReplica</code> of a secret, based on the <code>SecretId</code>.</p>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C, M, R> TagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::TagResourceInputOperationOutputAlias,
                crate::output::TagResourceOutput,
                crate::error::TagResourceError,
                crate::input::TagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the secret that you want to attach tags to. You can specify either the
        /// Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// Appends an item to `Tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        /// <p>The tags to attach to the secret. Each element in the list consists of a <code>Key</code>
        /// and a <code>Value</code>.</p>
        /// <p>This parameter to the API requires a JSON text string argument. For information on how to
        /// format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>CLI User Guide</i>. For the
        /// CLI, you can also use the syntax: <code>--Tags Key="Key1",Value="Value1"
        /// Key="Key2",Value="Value2"[,…]</code>
        /// </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C, M, R> UntagResource<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UntagResourceInputOperationOutputAlias,
                crate::output::UntagResourceOutput,
                crate::error::UntagResourceError,
                crate::input::UntagResourceInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The identifier for the secret that you want to remove tags from. You can specify either
        /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// Appends an item to `TagKeys`.
        ///
        /// To override the contents of this collection use [`set_tag_keys`](Self::set_tag_keys).
        /// <p>A list of tag key names to remove from the secret. You don't specify the value. Both the
        /// key and its associated value are removed.</p>
        /// <p>This parameter to the API requires a JSON text string argument. For information on how to
        /// format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>CLI User Guide</i>.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSecret<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_secret_input::Builder,
    }
    impl<C, M, R> UpdateSecret<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSecretOutput,
            smithy_http::result::SdkError<crate::error::UpdateSecretError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateSecretInputOperationOutputAlias,
                crate::output::UpdateSecretOutput,
                crate::error::UpdateSecretError,
                crate::input::UpdateSecretInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret that you want to modify or to which you want to add a new version.
        /// You can specify either the Amazon Resource Name (ARN) or the friendly name of the
        /// secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// <p>(Optional) If you want to add a new version to the secret, this parameter specifies a
        /// unique identifier for the new version that helps ensure idempotency. </p>
        /// <p>If you use the Amazon Web Services CLI or one of the Amazon Web Services SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
        /// in the request. If you don't use the SDK and instead generate a raw HTTP request to the Secrets Manager
        /// service endpoint, then you must generate a <code>ClientRequestToken</code> yourself for new
        /// versions and include that value in the request.</p>
        /// <p>You typically only need to interact with this value if you implement your own retry logic
        /// and want to ensure that a given secret is not created twice. We recommend that you generate a
        /// <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a>
        /// value to ensure uniqueness within the specified secret. </p>
        /// <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
        /// there are failures and retries during the Lambda rotation function's processing.</p>
        /// <ul>
        /// <li>
        /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
        /// of the secret then a new version of the secret is created. </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> and <code>SecretBinary</code> values are the same as those in
        /// the request then the request is ignored (the operation is idempotent). </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> and <code>SecretBinary</code> values are different from the
        /// request then an error occurs because you cannot modify an existing secret value.</p>
        /// </li>
        /// </ul>
        /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>(Optional) Specifies an updated user-provided description of the secret.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>(Optional) Specifies an updated ARN or alias of the Amazon Web Services KMS customer master key (CMK) to be
        /// used to encrypt the protected text in new versions of this secret.</p>
        /// <important>
        /// <p>You can only use the account's default CMK to encrypt and decrypt if you call this
        /// operation using credentials from the same account that owns the secret. If the secret is in
        /// a different account, then you must create a custom CMK and provide the ARN of that CMK in
        /// this field. The user making the call must have permissions to both the secret and the CMK in
        /// their respective accounts.</p>
        /// </important>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(inp);
            self
        }
        pub fn set_kms_key_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(input);
            self
        }
        /// <p>(Optional) Specifies updated binary data that you want to encrypt and store in the new
        /// version of the secret. To use this parameter in the command-line tools, we recommend that you
        /// store your binary data in a file and then use the appropriate technique for your tool to pass
        /// the contents of the file as a parameter. Either <code>SecretBinary</code> or
        /// <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
        /// <p>This parameter is not accessible using the Secrets Manager console.</p>
        pub fn secret_binary(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.secret_binary(inp);
            self
        }
        pub fn set_secret_binary(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_secret_binary(input);
            self
        }
        /// <p>(Optional) Specifies updated text data that you want to encrypt and store in this new
        /// version of the secret. Either <code>SecretBinary</code> or <code>SecretString</code> must have
        /// a value, but not both. They cannot both be empty.</p>
        /// <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
        /// protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
        /// stores the information as a JSON structure of key/value pairs that the default Lambda rotation
        /// function knows how to parse.</p>
        /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
        /// specify key/value pairs. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>CLI User Guide</i>. For example:</p>
        /// <p>
        /// <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text. You can
        /// also 'escape' the double quote character in the embedded JSON text by prefacing each with a
        /// backslash. For example, the following string is surrounded by double-quotes. All of the
        /// embedded double quotes are escaped:</p>
        /// <p>
        /// <code>"[{\"username\":\"bob\"},{\"password\":\"abc123xyz456\"}]"</code>
        /// </p>
        pub fn secret_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_string(inp);
            self
        }
        pub fn set_secret_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_secret_string(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateSecretVersionStage<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::update_secret_version_stage_input::Builder,
    }
    impl<C, M, R> UpdateSecretVersionStage<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateSecretVersionStageOutput,
            smithy_http::result::SdkError<crate::error::UpdateSecretVersionStageError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::UpdateSecretVersionStageInputOperationOutputAlias,
                crate::output::UpdateSecretVersionStageOutput,
                crate::error::UpdateSecretVersionStageError,
                crate::input::UpdateSecretVersionStageInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>Specifies the secret with the version with the list of staging labels you want to modify.
        /// You can specify either the Amazon Resource Name (ARN) or the friendly name of the
        /// secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// <p>The staging label to add to this version.</p>
        pub fn version_stage(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_stage(inp);
            self
        }
        pub fn set_version_stage(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_version_stage(input);
            self
        }
        /// <p>Specifies the secret version ID of the version that the staging label is to be removed
        /// from. If the staging label you are trying to attach to one version is already attached to a
        /// different version, then you must include this parameter and specify the version that the label
        /// is to be removed from. If the label is attached and you either do not specify this parameter,
        /// or the version ID does not match, then the operation fails.</p>
        pub fn remove_from_version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remove_from_version_id(inp);
            self
        }
        pub fn set_remove_from_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_remove_from_version_id(input);
            self
        }
        /// <p>(Optional) The secret version ID that you want to add the staging label. If you want to
        /// remove a label from a version, then do not specify this parameter.</p>
        /// <p>If the staging label is already attached to a different version of the secret, then you
        /// must also specify the <code>RemoveFromVersionId</code> parameter. </p>
        pub fn move_to_version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.move_to_version_id(inp);
            self
        }
        pub fn set_move_to_version_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_move_to_version_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ValidateResourcePolicy<
        C = smithy_client::erase::DynConnector,
        M = aws_hyper::AwsMiddleware,
        R = smithy_client::retry::Standard,
    > {
        handle: std::sync::Arc<super::Handle<C, M, R>>,
        inner: crate::input::validate_resource_policy_input::Builder,
    }
    impl<C, M, R> ValidateResourcePolicy<C, M, R>
    where
        C: smithy_client::bounds::SmithyConnector,
        M: smithy_client::bounds::SmithyMiddleware<C>,
        R: smithy_client::retry::NewRequestPolicy,
    {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C, M, R>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }
        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ValidateResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::ValidateResourcePolicyError>,
        >
        where
            R::Policy: smithy_client::bounds::SmithyRetryPolicy<
                crate::input::ValidateResourcePolicyInputOperationOutputAlias,
                crate::output::ValidateResourcePolicyOutput,
                crate::error::ValidateResourcePolicyError,
                crate::input::ValidateResourcePolicyInputOperationRetryAlias,
            >,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p> (Optional) The identifier of the secret with the resource-based policy you want to
        /// validate. You can specify either the Amazon Resource Name (ARN) or the friendly name of the
        /// secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(input);
            self
        }
        /// <p>A JSON-formatted string constructed according to the grammar and syntax for an Amazon Web Services
        /// resource-based policy. The policy in the string identifies who can access or manage this
        /// secret and its versions. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
        /// JSON for Parameters</a> in the <i>CLI User Guide</i>.publi</p>
        pub fn resource_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_policy(inp);
            self
        }
        pub fn set_resource_policy(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_policy(input);
            self
        }
    }
}
impl<C> Client<C, aws_hyper::AwsMiddleware, smithy_client::retry::Standard> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl
    Client<
        smithy_client::erase::DynConnector,
        aws_hyper::AwsMiddleware,
        smithy_client::retry::Standard,
    >
{
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn new(config: &aws_types::config::Config) -> Self {
        Self::from_conf(config.into())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
