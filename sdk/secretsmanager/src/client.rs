// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

#[derive(std::fmt::Debug)]
pub(crate) struct Handle {
    client: aws_hyper::Client<aws_hyper::conn::Standard>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client {
    handle: std::sync::Arc<Handle>,
}

impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf_conn(
            crate::Config::builder().build(),
            aws_hyper::conn::Standard::https(),
        )
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        Self::from_conf_conn(conf, aws_hyper::conn::Standard::https())
    }

    pub fn from_conf_conn(conf: crate::Config, conn: aws_hyper::conn::Standard) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }

    pub fn cancel_rotate_secret(&self) -> fluent_builders::CancelRotateSecret {
        fluent_builders::CancelRotateSecret::new(self.handle.clone())
    }

    pub fn create_secret(&self) -> fluent_builders::CreateSecret {
        fluent_builders::CreateSecret::new(self.handle.clone())
    }

    pub fn delete_resource_policy(&self) -> fluent_builders::DeleteResourcePolicy {
        fluent_builders::DeleteResourcePolicy::new(self.handle.clone())
    }

    pub fn delete_secret(&self) -> fluent_builders::DeleteSecret {
        fluent_builders::DeleteSecret::new(self.handle.clone())
    }

    pub fn describe_secret(&self) -> fluent_builders::DescribeSecret {
        fluent_builders::DescribeSecret::new(self.handle.clone())
    }

    pub fn get_random_password(&self) -> fluent_builders::GetRandomPassword {
        fluent_builders::GetRandomPassword::new(self.handle.clone())
    }

    pub fn get_resource_policy(&self) -> fluent_builders::GetResourcePolicy {
        fluent_builders::GetResourcePolicy::new(self.handle.clone())
    }

    pub fn get_secret_value(&self) -> fluent_builders::GetSecretValue {
        fluent_builders::GetSecretValue::new(self.handle.clone())
    }

    pub fn list_secrets(&self) -> fluent_builders::ListSecrets {
        fluent_builders::ListSecrets::new(self.handle.clone())
    }

    pub fn list_secret_version_ids(&self) -> fluent_builders::ListSecretVersionIds {
        fluent_builders::ListSecretVersionIds::new(self.handle.clone())
    }

    pub fn put_resource_policy(&self) -> fluent_builders::PutResourcePolicy {
        fluent_builders::PutResourcePolicy::new(self.handle.clone())
    }

    pub fn put_secret_value(&self) -> fluent_builders::PutSecretValue {
        fluent_builders::PutSecretValue::new(self.handle.clone())
    }

    pub fn restore_secret(&self) -> fluent_builders::RestoreSecret {
        fluent_builders::RestoreSecret::new(self.handle.clone())
    }

    pub fn rotate_secret(&self) -> fluent_builders::RotateSecret {
        fluent_builders::RotateSecret::new(self.handle.clone())
    }

    pub fn tag_resource(&self) -> fluent_builders::TagResource {
        fluent_builders::TagResource::new(self.handle.clone())
    }

    pub fn untag_resource(&self) -> fluent_builders::UntagResource {
        fluent_builders::UntagResource::new(self.handle.clone())
    }

    pub fn update_secret(&self) -> fluent_builders::UpdateSecret {
        fluent_builders::UpdateSecret::new(self.handle.clone())
    }

    pub fn update_secret_version_stage(&self) -> fluent_builders::UpdateSecretVersionStage {
        fluent_builders::UpdateSecretVersionStage::new(self.handle.clone())
    }

    pub fn validate_resource_policy(&self) -> fluent_builders::ValidateResourcePolicy {
        fluent_builders::ValidateResourcePolicy::new(self.handle.clone())
    }
}
pub mod fluent_builders {

    #[derive(std::fmt::Debug)]
    pub struct CancelRotateSecret {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::cancel_rotate_secret_input::Builder,
    }
    impl CancelRotateSecret {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CancelRotateSecretOutput,
            smithy_http::result::SdkError<crate::error::CancelRotateSecretError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specifies the secret to cancel a rotation request. You can specify either the Amazon
        /// Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct CreateSecret {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::create_secret_input::Builder,
    }
    impl CreateSecret {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::CreateSecretOutput,
            smithy_http::result::SdkError<crate::error::CreateSecretError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specifies the friendly name of the new secret.</p>
        /// <p>The secret name must be ASCII letters, digits, or the following characters :
        /// /_+=.@-</p>
        /// <note>
        /// <p>Do not end your secret name with a hyphen followed by six characters. If you do so, you
        /// risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager
        /// automatically adds a hyphen and six random characters at the end of the ARN.</p>
        /// </note>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(inp);
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(inp);
            self
        }
        /// <p>(Optional) Specifies a list of user-defined tags that are attached to the secret. Each tag
        /// is a "Key" and "Value" pair of strings. This operation only appends tags to the existing list
        /// of tags. To remove tags, you must use <a>UntagResource</a>.</p>
        /// <important>
        /// <ul>
        /// <li>
        /// <p>Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag
        /// from one with key "abc".</p>
        /// </li>
        /// <li>
        /// <p>If you check tags in IAM policy <code>Condition</code> elements as part of your
        /// security strategy, then adding or removing a tag can change permissions. If the
        /// successful completion of this operation would result in you losing your permissions for
        /// this secret, then this operation is blocked and returns an <code>Access Denied</code>
        /// error.</p>
        /// </li>
        /// </ul>
        /// </important>
        /// <p>This parameter requires a JSON text string argument. For information on how to format a
        /// JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
        /// <p>
        /// <code>[{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
        /// <p>The following basic restrictions apply to tags:</p>
        /// <ul>
        /// <li>
        /// <p>Maximum number of tags per secret—50</p>
        /// </li>
        /// <li>
        /// <p>Maximum key length—127 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Maximum value length—255 Unicode characters in UTF-8</p>
        /// </li>
        /// <li>
        /// <p>Tag keys and values are case sensitive.</p>
        /// </li>
        /// <li>
        /// <p>Do not use the <code>aws:</code> prefix in your tag names or values because AWS reserves it
        /// for AWS use. You can't edit or delete tag names or values with this
        /// prefix. Tags with this prefix do not count against your tags per secret limit.</p>
        /// </li>
        /// <li>
        /// <p>If you use your tagging schema across multiple services and resources,
        /// remember other services might have restrictions on allowed characters. Generally
        /// allowed characters: letters, spaces, and numbers representable in UTF-8, plus the
        /// following special characters: + - = . _ : / @.</p>
        /// </li>
        /// </ul>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
        /// <p>(Optional) Specifies the ARN, Key ID, or alias of the AWS KMS customer master key (CMK) to
        /// be used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values in the
        /// versions stored in this secret.</p>
        /// <p>You can specify any of the supported ways to identify a AWS KMS key ID. If you need to
        /// reference a CMK in a different account, you can use only the key ARN or the alias ARN.</p>
        /// <p>If you don't specify this value, then Secrets Manager defaults to using the AWS account's
        /// default CMK (the one named <code>aws/secretsmanager</code>). If a AWS KMS CMK with that name doesn't yet
        /// exist, then Secrets Manager creates it for you automatically the first time it needs to encrypt a
        /// version's <code>SecretString</code> or <code>SecretBinary</code> fields.</p>
        /// <important>
        /// <p>You can use the account default CMK to encrypt and decrypt only if you call this
        /// operation using credentials from the same account that owns the secret. If the secret
        /// resides in a different account, then you must create a custom CMK and specify the ARN in
        /// this field. </p>
        /// </important>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(inp);
            self
        }
        pub fn set_kms_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(inp);
            self
        }
        /// <p>(Optional) Specifies a user-provided description of the secret.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
        /// the secret.</p>
        /// <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
        /// both. They cannot both be empty.</p>
        /// <p>If you create a secret by using the Secrets Manager console then Secrets Manager puts the protected
        /// secret text in only the <code>SecretString</code> parameter. The Secrets Manager console stores the
        /// information as a JSON structure of key/value pairs that the Lambda rotation function knows how
        /// to parse.</p>
        /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
        /// specify key/value pairs. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
        /// <p>
        /// <code>{"username":"bob","password":"abc123xyz456"}</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
        pub fn secret_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_string(inp);
            self
        }
        pub fn set_secret_string(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_string(inp);
            self
        }
        /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
        /// the secret. To use this parameter in the command-line tools, we recommend that you store your
        /// binary data in a file and then use the appropriate technique for your tool to pass the
        /// contents of the file as a parameter.</p>
        /// <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
        /// both. They cannot both be empty.</p>
        /// <p>This parameter is not available using the Secrets Manager console. It can be accessed only by
        /// using the AWS CLI or one of the AWS SDKs.</p>
        pub fn secret_binary(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.secret_binary(inp);
            self
        }
        pub fn set_secret_binary(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_secret_binary(inp);
            self
        }
        /// <p>(Optional) If you include <code>SecretString</code> or <code>SecretBinary</code>, then an
        /// initial version is created as part of the secret, and this parameter specifies a unique
        /// identifier for the new version. </p>
        /// <note>
        /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes it
        /// as the value for this parameter in the request. If you don't use the SDK and instead
        /// generate a raw HTTP request to the Secrets Manager service endpoint, then you must generate a
        /// <code>ClientRequestToken</code> yourself for the new version and include the value in the
        /// request.</p>
        /// </note>
        /// <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
        /// creation of duplicate versions if there are failures and retries during a rotation. We
        /// recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
        /// ensure uniqueness of your versions within the specified secret. </p>
        /// <ul>
        /// <li>
        /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
        /// of the secret then a new version of the secret is created. </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and the version <code>SecretString</code>
        /// and <code>SecretBinary</code> values are the same as those in the request, then the
        /// request is ignored.</p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> and <code>SecretBinary</code> values are different from those
        /// in the request then the request fails because you cannot modify an existing version.
        /// Instead, use <a>PutSecretValue</a> to create a new version.</p>
        /// </li>
        /// </ul>
        /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteResourcePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_resource_policy_input::Builder,
    }
    impl DeleteResourcePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::DeleteResourcePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specifies the secret that you want to delete the attached resource-based policy for. You
        /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DeleteSecret {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::delete_secret_input::Builder,
    }
    impl DeleteSecret {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DeleteSecretOutput,
            smithy_http::result::SdkError<crate::error::DeleteSecretError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>(Optional) Specifies that the secret is to be deleted without any recovery window. You
        /// can't use both this parameter and the <code>RecoveryWindowInDays</code> parameter in the same
        /// API call.</p>
        /// <p>An asynchronous background process performs the actual deletion, so there can be a short
        /// delay before the operation completes. If you write code to delete and then immediately
        /// recreate a secret with the same name, ensure that your code includes appropriate back off and
        /// retry logic.</p>
        /// <important>
        /// <p>Use this parameter with caution. This parameter causes the operation to skip the normal
        /// waiting period before the permanent deletion that AWS would normally impose with the
        /// <code>RecoveryWindowInDays</code> parameter. If you delete a secret with the
        /// <code>ForceDeleteWithouRecovery</code> parameter, then you have no opportunity to recover
        /// the secret. It is permanently lost.</p>
        /// </important>
        pub fn force_delete_without_recovery(mut self, inp: bool) -> Self {
            self.inner = self.inner.force_delete_without_recovery(inp);
            self
        }
        pub fn set_force_delete_without_recovery(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_force_delete_without_recovery(inp);
            self
        }
        /// <p>(Optional) Specifies the number of days that Secrets Manager waits before it can delete the secret.
        /// You can't use both this parameter and the <code>ForceDeleteWithoutRecovery</code> parameter in
        /// the same API call.</p>
        /// <p>This value can range from 7 to 30 days. The default value is 30.</p>
        pub fn recovery_window_in_days(mut self, inp: i64) -> Self {
            self.inner = self.inner.recovery_window_in_days(inp);
            self
        }
        pub fn set_recovery_window_in_days(mut self, inp: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_recovery_window_in_days(inp);
            self
        }
        /// <p>Specifies the secret that you want to delete. You can specify either the Amazon Resource
        /// Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct DescribeSecret {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::describe_secret_input::Builder,
    }
    impl DescribeSecret {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::DescribeSecretOutput,
            smithy_http::result::SdkError<crate::error::DescribeSecretError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The identifier of the secret whose details you want to retrieve. You can specify either
        /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetRandomPassword {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_random_password_input::Builder,
    }
    impl GetRandomPassword {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetRandomPasswordOutput,
            smithy_http::result::SdkError<crate::error::GetRandomPasswordError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specifies that the generated password should not include digits. The default if you do not
        /// include this switch parameter is that digits can be included.</p>
        pub fn exclude_numbers(mut self, inp: bool) -> Self {
            self.inner = self.inner.exclude_numbers(inp);
            self
        }
        pub fn set_exclude_numbers(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_exclude_numbers(inp);
            self
        }
        /// <p>A string that includes characters that should not be included in the generated password.
        /// The default is that all characters from the included sets can be used.</p>
        pub fn exclude_characters(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.exclude_characters(inp);
            self
        }
        pub fn set_exclude_characters(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_exclude_characters(inp);
            self
        }
        /// <p>The desired length of the generated password. The default value if you do not include this
        /// parameter is 32 characters.</p>
        pub fn password_length(mut self, inp: i64) -> Self {
            self.inner = self.inner.password_length(inp);
            self
        }
        pub fn set_password_length(mut self, inp: std::option::Option<i64>) -> Self {
            self.inner = self.inner.set_password_length(inp);
            self
        }
        /// <p>A boolean value that specifies whether the generated password must include at least one of
        /// every allowed character type. The default value is <code>True</code> and the operation
        /// requires at least one of every character type.</p>
        pub fn require_each_included_type(mut self, inp: bool) -> Self {
            self.inner = self.inner.require_each_included_type(inp);
            self
        }
        pub fn set_require_each_included_type(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_require_each_included_type(inp);
            self
        }
        /// <p>Specifies that the generated password can include the space character. The default if you
        /// do not include this switch parameter is that the space character is not included.</p>
        pub fn include_space(mut self, inp: bool) -> Self {
            self.inner = self.inner.include_space(inp);
            self
        }
        pub fn set_include_space(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_space(inp);
            self
        }
        /// <p>Specifies that the generated password should not include punctuation characters. The
        /// default if you do not include this switch parameter is that punctuation characters can be
        /// included.</p>
        /// <p>The following are the punctuation characters that <i>can</i> be included in
        /// the generated password if you don't explicitly exclude them with
        /// <code>ExcludeCharacters</code> or <code>ExcludePunctuation</code>:</p>
        /// <p>
        /// <code>! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | }
        /// ~</code>
        /// </p>
        pub fn exclude_punctuation(mut self, inp: bool) -> Self {
            self.inner = self.inner.exclude_punctuation(inp);
            self
        }
        pub fn set_exclude_punctuation(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_exclude_punctuation(inp);
            self
        }
        /// <p>Specifies that the generated password should not include lowercase letters. The default if
        /// you do not include this switch parameter is that lowercase letters can be included.</p>
        pub fn exclude_lowercase(mut self, inp: bool) -> Self {
            self.inner = self.inner.exclude_lowercase(inp);
            self
        }
        pub fn set_exclude_lowercase(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_exclude_lowercase(inp);
            self
        }
        /// <p>Specifies that the generated password should not include uppercase letters. The default if
        /// you do not include this switch parameter is that uppercase letters can be included.</p>
        pub fn exclude_uppercase(mut self, inp: bool) -> Self {
            self.inner = self.inner.exclude_uppercase(inp);
            self
        }
        pub fn set_exclude_uppercase(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_exclude_uppercase(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetResourcePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_resource_policy_input::Builder,
    }
    impl GetResourcePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::GetResourcePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specifies the secret that you want to retrieve the attached resource-based policy for. You
        /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct GetSecretValue {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::get_secret_value_input::Builder,
    }
    impl GetSecretValue {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::GetSecretValueOutput,
            smithy_http::result::SdkError<crate::error::GetSecretValueError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specifies the secret containing the version that you want to retrieve. You can specify
        /// either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
        /// <p>Specifies the secret version that you want to retrieve by the staging label attached to
        /// the version.</p>
        /// <p>Staging labels are used to keep track of different versions during the rotation process.
        /// If you use this parameter then don't specify <code>VersionId</code>. If you don't
        /// specify either a <code>VersionStage</code> or <code>VersionId</code>, then the default is to
        /// perform the operation on the version with the <code>VersionStage</code> value of
        /// <code>AWSCURRENT</code>.</p>
        pub fn version_stage(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_stage(inp);
            self
        }
        pub fn set_version_stage(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_stage(inp);
            self
        }
        /// <p>Specifies the unique identifier of the version of the secret that you want to retrieve. If
        /// you specify this parameter then don't specify <code>VersionStage</code>. If you
        /// don't specify either a <code>VersionStage</code> or <code>VersionId</code> then the
        /// default is to perform the operation on the version with the <code>VersionStage</code> value of
        /// <code>AWSCURRENT</code>.</p>
        /// <p>This value is typically a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value with
        /// 32 hexadecimal digits.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_id(inp);
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListSecrets {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_secrets_input::Builder,
    }
    impl ListSecrets {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListSecretsOutput,
            smithy_http::result::SdkError<crate::error::ListSecretsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>(Optional) Limits the number of results you want to include in
        /// the response. If you don't include this parameter, it defaults to a value that's
        /// specific to the operation. If additional items exist beyond the maximum you specify, the
        /// <code>NextToken</code> response element is present and has a value (isn't null). Include
        /// that value as the <code>NextToken</code> request parameter in the next call to the operation to
        /// get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
        /// even when there are more results available. You should check <code>NextToken</code> after every
        /// operation to ensure that you receive all of the results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>Lists secrets in the requested order. </p>
        pub fn sort_order(mut self, inp: crate::model::SortOrderType) -> Self {
            self.inner = self.inner.sort_order(inp);
            self
        }
        pub fn set_sort_order(
            mut self,
            inp: std::option::Option<crate::model::SortOrderType>,
        ) -> Self {
            self.inner = self.inner.set_sort_order(inp);
            self
        }
        /// <p>(Optional) Use this parameter in a request if you receive a
        /// <code>NextToken</code> response in a previous request indicating there's more
        /// output available. In a subsequent call, set it to the value of the previous call
        /// <code>NextToken</code> response to indicate where the output should continue from.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>Lists the secret request filters.</p>
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            self.inner = self.inner.filters(inp);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.inner = self.inner.set_filters(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ListSecretVersionIds {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::list_secret_version_ids_input::Builder,
    }
    impl ListSecretVersionIds {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ListSecretVersionIdsOutput,
            smithy_http::result::SdkError<crate::error::ListSecretVersionIdsError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>(Optional) Limits the number of results you want to include in
        /// the response. If you don't include this parameter, it defaults to a value that's
        /// specific to the operation. If additional items exist beyond the maximum you specify, the
        /// <code>NextToken</code> response element is present and has a value (isn't null). Include
        /// that value as the <code>NextToken</code> request parameter in the next call to the operation to
        /// get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
        /// even when there are more results available. You should check <code>NextToken</code> after every
        /// operation to ensure that you receive all of the results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.inner = self.inner.max_results(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(inp);
            self
        }
        /// <p>The identifier for the secret containing the versions you want to list. You can specify
        /// either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
        /// <p>(Optional) Use this parameter in a request if you receive a
        /// <code>NextToken</code> response in a previous request indicating there's more
        /// output available. In a subsequent call, set it to the value of the previous call
        /// <code>NextToken</code> response to indicate where the output should continue from.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(inp);
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(inp);
            self
        }
        /// <p>(Optional) Specifies that you want the results to include versions that do not have any
        /// staging labels attached to them. Such versions are considered deprecated and are subject to
        /// deletion by Secrets Manager as needed.</p>
        pub fn include_deprecated(mut self, inp: bool) -> Self {
            self.inner = self.inner.include_deprecated(inp);
            self
        }
        pub fn set_include_deprecated(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_include_deprecated(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct PutResourcePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_resource_policy_input::Builder,
    }
    impl PutResourcePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::PutResourcePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>A JSON-formatted string that's constructed according to the grammar and syntax for an
        /// AWS resource-based policy. The policy in the string identifies who can access or manage this
        /// secret and its versions. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
        /// JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
        pub fn resource_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_policy(inp);
            self
        }
        pub fn set_resource_policy(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_policy(inp);
            self
        }
        /// <p>Makes an optional API call to Zelkova to validate the Resource Policy to prevent broad access to your secret.</p>
        pub fn block_public_policy(mut self, inp: bool) -> Self {
            self.inner = self.inner.block_public_policy(inp);
            self
        }
        pub fn set_block_public_policy(mut self, inp: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_block_public_policy(inp);
            self
        }
        /// <p>Specifies the secret that you want to attach the resource-based policy to. You can specify
        /// either the ARN or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct PutSecretValue {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::put_secret_value_input::Builder,
    }
    impl PutSecretValue {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::PutSecretValueOutput,
            smithy_http::result::SdkError<crate::error::PutSecretValueError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>(Optional) Specifies a unique identifier for the new version of the secret. </p>
        /// <note>
        /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
        /// in the request. If you don't use the SDK and instead generate a raw HTTP request to the
        /// Secrets Manager service endpoint, then you must generate a <code>ClientRequestToken</code> yourself
        /// for new versions and include that value in the request. </p>
        /// </note>
        /// <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
        /// creation of duplicate versions if there are failures and retries during the Lambda rotation
        /// function's processing. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
        /// ensure uniqueness within the specified secret. </p>
        /// <ul>
        /// <li>
        /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
        /// of the secret then a new version of the secret is created. </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> or <code>SecretBinary</code> values are the same as those in
        /// the request then the request is ignored (the operation is idempotent). </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and the version of the
        /// <code>SecretString</code> and <code>SecretBinary</code> values are different from those
        /// in the request then the request fails because you cannot modify an existing secret
        /// version. You can only create new versions to store new secret values.</p>
        /// </li>
        /// </ul>
        /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(inp);
            self
        }
        /// <p>Specifies the secret to which you want to add a new version. You can specify either the
        /// Amazon Resource Name (ARN) or the friendly name of the secret. The secret must already
        /// exist.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
        /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
        /// the secret. Either <code>SecretString</code> or <code>SecretBinary</code> must have a value,
        /// but not both. They cannot both be empty.</p>
        /// <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
        /// protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
        /// stores the information as a JSON structure of key/value pairs that the default Lambda rotation
        /// function knows how to parse.</p>
        /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
        /// specify key/value pairs. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
        /// <p> For example:</p>
        /// <p>
        /// <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text.</p>
        pub fn secret_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_string(inp);
            self
        }
        pub fn set_secret_string(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_string(inp);
            self
        }
        /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
        /// the secret. To use this parameter in the command-line tools, we recommend that you store your
        /// binary data in a file and then use the appropriate technique for your tool to pass the
        /// contents of the file as a parameter. Either <code>SecretBinary</code> or
        /// <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
        /// <p>This parameter is not accessible if the secret using the Secrets Manager console.</p>
        /// <p></p>
        pub fn secret_binary(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.secret_binary(inp);
            self
        }
        pub fn set_secret_binary(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_secret_binary(inp);
            self
        }
        /// <p>(Optional) Specifies a list of staging labels that are attached to this version of the
        /// secret. These staging labels are used to track the versions through the rotation process by
        /// the Lambda rotation function.</p>
        /// <p>A staging label must be unique to a single version of the secret. If you specify a staging
        /// label that's already associated with a different version of the same secret then that staging
        /// label is automatically removed from the other version and attached to this version.</p>
        /// <p>If you do not specify a value for <code>VersionStages</code> then Secrets Manager automatically
        /// moves the staging label <code>AWSCURRENT</code> to this new version.</p>
        pub fn version_stages(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_stages(inp);
            self
        }
        pub fn set_version_stages(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_version_stages(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct RestoreSecret {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::restore_secret_input::Builder,
    }
    impl RestoreSecret {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RestoreSecretOutput,
            smithy_http::result::SdkError<crate::error::RestoreSecretError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specifies the secret that you want to restore from a previously scheduled deletion. You
        /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct RotateSecret {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::rotate_secret_input::Builder,
    }
    impl RotateSecret {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::RotateSecretOutput,
            smithy_http::result::SdkError<crate::error::RotateSecretError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Specifies the secret that you want to rotate. You can specify either the Amazon Resource
        /// Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
        /// <p>(Optional) Specifies a unique identifier for the new version of the secret that helps
        /// ensure idempotency. </p>
        /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
        /// in the request for this parameter. If you don't use the SDK and instead generate a raw HTTP
        /// request to the Secrets Manager service endpoint, then you must generate a
        /// <code>ClientRequestToken</code> yourself for new versions and include that value in the
        /// request.</p>
        /// <p>You only need to specify your own value if you implement your own retry logic and want to
        /// ensure that a given secret is not created twice. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
        /// ensure uniqueness within the specified secret. </p>
        /// <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
        /// there are failures and retries during the function's processing. This value becomes the
        /// <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(inp);
            self
        }
        /// <p>A structure that defines the rotation configuration for this secret.</p>
        pub fn rotation_rules(mut self, inp: crate::model::RotationRulesType) -> Self {
            self.inner = self.inner.rotation_rules(inp);
            self
        }
        pub fn set_rotation_rules(
            mut self,
            inp: std::option::Option<crate::model::RotationRulesType>,
        ) -> Self {
            self.inner = self.inner.set_rotation_rules(inp);
            self
        }
        /// <p>(Optional) Specifies the ARN of the Lambda function that can rotate the secret.</p>
        pub fn rotation_lambda_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.rotation_lambda_arn(inp);
            self
        }
        pub fn set_rotation_lambda_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_rotation_lambda_arn(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct TagResource {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl TagResource {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>The identifier for the secret that you want to attach tags to. You can specify either the
        /// Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
        /// <p>The tags to attach to the secret. Each element in the list consists of a <code>Key</code>
        /// and a <code>Value</code>.</p>
        /// <p>This parameter to the API requires a JSON text string argument. For information on how to
        /// format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>. For the
        /// AWS CLI, you can also use the syntax: <code>--Tags
        /// Key="Key1",Value="Value1",Key="Key2",Value="Value2"[,…]</code>
        /// </p>
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            self.inner = self.inner.tags(inp);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.inner = self.inner.set_tags(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UntagResource {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl UntagResource {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>A list of tag key names to remove from the secret. You don't specify the value. Both the
        /// key and its associated value are removed.</p>
        /// <p>This parameter to the API requires a JSON text string argument. For information on how to
        /// format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(inp);
            self
        }
        /// <p>The identifier for the secret that you want to remove tags from. You can specify either
        /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateSecret {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_secret_input::Builder,
    }
    impl UpdateSecret {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateSecretOutput,
            smithy_http::result::SdkError<crate::error::UpdateSecretError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>(Optional) Specifies updated text data that you want to encrypt and store in this new
        /// version of the secret. Either <code>SecretBinary</code> or <code>SecretString</code> must have
        /// a value, but not both. They cannot both be empty.</p>
        /// <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
        /// protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
        /// stores the information as a JSON structure of key/value pairs that the default Lambda rotation
        /// function knows how to parse.</p>
        /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
        /// specify key/value pairs. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
        /// <p>
        /// <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text. You can
        /// also 'escape' the double quote character in the embedded JSON text by prefacing each with a
        /// backslash. For example, the following string is surrounded by double-quotes. All of the
        /// embedded double quotes are escaped:</p>
        /// <p>
        /// <code>"[{\"username\":\"bob\"},{\"password\":\"abc123xyz456\"}]"</code>
        /// </p>
        pub fn secret_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_string(inp);
            self
        }
        pub fn set_secret_string(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_string(inp);
            self
        }
        /// <p>(Optional) Specifies an updated ARN or alias of the AWS KMS customer master key (CMK) to be
        /// used to encrypt the protected text in new versions of this secret.</p>
        /// <important>
        /// <p>You can only use the account's default CMK to encrypt and decrypt if you call this
        /// operation using credentials from the same account that owns the secret. If the secret is in
        /// a different account, then you must create a custom CMK and provide the ARN of that CMK in
        /// this field. The user making the call must have permissions to both the secret and the CMK in
        /// their respective accounts.</p>
        /// </important>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.kms_key_id(inp);
            self
        }
        pub fn set_kms_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_kms_key_id(inp);
            self
        }
        /// <p>Specifies the secret that you want to modify or to which you want to add a new version.
        /// You can specify either the Amazon Resource Name (ARN) or the friendly name of the
        /// secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
        /// <p>(Optional) Specifies an updated user-provided description of the secret.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(inp);
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(inp);
            self
        }
        /// <p>(Optional) If you want to add a new version to the secret, this parameter specifies a
        /// unique identifier for the new version that helps ensure idempotency. </p>
        /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
        /// in the request. If you don't use the SDK and instead generate a raw HTTP request to the Secrets Manager
        /// service endpoint, then you must generate a <code>ClientRequestToken</code> yourself for new
        /// versions and include that value in the request.</p>
        /// <p>You typically only need to interact with this value if you implement your own retry logic
        /// and want to ensure that a given secret is not created twice. We recommend that you generate a
        /// <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a>
        /// value to ensure uniqueness within the specified secret. </p>
        /// <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
        /// there are failures and retries during the Lambda rotation function's processing.</p>
        /// <ul>
        /// <li>
        /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
        /// of the secret then a new version of the secret is created. </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> and <code>SecretBinary</code> values are the same as those in
        /// the request then the request is ignored (the operation is idempotent). </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> and <code>SecretBinary</code> values are different from the
        /// request then an error occurs because you cannot modify an existing secret value.</p>
        /// </li>
        /// </ul>
        /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(inp);
            self
        }
        pub fn set_client_request_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(inp);
            self
        }
        /// <p>(Optional) Specifies updated binary data that you want to encrypt and store in the new
        /// version of the secret. To use this parameter in the command-line tools, we recommend that you
        /// store your binary data in a file and then use the appropriate technique for your tool to pass
        /// the contents of the file as a parameter. Either <code>SecretBinary</code> or
        /// <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
        /// <p>This parameter is not accessible using the Secrets Manager console.</p>
        pub fn secret_binary(mut self, inp: smithy_types::Blob) -> Self {
            self.inner = self.inner.secret_binary(inp);
            self
        }
        pub fn set_secret_binary(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_secret_binary(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct UpdateSecretVersionStage {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::update_secret_version_stage_input::Builder,
    }
    impl UpdateSecretVersionStage {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::UpdateSecretVersionStageOutput,
            smithy_http::result::SdkError<crate::error::UpdateSecretVersionStageError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>(Optional) The secret version ID that you want to add the staging label. If you want to
        /// remove a label from a version, then do not specify this parameter.</p>
        /// <p>If the staging label is already attached to a different version of the secret, then you
        /// must also specify the <code>RemoveFromVersionId</code> parameter. </p>
        pub fn move_to_version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.move_to_version_id(inp);
            self
        }
        pub fn set_move_to_version_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_move_to_version_id(inp);
            self
        }
        /// <p>Specifies the secret with the version with the list of staging labels you want to modify.
        /// You can specify either the Amazon Resource Name (ARN) or the friendly name of the
        /// secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
        /// <p>Specifies the secret version ID of the version that the staging label is to be removed
        /// from. If the staging label you are trying to attach to one version is already attached to a
        /// different version, then you must include this parameter and specify the version that the label
        /// is to be removed from. If the label is attached and you either do not specify this parameter,
        /// or the version ID does not match, then the operation fails.</p>
        pub fn remove_from_version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.remove_from_version_id(inp);
            self
        }
        pub fn set_remove_from_version_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_remove_from_version_id(inp);
            self
        }
        /// <p>The staging label to add to this version.</p>
        pub fn version_stage(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.version_stage(inp);
            self
        }
        pub fn set_version_stage(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_version_stage(inp);
            self
        }
    }

    #[derive(std::fmt::Debug)]
    pub struct ValidateResourcePolicy {
        handle: std::sync::Arc<super::Handle>,
        inner: crate::input::validate_resource_policy_input::Builder,
    }
    impl ValidateResourcePolicy {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> Result<
            crate::output::ValidateResourcePolicyOutput,
            smithy_http::result::SdkError<crate::error::ValidateResourcePolicyError>,
        > {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }

        /// <p>Identifies the Resource Policy attached to the secret.</p>
        pub fn resource_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_policy(inp);
            self
        }
        pub fn set_resource_policy(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_resource_policy(inp);
            self
        }
        /// <p> The identifier for the secret that you want to validate a resource policy. You can specify either
        /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.secret_id(inp);
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_secret_id(inp);
            self
        }
    }
}
