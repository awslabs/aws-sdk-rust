// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl CreateSecretInput {
    /// Consumes the builder and constructs an Operation<[`CreateSecret`](crate::operation::create_secret::CreateSecret)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(mut self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::create_secret::CreateSecret, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        if self.client_request_token.is_none() {
                                self.client_request_token = Some(_config.make_token.make_idempotency_token());
                            }
        let mut request = {
            fn uri_base(_input: &crate::operation::create_secret::CreateSecretInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::operation::create_secret::CreateSecretInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "secretsmanager.CreateSecret"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_create_secret::ser_create_secret_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::meta::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::create_secret::CreateSecret::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("CreateSecret", "secretsmanager"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `CreateSecret`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct CreateSecret;
impl CreateSecret {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for CreateSecret {
                type Output = std::result::Result<crate::operation::create_secret::CreateSecretOutput, crate::operation::create_secret::CreateSecretError>;
                fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
                     tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
                     if !response.status().is_success() && response.status().as_u16() != 200 {
                        crate::protocol_serde::shape_create_secret::de_create_secret_http_error(response)
                     } else {
                        crate::protocol_serde::shape_create_secret::de_create_secret_http_response(response)
                     }
                }
            }

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type CreateSecretErrorKind = CreateSecretError;
/// Error type for the `CreateSecretError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSecretError {
    /// <p>Secrets Manager can't decrypt the protected secret text using the provided KMS key. </p>
    DecryptionFailure(crate::types::error::DecryptionFailure),
    /// <p>Secrets Manager can't encrypt the protected secret text using the provided KMS key. Check that the KMS key is available, enabled, and not in an invalid state. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">Key state: Effect on your KMS key</a>.</p>
    EncryptionFailure(crate::types::error::EncryptionFailure),
    /// <p>An error occurred on the server side.</p>
    InternalServiceError(crate::types::error::InternalServiceError),
    /// <p>The parameter name or value is invalid.</p>
    InvalidParameterException(crate::types::error::InvalidParameterException),
    /// <p>A parameter value is not valid for the current state of the resource.</p> 
    /// <p>Possible causes:</p> 
    /// <ul> 
    /// <li> <p>The secret is scheduled for deletion.</p> </li> 
    /// <li> <p>You tried to enable rotation on a secret that doesn't already have a Lambda function ARN configured and you didn't include such an ARN as a parameter in this call. </p> </li> 
    /// <li> <p>The secret is managed by another service, and you must use that service to update it. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/service-linked-secrets.html">Secrets managed by other Amazon Web Services services</a>.</p> </li> 
    /// </ul>
    InvalidRequestException(crate::types::error::InvalidRequestException),
    /// <p>The request failed because it would exceed one of the Secrets Manager quotas.</p>
    LimitExceededException(crate::types::error::LimitExceededException),
    /// <p>The resource policy has syntax errors.</p>
    MalformedPolicyDocumentException(crate::types::error::MalformedPolicyDocumentException),
    /// <p>The request failed because you did not complete all the prerequisite steps.</p>
    PreconditionNotMetException(crate::types::error::PreconditionNotMetException),
    /// <p>A resource with the ID you requested already exists.</p>
    ResourceExistsException(crate::types::error::ResourceExistsException),
    /// <p>Secrets Manager can't find the resource that you asked for.</p>
    ResourceNotFoundException(crate::types::error::ResourceNotFoundException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateSecretError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for CreateSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DecryptionFailure(_inner) =>
            _inner.fmt(f)
            ,
            Self::EncryptionFailure(_inner) =>
            _inner.fmt(f)
            ,
            Self::InternalServiceError(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidParameterException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidRequestException(_inner) =>
            _inner.fmt(f)
            ,
            Self::LimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::MalformedPolicyDocumentException(_inner) =>
            _inner.fmt(f)
            ,
            Self::PreconditionNotMetException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceExistsException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ResourceNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateSecretError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::DecryptionFailure(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::EncryptionFailure(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InternalServiceError(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidParameterException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidRequestException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::MalformedPolicyDocumentException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::PreconditionNotMetException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceExistsException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::operation::create_secret::CreateSecretError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for CreateSecretError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSecretError {
    /// Creates the `CreateSecretError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `CreateSecretError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::DecryptionFailure(e) => e.meta(),
            Self::EncryptionFailure(e) => e.meta(),
            Self::InternalServiceError(e) => e.meta(),
            Self::InvalidParameterException(e) => e.meta(),
            Self::InvalidRequestException(e) => e.meta(),
            Self::LimitExceededException(e) => e.meta(),
            Self::MalformedPolicyDocumentException(e) => e.meta(),
            Self::PreconditionNotMetException(e) => e.meta(),
            Self::ResourceExistsException(e) => e.meta(),
            Self::ResourceNotFoundException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateSecretError::DecryptionFailure`.
    pub fn is_decryption_failure(&self) -> bool {
        matches!(self, Self::DecryptionFailure(_))
    }
    /// Returns `true` if the error kind is `CreateSecretError::EncryptionFailure`.
    pub fn is_encryption_failure(&self) -> bool {
        matches!(self, Self::EncryptionFailure(_))
    }
    /// Returns `true` if the error kind is `CreateSecretError::InternalServiceError`.
    pub fn is_internal_service_error(&self) -> bool {
        matches!(self, Self::InternalServiceError(_))
    }
    /// Returns `true` if the error kind is `CreateSecretError::InvalidParameterException`.
    pub fn is_invalid_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateSecretError::InvalidRequestException`.
    pub fn is_invalid_request_exception(&self) -> bool {
        matches!(self, Self::InvalidRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateSecretError::LimitExceededException`.
    pub fn is_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::LimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateSecretError::MalformedPolicyDocumentException`.
    pub fn is_malformed_policy_document_exception(&self) -> bool {
        matches!(self, Self::MalformedPolicyDocumentException(_))
    }
    /// Returns `true` if the error kind is `CreateSecretError::PreconditionNotMetException`.
    pub fn is_precondition_not_met_exception(&self) -> bool {
        matches!(self, Self::PreconditionNotMetException(_))
    }
    /// Returns `true` if the error kind is `CreateSecretError::ResourceExistsException`.
    pub fn is_resource_exists_exception(&self) -> bool {
        matches!(self, Self::ResourceExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateSecretError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(self, Self::ResourceNotFoundException(_))
    }
}
impl std::error::Error for CreateSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::DecryptionFailure(_inner) =>
            Some(_inner)
            ,
            Self::EncryptionFailure(_inner) =>
            Some(_inner)
            ,
            Self::InternalServiceError(_inner) =>
            Some(_inner)
            ,
            Self::InvalidParameterException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidRequestException(_inner) =>
            Some(_inner)
            ,
            Self::LimitExceededException(_inner) =>
            Some(_inner)
            ,
            Self::MalformedPolicyDocumentException(_inner) =>
            Some(_inner)
            ,
            Self::PreconditionNotMetException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceExistsException(_inner) =>
            Some(_inner)
            ,
            Self::ResourceNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

pub use crate::operation::create_secret::_create_secret_output::CreateSecretOutput;

pub use crate::operation::create_secret::_create_secret_input::CreateSecretInput;

mod _create_secret_input;

mod _create_secret_output;

/// Builders
pub mod builders;

