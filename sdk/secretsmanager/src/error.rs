// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelRotateSecretError {
    pub kind: CancelRotateSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelRotateSecretErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelRotateSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelRotateSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            CancelRotateSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CancelRotateSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            CancelRotateSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            CancelRotateSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelRotateSecretError {
    fn code(&self) -> Option<&str> {
        CancelRotateSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CancelRotateSecretError {
    pub fn new(kind: CancelRotateSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelRotateSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelRotateSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelRotateSecretErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelRotateSecretErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelRotateSecretErrorKind::InvalidRequestError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            CancelRotateSecretErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for CancelRotateSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelRotateSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            CancelRotateSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CancelRotateSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            CancelRotateSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            CancelRotateSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSecretError {
    pub kind: CreateSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSecretErrorKind {
    EncryptionFailure(crate::error::EncryptionFailure),
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    PreconditionNotMetError(crate::error::PreconditionNotMetError),
    ResourceExistsError(crate::error::ResourceExistsError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSecretErrorKind::EncryptionFailure(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::PreconditionNotMetError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::ResourceExistsError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSecretError {
    fn code(&self) -> Option<&str> {
        CreateSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateSecretError {
    pub fn new(kind: CreateSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_failure(&self) -> bool {
        matches!(&self.kind, CreateSecretErrorKind::EncryptionFailure(_))
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, CreateSecretErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, CreateSecretErrorKind::InvalidParameterError(_))
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(&self.kind, CreateSecretErrorKind::InvalidRequestError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, CreateSecretErrorKind::LimitExceededError(_))
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecretErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_precondition_not_met_error(&self) -> bool {
        matches!(
            &self.kind,
            CreateSecretErrorKind::PreconditionNotMetError(_)
        )
    }
    pub fn is_resource_exists_error(&self) -> bool {
        matches!(&self.kind, CreateSecretErrorKind::ResourceExistsError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, CreateSecretErrorKind::ResourceNotFoundError(_))
    }
}
impl std::error::Error for CreateSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSecretErrorKind::EncryptionFailure(_inner) => Some(_inner),
            CreateSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            CreateSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreateSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            CreateSecretErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateSecretErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            CreateSecretErrorKind::PreconditionNotMetError(_inner) => Some(_inner),
            CreateSecretErrorKind::ResourceExistsError(_inner) => Some(_inner),
            CreateSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            CreateSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourcePolicyError {
    pub kind: DeleteResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourcePolicyErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourcePolicyErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourcePolicyError {
    fn code(&self) -> Option<&str> {
        DeleteResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteResourcePolicyError {
    pub fn new(kind: DeleteResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::InvalidRequestError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DeleteResourcePolicyErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for DeleteResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourcePolicyErrorKind::InternalServiceError(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::InvalidRequestError(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSecretError {
    pub kind: DeleteSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSecretErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            DeleteSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            DeleteSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSecretError {
    fn code(&self) -> Option<&str> {
        DeleteSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteSecretError {
    pub fn new(kind: DeleteSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, DeleteSecretErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, DeleteSecretErrorKind::InvalidParameterError(_))
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(&self.kind, DeleteSecretErrorKind::InvalidRequestError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, DeleteSecretErrorKind::ResourceNotFoundError(_))
    }
}
impl std::error::Error for DeleteSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            DeleteSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            DeleteSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSecretError {
    pub kind: DescribeSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSecretErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            DescribeSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSecretError {
    fn code(&self) -> Option<&str> {
        DescribeSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeSecretError {
    pub fn new(kind: DescribeSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, DescribeSecretErrorKind::InternalServiceError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            DescribeSecretErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for DescribeSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            DescribeSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRandomPasswordError {
    pub kind: GetRandomPasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRandomPasswordErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRandomPasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRandomPasswordErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            GetRandomPasswordErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetRandomPasswordErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            GetRandomPasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRandomPasswordError {
    fn code(&self) -> Option<&str> {
        GetRandomPasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRandomPasswordError {
    pub fn new(kind: GetRandomPasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRandomPasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRandomPasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            GetRandomPasswordErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            GetRandomPasswordErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(
            &self.kind,
            GetRandomPasswordErrorKind::InvalidRequestError(_)
        )
    }
}
impl std::error::Error for GetRandomPasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRandomPasswordErrorKind::InternalServiceError(_inner) => Some(_inner),
            GetRandomPasswordErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetRandomPasswordErrorKind::InvalidRequestError(_inner) => Some(_inner),
            GetRandomPasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResourcePolicyError {
    pub kind: GetResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourcePolicyErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResourcePolicyErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            GetResourcePolicyErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            GetResourcePolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResourcePolicyError {
    fn code(&self) -> Option<&str> {
        GetResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetResourcePolicyError {
    pub fn new(kind: GetResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePolicyErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePolicyErrorKind::InvalidRequestError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetResourcePolicyErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for GetResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResourcePolicyErrorKind::InternalServiceError(_inner) => Some(_inner),
            GetResourcePolicyErrorKind::InvalidRequestError(_inner) => Some(_inner),
            GetResourcePolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSecretValueError {
    pub kind: GetSecretValueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSecretValueErrorKind {
    DecryptionFailure(crate::error::DecryptionFailure),
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSecretValueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSecretValueErrorKind::DecryptionFailure(_inner) => _inner.fmt(f),
            GetSecretValueErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            GetSecretValueErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetSecretValueErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            GetSecretValueErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetSecretValueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSecretValueError {
    fn code(&self) -> Option<&str> {
        GetSecretValueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetSecretValueError {
    pub fn new(kind: GetSecretValueErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSecretValueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSecretValueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_decryption_failure(&self) -> bool {
        matches!(&self.kind, GetSecretValueErrorKind::DecryptionFailure(_))
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, GetSecretValueErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            GetSecretValueErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(&self.kind, GetSecretValueErrorKind::InvalidRequestError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            GetSecretValueErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for GetSecretValueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSecretValueErrorKind::DecryptionFailure(_inner) => Some(_inner),
            GetSecretValueErrorKind::InternalServiceError(_inner) => Some(_inner),
            GetSecretValueErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetSecretValueErrorKind::InvalidRequestError(_inner) => Some(_inner),
            GetSecretValueErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetSecretValueErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSecretsError {
    pub kind: ListSecretsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSecretsErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidNextTokenError(crate::error::InvalidNextTokenError),
    InvalidParameterError(crate::error::InvalidParameterError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSecretsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSecretsErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ListSecretsErrorKind::InvalidNextTokenError(_inner) => _inner.fmt(f),
            ListSecretsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListSecretsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSecretsError {
    fn code(&self) -> Option<&str> {
        ListSecretsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSecretsError {
    pub fn new(kind: ListSecretsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSecretsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSecretsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, ListSecretsErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_next_token_error(&self) -> bool {
        matches!(&self.kind, ListSecretsErrorKind::InvalidNextTokenError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, ListSecretsErrorKind::InvalidParameterError(_))
    }
}
impl std::error::Error for ListSecretsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSecretsErrorKind::InternalServiceError(_inner) => Some(_inner),
            ListSecretsErrorKind::InvalidNextTokenError(_inner) => Some(_inner),
            ListSecretsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListSecretsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSecretVersionIdsError {
    pub kind: ListSecretVersionIdsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSecretVersionIdsErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidNextTokenError(crate::error::InvalidNextTokenError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSecretVersionIdsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSecretVersionIdsErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ListSecretVersionIdsErrorKind::InvalidNextTokenError(_inner) => _inner.fmt(f),
            ListSecretVersionIdsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListSecretVersionIdsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSecretVersionIdsError {
    fn code(&self) -> Option<&str> {
        ListSecretVersionIdsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListSecretVersionIdsError {
    pub fn new(kind: ListSecretVersionIdsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSecretVersionIdsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSecretVersionIdsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSecretVersionIdsErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_next_token_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSecretVersionIdsErrorKind::InvalidNextTokenError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ListSecretVersionIdsErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for ListSecretVersionIdsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSecretVersionIdsErrorKind::InternalServiceError(_inner) => Some(_inner),
            ListSecretVersionIdsErrorKind::InvalidNextTokenError(_inner) => Some(_inner),
            ListSecretVersionIdsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListSecretVersionIdsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutResourcePolicyError {
    pub kind: PutResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutResourcePolicyErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    PublicPolicyError(crate::error::PublicPolicyError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutResourcePolicyErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::PublicPolicyError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutResourcePolicyError {
    fn code(&self) -> Option<&str> {
        PutResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutResourcePolicyError {
    pub fn new(kind: PutResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::InvalidRequestError(_)
        )
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_public_policy_error(&self) -> bool {
        matches!(&self.kind, PutResourcePolicyErrorKind::PublicPolicyError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutResourcePolicyErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for PutResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutResourcePolicyErrorKind::InternalServiceError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::InvalidRequestError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::PublicPolicyError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSecretValueError {
    pub kind: PutSecretValueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSecretValueErrorKind {
    EncryptionFailure(crate::error::EncryptionFailure),
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceExistsError(crate::error::ResourceExistsError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutSecretValueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSecretValueErrorKind::EncryptionFailure(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::ResourceExistsError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutSecretValueError {
    fn code(&self) -> Option<&str> {
        PutSecretValueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutSecretValueError {
    pub fn new(kind: PutSecretValueErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSecretValueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSecretValueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_failure(&self) -> bool {
        matches!(&self.kind, PutSecretValueErrorKind::EncryptionFailure(_))
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, PutSecretValueErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            PutSecretValueErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(&self.kind, PutSecretValueErrorKind::InvalidRequestError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, PutSecretValueErrorKind::LimitExceededError(_))
    }
    pub fn is_resource_exists_error(&self) -> bool {
        matches!(&self.kind, PutSecretValueErrorKind::ResourceExistsError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            PutSecretValueErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for PutSecretValueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSecretValueErrorKind::EncryptionFailure(_inner) => Some(_inner),
            PutSecretValueErrorKind::InternalServiceError(_inner) => Some(_inner),
            PutSecretValueErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutSecretValueErrorKind::InvalidRequestError(_inner) => Some(_inner),
            PutSecretValueErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutSecretValueErrorKind::ResourceExistsError(_inner) => Some(_inner),
            PutSecretValueErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutSecretValueErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RemoveRegionsFromReplicationError {
    pub kind: RemoveRegionsFromReplicationErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RemoveRegionsFromReplicationErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RemoveRegionsFromReplicationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RemoveRegionsFromReplicationErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            RemoveRegionsFromReplicationErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            RemoveRegionsFromReplicationErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            RemoveRegionsFromReplicationErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            RemoveRegionsFromReplicationErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RemoveRegionsFromReplicationError {
    fn code(&self) -> Option<&str> {
        RemoveRegionsFromReplicationError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RemoveRegionsFromReplicationError {
    pub fn new(kind: RemoveRegionsFromReplicationErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RemoveRegionsFromReplicationErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RemoveRegionsFromReplicationErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRegionsFromReplicationErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRegionsFromReplicationErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRegionsFromReplicationErrorKind::InvalidRequestError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            RemoveRegionsFromReplicationErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for RemoveRegionsFromReplicationError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RemoveRegionsFromReplicationErrorKind::InternalServiceError(_inner) => Some(_inner),
            RemoveRegionsFromReplicationErrorKind::InvalidParameterError(_inner) => Some(_inner),
            RemoveRegionsFromReplicationErrorKind::InvalidRequestError(_inner) => Some(_inner),
            RemoveRegionsFromReplicationErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            RemoveRegionsFromReplicationErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ReplicateSecretToRegionsError {
    pub kind: ReplicateSecretToRegionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ReplicateSecretToRegionsErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ReplicateSecretToRegionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ReplicateSecretToRegionsErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ReplicateSecretToRegionsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ReplicateSecretToRegionsErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            ReplicateSecretToRegionsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ReplicateSecretToRegionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ReplicateSecretToRegionsError {
    fn code(&self) -> Option<&str> {
        ReplicateSecretToRegionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ReplicateSecretToRegionsError {
    pub fn new(kind: ReplicateSecretToRegionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ReplicateSecretToRegionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ReplicateSecretToRegionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            ReplicateSecretToRegionsErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ReplicateSecretToRegionsErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ReplicateSecretToRegionsErrorKind::InvalidRequestError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ReplicateSecretToRegionsErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for ReplicateSecretToRegionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ReplicateSecretToRegionsErrorKind::InternalServiceError(_inner) => Some(_inner),
            ReplicateSecretToRegionsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ReplicateSecretToRegionsErrorKind::InvalidRequestError(_inner) => Some(_inner),
            ReplicateSecretToRegionsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ReplicateSecretToRegionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreSecretError {
    pub kind: RestoreSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreSecretErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            RestoreSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            RestoreSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            RestoreSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            RestoreSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreSecretError {
    fn code(&self) -> Option<&str> {
        RestoreSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RestoreSecretError {
    pub fn new(kind: RestoreSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, RestoreSecretErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, RestoreSecretErrorKind::InvalidParameterError(_))
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(&self.kind, RestoreSecretErrorKind::InvalidRequestError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, RestoreSecretErrorKind::ResourceNotFoundError(_))
    }
}
impl std::error::Error for RestoreSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            RestoreSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            RestoreSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            RestoreSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            RestoreSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RotateSecretError {
    pub kind: RotateSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RotateSecretErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RotateSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RotateSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            RotateSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            RotateSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            RotateSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            RotateSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RotateSecretError {
    fn code(&self) -> Option<&str> {
        RotateSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl RotateSecretError {
    pub fn new(kind: RotateSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RotateSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RotateSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, RotateSecretErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, RotateSecretErrorKind::InvalidParameterError(_))
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(&self.kind, RotateSecretErrorKind::InvalidRequestError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, RotateSecretErrorKind::ResourceNotFoundError(_))
    }
}
impl std::error::Error for RotateSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RotateSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            RotateSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            RotateSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            RotateSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            RotateSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct StopReplicationToReplicaError {
    pub kind: StopReplicationToReplicaErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum StopReplicationToReplicaErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for StopReplicationToReplicaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            StopReplicationToReplicaErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            StopReplicationToReplicaErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            StopReplicationToReplicaErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            StopReplicationToReplicaErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            StopReplicationToReplicaErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for StopReplicationToReplicaError {
    fn code(&self) -> Option<&str> {
        StopReplicationToReplicaError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl StopReplicationToReplicaError {
    pub fn new(kind: StopReplicationToReplicaErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: StopReplicationToReplicaErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: StopReplicationToReplicaErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            StopReplicationToReplicaErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            StopReplicationToReplicaErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(
            &self.kind,
            StopReplicationToReplicaErrorKind::InvalidRequestError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            StopReplicationToReplicaErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for StopReplicationToReplicaError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            StopReplicationToReplicaErrorKind::InternalServiceError(_inner) => Some(_inner),
            StopReplicationToReplicaErrorKind::InvalidParameterError(_inner) => Some(_inner),
            StopReplicationToReplicaErrorKind::InvalidRequestError(_inner) => Some(_inner),
            StopReplicationToReplicaErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            StopReplicationToReplicaErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidParameterError(_))
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidRequestError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::ResourceNotFoundError(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalServiceError(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidRequestError(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InvalidParameterError(_))
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::InvalidRequestError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::ResourceNotFoundError(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalServiceError(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidRequestError(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSecretError {
    pub kind: UpdateSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSecretErrorKind {
    EncryptionFailure(crate::error::EncryptionFailure),
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    PreconditionNotMetError(crate::error::PreconditionNotMetError),
    ResourceExistsError(crate::error::ResourceExistsError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSecretErrorKind::EncryptionFailure(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::PreconditionNotMetError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::ResourceExistsError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSecretError {
    fn code(&self) -> Option<&str> {
        UpdateSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSecretError {
    pub fn new(kind: UpdateSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_failure(&self) -> bool {
        matches!(&self.kind, UpdateSecretErrorKind::EncryptionFailure(_))
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(&self.kind, UpdateSecretErrorKind::InternalServiceError(_))
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(&self.kind, UpdateSecretErrorKind::InvalidParameterError(_))
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(&self.kind, UpdateSecretErrorKind::InvalidRequestError(_))
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(&self.kind, UpdateSecretErrorKind::LimitExceededError(_))
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecretErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_precondition_not_met_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecretErrorKind::PreconditionNotMetError(_)
        )
    }
    pub fn is_resource_exists_error(&self) -> bool {
        matches!(&self.kind, UpdateSecretErrorKind::ResourceExistsError(_))
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(&self.kind, UpdateSecretErrorKind::ResourceNotFoundError(_))
    }
}
impl std::error::Error for UpdateSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSecretErrorKind::EncryptionFailure(_inner) => Some(_inner),
            UpdateSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            UpdateSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            UpdateSecretErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateSecretErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            UpdateSecretErrorKind::PreconditionNotMetError(_inner) => Some(_inner),
            UpdateSecretErrorKind::ResourceExistsError(_inner) => Some(_inner),
            UpdateSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSecretVersionStageError {
    pub kind: UpdateSecretVersionStageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSecretVersionStageErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSecretVersionStageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSecretVersionStageErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            UpdateSecretVersionStageErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateSecretVersionStageErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            UpdateSecretVersionStageErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateSecretVersionStageErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateSecretVersionStageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSecretVersionStageError {
    fn code(&self) -> Option<&str> {
        UpdateSecretVersionStageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateSecretVersionStageError {
    pub fn new(kind: UpdateSecretVersionStageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSecretVersionStageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSecretVersionStageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecretVersionStageErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecretVersionStageErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecretVersionStageErrorKind::InvalidRequestError(_)
        )
    }
    pub fn is_limit_exceeded_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecretVersionStageErrorKind::LimitExceededError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            UpdateSecretVersionStageErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for UpdateSecretVersionStageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSecretVersionStageErrorKind::InternalServiceError(_inner) => Some(_inner),
            UpdateSecretVersionStageErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateSecretVersionStageErrorKind::InvalidRequestError(_inner) => Some(_inner),
            UpdateSecretVersionStageErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateSecretVersionStageErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateSecretVersionStageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateResourcePolicyError {
    pub kind: ValidateResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateResourcePolicyErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ValidateResourcePolicyErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ValidateResourcePolicyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ValidateResourcePolicyErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            ValidateResourcePolicyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            ValidateResourcePolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ValidateResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ValidateResourcePolicyError {
    fn code(&self) -> Option<&str> {
        ValidateResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ValidateResourcePolicyError {
    pub fn new(kind: ValidateResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ValidateResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ValidateResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_internal_service_error(&self) -> bool {
        matches!(
            &self.kind,
            ValidateResourcePolicyErrorKind::InternalServiceError(_)
        )
    }
    pub fn is_invalid_parameter_error(&self) -> bool {
        matches!(
            &self.kind,
            ValidateResourcePolicyErrorKind::InvalidParameterError(_)
        )
    }
    pub fn is_invalid_request_error(&self) -> bool {
        matches!(
            &self.kind,
            ValidateResourcePolicyErrorKind::InvalidRequestError(_)
        )
    }
    pub fn is_malformed_policy_document_error(&self) -> bool {
        matches!(
            &self.kind,
            ValidateResourcePolicyErrorKind::MalformedPolicyDocumentError(_)
        )
    }
    pub fn is_resource_not_found_error(&self) -> bool {
        matches!(
            &self.kind,
            ValidateResourcePolicyErrorKind::ResourceNotFoundError(_)
        )
    }
}
impl std::error::Error for ValidateResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ValidateResourcePolicyErrorKind::InternalServiceError(_inner) => Some(_inner),
            ValidateResourcePolicyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ValidateResourcePolicyErrorKind::InvalidRequestError(_inner) => Some(_inner),
            ValidateResourcePolicyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            ValidateResourcePolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ValidateResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>We can't find the resource that you asked for.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError [ResourceNotFoundException]")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
pub mod resource_not_found_error {
    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
        pub fn build(self) -> crate::error::ResourceNotFoundError {
            crate::error::ResourceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}

/// <p>You provided a resource-based policy with syntax errors.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedPolicyDocumentError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedPolicyDocumentError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedPolicyDocumentError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MalformedPolicyDocumentError [MalformedPolicyDocumentException]"
        )?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for MalformedPolicyDocumentError {}
/// See [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
pub mod malformed_policy_document_error {
    /// A builder for [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
        pub fn build(self) -> crate::error::MalformedPolicyDocumentError {
            crate::error::MalformedPolicyDocumentError {
                message: self.message,
            }
        }
    }
}
impl MalformedPolicyDocumentError {
    /// Creates a new builder-style object to manufacture [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    pub fn builder() -> crate::error::malformed_policy_document_error::Builder {
        crate::error::malformed_policy_document_error::Builder::default()
    }
}

/// <p>You provided a parameter value that is not valid for the current state of the
/// resource.</p>
/// <p>Possible causes:</p>
/// <ul>
/// <li>
/// <p>You tried to perform the operation on a secret that's currently marked deleted.</p>
/// </li>
/// <li>
/// <p>You tried to enable rotation on a secret that doesn't already have a Lambda function
/// ARN configured and you didn't include such an ARN as a parameter in this call. </p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestError [InvalidRequestException]")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRequestError {}
/// See [`InvalidRequestError`](crate::error::InvalidRequestError)
pub mod invalid_request_error {
    /// A builder for [`InvalidRequestError`](crate::error::InvalidRequestError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestError`](crate::error::InvalidRequestError)
        pub fn build(self) -> crate::error::InvalidRequestError {
            crate::error::InvalidRequestError {
                message: self.message,
            }
        }
    }
}
impl InvalidRequestError {
    /// Creates a new builder-style object to manufacture [`InvalidRequestError`](crate::error::InvalidRequestError)
    pub fn builder() -> crate::error::invalid_request_error::Builder {
        crate::error::invalid_request_error::Builder::default()
    }
}

/// <p>You provided an invalid value for a parameter.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterError [InvalidParameterException]")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParameterError {}
/// See [`InvalidParameterError`](crate::error::InvalidParameterError)
pub mod invalid_parameter_error {
    /// A builder for [`InvalidParameterError`](crate::error::InvalidParameterError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterError`](crate::error::InvalidParameterError)
        pub fn build(self) -> crate::error::InvalidParameterError {
            crate::error::InvalidParameterError {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterError {
    /// Creates a new builder-style object to manufacture [`InvalidParameterError`](crate::error::InvalidParameterError)
    pub fn builder() -> crate::error::invalid_parameter_error::Builder {
        crate::error::invalid_parameter_error::Builder::default()
    }
}

/// <p>An error occurred on the server side.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServiceError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServiceError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServiceError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InternalServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServiceError")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InternalServiceError {}
/// See [`InternalServiceError`](crate::error::InternalServiceError)
pub mod internal_service_error {
    /// A builder for [`InternalServiceError`](crate::error::InternalServiceError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalServiceError`](crate::error::InternalServiceError)
        pub fn build(self) -> crate::error::InternalServiceError {
            crate::error::InternalServiceError {
                message: self.message,
            }
        }
    }
}
impl InternalServiceError {
    /// Creates a new builder-style object to manufacture [`InternalServiceError`](crate::error::InternalServiceError)
    pub fn builder() -> crate::error::internal_service_error::Builder {
        crate::error::internal_service_error::Builder::default()
    }
}

/// <p>The request failed because it would exceed one of the Secrets Manager internal limits.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError [LimitExceededException]")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> crate::error::LimitExceededError {
            crate::error::LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

/// <p>A resource with the ID you requested already exists.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceExistsError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceExistsError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceExistsError [ResourceExistsException]")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceExistsError {}
/// See [`ResourceExistsError`](crate::error::ResourceExistsError)
pub mod resource_exists_error {
    /// A builder for [`ResourceExistsError`](crate::error::ResourceExistsError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceExistsError`](crate::error::ResourceExistsError)
        pub fn build(self) -> crate::error::ResourceExistsError {
            crate::error::ResourceExistsError {
                message: self.message,
            }
        }
    }
}
impl ResourceExistsError {
    /// Creates a new builder-style object to manufacture [`ResourceExistsError`](crate::error::ResourceExistsError)
    pub fn builder() -> crate::error::resource_exists_error::Builder {
        crate::error::resource_exists_error::Builder::default()
    }
}

/// <p>The request failed because you did not complete all the prerequisite steps.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PreconditionNotMetError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PreconditionNotMetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreconditionNotMetError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PreconditionNotMetError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PreconditionNotMetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PreconditionNotMetError [PreconditionNotMetException]")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for PreconditionNotMetError {}
/// See [`PreconditionNotMetError`](crate::error::PreconditionNotMetError)
pub mod precondition_not_met_error {
    /// A builder for [`PreconditionNotMetError`](crate::error::PreconditionNotMetError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PreconditionNotMetError`](crate::error::PreconditionNotMetError)
        pub fn build(self) -> crate::error::PreconditionNotMetError {
            crate::error::PreconditionNotMetError {
                message: self.message,
            }
        }
    }
}
impl PreconditionNotMetError {
    /// Creates a new builder-style object to manufacture [`PreconditionNotMetError`](crate::error::PreconditionNotMetError)
    pub fn builder() -> crate::error::precondition_not_met_error::Builder {
        crate::error::precondition_not_met_error::Builder::default()
    }
}

/// <p>Secrets Manager can't encrypt the protected secret text using the provided KMS key. Check that the
/// customer master key (CMK) is available, enabled, and not in an invalid state. For more
/// information, see <a href="http://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
/// Customer Master Key</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionFailure {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionFailure");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionFailure {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionFailure")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionFailure {}
/// See [`EncryptionFailure`](crate::error::EncryptionFailure)
pub mod encryption_failure {
    /// A builder for [`EncryptionFailure`](crate::error::EncryptionFailure)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionFailure`](crate::error::EncryptionFailure)
        pub fn build(self) -> crate::error::EncryptionFailure {
            crate::error::EncryptionFailure {
                message: self.message,
            }
        }
    }
}
impl EncryptionFailure {
    /// Creates a new builder-style object to manufacture [`EncryptionFailure`](crate::error::EncryptionFailure)
    pub fn builder() -> crate::error::encryption_failure::Builder {
        crate::error::encryption_failure::Builder::default()
    }
}

/// <p>The BlockPublicPolicy parameter is set to true and the resource policy did not prevent broad access to the secret.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PublicPolicyError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PublicPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublicPolicyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PublicPolicyError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PublicPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PublicPolicyError [PublicPolicyException]")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for PublicPolicyError {}
/// See [`PublicPolicyError`](crate::error::PublicPolicyError)
pub mod public_policy_error {
    /// A builder for [`PublicPolicyError`](crate::error::PublicPolicyError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PublicPolicyError`](crate::error::PublicPolicyError)
        pub fn build(self) -> crate::error::PublicPolicyError {
            crate::error::PublicPolicyError {
                message: self.message,
            }
        }
    }
}
impl PublicPolicyError {
    /// Creates a new builder-style object to manufacture [`PublicPolicyError`](crate::error::PublicPolicyError)
    pub fn builder() -> crate::error::public_policy_error::Builder {
        crate::error::public_policy_error::Builder::default()
    }
}

/// <p>You provided an invalid <code>NextToken</code> value.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenError {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenError {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidNextTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenError [InvalidNextTokenException]")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenError {}
/// See [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
pub mod invalid_next_token_error {
    /// A builder for [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
        pub fn build(self) -> crate::error::InvalidNextTokenError {
            crate::error::InvalidNextTokenError {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenError {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
    pub fn builder() -> crate::error::invalid_next_token_error::Builder {
        crate::error::invalid_next_token_error::Builder::default()
    }
}

/// <p>Secrets Manager can't decrypt the protected secret text using the provided KMS key. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DecryptionFailure {
    #[serde(rename = "Message")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DecryptionFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DecryptionFailure");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DecryptionFailure {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DecryptionFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DecryptionFailure")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for DecryptionFailure {}
/// See [`DecryptionFailure`](crate::error::DecryptionFailure)
pub mod decryption_failure {
    /// A builder for [`DecryptionFailure`](crate::error::DecryptionFailure)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DecryptionFailure`](crate::error::DecryptionFailure)
        pub fn build(self) -> crate::error::DecryptionFailure {
            crate::error::DecryptionFailure {
                message: self.message,
            }
        }
    }
}
impl DecryptionFailure {
    /// Creates a new builder-style object to manufacture [`DecryptionFailure`](crate::error::DecryptionFailure)
    pub fn builder() -> crate::error::decryption_failure::Builder {
        crate::error::decryption_failure::Builder::default()
    }
}
