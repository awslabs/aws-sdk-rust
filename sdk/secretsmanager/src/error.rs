// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CancelRotateSecretError {
    pub kind: CancelRotateSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CancelRotateSecretErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CancelRotateSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CancelRotateSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            CancelRotateSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CancelRotateSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            CancelRotateSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            CancelRotateSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CancelRotateSecretError {
    fn code(&self) -> Option<&str> {
        CancelRotateSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CancelRotateSecretError {
    pub fn new(kind: CancelRotateSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CancelRotateSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CancelRotateSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CancelRotateSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CancelRotateSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            CancelRotateSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CancelRotateSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            CancelRotateSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            CancelRotateSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateSecretError {
    pub kind: CreateSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateSecretErrorKind {
    EncryptionFailure(crate::error::EncryptionFailure),
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    PreconditionNotMetError(crate::error::PreconditionNotMetError),
    ResourceExistsError(crate::error::ResourceExistsError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateSecretErrorKind::EncryptionFailure(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::PreconditionNotMetError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::ResourceExistsError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            CreateSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateSecretError {
    fn code(&self) -> Option<&str> {
        CreateSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl CreateSecretError {
    pub fn new(kind: CreateSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for CreateSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateSecretErrorKind::EncryptionFailure(_inner) => Some(_inner),
            CreateSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            CreateSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            CreateSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            CreateSecretErrorKind::LimitExceededError(_inner) => Some(_inner),
            CreateSecretErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            CreateSecretErrorKind::PreconditionNotMetError(_inner) => Some(_inner),
            CreateSecretErrorKind::ResourceExistsError(_inner) => Some(_inner),
            CreateSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            CreateSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteResourcePolicyError {
    pub kind: DeleteResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteResourcePolicyErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteResourcePolicyErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteResourcePolicyError {
    fn code(&self) -> Option<&str> {
        DeleteResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteResourcePolicyError {
    pub fn new(kind: DeleteResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteResourcePolicyErrorKind::InternalServiceError(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::InvalidRequestError(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteSecretError {
    pub kind: DeleteSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteSecretErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            DeleteSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            DeleteSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            DeleteSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteSecretError {
    fn code(&self) -> Option<&str> {
        DeleteSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DeleteSecretError {
    pub fn new(kind: DeleteSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DeleteSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            DeleteSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            DeleteSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            DeleteSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeSecretError {
    pub kind: DescribeSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeSecretErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            DescribeSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeSecretError {
    fn code(&self) -> Option<&str> {
        DescribeSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl DescribeSecretError {
    pub fn new(kind: DescribeSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for DescribeSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            DescribeSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRandomPasswordError {
    pub kind: GetRandomPasswordErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRandomPasswordErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRandomPasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRandomPasswordErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            GetRandomPasswordErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetRandomPasswordErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            GetRandomPasswordErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRandomPasswordError {
    fn code(&self) -> Option<&str> {
        GetRandomPasswordError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetRandomPasswordError {
    pub fn new(kind: GetRandomPasswordErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRandomPasswordErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRandomPasswordErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetRandomPasswordError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRandomPasswordErrorKind::InternalServiceError(_inner) => Some(_inner),
            GetRandomPasswordErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetRandomPasswordErrorKind::InvalidRequestError(_inner) => Some(_inner),
            GetRandomPasswordErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetResourcePolicyError {
    pub kind: GetResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetResourcePolicyErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetResourcePolicyErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            GetResourcePolicyErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            GetResourcePolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetResourcePolicyError {
    fn code(&self) -> Option<&str> {
        GetResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetResourcePolicyError {
    pub fn new(kind: GetResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetResourcePolicyErrorKind::InternalServiceError(_inner) => Some(_inner),
            GetResourcePolicyErrorKind::InvalidRequestError(_inner) => Some(_inner),
            GetResourcePolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetSecretValueError {
    pub kind: GetSecretValueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetSecretValueErrorKind {
    DecryptionFailure(crate::error::DecryptionFailure),
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetSecretValueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetSecretValueErrorKind::DecryptionFailure(_inner) => _inner.fmt(f),
            GetSecretValueErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            GetSecretValueErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            GetSecretValueErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            GetSecretValueErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetSecretValueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetSecretValueError {
    fn code(&self) -> Option<&str> {
        GetSecretValueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl GetSecretValueError {
    pub fn new(kind: GetSecretValueErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetSecretValueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetSecretValueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for GetSecretValueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetSecretValueErrorKind::DecryptionFailure(_inner) => Some(_inner),
            GetSecretValueErrorKind::InternalServiceError(_inner) => Some(_inner),
            GetSecretValueErrorKind::InvalidParameterError(_inner) => Some(_inner),
            GetSecretValueErrorKind::InvalidRequestError(_inner) => Some(_inner),
            GetSecretValueErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            GetSecretValueErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSecretsError {
    pub kind: ListSecretsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSecretsErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidNextTokenError(crate::error::InvalidNextTokenError),
    InvalidParameterError(crate::error::InvalidParameterError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSecretsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSecretsErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ListSecretsErrorKind::InvalidNextTokenError(_inner) => _inner.fmt(f),
            ListSecretsErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ListSecretsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSecretsError {
    fn code(&self) -> Option<&str> {
        ListSecretsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListSecretsError {
    pub fn new(kind: ListSecretsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSecretsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSecretsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListSecretsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSecretsErrorKind::InternalServiceError(_inner) => Some(_inner),
            ListSecretsErrorKind::InvalidNextTokenError(_inner) => Some(_inner),
            ListSecretsErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ListSecretsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListSecretVersionIdsError {
    pub kind: ListSecretVersionIdsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListSecretVersionIdsErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidNextTokenError(crate::error::InvalidNextTokenError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListSecretVersionIdsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListSecretVersionIdsErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ListSecretVersionIdsErrorKind::InvalidNextTokenError(_inner) => _inner.fmt(f),
            ListSecretVersionIdsErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListSecretVersionIdsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListSecretVersionIdsError {
    fn code(&self) -> Option<&str> {
        ListSecretVersionIdsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ListSecretVersionIdsError {
    pub fn new(kind: ListSecretVersionIdsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListSecretVersionIdsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListSecretVersionIdsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ListSecretVersionIdsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListSecretVersionIdsErrorKind::InternalServiceError(_inner) => Some(_inner),
            ListSecretVersionIdsErrorKind::InvalidNextTokenError(_inner) => Some(_inner),
            ListSecretVersionIdsErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ListSecretVersionIdsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutResourcePolicyError {
    pub kind: PutResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutResourcePolicyErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    PublicPolicyError(crate::error::PublicPolicyError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutResourcePolicyErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::PublicPolicyError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutResourcePolicyError {
    fn code(&self) -> Option<&str> {
        PutResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutResourcePolicyError {
    pub fn new(kind: PutResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutResourcePolicyErrorKind::InternalServiceError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::InvalidRequestError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::PublicPolicyError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutSecretValueError {
    pub kind: PutSecretValueErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutSecretValueErrorKind {
    EncryptionFailure(crate::error::EncryptionFailure),
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceExistsError(crate::error::ResourceExistsError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutSecretValueError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutSecretValueErrorKind::EncryptionFailure(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::ResourceExistsError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutSecretValueErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutSecretValueError {
    fn code(&self) -> Option<&str> {
        PutSecretValueError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl PutSecretValueError {
    pub fn new(kind: PutSecretValueErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutSecretValueErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutSecretValueErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for PutSecretValueError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutSecretValueErrorKind::EncryptionFailure(_inner) => Some(_inner),
            PutSecretValueErrorKind::InternalServiceError(_inner) => Some(_inner),
            PutSecretValueErrorKind::InvalidParameterError(_inner) => Some(_inner),
            PutSecretValueErrorKind::InvalidRequestError(_inner) => Some(_inner),
            PutSecretValueErrorKind::LimitExceededError(_inner) => Some(_inner),
            PutSecretValueErrorKind::ResourceExistsError(_inner) => Some(_inner),
            PutSecretValueErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            PutSecretValueErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RestoreSecretError {
    pub kind: RestoreSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RestoreSecretErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RestoreSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RestoreSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            RestoreSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            RestoreSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            RestoreSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            RestoreSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RestoreSecretError {
    fn code(&self) -> Option<&str> {
        RestoreSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl RestoreSecretError {
    pub fn new(kind: RestoreSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RestoreSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RestoreSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for RestoreSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RestoreSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            RestoreSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            RestoreSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            RestoreSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            RestoreSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct RotateSecretError {
    pub kind: RotateSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum RotateSecretErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for RotateSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            RotateSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            RotateSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            RotateSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            RotateSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            RotateSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for RotateSecretError {
    fn code(&self) -> Option<&str> {
        RotateSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl RotateSecretError {
    pub fn new(kind: RotateSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: RotateSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: RotateSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for RotateSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            RotateSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            RotateSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            RotateSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            RotateSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            RotateSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InternalServiceError(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidRequestError(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InternalServiceError(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidRequestError(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSecretError {
    pub kind: UpdateSecretErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSecretErrorKind {
    EncryptionFailure(crate::error::EncryptionFailure),
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    PreconditionNotMetError(crate::error::PreconditionNotMetError),
    ResourceExistsError(crate::error::ResourceExistsError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSecretError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSecretErrorKind::EncryptionFailure(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::PreconditionNotMetError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::ResourceExistsError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateSecretErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSecretError {
    fn code(&self) -> Option<&str> {
        UpdateSecretError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateSecretError {
    pub fn new(kind: UpdateSecretErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSecretErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSecretErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateSecretError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSecretErrorKind::EncryptionFailure(_inner) => Some(_inner),
            UpdateSecretErrorKind::InternalServiceError(_inner) => Some(_inner),
            UpdateSecretErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateSecretErrorKind::InvalidRequestError(_inner) => Some(_inner),
            UpdateSecretErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateSecretErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            UpdateSecretErrorKind::PreconditionNotMetError(_inner) => Some(_inner),
            UpdateSecretErrorKind::ResourceExistsError(_inner) => Some(_inner),
            UpdateSecretErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateSecretErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateSecretVersionStageError {
    pub kind: UpdateSecretVersionStageErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateSecretVersionStageErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    LimitExceededError(crate::error::LimitExceededError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateSecretVersionStageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateSecretVersionStageErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            UpdateSecretVersionStageErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            UpdateSecretVersionStageErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            UpdateSecretVersionStageErrorKind::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateSecretVersionStageErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateSecretVersionStageErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateSecretVersionStageError {
    fn code(&self) -> Option<&str> {
        UpdateSecretVersionStageError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl UpdateSecretVersionStageError {
    pub fn new(kind: UpdateSecretVersionStageErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateSecretVersionStageErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateSecretVersionStageErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for UpdateSecretVersionStageError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateSecretVersionStageErrorKind::InternalServiceError(_inner) => Some(_inner),
            UpdateSecretVersionStageErrorKind::InvalidParameterError(_inner) => Some(_inner),
            UpdateSecretVersionStageErrorKind::InvalidRequestError(_inner) => Some(_inner),
            UpdateSecretVersionStageErrorKind::LimitExceededError(_inner) => Some(_inner),
            UpdateSecretVersionStageErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateSecretVersionStageErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ValidateResourcePolicyError {
    pub kind: ValidateResourcePolicyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ValidateResourcePolicyErrorKind {
    InternalServiceError(crate::error::InternalServiceError),
    InvalidParameterError(crate::error::InvalidParameterError),
    InvalidRequestError(crate::error::InvalidRequestError),
    MalformedPolicyDocumentError(crate::error::MalformedPolicyDocumentError),
    ResourceNotFoundError(crate::error::ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ValidateResourcePolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ValidateResourcePolicyErrorKind::InternalServiceError(_inner) => _inner.fmt(f),
            ValidateResourcePolicyErrorKind::InvalidParameterError(_inner) => _inner.fmt(f),
            ValidateResourcePolicyErrorKind::InvalidRequestError(_inner) => _inner.fmt(f),
            ValidateResourcePolicyErrorKind::MalformedPolicyDocumentError(_inner) => _inner.fmt(f),
            ValidateResourcePolicyErrorKind::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ValidateResourcePolicyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ValidateResourcePolicyError {
    fn code(&self) -> Option<&str> {
        ValidateResourcePolicyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}

impl ValidateResourcePolicyError {
    pub fn new(kind: ValidateResourcePolicyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ValidateResourcePolicyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ValidateResourcePolicyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message.as_deref()
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id.as_deref()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code.as_deref()
    }
}

impl std::error::Error for ValidateResourcePolicyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ValidateResourcePolicyErrorKind::InternalServiceError(_inner) => Some(_inner),
            ValidateResourcePolicyErrorKind::InvalidParameterError(_inner) => Some(_inner),
            ValidateResourcePolicyErrorKind::InvalidRequestError(_inner) => Some(_inner),
            ValidateResourcePolicyErrorKind::MalformedPolicyDocumentError(_inner) => Some(_inner),
            ValidateResourcePolicyErrorKind::ResourceNotFoundError(_inner) => Some(_inner),
            ValidateResourcePolicyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>We can't find the resource that you asked for.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceNotFoundError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError [ResourceNotFoundException]")?;
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
pub mod resource_not_found_error {
    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
        pub fn build(self) -> crate::error::ResourceNotFoundError {
            crate::error::ResourceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}

/// <p>The policy document that you provided isn't valid.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct MalformedPolicyDocumentError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MalformedPolicyDocumentError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MalformedPolicyDocumentError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for MalformedPolicyDocumentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "MalformedPolicyDocumentError [MalformedPolicyDocumentException]"
        )?;
        Ok(())
    }
}
impl std::error::Error for MalformedPolicyDocumentError {}
/// See [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
pub mod malformed_policy_document_error {
    /// A builder for [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
        pub fn build(self) -> crate::error::MalformedPolicyDocumentError {
            crate::error::MalformedPolicyDocumentError {
                message: self.message,
            }
        }
    }
}
impl MalformedPolicyDocumentError {
    /// Creates a new builder-style object to manufacture [`MalformedPolicyDocumentError`](crate::error::MalformedPolicyDocumentError)
    pub fn builder() -> crate::error::malformed_policy_document_error::Builder {
        crate::error::malformed_policy_document_error::Builder::default()
    }
}

/// <p>You provided a parameter value that is not valid for the current state of the
/// resource.</p>
/// <p>Possible causes:</p>
/// <ul>
/// <li>
/// <p>You tried to perform the operation on a secret that's currently marked deleted.</p>
/// </li>
/// <li>
/// <p>You tried to enable rotation on a secret that doesn't already have a Lambda function
/// ARN configured and you didn't include such an ARN as a parameter in this call. </p>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRequestError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRequestError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRequestError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvalidRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRequestError [InvalidRequestException]")?;
        Ok(())
    }
}
impl std::error::Error for InvalidRequestError {}
/// See [`InvalidRequestError`](crate::error::InvalidRequestError)
pub mod invalid_request_error {
    /// A builder for [`InvalidRequestError`](crate::error::InvalidRequestError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRequestError`](crate::error::InvalidRequestError)
        pub fn build(self) -> crate::error::InvalidRequestError {
            crate::error::InvalidRequestError {
                message: self.message,
            }
        }
    }
}
impl InvalidRequestError {
    /// Creates a new builder-style object to manufacture [`InvalidRequestError`](crate::error::InvalidRequestError)
    pub fn builder() -> crate::error::invalid_request_error::Builder {
        crate::error::invalid_request_error::Builder::default()
    }
}

/// <p>You provided an invalid value for a parameter.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParameterError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParameterError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParameterError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvalidParameterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParameterError [InvalidParameterException]")?;
        Ok(())
    }
}
impl std::error::Error for InvalidParameterError {}
/// See [`InvalidParameterError`](crate::error::InvalidParameterError)
pub mod invalid_parameter_error {
    /// A builder for [`InvalidParameterError`](crate::error::InvalidParameterError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParameterError`](crate::error::InvalidParameterError)
        pub fn build(self) -> crate::error::InvalidParameterError {
            crate::error::InvalidParameterError {
                message: self.message,
            }
        }
    }
}
impl InvalidParameterError {
    /// Creates a new builder-style object to manufacture [`InvalidParameterError`](crate::error::InvalidParameterError)
    pub fn builder() -> crate::error::invalid_parameter_error::Builder {
        crate::error::invalid_parameter_error::Builder::default()
    }
}

/// <p>An error occurred on the server side.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalServiceError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InternalServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalServiceError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InternalServiceError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InternalServiceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServiceError")?;
        Ok(())
    }
}
impl std::error::Error for InternalServiceError {}
/// See [`InternalServiceError`](crate::error::InternalServiceError)
pub mod internal_service_error {
    /// A builder for [`InternalServiceError`](crate::error::InternalServiceError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InternalServiceError`](crate::error::InternalServiceError)
        pub fn build(self) -> crate::error::InternalServiceError {
            crate::error::InternalServiceError {
                message: self.message,
            }
        }
    }
}
impl InternalServiceError {
    /// Creates a new builder-style object to manufacture [`InternalServiceError`](crate::error::InternalServiceError)
    pub fn builder() -> crate::error::internal_service_error::Builder {
        crate::error::internal_service_error::Builder::default()
    }
}

/// <p>The request failed because it would exceed one of the Secrets Manager internal limits.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct LimitExceededError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("LimitExceededError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl LimitExceededError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError [LimitExceededException]")?;
        Ok(())
    }
}
impl std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> crate::error::LimitExceededError {
            crate::error::LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

/// <p>A resource with the ID you requested already exists.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceExistsError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceExistsError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceExistsError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for ResourceExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceExistsError [ResourceExistsException]")?;
        Ok(())
    }
}
impl std::error::Error for ResourceExistsError {}
/// See [`ResourceExistsError`](crate::error::ResourceExistsError)
pub mod resource_exists_error {
    /// A builder for [`ResourceExistsError`](crate::error::ResourceExistsError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`ResourceExistsError`](crate::error::ResourceExistsError)
        pub fn build(self) -> crate::error::ResourceExistsError {
            crate::error::ResourceExistsError {
                message: self.message,
            }
        }
    }
}
impl ResourceExistsError {
    /// Creates a new builder-style object to manufacture [`ResourceExistsError`](crate::error::ResourceExistsError)
    pub fn builder() -> crate::error::resource_exists_error::Builder {
        crate::error::resource_exists_error::Builder::default()
    }
}

/// <p>The request failed because you did not complete all the prerequisite steps.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PreconditionNotMetError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PreconditionNotMetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PreconditionNotMetError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PreconditionNotMetError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for PreconditionNotMetError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PreconditionNotMetError [PreconditionNotMetException]")?;
        Ok(())
    }
}
impl std::error::Error for PreconditionNotMetError {}
/// See [`PreconditionNotMetError`](crate::error::PreconditionNotMetError)
pub mod precondition_not_met_error {
    /// A builder for [`PreconditionNotMetError`](crate::error::PreconditionNotMetError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`PreconditionNotMetError`](crate::error::PreconditionNotMetError)
        pub fn build(self) -> crate::error::PreconditionNotMetError {
            crate::error::PreconditionNotMetError {
                message: self.message,
            }
        }
    }
}
impl PreconditionNotMetError {
    /// Creates a new builder-style object to manufacture [`PreconditionNotMetError`](crate::error::PreconditionNotMetError)
    pub fn builder() -> crate::error::precondition_not_met_error::Builder {
        crate::error::precondition_not_met_error::Builder::default()
    }
}

/// <p>Secrets Manager can't encrypt the protected secret text using the provided KMS key. Check that the
/// customer master key (CMK) is available, enabled, and not in an invalid state. For more
/// information, see <a href="http://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">How Key State Affects Use of a
/// Customer Master Key</a>.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionFailure {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionFailure");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionFailure {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for EncryptionFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionFailure")?;
        Ok(())
    }
}
impl std::error::Error for EncryptionFailure {}
/// See [`EncryptionFailure`](crate::error::EncryptionFailure)
pub mod encryption_failure {
    /// A builder for [`EncryptionFailure`](crate::error::EncryptionFailure)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionFailure`](crate::error::EncryptionFailure)
        pub fn build(self) -> crate::error::EncryptionFailure {
            crate::error::EncryptionFailure {
                message: self.message,
            }
        }
    }
}
impl EncryptionFailure {
    /// Creates a new builder-style object to manufacture [`EncryptionFailure`](crate::error::EncryptionFailure)
    pub fn builder() -> crate::error::encryption_failure::Builder {
        crate::error::encryption_failure::Builder::default()
    }
}

/// <p>The resource policy did not prevent broad access to the secret.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct PublicPolicyError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PublicPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PublicPolicyError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PublicPolicyError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for PublicPolicyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PublicPolicyError [PublicPolicyException]")?;
        Ok(())
    }
}
impl std::error::Error for PublicPolicyError {}
/// See [`PublicPolicyError`](crate::error::PublicPolicyError)
pub mod public_policy_error {
    /// A builder for [`PublicPolicyError`](crate::error::PublicPolicyError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`PublicPolicyError`](crate::error::PublicPolicyError)
        pub fn build(self) -> crate::error::PublicPolicyError {
            crate::error::PublicPolicyError {
                message: self.message,
            }
        }
    }
}
impl PublicPolicyError {
    /// Creates a new builder-style object to manufacture [`PublicPolicyError`](crate::error::PublicPolicyError)
    pub fn builder() -> crate::error::public_policy_error::Builder {
        crate::error::public_policy_error::Builder::default()
    }
}

/// <p>You provided an invalid <code>NextToken</code> value.</p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidNextTokenError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidNextTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidNextTokenError");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidNextTokenError {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for InvalidNextTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidNextTokenError [InvalidNextTokenException]")?;
        Ok(())
    }
}
impl std::error::Error for InvalidNextTokenError {}
/// See [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
pub mod invalid_next_token_error {
    /// A builder for [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
        pub fn build(self) -> crate::error::InvalidNextTokenError {
            crate::error::InvalidNextTokenError {
                message: self.message,
            }
        }
    }
}
impl InvalidNextTokenError {
    /// Creates a new builder-style object to manufacture [`InvalidNextTokenError`](crate::error::InvalidNextTokenError)
    pub fn builder() -> crate::error::invalid_next_token_error::Builder {
        crate::error::invalid_next_token_error::Builder::default()
    }
}

/// <p>Secrets Manager can't decrypt the protected secret text using the provided KMS key. </p>
#[non_exhaustive]
#[derive(serde::Deserialize, serde::Serialize, std::clone::Clone, std::cmp::PartialEq)]
pub struct DecryptionFailure {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DecryptionFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DecryptionFailure");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DecryptionFailure {
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl std::fmt::Display for DecryptionFailure {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DecryptionFailure")?;
        Ok(())
    }
}
impl std::error::Error for DecryptionFailure {}
/// See [`DecryptionFailure`](crate::error::DecryptionFailure)
pub mod decryption_failure {
    /// A builder for [`DecryptionFailure`](crate::error::DecryptionFailure)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        pub fn set_message(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.message = inp;
            self
        }
        /// Consumes the builder and constructs a [`DecryptionFailure`](crate::error::DecryptionFailure)
        pub fn build(self) -> crate::error::DecryptionFailure {
            crate::error::DecryptionFailure {
                message: self.message,
            }
        }
    }
}
impl DecryptionFailure {
    /// Creates a new builder-style object to manufacture [`DecryptionFailure`](crate::error::DecryptionFailure)
    pub fn builder() -> crate::error::decryption_failure::Builder {
        crate::error::decryption_failure::Builder::default()
    }
}
