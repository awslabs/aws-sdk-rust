// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// See [`CancelRotateSecretInput`](crate::input::CancelRotateSecretInput)
pub mod cancel_rotate_secret_input {
    /// A builder for [`CancelRotateSecretInput`](crate::input::CancelRotateSecretInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        secret_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the secret to cancel a rotation request. You can specify either the Amazon
        /// Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`CancelRotateSecretInput`](crate::input::CancelRotateSecretInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CancelRotateSecretInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::CancelRotateSecretInput {
                secret_id: self.secret_id,
            })
        }
    }
}
impl CancelRotateSecretInput {
    /// Consumes the builder and constructs an Operation<[`CancelRotateSecret`](crate::operation::CancelRotateSecret)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CancelRotateSecret,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CancelRotateSecret::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CancelRotateSecret",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.CancelRotateSecret"))
    }
    fn body(&self) -> crate::serializer::CancelRotateSecretInputBody {
        crate::serializer::CancelRotateSecretInputBody {
            secret_id: &self.secret_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`CancelRotateSecretInput`](crate::input::CancelRotateSecretInput)
    pub fn builder() -> crate::input::cancel_rotate_secret_input::Builder {
        crate::input::cancel_rotate_secret_input::Builder::default()
    }
}

/// See [`CreateSecretInput`](crate::input::CreateSecretInput)
pub mod create_secret_input {
    /// A builder for [`CreateSecretInput`](crate::input::CreateSecretInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        name: std::option::Option<std::string::String>,
        tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        kms_key_id: std::option::Option<std::string::String>,
        description: std::option::Option<std::string::String>,
        secret_string: std::option::Option<std::string::String>,
        secret_binary: std::option::Option<smithy_types::Blob>,
        client_request_token: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the friendly name of the new secret.</p>
        /// <p>The secret name must be ASCII letters, digits, or the following characters :
        /// /_+=.@-</p>
        /// <note>
        /// <p>Do not end your secret name with a hyphen followed by six characters. If you do so, you
        /// risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager
        /// automatically adds a hyphen and six random characters at the end of the ARN.</p>
        /// </note>
        pub fn name(mut self, inp: impl Into<std::string::String>) -> Self {
            self.name = Some(inp.into());
            self
        }
        pub fn set_name(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.name = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// <p>(Optional) Specifies the ARN, Key ID, or alias of the AWS KMS customer master key (CMK) to
        /// be used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values in the
        /// versions stored in this secret.</p>
        /// <p>You can specify any of the supported ways to identify a AWS KMS key ID. If you need to
        /// reference a CMK in a different account, you can use only the key ARN or the alias ARN.</p>
        /// <p>If you don't specify this value, then Secrets Manager defaults to using the AWS account's
        /// default CMK (the one named <code>aws/secretsmanager</code>). If a AWS KMS CMK with that name doesn't yet
        /// exist, then Secrets Manager creates it for you automatically the first time it needs to encrypt a
        /// version's <code>SecretString</code> or <code>SecretBinary</code> fields.</p>
        /// <important>
        /// <p>You can use the account default CMK to encrypt and decrypt only if you call this
        /// operation using credentials from the same account that owns the secret. If the secret
        /// resides in a different account, then you must create a custom CMK and specify the ARN in
        /// this field. </p>
        /// </important>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(inp.into());
            self
        }
        pub fn set_kms_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = inp;
            self
        }
        /// <p>(Optional) Specifies a user-provided description of the secret.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
        /// the secret.</p>
        /// <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
        /// both. They cannot both be empty.</p>
        /// <p>If you create a secret by using the Secrets Manager console then Secrets Manager puts the protected
        /// secret text in only the <code>SecretString</code> parameter. The Secrets Manager console stores the
        /// information as a JSON structure of key/value pairs that the Lambda rotation function knows how
        /// to parse.</p>
        /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
        /// specify key/value pairs. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
        /// <p>
        /// <code>{"username":"bob","password":"abc123xyz456"}</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
        pub fn secret_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_string = Some(inp.into());
            self
        }
        pub fn set_secret_string(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_string = inp;
            self
        }
        /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
        /// the secret. To use this parameter in the command-line tools, we recommend that you store your
        /// binary data in a file and then use the appropriate technique for your tool to pass the
        /// contents of the file as a parameter.</p>
        /// <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
        /// both. They cannot both be empty.</p>
        /// <p>This parameter is not available using the Secrets Manager console. It can be accessed only by
        /// using the AWS CLI or one of the AWS SDKs.</p>
        pub fn secret_binary(mut self, inp: smithy_types::Blob) -> Self {
            self.secret_binary = Some(inp);
            self
        }
        pub fn set_secret_binary(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.secret_binary = inp;
            self
        }
        /// <p>(Optional) If you include <code>SecretString</code> or <code>SecretBinary</code>, then an
        /// initial version is created as part of the secret, and this parameter specifies a unique
        /// identifier for the new version. </p>
        /// <note>
        /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes it
        /// as the value for this parameter in the request. If you don't use the SDK and instead
        /// generate a raw HTTP request to the Secrets Manager service endpoint, then you must generate a
        /// <code>ClientRequestToken</code> yourself for the new version and include the value in the
        /// request.</p>
        /// </note>
        /// <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
        /// creation of duplicate versions if there are failures and retries during a rotation. We
        /// recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
        /// ensure uniqueness of your versions within the specified secret. </p>
        /// <ul>
        /// <li>
        /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
        /// of the secret then a new version of the secret is created. </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and the version <code>SecretString</code>
        /// and <code>SecretBinary</code> values are the same as those in the request, then the
        /// request is ignored.</p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> and <code>SecretBinary</code> values are different from those
        /// in the request then the request fails because you cannot modify an existing version.
        /// Instead, use <a>PutSecretValue</a> to create a new version.</p>
        /// </li>
        /// </ul>
        /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(inp.into());
            self
        }
        pub fn set_client_request_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = inp;
            self
        }
        /// Consumes the builder and constructs a [`CreateSecretInput`](crate::input::CreateSecretInput)
        pub fn build(
            self,
        ) -> Result<crate::input::CreateSecretInput, smithy_http::operation::BuildError> {
            Ok(crate::input::CreateSecretInput {
                name: self.name,
                tags: self.tags,
                kms_key_id: self.kms_key_id,
                description: self.description,
                secret_string: self.secret_string,
                secret_binary: self.secret_binary,
                client_request_token: self.client_request_token,
            })
        }
    }
}
impl CreateSecretInput {
    /// Consumes the builder and constructs an Operation<[`CreateSecret`](crate::operation::CreateSecret)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::CreateSecret,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            if self.client_request_token.is_none() {
                self.client_request_token = Some(_config.make_token.make_idempotency_token());
            }

            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::CreateSecret::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "CreateSecret",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.CreateSecret"))
    }
    fn body(&self) -> crate::serializer::CreateSecretInputBody {
        crate::serializer::CreateSecretInputBody {
            name: &self.name,
            tags: &self.tags,
            kms_key_id: &self.kms_key_id,
            description: &self.description,
            secret_string: &self.secret_string,
            secret_binary: &self.secret_binary,
            client_request_token: &self.client_request_token,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`CreateSecretInput`](crate::input::CreateSecretInput)
    pub fn builder() -> crate::input::create_secret_input::Builder {
        crate::input::create_secret_input::Builder::default()
    }
}

/// See [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
pub mod delete_resource_policy_input {
    /// A builder for [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        secret_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the secret that you want to delete the attached resource-based policy for. You
        /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteResourcePolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::DeleteResourcePolicyInput {
                secret_id: self.secret_id,
            })
        }
    }
}
impl DeleteResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`DeleteResourcePolicy`](crate::operation::DeleteResourcePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteResourcePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteResourcePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteResourcePolicy",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.DeleteResourcePolicy"))
    }
    fn body(&self) -> crate::serializer::DeleteResourcePolicyInputBody {
        crate::serializer::DeleteResourcePolicyInputBody {
            secret_id: &self.secret_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    pub fn builder() -> crate::input::delete_resource_policy_input::Builder {
        crate::input::delete_resource_policy_input::Builder::default()
    }
}

/// See [`DeleteSecretInput`](crate::input::DeleteSecretInput)
pub mod delete_secret_input {
    /// A builder for [`DeleteSecretInput`](crate::input::DeleteSecretInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        force_delete_without_recovery: std::option::Option<bool>,
        recovery_window_in_days: std::option::Option<i64>,
        secret_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>(Optional) Specifies that the secret is to be deleted without any recovery window. You
        /// can't use both this parameter and the <code>RecoveryWindowInDays</code> parameter in the same
        /// API call.</p>
        /// <p>An asynchronous background process performs the actual deletion, so there can be a short
        /// delay before the operation completes. If you write code to delete and then immediately
        /// recreate a secret with the same name, ensure that your code includes appropriate back off and
        /// retry logic.</p>
        /// <important>
        /// <p>Use this parameter with caution. This parameter causes the operation to skip the normal
        /// waiting period before the permanent deletion that AWS would normally impose with the
        /// <code>RecoveryWindowInDays</code> parameter. If you delete a secret with the
        /// <code>ForceDeleteWithouRecovery</code> parameter, then you have no opportunity to recover
        /// the secret. It is permanently lost.</p>
        /// </important>
        pub fn force_delete_without_recovery(mut self, inp: bool) -> Self {
            self.force_delete_without_recovery = Some(inp);
            self
        }
        pub fn set_force_delete_without_recovery(mut self, inp: std::option::Option<bool>) -> Self {
            self.force_delete_without_recovery = inp;
            self
        }
        /// <p>(Optional) Specifies the number of days that Secrets Manager waits before it can delete the secret.
        /// You can't use both this parameter and the <code>ForceDeleteWithoutRecovery</code> parameter in
        /// the same API call.</p>
        /// <p>This value can range from 7 to 30 days. The default value is 30.</p>
        pub fn recovery_window_in_days(mut self, inp: i64) -> Self {
            self.recovery_window_in_days = Some(inp);
            self
        }
        pub fn set_recovery_window_in_days(mut self, inp: std::option::Option<i64>) -> Self {
            self.recovery_window_in_days = inp;
            self
        }
        /// <p>Specifies the secret that you want to delete. You can specify either the Amazon Resource
        /// Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`DeleteSecretInput`](crate::input::DeleteSecretInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DeleteSecretInput, smithy_http::operation::BuildError> {
            Ok(crate::input::DeleteSecretInput {
                force_delete_without_recovery: self.force_delete_without_recovery,
                recovery_window_in_days: self.recovery_window_in_days,
                secret_id: self.secret_id,
            })
        }
    }
}
impl DeleteSecretInput {
    /// Consumes the builder and constructs an Operation<[`DeleteSecret`](crate::operation::DeleteSecret)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DeleteSecret,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DeleteSecret::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DeleteSecret",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.DeleteSecret"))
    }
    fn body(&self) -> crate::serializer::DeleteSecretInputBody {
        crate::serializer::DeleteSecretInputBody {
            force_delete_without_recovery: &self.force_delete_without_recovery,
            recovery_window_in_days: &self.recovery_window_in_days,
            secret_id: &self.secret_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DeleteSecretInput`](crate::input::DeleteSecretInput)
    pub fn builder() -> crate::input::delete_secret_input::Builder {
        crate::input::delete_secret_input::Builder::default()
    }
}

/// See [`DescribeSecretInput`](crate::input::DescribeSecretInput)
pub mod describe_secret_input {
    /// A builder for [`DescribeSecretInput`](crate::input::DescribeSecretInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        secret_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the secret whose details you want to retrieve. You can specify either
        /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`DescribeSecretInput`](crate::input::DescribeSecretInput)
        pub fn build(
            self,
        ) -> Result<crate::input::DescribeSecretInput, smithy_http::operation::BuildError> {
            Ok(crate::input::DescribeSecretInput {
                secret_id: self.secret_id,
            })
        }
    }
}
impl DescribeSecretInput {
    /// Consumes the builder and constructs an Operation<[`DescribeSecret`](crate::operation::DescribeSecret)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::DescribeSecret,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::DescribeSecret::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "DescribeSecret",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.DescribeSecret"))
    }
    fn body(&self) -> crate::serializer::DescribeSecretInputBody {
        crate::serializer::DescribeSecretInputBody {
            secret_id: &self.secret_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`DescribeSecretInput`](crate::input::DescribeSecretInput)
    pub fn builder() -> crate::input::describe_secret_input::Builder {
        crate::input::describe_secret_input::Builder::default()
    }
}

/// See [`GetRandomPasswordInput`](crate::input::GetRandomPasswordInput)
pub mod get_random_password_input {
    /// A builder for [`GetRandomPasswordInput`](crate::input::GetRandomPasswordInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        exclude_numbers: std::option::Option<bool>,
        exclude_characters: std::option::Option<std::string::String>,
        password_length: std::option::Option<i64>,
        require_each_included_type: std::option::Option<bool>,
        include_space: std::option::Option<bool>,
        exclude_punctuation: std::option::Option<bool>,
        exclude_lowercase: std::option::Option<bool>,
        exclude_uppercase: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Specifies that the generated password should not include digits. The default if you do not
        /// include this switch parameter is that digits can be included.</p>
        pub fn exclude_numbers(mut self, inp: bool) -> Self {
            self.exclude_numbers = Some(inp);
            self
        }
        pub fn set_exclude_numbers(mut self, inp: std::option::Option<bool>) -> Self {
            self.exclude_numbers = inp;
            self
        }
        /// <p>A string that includes characters that should not be included in the generated password.
        /// The default is that all characters from the included sets can be used.</p>
        pub fn exclude_characters(mut self, inp: impl Into<std::string::String>) -> Self {
            self.exclude_characters = Some(inp.into());
            self
        }
        pub fn set_exclude_characters(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.exclude_characters = inp;
            self
        }
        /// <p>The desired length of the generated password. The default value if you do not include this
        /// parameter is 32 characters.</p>
        pub fn password_length(mut self, inp: i64) -> Self {
            self.password_length = Some(inp);
            self
        }
        pub fn set_password_length(mut self, inp: std::option::Option<i64>) -> Self {
            self.password_length = inp;
            self
        }
        /// <p>A boolean value that specifies whether the generated password must include at least one of
        /// every allowed character type. The default value is <code>True</code> and the operation
        /// requires at least one of every character type.</p>
        pub fn require_each_included_type(mut self, inp: bool) -> Self {
            self.require_each_included_type = Some(inp);
            self
        }
        pub fn set_require_each_included_type(mut self, inp: std::option::Option<bool>) -> Self {
            self.require_each_included_type = inp;
            self
        }
        /// <p>Specifies that the generated password can include the space character. The default if you
        /// do not include this switch parameter is that the space character is not included.</p>
        pub fn include_space(mut self, inp: bool) -> Self {
            self.include_space = Some(inp);
            self
        }
        pub fn set_include_space(mut self, inp: std::option::Option<bool>) -> Self {
            self.include_space = inp;
            self
        }
        /// <p>Specifies that the generated password should not include punctuation characters. The
        /// default if you do not include this switch parameter is that punctuation characters can be
        /// included.</p>
        /// <p>The following are the punctuation characters that <i>can</i> be included in
        /// the generated password if you don't explicitly exclude them with
        /// <code>ExcludeCharacters</code> or <code>ExcludePunctuation</code>:</p>
        /// <p>
        /// <code>! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | }
        /// ~</code>
        /// </p>
        pub fn exclude_punctuation(mut self, inp: bool) -> Self {
            self.exclude_punctuation = Some(inp);
            self
        }
        pub fn set_exclude_punctuation(mut self, inp: std::option::Option<bool>) -> Self {
            self.exclude_punctuation = inp;
            self
        }
        /// <p>Specifies that the generated password should not include lowercase letters. The default if
        /// you do not include this switch parameter is that lowercase letters can be included.</p>
        pub fn exclude_lowercase(mut self, inp: bool) -> Self {
            self.exclude_lowercase = Some(inp);
            self
        }
        pub fn set_exclude_lowercase(mut self, inp: std::option::Option<bool>) -> Self {
            self.exclude_lowercase = inp;
            self
        }
        /// <p>Specifies that the generated password should not include uppercase letters. The default if
        /// you do not include this switch parameter is that uppercase letters can be included.</p>
        pub fn exclude_uppercase(mut self, inp: bool) -> Self {
            self.exclude_uppercase = Some(inp);
            self
        }
        pub fn set_exclude_uppercase(mut self, inp: std::option::Option<bool>) -> Self {
            self.exclude_uppercase = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetRandomPasswordInput`](crate::input::GetRandomPasswordInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetRandomPasswordInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetRandomPasswordInput {
                exclude_numbers: self.exclude_numbers,
                exclude_characters: self.exclude_characters,
                password_length: self.password_length,
                require_each_included_type: self.require_each_included_type,
                include_space: self.include_space,
                exclude_punctuation: self.exclude_punctuation,
                exclude_lowercase: self.exclude_lowercase,
                exclude_uppercase: self.exclude_uppercase,
            })
        }
    }
}
impl GetRandomPasswordInput {
    /// Consumes the builder and constructs an Operation<[`GetRandomPassword`](crate::operation::GetRandomPassword)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetRandomPassword,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetRandomPassword::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetRandomPassword",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.GetRandomPassword"))
    }
    fn body(&self) -> crate::serializer::GetRandomPasswordInputBody {
        crate::serializer::GetRandomPasswordInputBody {
            exclude_numbers: &self.exclude_numbers,
            exclude_characters: &self.exclude_characters,
            password_length: &self.password_length,
            require_each_included_type: &self.require_each_included_type,
            include_space: &self.include_space,
            exclude_punctuation: &self.exclude_punctuation,
            exclude_lowercase: &self.exclude_lowercase,
            exclude_uppercase: &self.exclude_uppercase,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`GetRandomPasswordInput`](crate::input::GetRandomPasswordInput)
    pub fn builder() -> crate::input::get_random_password_input::Builder {
        crate::input::get_random_password_input::Builder::default()
    }
}

/// See [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput)
pub mod get_resource_policy_input {
    /// A builder for [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        secret_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the secret that you want to retrieve the attached resource-based policy for. You
        /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetResourcePolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::GetResourcePolicyInput {
                secret_id: self.secret_id,
            })
        }
    }
}
impl GetResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`GetResourcePolicy`](crate::operation::GetResourcePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetResourcePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetResourcePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetResourcePolicy",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.GetResourcePolicy"))
    }
    fn body(&self) -> crate::serializer::GetResourcePolicyInputBody {
        crate::serializer::GetResourcePolicyInputBody {
            secret_id: &self.secret_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput)
    pub fn builder() -> crate::input::get_resource_policy_input::Builder {
        crate::input::get_resource_policy_input::Builder::default()
    }
}

/// See [`GetSecretValueInput`](crate::input::GetSecretValueInput)
pub mod get_secret_value_input {
    /// A builder for [`GetSecretValueInput`](crate::input::GetSecretValueInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        secret_id: std::option::Option<std::string::String>,
        version_stage: std::option::Option<std::string::String>,
        version_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the secret containing the version that you want to retrieve. You can specify
        /// either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// <p>Specifies the secret version that you want to retrieve by the staging label attached to
        /// the version.</p>
        /// <p>Staging labels are used to keep track of different versions during the rotation process.
        /// If you use this parameter then don't specify <code>VersionId</code>. If you don't
        /// specify either a <code>VersionStage</code> or <code>VersionId</code>, then the default is to
        /// perform the operation on the version with the <code>VersionStage</code> value of
        /// <code>AWSCURRENT</code>.</p>
        pub fn version_stage(mut self, inp: impl Into<std::string::String>) -> Self {
            self.version_stage = Some(inp.into());
            self
        }
        pub fn set_version_stage(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.version_stage = inp;
            self
        }
        /// <p>Specifies the unique identifier of the version of the secret that you want to retrieve. If
        /// you specify this parameter then don't specify <code>VersionStage</code>. If you
        /// don't specify either a <code>VersionStage</code> or <code>VersionId</code> then the
        /// default is to perform the operation on the version with the <code>VersionStage</code> value of
        /// <code>AWSCURRENT</code>.</p>
        /// <p>This value is typically a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value with
        /// 32 hexadecimal digits.</p>
        pub fn version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.version_id = Some(inp.into());
            self
        }
        pub fn set_version_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.version_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`GetSecretValueInput`](crate::input::GetSecretValueInput)
        pub fn build(
            self,
        ) -> Result<crate::input::GetSecretValueInput, smithy_http::operation::BuildError> {
            Ok(crate::input::GetSecretValueInput {
                secret_id: self.secret_id,
                version_stage: self.version_stage,
                version_id: self.version_id,
            })
        }
    }
}
impl GetSecretValueInput {
    /// Consumes the builder and constructs an Operation<[`GetSecretValue`](crate::operation::GetSecretValue)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::GetSecretValue,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::GetSecretValue::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "GetSecretValue",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.GetSecretValue"))
    }
    fn body(&self) -> crate::serializer::GetSecretValueInputBody {
        crate::serializer::GetSecretValueInputBody {
            secret_id: &self.secret_id,
            version_stage: &self.version_stage,
            version_id: &self.version_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`GetSecretValueInput`](crate::input::GetSecretValueInput)
    pub fn builder() -> crate::input::get_secret_value_input::Builder {
        crate::input::get_secret_value_input::Builder::default()
    }
}

/// See [`ListSecretsInput`](crate::input::ListSecretsInput)
pub mod list_secrets_input {
    /// A builder for [`ListSecretsInput`](crate::input::ListSecretsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        max_results: std::option::Option<i32>,
        sort_order: std::option::Option<crate::model::SortOrderType>,
        next_token: std::option::Option<std::string::String>,
        filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
    }
    impl Builder {
        /// <p>(Optional) Limits the number of results you want to include in
        /// the response. If you don't include this parameter, it defaults to a value that's
        /// specific to the operation. If additional items exist beyond the maximum you specify, the
        /// <code>NextToken</code> response element is present and has a value (isn't null). Include
        /// that value as the <code>NextToken</code> request parameter in the next call to the operation to
        /// get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
        /// even when there are more results available. You should check <code>NextToken</code> after every
        /// operation to ensure that you receive all of the results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.max_results = Some(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_results = inp;
            self
        }
        /// <p>Lists secrets in the requested order. </p>
        pub fn sort_order(mut self, inp: crate::model::SortOrderType) -> Self {
            self.sort_order = Some(inp);
            self
        }
        pub fn set_sort_order(
            mut self,
            inp: std::option::Option<crate::model::SortOrderType>,
        ) -> Self {
            self.sort_order = inp;
            self
        }
        /// <p>(Optional) Use this parameter in a request if you receive a
        /// <code>NextToken</code> response in a previous request indicating there's more
        /// output available. In a subsequent call, set it to the value of the previous call
        /// <code>NextToken</code> response to indicate where the output should continue from.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.next_token = Some(inp.into());
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.next_token = inp;
            self
        }
        pub fn filters(mut self, inp: impl Into<crate::model::Filter>) -> Self {
            let mut v = self.filters.unwrap_or_default();
            v.push(inp.into());
            self.filters = Some(v);
            self
        }
        pub fn set_filters(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Filter>>,
        ) -> Self {
            self.filters = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListSecretsInput`](crate::input::ListSecretsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListSecretsInput, smithy_http::operation::BuildError> {
            Ok(crate::input::ListSecretsInput {
                max_results: self.max_results,
                sort_order: self.sort_order,
                next_token: self.next_token,
                filters: self.filters,
            })
        }
    }
}
impl ListSecretsInput {
    /// Consumes the builder and constructs an Operation<[`ListSecrets`](crate::operation::ListSecrets)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListSecrets,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListSecrets::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListSecrets",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.ListSecrets"))
    }
    fn body(&self) -> crate::serializer::ListSecretsInputBody {
        crate::serializer::ListSecretsInputBody {
            max_results: &self.max_results,
            sort_order: &self.sort_order,
            next_token: &self.next_token,
            filters: &self.filters,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ListSecretsInput`](crate::input::ListSecretsInput)
    pub fn builder() -> crate::input::list_secrets_input::Builder {
        crate::input::list_secrets_input::Builder::default()
    }
}

/// See [`ListSecretVersionIdsInput`](crate::input::ListSecretVersionIdsInput)
pub mod list_secret_version_ids_input {
    /// A builder for [`ListSecretVersionIdsInput`](crate::input::ListSecretVersionIdsInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        max_results: std::option::Option<i32>,
        secret_id: std::option::Option<std::string::String>,
        next_token: std::option::Option<std::string::String>,
        include_deprecated: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>(Optional) Limits the number of results you want to include in
        /// the response. If you don't include this parameter, it defaults to a value that's
        /// specific to the operation. If additional items exist beyond the maximum you specify, the
        /// <code>NextToken</code> response element is present and has a value (isn't null). Include
        /// that value as the <code>NextToken</code> request parameter in the next call to the operation to
        /// get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
        /// even when there are more results available. You should check <code>NextToken</code> after every
        /// operation to ensure that you receive all of the results.</p>
        pub fn max_results(mut self, inp: i32) -> Self {
            self.max_results = Some(inp);
            self
        }
        pub fn set_max_results(mut self, inp: std::option::Option<i32>) -> Self {
            self.max_results = inp;
            self
        }
        /// <p>The identifier for the secret containing the versions you want to list. You can specify
        /// either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// <p>(Optional) Use this parameter in a request if you receive a
        /// <code>NextToken</code> response in a previous request indicating there's more
        /// output available. In a subsequent call, set it to the value of the previous call
        /// <code>NextToken</code> response to indicate where the output should continue from.</p>
        pub fn next_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.next_token = Some(inp.into());
            self
        }
        pub fn set_next_token(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.next_token = inp;
            self
        }
        /// <p>(Optional) Specifies that you want the results to include versions that do not have any
        /// staging labels attached to them. Such versions are considered deprecated and are subject to
        /// deletion by Secrets Manager as needed.</p>
        pub fn include_deprecated(mut self, inp: bool) -> Self {
            self.include_deprecated = Some(inp);
            self
        }
        pub fn set_include_deprecated(mut self, inp: std::option::Option<bool>) -> Self {
            self.include_deprecated = inp;
            self
        }
        /// Consumes the builder and constructs a [`ListSecretVersionIdsInput`](crate::input::ListSecretVersionIdsInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ListSecretVersionIdsInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ListSecretVersionIdsInput {
                max_results: self.max_results,
                secret_id: self.secret_id,
                next_token: self.next_token,
                include_deprecated: self.include_deprecated,
            })
        }
    }
}
impl ListSecretVersionIdsInput {
    /// Consumes the builder and constructs an Operation<[`ListSecretVersionIds`](crate::operation::ListSecretVersionIds)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ListSecretVersionIds,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ListSecretVersionIds::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ListSecretVersionIds",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.ListSecretVersionIds"))
    }
    fn body(&self) -> crate::serializer::ListSecretVersionIdsInputBody {
        crate::serializer::ListSecretVersionIdsInputBody {
            max_results: &self.max_results,
            secret_id: &self.secret_id,
            next_token: &self.next_token,
            include_deprecated: &self.include_deprecated,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ListSecretVersionIdsInput`](crate::input::ListSecretVersionIdsInput)
    pub fn builder() -> crate::input::list_secret_version_ids_input::Builder {
        crate::input::list_secret_version_ids_input::Builder::default()
    }
}

/// See [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
pub mod put_resource_policy_input {
    /// A builder for [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        resource_policy: std::option::Option<std::string::String>,
        block_public_policy: std::option::Option<bool>,
        secret_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>A JSON-formatted string that's constructed according to the grammar and syntax for an
        /// AWS resource-based policy. The policy in the string identifies who can access or manage this
        /// secret and its versions. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
        /// JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
        pub fn resource_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_policy = Some(inp.into());
            self
        }
        pub fn set_resource_policy(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_policy = inp;
            self
        }
        /// <p>Makes an optional API call to Zelkova to validate the Resource Policy to prevent broad access to your secret.</p>
        pub fn block_public_policy(mut self, inp: bool) -> Self {
            self.block_public_policy = Some(inp);
            self
        }
        pub fn set_block_public_policy(mut self, inp: std::option::Option<bool>) -> Self {
            self.block_public_policy = inp;
            self
        }
        /// <p>Specifies the secret that you want to attach the resource-based policy to. You can specify
        /// either the ARN or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::PutResourcePolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::PutResourcePolicyInput {
                resource_policy: self.resource_policy,
                block_public_policy: self.block_public_policy,
                secret_id: self.secret_id,
            })
        }
    }
}
impl PutResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`PutResourcePolicy`](crate::operation::PutResourcePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::PutResourcePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutResourcePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutResourcePolicy",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.PutResourcePolicy"))
    }
    fn body(&self) -> crate::serializer::PutResourcePolicyInputBody {
        crate::serializer::PutResourcePolicyInputBody {
            resource_policy: &self.resource_policy,
            block_public_policy: &self.block_public_policy,
            secret_id: &self.secret_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
    pub fn builder() -> crate::input::put_resource_policy_input::Builder {
        crate::input::put_resource_policy_input::Builder::default()
    }
}

/// See [`PutSecretValueInput`](crate::input::PutSecretValueInput)
pub mod put_secret_value_input {
    /// A builder for [`PutSecretValueInput`](crate::input::PutSecretValueInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        client_request_token: std::option::Option<std::string::String>,
        secret_id: std::option::Option<std::string::String>,
        secret_string: std::option::Option<std::string::String>,
        secret_binary: std::option::Option<smithy_types::Blob>,
        version_stages: std::option::Option<std::vec::Vec<std::string::String>>,
    }
    impl Builder {
        /// <p>(Optional) Specifies a unique identifier for the new version of the secret. </p>
        /// <note>
        /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
        /// in the request. If you don't use the SDK and instead generate a raw HTTP request to the
        /// Secrets Manager service endpoint, then you must generate a <code>ClientRequestToken</code> yourself
        /// for new versions and include that value in the request. </p>
        /// </note>
        /// <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
        /// creation of duplicate versions if there are failures and retries during the Lambda rotation
        /// function's processing. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
        /// ensure uniqueness within the specified secret. </p>
        /// <ul>
        /// <li>
        /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
        /// of the secret then a new version of the secret is created. </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> or <code>SecretBinary</code> values are the same as those in
        /// the request then the request is ignored (the operation is idempotent). </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and the version of the
        /// <code>SecretString</code> and <code>SecretBinary</code> values are different from those
        /// in the request then the request fails because you cannot modify an existing secret
        /// version. You can only create new versions to store new secret values.</p>
        /// </li>
        /// </ul>
        /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(inp.into());
            self
        }
        pub fn set_client_request_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = inp;
            self
        }
        /// <p>Specifies the secret to which you want to add a new version. You can specify either the
        /// Amazon Resource Name (ARN) or the friendly name of the secret. The secret must already
        /// exist.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
        /// the secret. Either <code>SecretString</code> or <code>SecretBinary</code> must have a value,
        /// but not both. They cannot both be empty.</p>
        /// <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
        /// protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
        /// stores the information as a JSON structure of key/value pairs that the default Lambda rotation
        /// function knows how to parse.</p>
        /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
        /// specify key/value pairs. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
        /// <p> For example:</p>
        /// <p>
        /// <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text.</p>
        pub fn secret_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_string = Some(inp.into());
            self
        }
        pub fn set_secret_string(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_string = inp;
            self
        }
        /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
        /// the secret. To use this parameter in the command-line tools, we recommend that you store your
        /// binary data in a file and then use the appropriate technique for your tool to pass the
        /// contents of the file as a parameter. Either <code>SecretBinary</code> or
        /// <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
        /// <p>This parameter is not accessible if the secret using the Secrets Manager console.</p>
        /// <p></p>
        pub fn secret_binary(mut self, inp: smithy_types::Blob) -> Self {
            self.secret_binary = Some(inp);
            self
        }
        pub fn set_secret_binary(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.secret_binary = inp;
            self
        }
        pub fn version_stages(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.version_stages.unwrap_or_default();
            v.push(inp.into());
            self.version_stages = Some(v);
            self
        }
        pub fn set_version_stages(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.version_stages = inp;
            self
        }
        /// Consumes the builder and constructs a [`PutSecretValueInput`](crate::input::PutSecretValueInput)
        pub fn build(
            self,
        ) -> Result<crate::input::PutSecretValueInput, smithy_http::operation::BuildError> {
            Ok(crate::input::PutSecretValueInput {
                client_request_token: self.client_request_token,
                secret_id: self.secret_id,
                secret_string: self.secret_string,
                secret_binary: self.secret_binary,
                version_stages: self.version_stages,
            })
        }
    }
}
impl PutSecretValueInput {
    /// Consumes the builder and constructs an Operation<[`PutSecretValue`](crate::operation::PutSecretValue)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::PutSecretValue,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            if self.client_request_token.is_none() {
                self.client_request_token = Some(_config.make_token.make_idempotency_token());
            }

            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::PutSecretValue::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "PutSecretValue",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.PutSecretValue"))
    }
    fn body(&self) -> crate::serializer::PutSecretValueInputBody {
        crate::serializer::PutSecretValueInputBody {
            client_request_token: &self.client_request_token,
            secret_id: &self.secret_id,
            secret_string: &self.secret_string,
            secret_binary: &self.secret_binary,
            version_stages: &self.version_stages,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`PutSecretValueInput`](crate::input::PutSecretValueInput)
    pub fn builder() -> crate::input::put_secret_value_input::Builder {
        crate::input::put_secret_value_input::Builder::default()
    }
}

/// See [`RestoreSecretInput`](crate::input::RestoreSecretInput)
pub mod restore_secret_input {
    /// A builder for [`RestoreSecretInput`](crate::input::RestoreSecretInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        secret_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the secret that you want to restore from a previously scheduled deletion. You
        /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`RestoreSecretInput`](crate::input::RestoreSecretInput)
        pub fn build(
            self,
        ) -> Result<crate::input::RestoreSecretInput, smithy_http::operation::BuildError> {
            Ok(crate::input::RestoreSecretInput {
                secret_id: self.secret_id,
            })
        }
    }
}
impl RestoreSecretInput {
    /// Consumes the builder and constructs an Operation<[`RestoreSecret`](crate::operation::RestoreSecret)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::RestoreSecret,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::RestoreSecret::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "RestoreSecret",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.RestoreSecret"))
    }
    fn body(&self) -> crate::serializer::RestoreSecretInputBody {
        crate::serializer::RestoreSecretInputBody {
            secret_id: &self.secret_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`RestoreSecretInput`](crate::input::RestoreSecretInput)
    pub fn builder() -> crate::input::restore_secret_input::Builder {
        crate::input::restore_secret_input::Builder::default()
    }
}

/// See [`RotateSecretInput`](crate::input::RotateSecretInput)
pub mod rotate_secret_input {
    /// A builder for [`RotateSecretInput`](crate::input::RotateSecretInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        secret_id: std::option::Option<std::string::String>,
        client_request_token: std::option::Option<std::string::String>,
        rotation_rules: std::option::Option<crate::model::RotationRulesType>,
        rotation_lambda_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Specifies the secret that you want to rotate. You can specify either the Amazon Resource
        /// Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// <p>(Optional) Specifies a unique identifier for the new version of the secret that helps
        /// ensure idempotency. </p>
        /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
        /// in the request for this parameter. If you don't use the SDK and instead generate a raw HTTP
        /// request to the Secrets Manager service endpoint, then you must generate a
        /// <code>ClientRequestToken</code> yourself for new versions and include that value in the
        /// request.</p>
        /// <p>You only need to specify your own value if you implement your own retry logic and want to
        /// ensure that a given secret is not created twice. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
        /// ensure uniqueness within the specified secret. </p>
        /// <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
        /// there are failures and retries during the function's processing. This value becomes the
        /// <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(inp.into());
            self
        }
        pub fn set_client_request_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = inp;
            self
        }
        /// <p>A structure that defines the rotation configuration for this secret.</p>
        pub fn rotation_rules(mut self, inp: crate::model::RotationRulesType) -> Self {
            self.rotation_rules = Some(inp);
            self
        }
        pub fn set_rotation_rules(
            mut self,
            inp: std::option::Option<crate::model::RotationRulesType>,
        ) -> Self {
            self.rotation_rules = inp;
            self
        }
        /// <p>(Optional) Specifies the ARN of the Lambda function that can rotate the secret.</p>
        pub fn rotation_lambda_arn(mut self, inp: impl Into<std::string::String>) -> Self {
            self.rotation_lambda_arn = Some(inp.into());
            self
        }
        pub fn set_rotation_lambda_arn(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.rotation_lambda_arn = inp;
            self
        }
        /// Consumes the builder and constructs a [`RotateSecretInput`](crate::input::RotateSecretInput)
        pub fn build(
            self,
        ) -> Result<crate::input::RotateSecretInput, smithy_http::operation::BuildError> {
            Ok(crate::input::RotateSecretInput {
                secret_id: self.secret_id,
                client_request_token: self.client_request_token,
                rotation_rules: self.rotation_rules,
                rotation_lambda_arn: self.rotation_lambda_arn,
            })
        }
    }
}
impl RotateSecretInput {
    /// Consumes the builder and constructs an Operation<[`RotateSecret`](crate::operation::RotateSecret)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::RotateSecret,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            if self.client_request_token.is_none() {
                self.client_request_token = Some(_config.make_token.make_idempotency_token());
            }

            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::RotateSecret::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "RotateSecret",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.RotateSecret"))
    }
    fn body(&self) -> crate::serializer::RotateSecretInputBody {
        crate::serializer::RotateSecretInputBody {
            secret_id: &self.secret_id,
            client_request_token: &self.client_request_token,
            rotation_rules: &self.rotation_rules,
            rotation_lambda_arn: &self.rotation_lambda_arn,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`RotateSecretInput`](crate::input::RotateSecretInput)
    pub fn builder() -> crate::input::rotate_secret_input::Builder {
        crate::input::rotate_secret_input::Builder::default()
    }
}

/// See [`TagResourceInput`](crate::input::TagResourceInput)
pub mod tag_resource_input {
    /// A builder for [`TagResourceInput`](crate::input::TagResourceInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        secret_id: std::option::Option<std::string::String>,
        tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The identifier for the secret that you want to attach tags to. You can specify either the
        /// Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        pub fn tags(mut self, inp: impl Into<crate::model::Tag>) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(inp.into());
            self.tags = Some(v);
            self
        }
        pub fn set_tags(
            mut self,
            inp: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = inp;
            self
        }
        /// Consumes the builder and constructs a [`TagResourceInput`](crate::input::TagResourceInput)
        pub fn build(
            self,
        ) -> Result<crate::input::TagResourceInput, smithy_http::operation::BuildError> {
            Ok(crate::input::TagResourceInput {
                secret_id: self.secret_id,
                tags: self.tags,
            })
        }
    }
}
impl TagResourceInput {
    /// Consumes the builder and constructs an Operation<[`TagResource`](crate::operation::TagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::TagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::TagResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "TagResource",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.TagResource"))
    }
    fn body(&self) -> crate::serializer::TagResourceInputBody {
        crate::serializer::TagResourceInputBody {
            secret_id: &self.secret_id,
            tags: &self.tags,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
}

/// See [`UntagResourceInput`](crate::input::UntagResourceInput)
pub mod untag_resource_input {
    /// A builder for [`UntagResourceInput`](crate::input::UntagResourceInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
        secret_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            let mut v = self.tag_keys.unwrap_or_default();
            v.push(inp.into());
            self.tag_keys = Some(v);
            self
        }
        pub fn set_tag_keys(
            mut self,
            inp: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.tag_keys = inp;
            self
        }
        /// <p>The identifier for the secret that you want to remove tags from. You can specify either
        /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`UntagResourceInput`](crate::input::UntagResourceInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UntagResourceInput, smithy_http::operation::BuildError> {
            Ok(crate::input::UntagResourceInput {
                tag_keys: self.tag_keys,
                secret_id: self.secret_id,
            })
        }
    }
}
impl UntagResourceInput {
    /// Consumes the builder and constructs an Operation<[`UntagResource`](crate::operation::UntagResource)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UntagResource,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UntagResource::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UntagResource",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.UntagResource"))
    }
    fn body(&self) -> crate::serializer::UntagResourceInputBody {
        crate::serializer::UntagResourceInputBody {
            tag_keys: &self.tag_keys,
            secret_id: &self.secret_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
}

/// See [`UpdateSecretInput`](crate::input::UpdateSecretInput)
pub mod update_secret_input {
    /// A builder for [`UpdateSecretInput`](crate::input::UpdateSecretInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        secret_string: std::option::Option<std::string::String>,
        kms_key_id: std::option::Option<std::string::String>,
        secret_id: std::option::Option<std::string::String>,
        description: std::option::Option<std::string::String>,
        client_request_token: std::option::Option<std::string::String>,
        secret_binary: std::option::Option<smithy_types::Blob>,
    }
    impl Builder {
        /// <p>(Optional) Specifies updated text data that you want to encrypt and store in this new
        /// version of the secret. Either <code>SecretBinary</code> or <code>SecretString</code> must have
        /// a value, but not both. They cannot both be empty.</p>
        /// <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
        /// protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
        /// stores the information as a JSON structure of key/value pairs that the default Lambda rotation
        /// function knows how to parse.</p>
        /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
        /// specify key/value pairs. For information on how to format a JSON parameter for the various
        /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
        /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
        /// <p>
        /// <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
        /// </p>
        /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
        /// use single quotes to avoid confusion with the double quotes required in the JSON text. You can
        /// also 'escape' the double quote character in the embedded JSON text by prefacing each with a
        /// backslash. For example, the following string is surrounded by double-quotes. All of the
        /// embedded double quotes are escaped:</p>
        /// <p>
        /// <code>"[{\"username\":\"bob\"},{\"password\":\"abc123xyz456\"}]"</code>
        /// </p>
        pub fn secret_string(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_string = Some(inp.into());
            self
        }
        pub fn set_secret_string(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_string = inp;
            self
        }
        /// <p>(Optional) Specifies an updated ARN or alias of the AWS KMS customer master key (CMK) to be
        /// used to encrypt the protected text in new versions of this secret.</p>
        /// <important>
        /// <p>You can only use the account's default CMK to encrypt and decrypt if you call this
        /// operation using credentials from the same account that owns the secret. If the secret is in
        /// a different account, then you must create a custom CMK and provide the ARN of that CMK in
        /// this field. The user making the call must have permissions to both the secret and the CMK in
        /// their respective accounts.</p>
        /// </important>
        pub fn kms_key_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.kms_key_id = Some(inp.into());
            self
        }
        pub fn set_kms_key_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.kms_key_id = inp;
            self
        }
        /// <p>Specifies the secret that you want to modify or to which you want to add a new version.
        /// You can specify either the Amazon Resource Name (ARN) or the friendly name of the
        /// secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// <p>(Optional) Specifies an updated user-provided description of the secret.</p>
        pub fn description(mut self, inp: impl Into<std::string::String>) -> Self {
            self.description = Some(inp.into());
            self
        }
        pub fn set_description(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.description = inp;
            self
        }
        /// <p>(Optional) If you want to add a new version to the secret, this parameter specifies a
        /// unique identifier for the new version that helps ensure idempotency. </p>
        /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
        /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
        /// in the request. If you don't use the SDK and instead generate a raw HTTP request to the Secrets Manager
        /// service endpoint, then you must generate a <code>ClientRequestToken</code> yourself for new
        /// versions and include that value in the request.</p>
        /// <p>You typically only need to interact with this value if you implement your own retry logic
        /// and want to ensure that a given secret is not created twice. We recommend that you generate a
        /// <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a>
        /// value to ensure uniqueness within the specified secret. </p>
        /// <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
        /// there are failures and retries during the Lambda rotation function's processing.</p>
        /// <ul>
        /// <li>
        /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
        /// of the secret then a new version of the secret is created. </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> and <code>SecretBinary</code> values are the same as those in
        /// the request then the request is ignored (the operation is idempotent). </p>
        /// </li>
        /// <li>
        /// <p>If a version with this value already exists and that version's
        /// <code>SecretString</code> and <code>SecretBinary</code> values are different from the
        /// request then an error occurs because you cannot modify an existing secret value.</p>
        /// </li>
        /// </ul>
        /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
        pub fn client_request_token(mut self, inp: impl Into<std::string::String>) -> Self {
            self.client_request_token = Some(inp.into());
            self
        }
        pub fn set_client_request_token(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.client_request_token = inp;
            self
        }
        /// <p>(Optional) Specifies updated binary data that you want to encrypt and store in the new
        /// version of the secret. To use this parameter in the command-line tools, we recommend that you
        /// store your binary data in a file and then use the appropriate technique for your tool to pass
        /// the contents of the file as a parameter. Either <code>SecretBinary</code> or
        /// <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
        /// <p>This parameter is not accessible using the Secrets Manager console.</p>
        pub fn secret_binary(mut self, inp: smithy_types::Blob) -> Self {
            self.secret_binary = Some(inp);
            self
        }
        pub fn set_secret_binary(mut self, inp: std::option::Option<smithy_types::Blob>) -> Self {
            self.secret_binary = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSecretInput`](crate::input::UpdateSecretInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateSecretInput, smithy_http::operation::BuildError> {
            Ok(crate::input::UpdateSecretInput {
                secret_string: self.secret_string,
                kms_key_id: self.kms_key_id,
                secret_id: self.secret_id,
                description: self.description,
                client_request_token: self.client_request_token,
                secret_binary: self.secret_binary,
            })
        }
    }
}
impl UpdateSecretInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSecret`](crate::operation::UpdateSecret)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        mut self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateSecret,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            if self.client_request_token.is_none() {
                self.client_request_token = Some(_config.make_token.make_idempotency_token());
            }

            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateSecret::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateSecret",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.UpdateSecret"))
    }
    fn body(&self) -> crate::serializer::UpdateSecretInputBody {
        crate::serializer::UpdateSecretInputBody {
            secret_string: &self.secret_string,
            kms_key_id: &self.kms_key_id,
            secret_id: &self.secret_id,
            description: &self.description,
            client_request_token: &self.client_request_token,
            secret_binary: &self.secret_binary,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`UpdateSecretInput`](crate::input::UpdateSecretInput)
    pub fn builder() -> crate::input::update_secret_input::Builder {
        crate::input::update_secret_input::Builder::default()
    }
}

/// See [`UpdateSecretVersionStageInput`](crate::input::UpdateSecretVersionStageInput)
pub mod update_secret_version_stage_input {
    /// A builder for [`UpdateSecretVersionStageInput`](crate::input::UpdateSecretVersionStageInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        move_to_version_id: std::option::Option<std::string::String>,
        secret_id: std::option::Option<std::string::String>,
        remove_from_version_id: std::option::Option<std::string::String>,
        version_stage: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>(Optional) The secret version ID that you want to add the staging label. If you want to
        /// remove a label from a version, then do not specify this parameter.</p>
        /// <p>If the staging label is already attached to a different version of the secret, then you
        /// must also specify the <code>RemoveFromVersionId</code> parameter. </p>
        pub fn move_to_version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.move_to_version_id = Some(inp.into());
            self
        }
        pub fn set_move_to_version_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.move_to_version_id = inp;
            self
        }
        /// <p>Specifies the secret with the version with the list of staging labels you want to modify.
        /// You can specify either the Amazon Resource Name (ARN) or the friendly name of the
        /// secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// <p>Specifies the secret version ID of the version that the staging label is to be removed
        /// from. If the staging label you are trying to attach to one version is already attached to a
        /// different version, then you must include this parameter and specify the version that the label
        /// is to be removed from. If the label is attached and you either do not specify this parameter,
        /// or the version ID does not match, then the operation fails.</p>
        pub fn remove_from_version_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.remove_from_version_id = Some(inp.into());
            self
        }
        pub fn set_remove_from_version_id(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.remove_from_version_id = inp;
            self
        }
        /// <p>The staging label to add to this version.</p>
        pub fn version_stage(mut self, inp: impl Into<std::string::String>) -> Self {
            self.version_stage = Some(inp.into());
            self
        }
        pub fn set_version_stage(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.version_stage = inp;
            self
        }
        /// Consumes the builder and constructs a [`UpdateSecretVersionStageInput`](crate::input::UpdateSecretVersionStageInput)
        pub fn build(
            self,
        ) -> Result<crate::input::UpdateSecretVersionStageInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::UpdateSecretVersionStageInput {
                move_to_version_id: self.move_to_version_id,
                secret_id: self.secret_id,
                remove_from_version_id: self.remove_from_version_id,
                version_stage: self.version_stage,
            })
        }
    }
}
impl UpdateSecretVersionStageInput {
    /// Consumes the builder and constructs an Operation<[`UpdateSecretVersionStage`](crate::operation::UpdateSecretVersionStage)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::UpdateSecretVersionStage,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::UpdateSecretVersionStage::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "UpdateSecretVersionStage",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.UpdateSecretVersionStage"))
    }
    fn body(&self) -> crate::serializer::UpdateSecretVersionStageInputBody {
        crate::serializer::UpdateSecretVersionStageInputBody {
            move_to_version_id: &self.move_to_version_id,
            secret_id: &self.secret_id,
            remove_from_version_id: &self.remove_from_version_id,
            version_stage: &self.version_stage,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`UpdateSecretVersionStageInput`](crate::input::UpdateSecretVersionStageInput)
    pub fn builder() -> crate::input::update_secret_version_stage_input::Builder {
        crate::input::update_secret_version_stage_input::Builder::default()
    }
}

/// See [`ValidateResourcePolicyInput`](crate::input::ValidateResourcePolicyInput)
pub mod validate_resource_policy_input {
    /// A builder for [`ValidateResourcePolicyInput`](crate::input::ValidateResourcePolicyInput)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        resource_policy: std::option::Option<std::string::String>,
        secret_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Identifies the Resource Policy attached to the secret.</p>
        pub fn resource_policy(mut self, inp: impl Into<std::string::String>) -> Self {
            self.resource_policy = Some(inp.into());
            self
        }
        pub fn set_resource_policy(
            mut self,
            inp: std::option::Option<std::string::String>,
        ) -> Self {
            self.resource_policy = inp;
            self
        }
        /// <p> The identifier for the secret that you want to validate a resource policy. You can specify either
        /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
        /// <note>
        /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
        /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
        /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
        /// match can work as long as it uniquely matches only one secret. However, if your secret has a
        /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
        /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
        /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
        /// results. To avoid this situation, we recommend that you don’t create secret names ending
        /// with a hyphen followed by six characters.</p>
        /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
        /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
        /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
        /// </note>
        pub fn secret_id(mut self, inp: impl Into<std::string::String>) -> Self {
            self.secret_id = Some(inp.into());
            self
        }
        pub fn set_secret_id(mut self, inp: std::option::Option<std::string::String>) -> Self {
            self.secret_id = inp;
            self
        }
        /// Consumes the builder and constructs a [`ValidateResourcePolicyInput`](crate::input::ValidateResourcePolicyInput)
        pub fn build(
            self,
        ) -> Result<crate::input::ValidateResourcePolicyInput, smithy_http::operation::BuildError>
        {
            Ok(crate::input::ValidateResourcePolicyInput {
                resource_policy: self.resource_policy,
                secret_id: self.secret_id,
            })
        }
    }
}
impl ValidateResourcePolicyInput {
    /// Consumes the builder and constructs an Operation<[`ValidateResourcePolicy`](crate::operation::ValidateResourcePolicy)>
    #[allow(clippy::let_and_return)]
    pub fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> Result<
        smithy_http::operation::Operation<
            crate::operation::ValidateResourcePolicy,
            aws_http::AwsErrorRetryPolicy,
        >,
        smithy_http::operation::BuildError,
    > {
        Ok({
            let request = Self::assemble(self.request_builder_base()?, self.build_body());

            #[allow(unused_mut)]
            let mut request =
                smithy_http::operation::Request::new(request.map(smithy_http::body::SdkBody::from));

            request
                .config_mut()
                .insert(aws_http::user_agent::AwsUserAgent::new_from_environment(
                    crate::API_METADATA.clone(),
                ));

            request
                .config_mut()
                .insert(aws_sig_auth::signer::OperationSigningConfig::default_config());
            request
                .config_mut()
                .insert(aws_types::SigningService::from_static(
                    _config.signing_service(),
                ));

            aws_endpoint::set_endpoint_resolver(
                &mut request.config_mut(),
                _config.endpoint_resolver.clone(),
            );

            if let Some(region) = &_config.region {
                request.config_mut().insert(region.clone());
            }

            aws_auth::set_provider(
                &mut request.config_mut(),
                _config.credentials_provider.clone(),
            );

            let op = smithy_http::operation::Operation::new(
                request,
                crate::operation::ValidateResourcePolicy::new(),
            )
            .with_metadata(smithy_http::operation::Metadata::new(
                "ValidateResourcePolicy",
                "secretsmanager",
            ));

            let op = op.with_retry_policy(aws_http::AwsErrorRetryPolicy::new());
            op
        })
    }
    pub fn request_builder_base(
        &self,
    ) -> Result<http::request::Builder, smithy_http::operation::BuildError> {
        let builder = http::request::Builder::new();

        Ok(builder
            .method("POST")
            .header("Content-Type", "application/x-amz-json-1.1")
            .header("X-Amz-Target", "secretsmanager.ValidateResourcePolicy"))
    }
    fn body(&self) -> crate::serializer::ValidateResourcePolicyInputBody {
        crate::serializer::ValidateResourcePolicyInputBody {
            resource_policy: &self.resource_policy,
            secret_id: &self.secret_id,
        }
    }
    pub fn build_body(&self) -> std::vec::Vec<u8> {
        serde_json::to_vec(&self.body()).expect("serialization should succeed")
    }
    pub fn assemble(
        builder: http::request::Builder,
        body: std::vec::Vec<u8>,
    ) -> http::request::Request<std::vec::Vec<u8>> {
        builder
            .header(http::header::CONTENT_LENGTH, body.len())
            .body(body)
            .expect("http request should be valid")
    }
    /// Creates a new builder-style object to manufacture [`ValidateResourcePolicyInput`](crate::input::ValidateResourcePolicyInput)
    pub fn builder() -> crate::input::validate_resource_policy_input::Builder {
        crate::input::validate_resource_policy_input::Builder::default()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidateResourcePolicyInput {
    /// <p>Identifies the Resource Policy attached to the secret.</p>
    pub resource_policy: std::option::Option<std::string::String>,
    /// <p> The identifier for the secret that you want to validate a resource policy. You can specify either
    /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ValidateResourcePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidateResourcePolicyInput");
        formatter.field("resource_policy", &self.resource_policy);
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSecretVersionStageInput {
    /// <p>(Optional) The secret version ID that you want to add the staging label. If you want to
    /// remove a label from a version, then do not specify this parameter.</p>
    /// <p>If the staging label is already attached to a different version of the secret, then you
    /// must also specify the <code>RemoveFromVersionId</code> parameter. </p>
    pub move_to_version_id: std::option::Option<std::string::String>,
    /// <p>Specifies the secret with the version with the list of staging labels you want to modify.
    /// You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    /// secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
    /// <p>Specifies the secret version ID of the version that the staging label is to be removed
    /// from. If the staging label you are trying to attach to one version is already attached to a
    /// different version, then you must include this parameter and specify the version that the label
    /// is to be removed from. If the label is attached and you either do not specify this parameter,
    /// or the version ID does not match, then the operation fails.</p>
    pub remove_from_version_id: std::option::Option<std::string::String>,
    /// <p>The staging label to add to this version.</p>
    pub version_stage: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UpdateSecretVersionStageInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSecretVersionStageInput");
        formatter.field("move_to_version_id", &self.move_to_version_id);
        formatter.field("secret_id", &self.secret_id);
        formatter.field("remove_from_version_id", &self.remove_from_version_id);
        formatter.field("version_stage", &self.version_stage);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UpdateSecretInput {
    /// <p>(Optional) Specifies updated text data that you want to encrypt and store in this new
    /// version of the secret. Either <code>SecretBinary</code> or <code>SecretString</code> must have
    /// a value, but not both. They cannot both be empty.</p>
    /// <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
    /// protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
    /// stores the information as a JSON structure of key/value pairs that the default Lambda rotation
    /// function knows how to parse.</p>
    /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
    /// specify key/value pairs. For information on how to format a JSON parameter for the various
    /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    /// <p>
    /// <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
    /// </p>
    /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    /// use single quotes to avoid confusion with the double quotes required in the JSON text. You can
    /// also 'escape' the double quote character in the embedded JSON text by prefacing each with a
    /// backslash. For example, the following string is surrounded by double-quotes. All of the
    /// embedded double quotes are escaped:</p>
    /// <p>
    /// <code>"[{\"username\":\"bob\"},{\"password\":\"abc123xyz456\"}]"</code>
    /// </p>
    pub secret_string: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies an updated ARN or alias of the AWS KMS customer master key (CMK) to be
    /// used to encrypt the protected text in new versions of this secret.</p>
    /// <important>
    /// <p>You can only use the account's default CMK to encrypt and decrypt if you call this
    /// operation using credentials from the same account that owns the secret. If the secret is in
    /// a different account, then you must create a custom CMK and provide the ARN of that CMK in
    /// this field. The user making the call must have permissions to both the secret and the CMK in
    /// their respective accounts.</p>
    /// </important>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>Specifies the secret that you want to modify or to which you want to add a new version.
    /// You can specify either the Amazon Resource Name (ARN) or the friendly name of the
    /// secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies an updated user-provided description of the secret.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>(Optional) If you want to add a new version to the secret, this parameter specifies a
    /// unique identifier for the new version that helps ensure idempotency. </p>
    /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    /// in the request. If you don't use the SDK and instead generate a raw HTTP request to the Secrets Manager
    /// service endpoint, then you must generate a <code>ClientRequestToken</code> yourself for new
    /// versions and include that value in the request.</p>
    /// <p>You typically only need to interact with this value if you implement your own retry logic
    /// and want to ensure that a given secret is not created twice. We recommend that you generate a
    /// <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a>
    /// value to ensure uniqueness within the specified secret. </p>
    /// <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
    /// there are failures and retries during the Lambda rotation function's processing.</p>
    /// <ul>
    /// <li>
    /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    /// of the secret then a new version of the secret is created. </p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and that version's
    /// <code>SecretString</code> and <code>SecretBinary</code> values are the same as those in
    /// the request then the request is ignored (the operation is idempotent). </p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and that version's
    /// <code>SecretString</code> and <code>SecretBinary</code> values are different from the
    /// request then an error occurs because you cannot modify an existing secret value.</p>
    /// </li>
    /// </ul>
    /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies updated binary data that you want to encrypt and store in the new
    /// version of the secret. To use this parameter in the command-line tools, we recommend that you
    /// store your binary data in a file and then use the appropriate technique for your tool to pass
    /// the contents of the file as a parameter. Either <code>SecretBinary</code> or
    /// <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
    /// <p>This parameter is not accessible using the Secrets Manager console.</p>
    pub secret_binary: std::option::Option<smithy_types::Blob>,
}
impl std::fmt::Debug for UpdateSecretInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UpdateSecretInput");
        formatter.field("secret_string", &"*** Sensitive Data Redacted ***");
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("secret_id", &self.secret_id);
        formatter.field("description", &self.description);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("secret_binary", &"*** Sensitive Data Redacted ***");
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UntagResourceInput {
    /// <p>A list of tag key names to remove from the secret. You don't specify the value. Both the
    /// key and its associated value are removed.</p>
    /// <p>This parameter to the API requires a JSON text string argument. For information on how to
    /// format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    pub tag_keys: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The identifier for the secret that you want to remove tags from. You can specify either
    /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for UntagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UntagResourceInput");
        formatter.field("tag_keys", &self.tag_keys);
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagResourceInput {
    /// <p>The identifier for the secret that you want to attach tags to. You can specify either the
    /// Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
    /// <p>The tags to attach to the secret. Each element in the list consists of a <code>Key</code>
    /// and a <code>Value</code>.</p>
    /// <p>This parameter to the API requires a JSON text string argument. For information on how to
    /// format a JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for Parameters</a> in the <i>AWS CLI User Guide</i>. For the
    /// AWS CLI, you can also use the syntax: <code>--Tags
    /// Key="Key1",Value="Value1",Key="Key2",Value="Value2"[,…]</code>
    /// </p>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl std::fmt::Debug for TagResourceInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagResourceInput");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("tags", &self.tags);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RotateSecretInput {
    /// <p>Specifies the secret that you want to rotate. You can specify either the Amazon Resource
    /// Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies a unique identifier for the new version of the secret that helps
    /// ensure idempotency. </p>
    /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    /// in the request for this parameter. If you don't use the SDK and instead generate a raw HTTP
    /// request to the Secrets Manager service endpoint, then you must generate a
    /// <code>ClientRequestToken</code> yourself for new versions and include that value in the
    /// request.</p>
    /// <p>You only need to specify your own value if you implement your own retry logic and want to
    /// ensure that a given secret is not created twice. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    /// ensure uniqueness within the specified secret. </p>
    /// <p>Secrets Manager uses this value to prevent the accidental creation of duplicate versions if
    /// there are failures and retries during the function's processing. This value becomes the
    /// <code>VersionId</code> of the new version.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>A structure that defines the rotation configuration for this secret.</p>
    pub rotation_rules: std::option::Option<crate::model::RotationRulesType>,
    /// <p>(Optional) Specifies the ARN of the Lambda function that can rotate the secret.</p>
    pub rotation_lambda_arn: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RotateSecretInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RotateSecretInput");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("rotation_rules", &self.rotation_rules);
        formatter.field("rotation_lambda_arn", &self.rotation_lambda_arn);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RestoreSecretInput {
    /// <p>Specifies the secret that you want to restore from a previously scheduled deletion. You
    /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RestoreSecretInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestoreSecretInput");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutSecretValueInput {
    /// <p>(Optional) Specifies a unique identifier for the new version of the secret. </p>
    /// <note>
    /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes that
    /// in the request. If you don't use the SDK and instead generate a raw HTTP request to the
    /// Secrets Manager service endpoint, then you must generate a <code>ClientRequestToken</code> yourself
    /// for new versions and include that value in the request. </p>
    /// </note>
    /// <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
    /// creation of duplicate versions if there are failures and retries during the Lambda rotation
    /// function's processing. We recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    /// ensure uniqueness within the specified secret. </p>
    /// <ul>
    /// <li>
    /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    /// of the secret then a new version of the secret is created. </p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and that version's
    /// <code>SecretString</code> or <code>SecretBinary</code> values are the same as those in
    /// the request then the request is ignored (the operation is idempotent). </p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and the version of the
    /// <code>SecretString</code> and <code>SecretBinary</code> values are different from those
    /// in the request then the request fails because you cannot modify an existing secret
    /// version. You can only create new versions to store new secret values.</p>
    /// </li>
    /// </ul>
    /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
    pub client_request_token: std::option::Option<std::string::String>,
    /// <p>Specifies the secret to which you want to add a new version. You can specify either the
    /// Amazon Resource Name (ARN) or the friendly name of the secret. The secret must already
    /// exist.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
    /// the secret. Either <code>SecretString</code> or <code>SecretBinary</code> must have a value,
    /// but not both. They cannot both be empty.</p>
    /// <p>If you create this secret by using the Secrets Manager console then Secrets Manager puts the
    /// protected secret text in only the <code>SecretString</code> parameter. The Secrets Manager console
    /// stores the information as a JSON structure of key/value pairs that the default Lambda rotation
    /// function knows how to parse.</p>
    /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
    /// specify key/value pairs. For information on how to format a JSON parameter for the various
    /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    /// Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    /// <p> For example:</p>
    /// <p>
    /// <code>[{"username":"bob"},{"password":"abc123xyz456"}]</code>
    /// </p>
    /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    /// use single quotes to avoid confusion with the double quotes required in the JSON text.</p>
    pub secret_string: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
    /// the secret. To use this parameter in the command-line tools, we recommend that you store your
    /// binary data in a file and then use the appropriate technique for your tool to pass the
    /// contents of the file as a parameter. Either <code>SecretBinary</code> or
    /// <code>SecretString</code> must have a value, but not both. They cannot both be empty.</p>
    /// <p>This parameter is not accessible if the secret using the Secrets Manager console.</p>
    /// <p></p>
    pub secret_binary: std::option::Option<smithy_types::Blob>,
    /// <p>(Optional) Specifies a list of staging labels that are attached to this version of the
    /// secret. These staging labels are used to track the versions through the rotation process by
    /// the Lambda rotation function.</p>
    /// <p>A staging label must be unique to a single version of the secret. If you specify a staging
    /// label that's already associated with a different version of the same secret then that staging
    /// label is automatically removed from the other version and attached to this version.</p>
    /// <p>If you do not specify a value for <code>VersionStages</code> then Secrets Manager automatically
    /// moves the staging label <code>AWSCURRENT</code> to this new version.</p>
    pub version_stages: std::option::Option<std::vec::Vec<std::string::String>>,
}
impl std::fmt::Debug for PutSecretValueInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutSecretValueInput");
        formatter.field("client_request_token", &self.client_request_token);
        formatter.field("secret_id", &self.secret_id);
        formatter.field("secret_string", &"*** Sensitive Data Redacted ***");
        formatter.field("secret_binary", &"*** Sensitive Data Redacted ***");
        formatter.field("version_stages", &self.version_stages);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutResourcePolicyInput {
    /// <p>A JSON-formatted string that's constructed according to the grammar and syntax for an
    /// AWS resource-based policy. The policy in the string identifies who can access or manage this
    /// secret and its versions. For information on how to format a JSON parameter for the various
    /// command line tool environments, see <a href="http://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using
    /// JSON for Parameters</a> in the <i>AWS CLI User Guide</i>.</p>
    pub resource_policy: std::option::Option<std::string::String>,
    /// <p>Makes an optional API call to Zelkova to validate the Resource Policy to prevent broad access to your secret.</p>
    pub block_public_policy: std::option::Option<bool>,
    /// <p>Specifies the secret that you want to attach the resource-based policy to. You can specify
    /// either the ARN or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutResourcePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutResourcePolicyInput");
        formatter.field("resource_policy", &self.resource_policy);
        formatter.field("block_public_policy", &self.block_public_policy);
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSecretVersionIdsInput {
    /// <p>(Optional) Limits the number of results you want to include in
    /// the response. If you don't include this parameter, it defaults to a value that's
    /// specific to the operation. If additional items exist beyond the maximum you specify, the
    /// <code>NextToken</code> response element is present and has a value (isn't null). Include
    /// that value as the <code>NextToken</code> request parameter in the next call to the operation to
    /// get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
    /// even when there are more results available. You should check <code>NextToken</code> after every
    /// operation to ensure that you receive all of the results.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>The identifier for the secret containing the versions you want to list. You can specify
    /// either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
    /// <p>(Optional) Use this parameter in a request if you receive a
    /// <code>NextToken</code> response in a previous request indicating there's more
    /// output available. In a subsequent call, set it to the value of the previous call
    /// <code>NextToken</code> response to indicate where the output should continue from.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies that you want the results to include versions that do not have any
    /// staging labels attached to them. Such versions are considered deprecated and are subject to
    /// deletion by Secrets Manager as needed.</p>
    pub include_deprecated: std::option::Option<bool>,
}
impl std::fmt::Debug for ListSecretVersionIdsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSecretVersionIdsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("secret_id", &self.secret_id);
        formatter.field("next_token", &self.next_token);
        formatter.field("include_deprecated", &self.include_deprecated);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ListSecretsInput {
    /// <p>(Optional) Limits the number of results you want to include in
    /// the response. If you don't include this parameter, it defaults to a value that's
    /// specific to the operation. If additional items exist beyond the maximum you specify, the
    /// <code>NextToken</code> response element is present and has a value (isn't null). Include
    /// that value as the <code>NextToken</code> request parameter in the next call to the operation to
    /// get the next part of the results. Note that Secrets Manager might return fewer results than the maximum
    /// even when there are more results available. You should check <code>NextToken</code> after every
    /// operation to ensure that you receive all of the results.</p>
    pub max_results: std::option::Option<i32>,
    /// <p>Lists secrets in the requested order. </p>
    pub sort_order: std::option::Option<crate::model::SortOrderType>,
    /// <p>(Optional) Use this parameter in a request if you receive a
    /// <code>NextToken</code> response in a previous request indicating there's more
    /// output available. In a subsequent call, set it to the value of the previous call
    /// <code>NextToken</code> response to indicate where the output should continue from.</p>
    pub next_token: std::option::Option<std::string::String>,
    /// <p>Lists the secret request filters.</p>
    pub filters: std::option::Option<std::vec::Vec<crate::model::Filter>>,
}
impl std::fmt::Debug for ListSecretsInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ListSecretsInput");
        formatter.field("max_results", &self.max_results);
        formatter.field("sort_order", &self.sort_order);
        formatter.field("next_token", &self.next_token);
        formatter.field("filters", &self.filters);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetSecretValueInput {
    /// <p>Specifies the secret containing the version that you want to retrieve. You can specify
    /// either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
    /// <p>Specifies the secret version that you want to retrieve by the staging label attached to
    /// the version.</p>
    /// <p>Staging labels are used to keep track of different versions during the rotation process.
    /// If you use this parameter then don't specify <code>VersionId</code>. If you don't
    /// specify either a <code>VersionStage</code> or <code>VersionId</code>, then the default is to
    /// perform the operation on the version with the <code>VersionStage</code> value of
    /// <code>AWSCURRENT</code>.</p>
    pub version_stage: std::option::Option<std::string::String>,
    /// <p>Specifies the unique identifier of the version of the secret that you want to retrieve. If
    /// you specify this parameter then don't specify <code>VersionStage</code>. If you
    /// don't specify either a <code>VersionStage</code> or <code>VersionId</code> then the
    /// default is to perform the operation on the version with the <code>VersionStage</code> value of
    /// <code>AWSCURRENT</code>.</p>
    /// <p>This value is typically a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value with
    /// 32 hexadecimal digits.</p>
    pub version_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetSecretValueInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetSecretValueInput");
        formatter.field("secret_id", &self.secret_id);
        formatter.field("version_stage", &self.version_stage);
        formatter.field("version_id", &self.version_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetResourcePolicyInput {
    /// <p>Specifies the secret that you want to retrieve the attached resource-based policy for. You
    /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for GetResourcePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetResourcePolicyInput");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GetRandomPasswordInput {
    /// <p>Specifies that the generated password should not include digits. The default if you do not
    /// include this switch parameter is that digits can be included.</p>
    pub exclude_numbers: std::option::Option<bool>,
    /// <p>A string that includes characters that should not be included in the generated password.
    /// The default is that all characters from the included sets can be used.</p>
    pub exclude_characters: std::option::Option<std::string::String>,
    /// <p>The desired length of the generated password. The default value if you do not include this
    /// parameter is 32 characters.</p>
    pub password_length: std::option::Option<i64>,
    /// <p>A boolean value that specifies whether the generated password must include at least one of
    /// every allowed character type. The default value is <code>True</code> and the operation
    /// requires at least one of every character type.</p>
    pub require_each_included_type: std::option::Option<bool>,
    /// <p>Specifies that the generated password can include the space character. The default if you
    /// do not include this switch parameter is that the space character is not included.</p>
    pub include_space: std::option::Option<bool>,
    /// <p>Specifies that the generated password should not include punctuation characters. The
    /// default if you do not include this switch parameter is that punctuation characters can be
    /// included.</p>
    /// <p>The following are the punctuation characters that <i>can</i> be included in
    /// the generated password if you don't explicitly exclude them with
    /// <code>ExcludeCharacters</code> or <code>ExcludePunctuation</code>:</p>
    /// <p>
    /// <code>! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | }
    /// ~</code>
    /// </p>
    pub exclude_punctuation: std::option::Option<bool>,
    /// <p>Specifies that the generated password should not include lowercase letters. The default if
    /// you do not include this switch parameter is that lowercase letters can be included.</p>
    pub exclude_lowercase: std::option::Option<bool>,
    /// <p>Specifies that the generated password should not include uppercase letters. The default if
    /// you do not include this switch parameter is that uppercase letters can be included.</p>
    pub exclude_uppercase: std::option::Option<bool>,
}
impl std::fmt::Debug for GetRandomPasswordInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GetRandomPasswordInput");
        formatter.field("exclude_numbers", &self.exclude_numbers);
        formatter.field("exclude_characters", &self.exclude_characters);
        formatter.field("password_length", &self.password_length);
        formatter.field(
            "require_each_included_type",
            &self.require_each_included_type,
        );
        formatter.field("include_space", &self.include_space);
        formatter.field("exclude_punctuation", &self.exclude_punctuation);
        formatter.field("exclude_lowercase", &self.exclude_lowercase);
        formatter.field("exclude_uppercase", &self.exclude_uppercase);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DescribeSecretInput {
    /// <p>The identifier of the secret whose details you want to retrieve. You can specify either
    /// the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DescribeSecretInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DescribeSecretInput");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteSecretInput {
    /// <p>(Optional) Specifies that the secret is to be deleted without any recovery window. You
    /// can't use both this parameter and the <code>RecoveryWindowInDays</code> parameter in the same
    /// API call.</p>
    /// <p>An asynchronous background process performs the actual deletion, so there can be a short
    /// delay before the operation completes. If you write code to delete and then immediately
    /// recreate a secret with the same name, ensure that your code includes appropriate back off and
    /// retry logic.</p>
    /// <important>
    /// <p>Use this parameter with caution. This parameter causes the operation to skip the normal
    /// waiting period before the permanent deletion that AWS would normally impose with the
    /// <code>RecoveryWindowInDays</code> parameter. If you delete a secret with the
    /// <code>ForceDeleteWithouRecovery</code> parameter, then you have no opportunity to recover
    /// the secret. It is permanently lost.</p>
    /// </important>
    pub force_delete_without_recovery: std::option::Option<bool>,
    /// <p>(Optional) Specifies the number of days that Secrets Manager waits before it can delete the secret.
    /// You can't use both this parameter and the <code>ForceDeleteWithoutRecovery</code> parameter in
    /// the same API call.</p>
    /// <p>This value can range from 7 to 30 days. The default value is 30.</p>
    pub recovery_window_in_days: std::option::Option<i64>,
    /// <p>Specifies the secret that you want to delete. You can specify either the Amazon Resource
    /// Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteSecretInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteSecretInput");
        formatter.field(
            "force_delete_without_recovery",
            &self.force_delete_without_recovery,
        );
        formatter.field("recovery_window_in_days", &self.recovery_window_in_days);
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DeleteResourcePolicyInput {
    /// <p>Specifies the secret that you want to delete the attached resource-based policy for. You
    /// can specify either the Amazon Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DeleteResourcePolicyInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DeleteResourcePolicyInput");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CreateSecretInput {
    /// <p>Specifies the friendly name of the new secret.</p>
    /// <p>The secret name must be ASCII letters, digits, or the following characters :
    /// /_+=.@-</p>
    /// <note>
    /// <p>Do not end your secret name with a hyphen followed by six characters. If you do so, you
    /// risk confusion and unexpected results when searching for a secret by partial ARN. Secrets Manager
    /// automatically adds a hyphen and six random characters at the end of the ARN.</p>
    /// </note>
    pub name: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies a list of user-defined tags that are attached to the secret. Each tag
    /// is a "Key" and "Value" pair of strings. This operation only appends tags to the existing list
    /// of tags. To remove tags, you must use <a>UntagResource</a>.</p>
    /// <important>
    /// <ul>
    /// <li>
    /// <p>Secrets Manager tag key names are case sensitive. A tag with the key "ABC" is a different tag
    /// from one with key "abc".</p>
    /// </li>
    /// <li>
    /// <p>If you check tags in IAM policy <code>Condition</code> elements as part of your
    /// security strategy, then adding or removing a tag can change permissions. If the
    /// successful completion of this operation would result in you losing your permissions for
    /// this secret, then this operation is blocked and returns an <code>Access Denied</code>
    /// error.</p>
    /// </li>
    /// </ul>
    /// </important>
    /// <p>This parameter requires a JSON text string argument. For information on how to format a
    /// JSON parameter for the various command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    /// <p>
    /// <code>[{"Key":"CostCenter","Value":"12345"},{"Key":"environment","Value":"production"}]</code>
    /// </p>
    /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    /// use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
    /// <p>The following basic restrictions apply to tags:</p>
    /// <ul>
    /// <li>
    /// <p>Maximum number of tags per secret—50</p>
    /// </li>
    /// <li>
    /// <p>Maximum key length—127 Unicode characters in UTF-8</p>
    /// </li>
    /// <li>
    /// <p>Maximum value length—255 Unicode characters in UTF-8</p>
    /// </li>
    /// <li>
    /// <p>Tag keys and values are case sensitive.</p>
    /// </li>
    /// <li>
    /// <p>Do not use the <code>aws:</code> prefix in your tag names or values because AWS reserves it
    /// for AWS use. You can't edit or delete tag names or values with this
    /// prefix. Tags with this prefix do not count against your tags per secret limit.</p>
    /// </li>
    /// <li>
    /// <p>If you use your tagging schema across multiple services and resources,
    /// remember other services might have restrictions on allowed characters. Generally
    /// allowed characters: letters, spaces, and numbers representable in UTF-8, plus the
    /// following special characters: + - = . _ : / @.</p>
    /// </li>
    /// </ul>
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    /// <p>(Optional) Specifies the ARN, Key ID, or alias of the AWS KMS customer master key (CMK) to
    /// be used to encrypt the <code>SecretString</code> or <code>SecretBinary</code> values in the
    /// versions stored in this secret.</p>
    /// <p>You can specify any of the supported ways to identify a AWS KMS key ID. If you need to
    /// reference a CMK in a different account, you can use only the key ARN or the alias ARN.</p>
    /// <p>If you don't specify this value, then Secrets Manager defaults to using the AWS account's
    /// default CMK (the one named <code>aws/secretsmanager</code>). If a AWS KMS CMK with that name doesn't yet
    /// exist, then Secrets Manager creates it for you automatically the first time it needs to encrypt a
    /// version's <code>SecretString</code> or <code>SecretBinary</code> fields.</p>
    /// <important>
    /// <p>You can use the account default CMK to encrypt and decrypt only if you call this
    /// operation using credentials from the same account that owns the secret. If the secret
    /// resides in a different account, then you must create a custom CMK and specify the ARN in
    /// this field. </p>
    /// </important>
    pub kms_key_id: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies a user-provided description of the secret.</p>
    pub description: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies text data that you want to encrypt and store in this new version of
    /// the secret.</p>
    /// <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
    /// both. They cannot both be empty.</p>
    /// <p>If you create a secret by using the Secrets Manager console then Secrets Manager puts the protected
    /// secret text in only the <code>SecretString</code> parameter. The Secrets Manager console stores the
    /// information as a JSON structure of key/value pairs that the Lambda rotation function knows how
    /// to parse.</p>
    /// <p>For storing multiple values, we recommend that you use a JSON text string argument and
    /// specify key/value pairs. For information on how to format a JSON parameter for the various
    /// command line tool environments, see <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json">Using JSON for
    /// Parameters</a> in the <i>AWS CLI User Guide</i>. For example:</p>
    /// <p>
    /// <code>{"username":"bob","password":"abc123xyz456"}</code>
    /// </p>
    /// <p>If your command-line tool or SDK requires quotation marks around the parameter, you should
    /// use single quotes to avoid confusion with the double quotes required in the JSON text. </p>
    pub secret_string: std::option::Option<std::string::String>,
    /// <p>(Optional) Specifies binary data that you want to encrypt and store in the new version of
    /// the secret. To use this parameter in the command-line tools, we recommend that you store your
    /// binary data in a file and then use the appropriate technique for your tool to pass the
    /// contents of the file as a parameter.</p>
    /// <p>Either <code>SecretString</code> or <code>SecretBinary</code> must have a value, but not
    /// both. They cannot both be empty.</p>
    /// <p>This parameter is not available using the Secrets Manager console. It can be accessed only by
    /// using the AWS CLI or one of the AWS SDKs.</p>
    pub secret_binary: std::option::Option<smithy_types::Blob>,
    /// <p>(Optional) If you include <code>SecretString</code> or <code>SecretBinary</code>, then an
    /// initial version is created as part of the secret, and this parameter specifies a unique
    /// identifier for the new version. </p>
    /// <note>
    /// <p>If you use the AWS CLI or one of the AWS SDK to call this operation, then you can
    /// leave this parameter empty. The CLI or SDK generates a random UUID for you and includes it
    /// as the value for this parameter in the request. If you don't use the SDK and instead
    /// generate a raw HTTP request to the Secrets Manager service endpoint, then you must generate a
    /// <code>ClientRequestToken</code> yourself for the new version and include the value in the
    /// request.</p>
    /// </note>
    /// <p>This value helps ensure idempotency. Secrets Manager uses this value to prevent the accidental
    /// creation of duplicate versions if there are failures and retries during a rotation. We
    /// recommend that you generate a <a href="https://wikipedia.org/wiki/Universally_unique_identifier">UUID-type</a> value to
    /// ensure uniqueness of your versions within the specified secret. </p>
    /// <ul>
    /// <li>
    /// <p>If the <code>ClientRequestToken</code> value isn't already associated with a version
    /// of the secret then a new version of the secret is created. </p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and the version <code>SecretString</code>
    /// and <code>SecretBinary</code> values are the same as those in the request, then the
    /// request is ignored.</p>
    /// </li>
    /// <li>
    /// <p>If a version with this value already exists and that version's
    /// <code>SecretString</code> and <code>SecretBinary</code> values are different from those
    /// in the request then the request fails because you cannot modify an existing version.
    /// Instead, use <a>PutSecretValue</a> to create a new version.</p>
    /// </li>
    /// </ul>
    /// <p>This value becomes the <code>VersionId</code> of the new version.</p>
    pub client_request_token: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CreateSecretInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CreateSecretInput");
        formatter.field("name", &self.name);
        formatter.field("tags", &self.tags);
        formatter.field("kms_key_id", &self.kms_key_id);
        formatter.field("description", &self.description);
        formatter.field("secret_string", &"*** Sensitive Data Redacted ***");
        formatter.field("secret_binary", &"*** Sensitive Data Redacted ***");
        formatter.field("client_request_token", &self.client_request_token);
        formatter.finish()
    }
}

#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CancelRotateSecretInput {
    /// <p>Specifies the secret to cancel a rotation request. You can specify either the Amazon
    /// Resource Name (ARN) or the friendly name of the secret.</p>
    /// <note>
    /// <p>If you specify an ARN, we generally recommend that you specify a complete ARN. You can
    /// specify a partial ARN too—for example, if you don’t include the final hyphen and six random
    /// characters that Secrets Manager adds at the end of the ARN when you created the secret. A partial ARN
    /// match can work as long as it uniquely matches only one secret. However, if your secret has a
    /// name that ends in a hyphen followed by six characters (before Secrets Manager adds the hyphen and six
    /// characters to the ARN) and you try to use that as a partial ARN, then those characters cause
    /// Secrets Manager to assume that you’re specifying a complete ARN. This confusion can cause unexpected
    /// results. To avoid this situation, we recommend that you don’t create secret names ending
    /// with a hyphen followed by six characters.</p>
    /// <p>If you specify an incomplete ARN without the random suffix, and instead provide the
    /// 'friendly name', you <i>must</i> not include the random suffix. If you do include the random suffix added by Secrets Manager,
    /// you receive either a <i>ResourceNotFoundException</i> or an <i>AccessDeniedException</i> error, depending on your permissions.</p>
    /// </note>
    pub secret_id: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CancelRotateSecretInput {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CancelRotateSecretInput");
        formatter.field("secret_id", &self.secret_id);
        formatter.finish()
    }
}
