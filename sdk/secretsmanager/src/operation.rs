// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Disables automatic scheduled rotation and cancels the rotation of a secret if currently in
/// progress.</p>
/// <p>To re-enable scheduled rotation, call <a>RotateSecret</a> with
/// <code>AutomaticallyRotateAfterDays</code> set to a value greater than 0. This immediately
/// rotates your secret and then enables the automatic schedule.</p>
/// <note>
/// <p>If you cancel a rotation while in progress, it can leave the <code>VersionStage</code>
/// labels in an unexpected state. Depending on the step of the rotation in progress, you might
/// need to remove the staging label <code>AWSPENDING</code> from the partially created version, specified
/// by the <code>VersionId</code> response value. You should also evaluate the partially rotated
/// new version to see if it should be deleted, which you can do by removing all staging labels
/// from the new version <code>VersionStage</code> field.</p>
/// </note>
/// <p>To successfully start a rotation, the staging label <code>AWSPENDING</code> must be in one of the
/// following states:</p>
/// <ul>
/// <li>
/// <p>Not attached to any version at all</p>
/// </li>
/// <li>
/// <p>Attached to the same version as the staging label <code>AWSCURRENT</code>
/// </p>
/// </li>
/// </ul>
/// <p>If the staging label <code>AWSPENDING</code> attached to a different version than the version with
/// <code>AWSCURRENT</code> then the attempt to rotate fails.</p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:CancelRotateSecret</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To configure rotation for a secret or to manually trigger a rotation, use <a>RotateSecret</a>.</p>
/// </li>
/// <li>
/// <p>To get the rotation configuration details for a secret, use <a>DescribeSecret</a>.</p>
/// </li>
/// <li>
/// <p>To list all of the currently available secrets, use <a>ListSecrets</a>.</p>
/// </li>
/// <li>
/// <p>To list all of the versions currently associated with a secret, use <a>ListSecretVersionIds</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CancelRotateSecret {
    _private: (),
}
impl CancelRotateSecret {
    /// Creates a new builder-style object to manufacture [`CancelRotateSecretInput`](crate::input::CancelRotateSecretInput)
    pub fn builder() -> crate::input::cancel_rotate_secret_input::Builder {
        crate::input::cancel_rotate_secret_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CancelRotateSecret {
    type Output = std::result::Result<
        crate::output::CancelRotateSecretOutput,
        crate::error::CancelRotateSecretError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_cancel_rotate_secret_error(response)
        } else {
            crate::operation_deser::parse_cancel_rotate_secret_response(response)
        }
    }
}

/// <p>Creates a new secret. A secret in Secrets Manager consists of both the protected secret data and the
/// important information needed to manage the secret.</p>
/// <p>Secrets Manager stores the encrypted secret data in one of a collection of "versions"
/// associated with the secret. Each version contains a copy of the encrypted secret data. Each
/// version is associated with one or more "staging labels" that identify where the version is in
/// the rotation cycle. The <code>SecretVersionsToStages</code> field of the secret contains the
/// mapping of staging labels to the active versions of the secret. Versions without a staging
/// label are considered deprecated and not included in the list.</p>
/// <p>You provide the secret data to be encrypted by putting text in either the
/// <code>SecretString</code> parameter or binary data in the <code>SecretBinary</code>
/// parameter, but not both. If you include <code>SecretString</code> or <code>SecretBinary</code>
/// then Secrets Manager also creates an initial secret version and automatically attaches the staging
/// label <code>AWSCURRENT</code> to the new version.</p>
/// <note>
/// <ul>
/// <li>
/// <p>If you call an operation to encrypt or decrypt the <code>SecretString</code>
/// or <code>SecretBinary</code> for a secret in the same account as the calling user and that
/// secret doesn't specify a Amazon Web Services KMS encryption key, Secrets Manager uses the account's default
/// Amazon Web Services managed customer master key (CMK) with the alias <code>aws/secretsmanager</code>. If this key
/// doesn't already exist in your account then Secrets Manager creates it for you automatically. All
/// users and roles in the same Amazon Web Services account automatically have access to use the default CMK.
/// Note that if an Secrets Manager API call results in Amazon Web Services creating the account's
/// Amazon Web Services-managed CMK, it can result in a one-time significant delay in returning the
/// result.</p>
/// </li>
/// <li>
/// <p>If the secret resides in a different Amazon Web Services account from the credentials calling an API that
/// requires encryption or decryption of the secret value then you must create and use a custom
/// Amazon Web Services KMS CMK because you can't access the default CMK for the account using credentials
/// from a different Amazon Web Services account. Store the ARN of the CMK in the secret when you create the
/// secret or when you update it by including it in the <code>KMSKeyId</code>. If you call an
/// API that must encrypt or decrypt <code>SecretString</code> or <code>SecretBinary</code>
/// using credentials from a different account then the Amazon Web Services KMS key policy must grant cross-account
/// access to that other account's user or role for both the kms:GenerateDataKey and
/// kms:Decrypt operations.</p>
/// </li>
/// </ul>
/// </note>
/// <p> </p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:CreateSecret</p>
/// </li>
/// <li>
/// <p>kms:GenerateDataKey - needed only if you use a customer-managed Amazon Web Services KMS key to encrypt
/// the secret. You do not need this permission to use the account default Amazon Web Services managed CMK
/// for Secrets Manager.</p>
/// </li>
/// <li>
/// <p>kms:Decrypt - needed only if you use a customer-managed Amazon Web Services KMS key to encrypt the
/// secret. You do not need this permission to use the account default Amazon Web Services managed CMK for
/// Secrets Manager.</p>
/// </li>
/// <li>
/// <p>secretsmanager:TagResource - needed only if you include the <code>Tags</code>
/// parameter. </p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To delete a secret, use <a>DeleteSecret</a>.</p>
/// </li>
/// <li>
/// <p>To modify an existing secret, use <a>UpdateSecret</a>.</p>
/// </li>
/// <li>
/// <p>To create a new version of a secret, use <a>PutSecretValue</a>.</p>
/// </li>
/// <li>
/// <p>To retrieve the encrypted secure string and secure binary values, use <a>GetSecretValue</a>.</p>
/// </li>
/// <li>
/// <p>To retrieve all other details for a secret, use <a>DescribeSecret</a>. This
/// does not include the encrypted secure string and secure binary values.</p>
/// </li>
/// <li>
/// <p>To retrieve the list of secret versions associated with the current secret, use <a>DescribeSecret</a> and examine the <code>SecretVersionsToStages</code> response
/// value.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateSecret {
    _private: (),
}
impl CreateSecret {
    /// Creates a new builder-style object to manufacture [`CreateSecretInput`](crate::input::CreateSecretInput)
    pub fn builder() -> crate::input::create_secret_input::Builder {
        crate::input::create_secret_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateSecret {
    type Output =
        std::result::Result<crate::output::CreateSecretOutput, crate::error::CreateSecretError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_secret_error(response)
        } else {
            crate::operation_deser::parse_create_secret_response(response)
        }
    }
}

/// <p>Deletes the resource-based permission policy attached to the secret.</p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:DeleteResourcePolicy</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To attach a resource policy to a secret, use <a>PutResourcePolicy</a>.</p>
/// </li>
/// <li>
/// <p>To retrieve the current resource-based policy attached to a secret, use <a>GetResourcePolicy</a>.</p>
/// </li>
/// <li>
/// <p>To list all of the currently available secrets, use <a>ListSecrets</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteResourcePolicy {
    _private: (),
}
impl DeleteResourcePolicy {
    /// Creates a new builder-style object to manufacture [`DeleteResourcePolicyInput`](crate::input::DeleteResourcePolicyInput)
    pub fn builder() -> crate::input::delete_resource_policy_input::Builder {
        crate::input::delete_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteResourcePolicy {
    type Output = std::result::Result<
        crate::output::DeleteResourcePolicyOutput,
        crate::error::DeleteResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_delete_resource_policy_response(response)
        }
    }
}

/// <p>Deletes an entire secret and all of the versions. You can optionally include a recovery
/// window during which you can restore the secret. If you don't specify a recovery window value,
/// the operation defaults to 30 days. Secrets Manager attaches a <code>DeletionDate</code> stamp to
/// the secret that specifies the end of the recovery window. At the end of the recovery window,
/// Secrets Manager deletes the secret permanently.</p>
/// <p>At any time before recovery window ends, you can use <a>RestoreSecret</a> to
/// remove the <code>DeletionDate</code> and cancel the deletion of the secret.</p>
/// <p>You cannot access the encrypted secret information in any secret scheduled for deletion.
/// If you need to access that information, you must cancel the deletion with <a>RestoreSecret</a> and then retrieve the information.</p>
/// <note>
/// <ul>
/// <li>
/// <p>There is no explicit operation to delete a version of a secret. Instead, remove all
/// staging labels from the <code>VersionStage</code> field of a version. That marks the
/// version as deprecated and allows Secrets Manager to delete it as needed. Versions without any
/// staging labels do not show up in <a>ListSecretVersionIds</a> unless you
/// specify <code>IncludeDeprecated</code>.</p>
/// </li>
/// <li>
/// <p>The permanent secret deletion at the end of the waiting period is performed as a
/// background task with low priority. There is no guarantee of a specific time after the
/// recovery window for the actual delete operation to occur.</p>
/// </li>
/// </ul>
/// </note>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:DeleteSecret</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To create a secret, use <a>CreateSecret</a>.</p>
/// </li>
/// <li>
/// <p>To cancel deletion of a version of a secret before the recovery window has expired,
/// use <a>RestoreSecret</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteSecret {
    _private: (),
}
impl DeleteSecret {
    /// Creates a new builder-style object to manufacture [`DeleteSecretInput`](crate::input::DeleteSecretInput)
    pub fn builder() -> crate::input::delete_secret_input::Builder {
        crate::input::delete_secret_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteSecret {
    type Output =
        std::result::Result<crate::output::DeleteSecretOutput, crate::error::DeleteSecretError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_secret_error(response)
        } else {
            crate::operation_deser::parse_delete_secret_response(response)
        }
    }
}

/// <p>Retrieves the details of a secret. It does not include the encrypted fields. Secrets
/// Manager only returns fields populated with a value in the response. </p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:DescribeSecret</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To create a secret, use <a>CreateSecret</a>.</p>
/// </li>
/// <li>
/// <p>To modify a secret, use <a>UpdateSecret</a>.</p>
/// </li>
/// <li>
/// <p>To retrieve the encrypted secret information in a version of the secret, use <a>GetSecretValue</a>.</p>
/// </li>
/// <li>
/// <p>To list all of the secrets in the Amazon Web Services account, use <a>ListSecrets</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeSecret {
    _private: (),
}
impl DescribeSecret {
    /// Creates a new builder-style object to manufacture [`DescribeSecretInput`](crate::input::DescribeSecretInput)
    pub fn builder() -> crate::input::describe_secret_input::Builder {
        crate::input::describe_secret_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeSecret {
    type Output =
        std::result::Result<crate::output::DescribeSecretOutput, crate::error::DescribeSecretError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_secret_error(response)
        } else {
            crate::operation_deser::parse_describe_secret_response(response)
        }
    }
}

/// <p>Generates a random password of the specified complexity. This operation is intended for
/// use in the Lambda rotation function. Per best practice, we recommend that you specify the
/// maximum length and include every character type that the system you are generating a password
/// for can support.</p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:GetRandomPassword</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRandomPassword {
    _private: (),
}
impl GetRandomPassword {
    /// Creates a new builder-style object to manufacture [`GetRandomPasswordInput`](crate::input::GetRandomPasswordInput)
    pub fn builder() -> crate::input::get_random_password_input::Builder {
        crate::input::get_random_password_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRandomPassword {
    type Output = std::result::Result<
        crate::output::GetRandomPasswordOutput,
        crate::error::GetRandomPasswordError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_random_password_error(response)
        } else {
            crate::operation_deser::parse_get_random_password_response(response)
        }
    }
}

/// <p>Retrieves the JSON text of the resource-based policy document attached to the specified
/// secret. The JSON request string input and response output displays formatted code
/// with white space and line breaks for better readability. Submit your input as a single line
/// JSON string.</p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:GetResourcePolicy</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To attach a resource policy to a secret, use <a>PutResourcePolicy</a>.</p>
/// </li>
/// <li>
/// <p>To delete the resource-based policy attached to a secret, use <a>DeleteResourcePolicy</a>.</p>
/// </li>
/// <li>
/// <p>To list all of the currently available secrets, use <a>ListSecrets</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetResourcePolicy {
    _private: (),
}
impl GetResourcePolicy {
    /// Creates a new builder-style object to manufacture [`GetResourcePolicyInput`](crate::input::GetResourcePolicyInput)
    pub fn builder() -> crate::input::get_resource_policy_input::Builder {
        crate::input::get_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetResourcePolicy {
    type Output = std::result::Result<
        crate::output::GetResourcePolicyOutput,
        crate::error::GetResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_get_resource_policy_response(response)
        }
    }
}

/// <p>Retrieves the contents of the encrypted fields <code>SecretString</code> or
/// <code>SecretBinary</code> from the specified version of a secret, whichever contains
/// content.</p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:GetSecretValue</p>
/// </li>
/// <li>
/// <p>kms:Decrypt - required only if you use a customer-managed Amazon Web Services KMS key to encrypt the
/// secret. You do not need this permission to use the account's default Amazon Web Services managed CMK for
/// Secrets Manager.</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To create a new version of the secret with different encrypted information, use <a>PutSecretValue</a>.</p>
/// </li>
/// <li>
/// <p>To retrieve the non-encrypted details for the secret, use <a>DescribeSecret</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetSecretValue {
    _private: (),
}
impl GetSecretValue {
    /// Creates a new builder-style object to manufacture [`GetSecretValueInput`](crate::input::GetSecretValueInput)
    pub fn builder() -> crate::input::get_secret_value_input::Builder {
        crate::input::get_secret_value_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetSecretValue {
    type Output =
        std::result::Result<crate::output::GetSecretValueOutput, crate::error::GetSecretValueError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_secret_value_error(response)
        } else {
            crate::operation_deser::parse_get_secret_value_response(response)
        }
    }
}

/// <p>Lists all of the secrets that are stored by Secrets Manager in the Amazon Web Services account. To list the
/// versions currently stored for a specific secret, use <a>ListSecretVersionIds</a>.
/// The encrypted fields <code>SecretString</code> and <code>SecretBinary</code> are not included
/// in the output. To get that information, call the <a>GetSecretValue</a>
/// operation.</p>
/// <note>
/// <p>Always check the <code>NextToken</code> response parameter
/// when calling any of the <code>List*</code> operations. These operations can occasionally return
/// an empty or shorter than expected list of results even when there more results become available.
/// When this happens, the <code>NextToken</code> response parameter contains a value to pass to the
/// next call to the same API to request the next part of the list.</p>
/// </note>
/// <p>
/// <b>Minimum
/// permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:ListSecrets</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To list the versions attached to a secret, use <a>ListSecretVersionIds</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSecrets {
    _private: (),
}
impl ListSecrets {
    /// Creates a new builder-style object to manufacture [`ListSecretsInput`](crate::input::ListSecretsInput)
    pub fn builder() -> crate::input::list_secrets_input::Builder {
        crate::input::list_secrets_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSecrets {
    type Output =
        std::result::Result<crate::output::ListSecretsOutput, crate::error::ListSecretsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_secrets_error(response)
        } else {
            crate::operation_deser::parse_list_secrets_response(response)
        }
    }
}

/// <p>Lists all of the versions attached to the specified secret. The output does not include
/// the <code>SecretString</code> or <code>SecretBinary</code> fields. By default, the list
/// includes only versions that have at least one staging label in <code>VersionStage</code>
/// attached.</p>
/// <note>
/// <p>Always check the <code>NextToken</code> response parameter
/// when calling any of the <code>List*</code> operations. These operations can occasionally return
/// an empty or shorter than expected list of results even when there more results become available.
/// When this happens, the <code>NextToken</code> response parameter contains a value to pass to the
/// next call to the same API to request the next part of the list.</p>
/// </note>
/// <p>
/// <b>Minimum
/// permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:ListSecretVersionIds</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To list the secrets in an account, use <a>ListSecrets</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListSecretVersionIds {
    _private: (),
}
impl ListSecretVersionIds {
    /// Creates a new builder-style object to manufacture [`ListSecretVersionIdsInput`](crate::input::ListSecretVersionIdsInput)
    pub fn builder() -> crate::input::list_secret_version_ids_input::Builder {
        crate::input::list_secret_version_ids_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListSecretVersionIds {
    type Output = std::result::Result<
        crate::output::ListSecretVersionIdsOutput,
        crate::error::ListSecretVersionIdsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_secret_version_ids_error(response)
        } else {
            crate::operation_deser::parse_list_secret_version_ids_response(response)
        }
    }
}

/// <p>Attaches the contents of the specified resource-based permission policy to a secret. A
/// resource-based policy is optional. Alternatively, you can use IAM identity-based policies
/// that specify the secret's Amazon Resource Name (ARN) in the policy statement's
/// <code>Resources</code> element. You can also use a combination of both identity-based and
/// resource-based policies. The affected users and roles receive the permissions that are
/// permitted by all of the relevant policies. For more information, see <a href="http://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access_resource-based-policies.html">Using Resource-Based
/// Policies for Amazon Web Services Secrets Manager</a>. For the complete description of the Amazon Web Services policy syntax and
/// grammar, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies.html">IAM JSON
/// Policy Reference</a> in the <i>IAM User Guide</i>.</p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:PutResourcePolicy</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To retrieve the resource policy attached to a secret, use <a>GetResourcePolicy</a>.</p>
/// </li>
/// <li>
/// <p>To delete the resource-based policy attached to a secret, use <a>DeleteResourcePolicy</a>.</p>
/// </li>
/// <li>
/// <p>To list all of the currently available secrets, use <a>ListSecrets</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutResourcePolicy {
    _private: (),
}
impl PutResourcePolicy {
    /// Creates a new builder-style object to manufacture [`PutResourcePolicyInput`](crate::input::PutResourcePolicyInput)
    pub fn builder() -> crate::input::put_resource_policy_input::Builder {
        crate::input::put_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutResourcePolicy {
    type Output = std::result::Result<
        crate::output::PutResourcePolicyOutput,
        crate::error::PutResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_put_resource_policy_response(response)
        }
    }
}

/// <p>Stores a new encrypted secret value in the specified secret. To do this, the operation
/// creates a new version and attaches it to the secret. The version can contain a new
/// <code>SecretString</code> value or a new <code>SecretBinary</code> value. You can also
/// specify the staging labels that are initially attached to the new version.</p>
/// <note>
/// <p>The Secrets Manager console uses only the <code>SecretString</code> field. To add binary data to a
/// secret with the <code>SecretBinary</code> field you must use the Amazon Web Services CLI or one of the
/// Amazon Web Services SDKs.</p>
/// </note>
/// <ul>
/// <li>
/// <p>If this operation creates the first version for the secret then Secrets Manager
/// automatically attaches the staging label <code>AWSCURRENT</code> to the new version.</p>
/// </li>
/// <li>
/// <p>If you do not specify a value for VersionStages then Secrets Manager automatically
/// moves the staging label <code>AWSCURRENT</code> to this new version.</p>
/// </li>
/// <li>
/// <p>If this operation moves the staging label <code>AWSCURRENT</code> from another version to this
/// version, then Secrets Manager also automatically moves the staging label <code>AWSPREVIOUS</code> to
/// the version that <code>AWSCURRENT</code> was removed from.</p>
/// </li>
/// <li>
/// <p>This operation is idempotent. If a version with a <code>VersionId</code> with the same
/// value as the <code>ClientRequestToken</code> parameter already exists and you specify the
/// same secret data, the operation succeeds but does nothing. However, if the secret data is
/// different, then the operation fails because you cannot modify an existing version; you can
/// only create new ones.</p>
/// </li>
/// </ul>
/// <note>
/// <ul>
/// <li>
/// <p>If you call an operation to encrypt or decrypt the <code>SecretString</code>
/// or <code>SecretBinary</code> for a secret in the same account as the calling user and that
/// secret doesn't specify a Amazon Web Services KMS encryption key, Secrets Manager uses the account's default
/// Amazon Web Services managed customer master key (CMK) with the alias <code>aws/secretsmanager</code>. If this key
/// doesn't already exist in your account then Secrets Manager creates it for you automatically. All
/// users and roles in the same Amazon Web Services account automatically have access to use the default CMK.
/// Note that if an Secrets Manager API call results in Amazon Web Services creating the account's
/// Amazon Web Services-managed CMK, it can result in a one-time significant delay in returning the
/// result.</p>
/// </li>
/// <li>
/// <p>If the secret resides in a different Amazon Web Services account from the credentials calling an API that
/// requires encryption or decryption of the secret value then you must create and use a custom
/// Amazon Web Services KMS CMK because you can't access the default CMK for the account using credentials
/// from a different Amazon Web Services account. Store the ARN of the CMK in the secret when you create the
/// secret or when you update it by including it in the <code>KMSKeyId</code>. If you call an
/// API that must encrypt or decrypt <code>SecretString</code> or <code>SecretBinary</code>
/// using credentials from a different account then the Amazon Web Services KMS key policy must grant cross-account
/// access to that other account's user or role for both the kms:GenerateDataKey and
/// kms:Decrypt operations.</p>
/// </li>
/// </ul>
/// </note>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:PutSecretValue</p>
/// </li>
/// <li>
/// <p>kms:GenerateDataKey - needed only if you use a customer-managed Amazon Web Services KMS key to encrypt
/// the secret. You do not need this permission to use the account's default Amazon Web Services managed CMK
/// for Secrets Manager.</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To retrieve the encrypted value you store in the version of a secret, use <a>GetSecretValue</a>.</p>
/// </li>
/// <li>
/// <p>To create a secret, use <a>CreateSecret</a>.</p>
/// </li>
/// <li>
/// <p>To get the details for a secret, use <a>DescribeSecret</a>.</p>
/// </li>
/// <li>
/// <p>To list the versions attached to a secret, use <a>ListSecretVersionIds</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutSecretValue {
    _private: (),
}
impl PutSecretValue {
    /// Creates a new builder-style object to manufacture [`PutSecretValueInput`](crate::input::PutSecretValueInput)
    pub fn builder() -> crate::input::put_secret_value_input::Builder {
        crate::input::put_secret_value_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutSecretValue {
    type Output =
        std::result::Result<crate::output::PutSecretValueOutput, crate::error::PutSecretValueError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_secret_value_error(response)
        } else {
            crate::operation_deser::parse_put_secret_value_response(response)
        }
    }
}

/// <p>Remove regions from replication.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RemoveRegionsFromReplication {
    _private: (),
}
impl RemoveRegionsFromReplication {
    /// Creates a new builder-style object to manufacture [`RemoveRegionsFromReplicationInput`](crate::input::RemoveRegionsFromReplicationInput)
    pub fn builder() -> crate::input::remove_regions_from_replication_input::Builder {
        crate::input::remove_regions_from_replication_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RemoveRegionsFromReplication {
    type Output = std::result::Result<
        crate::output::RemoveRegionsFromReplicationOutput,
        crate::error::RemoveRegionsFromReplicationError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_remove_regions_from_replication_error(response)
        } else {
            crate::operation_deser::parse_remove_regions_from_replication_response(response)
        }
    }
}

/// <p>Converts an existing secret to a multi-Region secret and begins replication the secret to a
/// list of new regions. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ReplicateSecretToRegions {
    _private: (),
}
impl ReplicateSecretToRegions {
    /// Creates a new builder-style object to manufacture [`ReplicateSecretToRegionsInput`](crate::input::ReplicateSecretToRegionsInput)
    pub fn builder() -> crate::input::replicate_secret_to_regions_input::Builder {
        crate::input::replicate_secret_to_regions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ReplicateSecretToRegions {
    type Output = std::result::Result<
        crate::output::ReplicateSecretToRegionsOutput,
        crate::error::ReplicateSecretToRegionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_replicate_secret_to_regions_error(response)
        } else {
            crate::operation_deser::parse_replicate_secret_to_regions_response(response)
        }
    }
}

/// <p>Cancels the scheduled deletion of a secret by removing the <code>DeletedDate</code> time
/// stamp. This makes the secret accessible to query once again.</p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:RestoreSecret</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To delete a secret, use <a>DeleteSecret</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RestoreSecret {
    _private: (),
}
impl RestoreSecret {
    /// Creates a new builder-style object to manufacture [`RestoreSecretInput`](crate::input::RestoreSecretInput)
    pub fn builder() -> crate::input::restore_secret_input::Builder {
        crate::input::restore_secret_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RestoreSecret {
    type Output =
        std::result::Result<crate::output::RestoreSecretOutput, crate::error::RestoreSecretError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_restore_secret_error(response)
        } else {
            crate::operation_deser::parse_restore_secret_response(response)
        }
    }
}

/// <p>Configures and starts the asynchronous process of rotating this secret. If you include the
/// configuration parameters, the operation sets those values for the secret and then immediately
/// starts a rotation. If you do not include the configuration parameters, the operation starts a
/// rotation with the values already stored in the secret. After the rotation completes, the
/// protected service and its clients all use the new version of the secret. </p>
/// <p>This required configuration information includes the ARN of an Amazon Web Services Lambda function and
/// optionally, the time between scheduled rotations. The Lambda rotation function creates a new
/// version of the secret and creates or updates the credentials on the protected service to
/// match. After testing the new credentials, the function marks the new secret with the staging
/// label <code>AWSCURRENT</code> so that your clients all immediately begin to use the new version. For more
/// information about rotating secrets and how to configure a Lambda function to rotate the
/// secrets for your protected service, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets.html">Rotating Secrets in Amazon Web Services Secrets Manager</a> in the
/// <i>Amazon Web Services Secrets Manager User Guide</i>.</p>
/// <p>Secrets Manager schedules the next rotation when the previous
/// one completes. Secrets Manager schedules the date by adding the rotation interval (number of days) to the
/// actual date of the last rotation. The service chooses the hour within that 24-hour date window
/// randomly. The minute is also chosen somewhat randomly, but weighted towards the top of the hour
/// and influenced by a variety of factors that help distribute load.</p>
/// <p>The
/// rotation function must end with the versions of the secret in one of two states:</p>
/// <ul>
/// <li>
/// <p>The <code>AWSPENDING</code> and <code>AWSCURRENT</code> staging labels are attached to the same version of
/// the secret, or</p>
/// </li>
/// <li>
/// <p>The <code>AWSPENDING</code> staging label is not attached to any version of the secret.</p>
/// </li>
/// </ul>
/// <p>If the <code>AWSPENDING</code> staging label is present but not attached to the same version as
/// <code>AWSCURRENT</code> then any later invocation of <code>RotateSecret</code> assumes that a previous
/// rotation request is still in progress and returns an error.</p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:RotateSecret</p>
/// </li>
/// <li>
/// <p>lambda:InvokeFunction (on the function specified in the secret's metadata)</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To list the secrets in your account, use <a>ListSecrets</a>.</p>
/// </li>
/// <li>
/// <p>To get the details for a version of a secret, use <a>DescribeSecret</a>.</p>
/// </li>
/// <li>
/// <p>To create a new version of a secret, use <a>CreateSecret</a>.</p>
/// </li>
/// <li>
/// <p>To attach staging labels to or remove staging labels from a version of a secret, use
/// <a>UpdateSecretVersionStage</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RotateSecret {
    _private: (),
}
impl RotateSecret {
    /// Creates a new builder-style object to manufacture [`RotateSecretInput`](crate::input::RotateSecretInput)
    pub fn builder() -> crate::input::rotate_secret_input::Builder {
        crate::input::rotate_secret_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RotateSecret {
    type Output =
        std::result::Result<crate::output::RotateSecretOutput, crate::error::RotateSecretError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_rotate_secret_error(response)
        } else {
            crate::operation_deser::parse_rotate_secret_response(response)
        }
    }
}

/// <p>Removes the secret from replication and promotes the secret to a regional secret in the replica Region.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopReplicationToReplica {
    _private: (),
}
impl StopReplicationToReplica {
    /// Creates a new builder-style object to manufacture [`StopReplicationToReplicaInput`](crate::input::StopReplicationToReplicaInput)
    pub fn builder() -> crate::input::stop_replication_to_replica_input::Builder {
        crate::input::stop_replication_to_replica_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopReplicationToReplica {
    type Output = std::result::Result<
        crate::output::StopReplicationToReplicaOutput,
        crate::error::StopReplicationToReplicaError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_replication_to_replica_error(response)
        } else {
            crate::operation_deser::parse_stop_replication_to_replica_response(response)
        }
    }
}

/// <p>Attaches one or more tags, each consisting of a key name and a value, to the specified
/// secret. Tags are part of the secret's overall metadata, and are not associated with any
/// specific version of the secret. This operation only appends tags to the existing list of tags.
/// To remove tags, you must use <a>UntagResource</a>.</p>         
/// <p>The following basic restrictions apply to tags:</p>
/// <ul>
/// <li>
/// <p>Maximum number of tags per secret—50</p>
/// </li>
/// <li>
/// <p>Maximum key length—127 Unicode characters in UTF-8</p>
/// </li>
/// <li>
/// <p>Maximum value length—255 Unicode characters in UTF-8</p>
/// </li>
/// <li>
/// <p>Tag keys and values are case sensitive.</p>
/// </li>
/// <li>
/// <p>Do not use the <code>aws:</code> prefix in your tag names or values because Amazon Web Services reserves it
/// for Amazon Web Services use. You can't edit or delete tag names or values with this
/// prefix. Tags with this prefix do not count against your tags per secret limit.</p>
/// </li>
/// <li>
/// <p>If you use your tagging schema across multiple services and resources,
/// remember other services might have restrictions on allowed characters. Generally
/// allowed characters: letters, spaces, and numbers representable in UTF-8, plus the
/// following special characters: + - = . _ : / @.</p>
/// </li>
/// </ul>
/// <important>
/// <p>If you use tags as part of your security strategy, then adding or removing a tag can
/// change permissions. If successfully completing this operation would result in you losing
/// your permissions for this secret, then the operation is blocked and returns an Access Denied
/// error.</p>
/// </important>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:TagResource</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To remove one or more tags from the collection attached to a secret, use <a>UntagResource</a>.</p>
/// </li>
/// <li>
/// <p>To view the list of tags attached to a secret, use <a>DescribeSecret</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Removes one or more tags from the specified secret.</p>
/// <p>This operation is idempotent. If a requested tag is not attached to the secret, no error
/// is returned and the secret metadata is unchanged.</p>
/// <important>
/// <p>If you use tags as part of your security strategy, then removing a tag can change
/// permissions. If successfully completing this operation would result in you losing your
/// permissions for this secret, then the operation is blocked and returns an Access Denied
/// error.</p>
/// </important>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:UntagResource</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To add one or more tags to the collection attached to a secret, use <a>TagResource</a>.</p>
/// </li>
/// <li>
/// <p>To view the list of tags attached to a secret, use <a>DescribeSecret</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Modifies many of the details of the specified secret. If you include a
/// <code>ClientRequestToken</code> and <i>either</i>
/// <code>SecretString</code> or <code>SecretBinary</code> then it also creates a new version
/// attached to the secret.</p>
/// <p>To modify the rotation configuration of a secret, use <a>RotateSecret</a>
/// instead.</p>
/// <note>
/// <p>The Secrets Manager console uses only the <code>SecretString</code> parameter and therefore limits
/// you to encrypting and storing only a text string. To encrypt and store binary data as part
/// of the version of a secret, you must use either the Amazon Web Services CLI or one of the Amazon Web Services
/// SDKs.</p>
/// </note>
/// <ul>
/// <li>
/// <p>If a version with a <code>VersionId</code> with the same value as the
/// <code>ClientRequestToken</code> parameter already exists, the operation results in an
/// error. You cannot modify an existing version, you can only create a new version.</p>
/// </li>
/// <li>
/// <p>If you include <code>SecretString</code> or <code>SecretBinary</code> to create a new
/// secret version, Secrets Manager automatically attaches the staging label <code>AWSCURRENT</code> to the new
/// version. </p>
/// </li>
/// </ul>
/// <note>
/// <ul>
/// <li>
/// <p>If you call an operation to encrypt or decrypt the <code>SecretString</code>
/// or <code>SecretBinary</code> for a secret in the same account as the calling user and that
/// secret doesn't specify a Amazon Web Services KMS encryption key, Secrets Manager uses the account's default
/// Amazon Web Services managed customer master key (CMK) with the alias <code>aws/secretsmanager</code>. If this key
/// doesn't already exist in your account then Secrets Manager creates it for you automatically. All
/// users and roles in the same Amazon Web Services account automatically have access to use the default CMK.
/// Note that if an Secrets Manager API call results in Amazon Web Services creating the account's
/// Amazon Web Services-managed CMK, it can result in a one-time significant delay in returning the
/// result.</p>
/// </li>
/// <li>
/// <p>If the secret resides in a different Amazon Web Services account from the credentials calling an API that
/// requires encryption or decryption of the secret value then you must create and use a custom
/// Amazon Web Services KMS CMK because you can't access the default CMK for the account using credentials
/// from a different Amazon Web Services account. Store the ARN of the CMK in the secret when you create the
/// secret or when you update it by including it in the <code>KMSKeyId</code>. If you call an
/// API that must encrypt or decrypt <code>SecretString</code> or <code>SecretBinary</code>
/// using credentials from a different account then the Amazon Web Services KMS key policy must grant cross-account
/// access to that other account's user or role for both the kms:GenerateDataKey and
/// kms:Decrypt operations.</p>
/// </li>
/// </ul>
/// </note>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:UpdateSecret</p>
/// </li>
/// <li>
/// <p>kms:GenerateDataKey - needed only if you use a custom Amazon Web Services KMS key to encrypt the secret.
/// You do not need this permission to use the account's Amazon Web Services managed CMK for
/// Secrets Manager.</p>
/// </li>
/// <li>
/// <p>kms:Decrypt - needed only if you use a custom Amazon Web Services KMS key to encrypt the secret. You do
/// not need this permission to use the account's Amazon Web Services managed CMK for Secrets Manager.</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To create a new secret, use <a>CreateSecret</a>.</p>
/// </li>
/// <li>
/// <p>To add only a new version to an existing secret, use <a>PutSecretValue</a>.</p>
/// </li>
/// <li>
/// <p>To get the details for a secret, use <a>DescribeSecret</a>.</p>
/// </li>
/// <li>
/// <p>To list the versions contained in a secret, use <a>ListSecretVersionIds</a>.</p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSecret {
    _private: (),
}
impl UpdateSecret {
    /// Creates a new builder-style object to manufacture [`UpdateSecretInput`](crate::input::UpdateSecretInput)
    pub fn builder() -> crate::input::update_secret_input::Builder {
        crate::input::update_secret_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSecret {
    type Output =
        std::result::Result<crate::output::UpdateSecretOutput, crate::error::UpdateSecretError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_secret_error(response)
        } else {
            crate::operation_deser::parse_update_secret_response(response)
        }
    }
}

/// <p>Modifies the staging labels attached to a version of a secret. Staging labels are used to
/// track a version as it progresses through the secret rotation process. You can attach a staging
/// label to only one version of a secret at a time. If a staging label to be added is already
/// attached to another version, then it is moved--removed from the other version first and
/// then attached to this one. For more information about staging labels, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/terms-concepts.html#term_staging-label">Staging
/// Labels</a> in the <i>Amazon Web Services Secrets Manager User Guide</i>. </p>
/// <p>The staging labels that you specify in the <code>VersionStage</code> parameter are added
/// to the existing list of staging labels--they don't replace it.</p>
/// <p>You can move the <code>AWSCURRENT</code> staging label to this version by including it in this
/// call.</p>
/// <note>
/// <p>Whenever you move <code>AWSCURRENT</code>, Secrets Manager automatically moves the label <code>AWSPREVIOUS</code>
/// to the version that <code>AWSCURRENT</code> was removed from.</p>
/// </note>
/// <p>If this action results in the last label being removed from a version, then the version is
/// considered to be 'deprecated' and can be deleted by Secrets Manager.</p>
/// <p>
/// <b>Minimum permissions</b>
/// </p>
/// <p>To run this command, you must have the following permissions:</p>
/// <ul>
/// <li>
/// <p>secretsmanager:UpdateSecretVersionStage</p>
/// </li>
/// </ul>
/// <p>
/// <b>Related operations</b>
/// </p>
/// <ul>
/// <li>
/// <p>To get the list of staging labels that are currently associated with a version of a
/// secret, use <code>
/// <a>DescribeSecret</a>
/// </code> and examine the
/// <code>SecretVersionsToStages</code> response value. </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateSecretVersionStage {
    _private: (),
}
impl UpdateSecretVersionStage {
    /// Creates a new builder-style object to manufacture [`UpdateSecretVersionStageInput`](crate::input::UpdateSecretVersionStageInput)
    pub fn builder() -> crate::input::update_secret_version_stage_input::Builder {
        crate::input::update_secret_version_stage_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateSecretVersionStage {
    type Output = std::result::Result<
        crate::output::UpdateSecretVersionStageOutput,
        crate::error::UpdateSecretVersionStageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_secret_version_stage_error(response)
        } else {
            crate::operation_deser::parse_update_secret_version_stage_response(response)
        }
    }
}

/// <p>Validates that the resource policy does not grant a wide range of IAM principals access to
/// your secret. The JSON request string input and response output displays formatted code
/// with white space and line breaks for better readability. Submit your input as a single line
/// JSON string. A resource-based policy is optional for secrets.</p>
/// <p>The API performs three checks when validating the secret:</p>
/// <ul>
/// <li>
/// <p>Sends a call to <a href="https://aws.amazon.com/blogs/security/protect-sensitive-data-in-the-cloud-with-automated-reasoning-zelkova/">Zelkova</a>, an automated reasoning engine, to ensure your Resource Policy does not
/// allow broad access to your secret.</p>
/// </li>
/// <li>
/// <p>Checks for correct syntax in a policy.</p>
/// </li>
/// <li>
/// <p>Verifies the policy does not lock out a caller.</p>
/// </li>
/// </ul>
/// <p>
/// <b>Minimum Permissions</b>
/// </p>
/// <p>You must have the permissions required to access the following APIs:</p>
/// <ul>
/// <li>
/// <p>
/// <code>secretsmanager:PutResourcePolicy</code>
/// </p>
/// </li>
/// <li>
/// <p>
/// <code>secretsmanager:ValidateResourcePolicy</code>
/// </p>
/// </li>
/// </ul>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ValidateResourcePolicy {
    _private: (),
}
impl ValidateResourcePolicy {
    /// Creates a new builder-style object to manufacture [`ValidateResourcePolicyInput`](crate::input::ValidateResourcePolicyInput)
    pub fn builder() -> crate::input::validate_resource_policy_input::Builder {
        crate::input::validate_resource_policy_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ValidateResourcePolicy {
    type Output = std::result::Result<
        crate::output::ValidateResourcePolicyOutput,
        crate::error::ValidateResourcePolicyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_validate_resource_policy_error(response)
        } else {
            crate::operation_deser::parse_validate_resource_policy_response(response)
        }
    }
}
