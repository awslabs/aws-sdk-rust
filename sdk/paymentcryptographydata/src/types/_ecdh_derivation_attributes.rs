// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Parameters required to establish ECDH based key exchange.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq)]
pub struct EcdhDerivationAttributes {
    /// <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub certificate_authority_public_key_identifier: ::std::string::String,
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub public_key_certificate: ::std::string::String,
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub key_algorithm: crate::types::SymmetricKeyAlgorithm,
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub key_derivation_function: crate::types::KeyDerivationFunction,
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub key_derivation_hash_algorithm: crate::types::KeyDerivationHashAlgorithm,
    /// <p>A byte string containing information that binds the ECDH derived key to the two parties involved or to the context of the key.</p>
    /// <p>It may include details like identities of the two parties deriving the key, context of the operation, session IDs, and optionally a nonce. It must not contain zero bytes, and re-using shared information for multiple ECDH key derivations is not recommended.</p>
    pub shared_information: ::std::string::String,
}
impl EcdhDerivationAttributes {
    /// <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub fn certificate_authority_public_key_identifier(&self) -> &str {
        use std::ops::Deref;
        self.certificate_authority_public_key_identifier.deref()
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub fn public_key_certificate(&self) -> &str {
        use std::ops::Deref;
        self.public_key_certificate.deref()
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub fn key_algorithm(&self) -> &crate::types::SymmetricKeyAlgorithm {
        &self.key_algorithm
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub fn key_derivation_function(&self) -> &crate::types::KeyDerivationFunction {
        &self.key_derivation_function
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub fn key_derivation_hash_algorithm(&self) -> &crate::types::KeyDerivationHashAlgorithm {
        &self.key_derivation_hash_algorithm
    }
    /// <p>A byte string containing information that binds the ECDH derived key to the two parties involved or to the context of the key.</p>
    /// <p>It may include details like identities of the two parties deriving the key, context of the operation, session IDs, and optionally a nonce. It must not contain zero bytes, and re-using shared information for multiple ECDH key derivations is not recommended.</p>
    pub fn shared_information(&self) -> &str {
        use std::ops::Deref;
        self.shared_information.deref()
    }
}
impl ::std::fmt::Debug for EcdhDerivationAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("EcdhDerivationAttributes");
        formatter.field(
            "certificate_authority_public_key_identifier",
            &self.certificate_authority_public_key_identifier,
        );
        formatter.field("public_key_certificate", &"*** Sensitive Data Redacted ***");
        formatter.field("key_algorithm", &self.key_algorithm);
        formatter.field("key_derivation_function", &self.key_derivation_function);
        formatter.field("key_derivation_hash_algorithm", &self.key_derivation_hash_algorithm);
        formatter.field("shared_information", &self.shared_information);
        formatter.finish()
    }
}
impl EcdhDerivationAttributes {
    /// Creates a new builder-style object to manufacture [`EcdhDerivationAttributes`](crate::types::EcdhDerivationAttributes).
    pub fn builder() -> crate::types::builders::EcdhDerivationAttributesBuilder {
        crate::types::builders::EcdhDerivationAttributesBuilder::default()
    }
}

/// A builder for [`EcdhDerivationAttributes`](crate::types::EcdhDerivationAttributes).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default)]
#[non_exhaustive]
pub struct EcdhDerivationAttributesBuilder {
    pub(crate) certificate_authority_public_key_identifier: ::std::option::Option<::std::string::String>,
    pub(crate) public_key_certificate: ::std::option::Option<::std::string::String>,
    pub(crate) key_algorithm: ::std::option::Option<crate::types::SymmetricKeyAlgorithm>,
    pub(crate) key_derivation_function: ::std::option::Option<crate::types::KeyDerivationFunction>,
    pub(crate) key_derivation_hash_algorithm: ::std::option::Option<crate::types::KeyDerivationHashAlgorithm>,
    pub(crate) shared_information: ::std::option::Option<::std::string::String>,
}
impl EcdhDerivationAttributesBuilder {
    /// <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    /// This field is required.
    pub fn certificate_authority_public_key_identifier(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.certificate_authority_public_key_identifier = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub fn set_certificate_authority_public_key_identifier(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.certificate_authority_public_key_identifier = input;
        self
    }
    /// <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
    pub fn get_certificate_authority_public_key_identifier(&self) -> &::std::option::Option<::std::string::String> {
        &self.certificate_authority_public_key_identifier
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    /// This field is required.
    pub fn public_key_certificate(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.public_key_certificate = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub fn set_public_key_certificate(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.public_key_certificate = input;
        self
    }
    /// <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
    pub fn get_public_key_certificate(&self) -> &::std::option::Option<::std::string::String> {
        &self.public_key_certificate
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    /// This field is required.
    pub fn key_algorithm(mut self, input: crate::types::SymmetricKeyAlgorithm) -> Self {
        self.key_algorithm = ::std::option::Option::Some(input);
        self
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub fn set_key_algorithm(mut self, input: ::std::option::Option<crate::types::SymmetricKeyAlgorithm>) -> Self {
        self.key_algorithm = input;
        self
    }
    /// <p>The key algorithm of the derived ECDH key.</p>
    pub fn get_key_algorithm(&self) -> &::std::option::Option<crate::types::SymmetricKeyAlgorithm> {
        &self.key_algorithm
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    /// This field is required.
    pub fn key_derivation_function(mut self, input: crate::types::KeyDerivationFunction) -> Self {
        self.key_derivation_function = ::std::option::Option::Some(input);
        self
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub fn set_key_derivation_function(mut self, input: ::std::option::Option<crate::types::KeyDerivationFunction>) -> Self {
        self.key_derivation_function = input;
        self
    }
    /// <p>The key derivation function to use for deriving a key using ECDH.</p>
    pub fn get_key_derivation_function(&self) -> &::std::option::Option<crate::types::KeyDerivationFunction> {
        &self.key_derivation_function
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    /// This field is required.
    pub fn key_derivation_hash_algorithm(mut self, input: crate::types::KeyDerivationHashAlgorithm) -> Self {
        self.key_derivation_hash_algorithm = ::std::option::Option::Some(input);
        self
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub fn set_key_derivation_hash_algorithm(mut self, input: ::std::option::Option<crate::types::KeyDerivationHashAlgorithm>) -> Self {
        self.key_derivation_hash_algorithm = input;
        self
    }
    /// <p>The hash type to use for deriving a key using ECDH.</p>
    pub fn get_key_derivation_hash_algorithm(&self) -> &::std::option::Option<crate::types::KeyDerivationHashAlgorithm> {
        &self.key_derivation_hash_algorithm
    }
    /// <p>A byte string containing information that binds the ECDH derived key to the two parties involved or to the context of the key.</p>
    /// <p>It may include details like identities of the two parties deriving the key, context of the operation, session IDs, and optionally a nonce. It must not contain zero bytes, and re-using shared information for multiple ECDH key derivations is not recommended.</p>
    /// This field is required.
    pub fn shared_information(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.shared_information = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>A byte string containing information that binds the ECDH derived key to the two parties involved or to the context of the key.</p>
    /// <p>It may include details like identities of the two parties deriving the key, context of the operation, session IDs, and optionally a nonce. It must not contain zero bytes, and re-using shared information for multiple ECDH key derivations is not recommended.</p>
    pub fn set_shared_information(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.shared_information = input;
        self
    }
    /// <p>A byte string containing information that binds the ECDH derived key to the two parties involved or to the context of the key.</p>
    /// <p>It may include details like identities of the two parties deriving the key, context of the operation, session IDs, and optionally a nonce. It must not contain zero bytes, and re-using shared information for multiple ECDH key derivations is not recommended.</p>
    pub fn get_shared_information(&self) -> &::std::option::Option<::std::string::String> {
        &self.shared_information
    }
    /// Consumes the builder and constructs a [`EcdhDerivationAttributes`](crate::types::EcdhDerivationAttributes).
    /// This method will fail if any of the following fields are not set:
    /// - [`certificate_authority_public_key_identifier`](crate::types::builders::EcdhDerivationAttributesBuilder::certificate_authority_public_key_identifier)
    /// - [`public_key_certificate`](crate::types::builders::EcdhDerivationAttributesBuilder::public_key_certificate)
    /// - [`key_algorithm`](crate::types::builders::EcdhDerivationAttributesBuilder::key_algorithm)
    /// - [`key_derivation_function`](crate::types::builders::EcdhDerivationAttributesBuilder::key_derivation_function)
    /// - [`key_derivation_hash_algorithm`](crate::types::builders::EcdhDerivationAttributesBuilder::key_derivation_hash_algorithm)
    /// - [`shared_information`](crate::types::builders::EcdhDerivationAttributesBuilder::shared_information)
    pub fn build(self) -> ::std::result::Result<crate::types::EcdhDerivationAttributes, ::aws_smithy_types::error::operation::BuildError> {
        ::std::result::Result::Ok(crate::types::EcdhDerivationAttributes {
            certificate_authority_public_key_identifier: self.certificate_authority_public_key_identifier.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "certificate_authority_public_key_identifier",
                    "certificate_authority_public_key_identifier was not specified but it is required when building EcdhDerivationAttributes",
                )
            })?,
            public_key_certificate: self.public_key_certificate.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "public_key_certificate",
                    "public_key_certificate was not specified but it is required when building EcdhDerivationAttributes",
                )
            })?,
            key_algorithm: self.key_algorithm.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "key_algorithm",
                    "key_algorithm was not specified but it is required when building EcdhDerivationAttributes",
                )
            })?,
            key_derivation_function: self.key_derivation_function.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "key_derivation_function",
                    "key_derivation_function was not specified but it is required when building EcdhDerivationAttributes",
                )
            })?,
            key_derivation_hash_algorithm: self.key_derivation_hash_algorithm.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "key_derivation_hash_algorithm",
                    "key_derivation_hash_algorithm was not specified but it is required when building EcdhDerivationAttributes",
                )
            })?,
            shared_information: self.shared_information.ok_or_else(|| {
                ::aws_smithy_types::error::operation::BuildError::missing_field(
                    "shared_information",
                    "shared_information was not specified but it is required when building EcdhDerivationAttributes",
                )
            })?,
        })
    }
}
impl ::std::fmt::Debug for EcdhDerivationAttributesBuilder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        let mut formatter = f.debug_struct("EcdhDerivationAttributesBuilder");
        formatter.field(
            "certificate_authority_public_key_identifier",
            &self.certificate_authority_public_key_identifier,
        );
        formatter.field("public_key_certificate", &"*** Sensitive Data Redacted ***");
        formatter.field("key_algorithm", &self.key_algorithm);
        formatter.field("key_derivation_function", &self.key_derivation_function);
        formatter.field("key_derivation_hash_algorithm", &self.key_derivation_hash_algorithm);
        formatter.field("shared_information", &self.shared_information);
        formatter.finish()
    }
}
